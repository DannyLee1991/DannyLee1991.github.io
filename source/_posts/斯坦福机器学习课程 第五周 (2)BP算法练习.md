title: 斯坦福机器学习课程 第五周 (2)BP算法练习
tags:
  - 机器学习
  - 斯坦福课程
  - 神经网络
categories:
  - 机器学习
comments: true
date: 2016-10-13 00:08:00
mathjax: true
---

## 将参数从矩阵展开成向量

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/60Uxp/implementation-note-unrolling-parameters)

> 在这一节中，我想快速地向你介绍一个细节的实现过程，怎样把你的参数从矩阵展开成向量，以便我们在高级最优化步骤中的使用需要。

```
function [jVal, gradient] = costFunction(theta)
	...
optTheta = fminunc(@costFunction, initialTheta, options)
```

具体来讲，对代价函数`costFunction(theta)`传入参数`theta`，函数返回值是代价函数`jVal`以及导数值`gradient`，然后你可以将返回值传递给高级最优化算法`fminunc`。

> 顺便提一下，`fminunc`并不是唯一的算法，你也可以使用别的优化算法，

其中`costFunction`中的参数、返回值`gradient`以及`fiminunc`的参数`initialTheta`都是一个$R^{n+1}$阶的向量。

![](/img/16_10_13/001.png)

这部分在我们使用逻辑回归的时候运行顺利，但现在对于神经网络，我们的参数将不再是向量，而是矩阵了。

以一个拥有4层的完整的神经网络为例：

其参数`theta`所代表的参数矩阵为矩阵为$Θ^{(1)}$,$Θ^{(2)}$,$Θ^{(3)}$，在Octave中，我们可以设为`Theta1`,`Theta2`,`Theta3`。

![](/img/16_10_13/003.png)

![](/img/16_10_13/002.png)

类似的，这些梯度项`gradient`也是`costFunction`的返回值之一，在之前的视频中我们演示了如何计算这些梯度矩阵，它们的计算结果是$D^{(1)}$,$D^{(2)}$,$D^{(3)}$，在Octave中用`D1`,`D2`,`D3`来表示。

![](/img/16_10_13/005.png)

![](/img/16_10_13/004.png)

在这一节中，我想很快地向你介绍怎样取出这些矩阵，并将他们展开成向量，以便它们最终成为恰当的格式，能够传入这里的`initialTheta`:

![](/img/16_10_13/006.png)

并且得到正确的梯度返回值`gradient`。

----

具体来说，假设我们有这样一个神经网络：

![](/img/16_10_13/007.png)

其输入层有10个输入单元($s\_{1}=10$)，隐藏层有10个单元($s\_{2}=10$)，最后的输出层只有一个输出单元($s\_{3}=1$)。

在这种情况下矩阵$Θ$的维度，和矩阵$D$的维度将有这个神经网络的结构所决定，比如$Θ^{(1)}$是一个$10 × 11$的矩阵。

因此，在Octave中，如果你想讲这些矩阵向量化，那么你要做的是取出你的$Θ^{(1)}$、$Θ^{(2)}$、$Θ^{(3)}$，然后使用下面这段代码，这段代码将取出三个$Θ$矩阵中的所有元素，然后把他们全部展开，成为一个很长的向量，也就是`thetaVec`。

```
thetaVec = [Theta1(:);Theta2(:);Theta3(:)];
```

同样的，下面这段代码将取出$D$矩阵的所有元素，然后展开成一个长向量`DVec`：

```
DVec = [D1(:);D2(:);D3(:)];
```

最后，如果你想要从向量表达式返回到矩阵表达式的话，你要做的就是使用`reshape`函数，传入向量的区间以及矩阵的行数和列数，即可得到对应的矩阵：

```
Theta1 = reshape(thetaVec(1:110),10,11);
Theta2 = reshape(thetaVec(111:220),10,11);
Theta3 = reshape(thetaVec(221:231),10,11);
```

----

下面用一个Octave例子来展示上面的计算过程：

首先，让我们假设`Theta1`是一个10行11列的单位矩阵：

```
>> Theta1 = ones(10,11);
>> Theta1
Theta1 =

   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
```

`Theta2`是一个元素都为2的10行11列的矩阵：

```
>> Theta2 = 2*ones(10,11);
>> Theta2
Theta2 =

   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
```

然后假设`Theta3`是一个`1×11`的元素均为3的矩阵：

```
>> Theta3 = 3*ones(1,11);
>> Theta3
Theta3 =

   3   3   3   3   3   3   3   3   3   3   3
```

现在，我们想把这些所有的矩阵变成一个向量`thetaVec` ：

```
>> thetaVec = [ Theta1(:); Theta2(:); Theta3(:)];
>> thetaVec

thetaVec =

   1
   1
   1
   1
   1
   1
   1
   1
   1
   1
   1
   1
   ...
```

我们可以看到`thetaVec`是一个$231×1$的向量，这里包含了所有矩阵的元素：

```
>> size(thetaVec)
ans =

   231     1
```

如果我想重新得到我最初的三个矩阵，我可以对`thetaVec`使用`reshape`命令。

比如，我们可以抽出前110个元素，来重组一个$10×11$的矩阵，即`Theta1`：

```
>> reshape(thetaVec(1:110),10,11)
ans =

   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
   1   1   1   1   1   1   1   1   1   1   1
```

我们也可以用同样的方式来取接下来的110个元素，来重组`Theta2`：

```
>> reshape(thetaVec(111:220),10,11)
ans =

   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
   2   2   2   2   2   2   2   2   2   2   2
```

最后再抽出221到231的元素，重组`Theta3`：

```
>> reshape(thetaVec(221:231),1,11)
ans =

   3   3   3   3   3   3   3   3   3   3   3
```

--- 

为了使这个过程更形象，下面我们来看怎样将这一方法应用于我们的学习算法：

假设你有一些初始参数值:$Θ^{(1)}$，$Θ^{(2)}$，$Θ^{(3)}$。

我们要做的是取出这些参数，并且将它们展开为一个长向量作为`initialTheta`，带入`fminunc`函数：

```
fminunc(@costFunction, initialTheta, options)
```

我们要做的另一件事是执行代价函数`@costFunction`，实现算法如下：

```
function [jval, gradientVec] = costFunction(thetaVec)
```

代价函数`costFunction`传入参数`thetaVec`，这也是我所有参数的向量，是将所有的参数展开成一个向量的形式。

因此，我要做的第一件事就是通过向量`thetaVec`使用重组函数`reshape`来得到$Θ^{(1)}$,$Θ^{(2)}$,$Θ^{(3)}$。

这样我就能执行**向前传播**和**反向传播**来计算出导数$D^{(1)}$,$D^{(2)}$,$D^{(3)}$和代价函数$J(Θ)$。

最后，我可以取出这些导数值，然后让它们保存和我展开的$Θ$值相同的顺序来展开它们(按照$D^{(1)}$,$D^{(2)}$,$D^{(3)}$的顺序)，得到`gradientVec`，这个值由我的代价函数返回，它可以以一个向量的形式返回这些导数值。

> 现在，你应该对怎样进行参数的矩阵表达式和向量表达式之间的转换，有了一个更清晰的认识。
> 
> 使用矩阵表达式的好处是：当你的参数以矩阵的形式存储时，你在进行正向传播和反向传播时，你会觉得更加方便。当你将参数存储为矩阵时，一个大好处是充分利用了向量化的实现过程。
> 
> 相反地，向量表达式的优点是如果你有像thetaVec或者DVec这样的矩阵，当你使用一些高级的优化算法时，这些算法通常要求你所有的参数都展开成一个长向量的形式。

## 梯度检验（Gradient Checking）

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/Y3s6r/gradient-checking)

> 在之前的视频中，我们讨论了如何使用向前传播和反向传播计算神经网络中的导数，但反向传播作为一个有很多细节的算法，在实现的时候会有点复杂，而且有一个不好的方面是在实现反向传播时，会遇到很多细小的错误。所以如果你把它和梯度下降算法或者其他优化算法一起运行时，可能看起来它运行正常，并且你的代价函数$J(Θ)$最后可能在每次梯度下降法迭代时，都会减小，即使在实现反向传播时有一些小错误，可能也会检查不出来。
> 
> 所以它看起来是$J(Θ)$在减小，但是可能你最后得到的神经网络误差比没有错误的要高，而且你很可能就不知道你的这些结果是这些小错误导致的。那你应该怎么办呢？
> 
> 有一个想法叫做**梯度检验(Gradient Checking)**可以解决基本所有的问题。我现在每次实现神经网络的反向传播或者类似的梯度下降算法或者其他比较复杂的模型，我都会使用梯度检验，如果你这么做，它会帮你确定并且能很确信你实现的向前传播和反向传播或者其他的什么算法是100%正确的。
> 
> 在之前的视频中，我一般是让你相信我给出的那些计算就是代价函数的梯度，但一旦你们实现数值梯度检验，也就是这节视频的主题，你就能自己验证你写的代码确实是在计算代价函数$J(Θ)$了。

### 梯度检验原理

看下面这样的例子：

![](/img/16_10_13/008.png)

加入我有一个代价函数$J(\theta)$，并且我有一个实数值$\theta$：

![](/img/16_10_13/009.png)

假如说我想估计这个函数在这一点的导数，这个导数就等于这样一条直线的斜率：

![](/img/16_10_13/010.png)

下面我要用数值计算的方法来计算近似的导数，这个是用数值方法计算近似导数的过程：

我要找到$\theta+ε$和$\theta-ε$这两个点，然后用一条直线把这两点连起来：

![](/img/16_10_13/011.png)

然后用这条红线的斜率来作为导数的近似值。在数学上，这条红线的斜率等于两点之间垂直方向的差值除以水平方向的差值：

![](/img/16_10_13/012.png)

所以垂直方向上的差值为：

$$
J(\theta+ε) - J(\theta-ε)
$$

水平方向的差值为：

$$
2ε
$$

那么我们的近似是这样的：

$$
\frac{\partial}{\partial \theta}J(\theta)≈
\frac{J(\theta+ε) - J(\theta-ε)}{2ε}
$$

> 通常，我给$ε$取很小的值，比如可能取$ε=10^{-4}$，$ε$的取值在一个很大的范围内都是可行的，实际上，如果你让$ε$非常小，那么数学上上面的式子实际上就是导数。只是我们不用想非常非常小的$ε$，因为可能会产生数值问题，所以我通常让$ε$取$ε=10^{-4}$。
> 
> 顺便说一下，可能你们见过这种估计导数的公式：$\frac{J(\theta+ε) - J(\theta)}{ε}$，这种方式称为**单侧差分**，而上面的那种方式叫做**双侧差分**。双侧差分给我们了一个稍微精确些的估计，所以，我通常用双侧差分，而不用单侧差分估计。

### Octave中实现梯度检验

具体地说，你在Octave中实现时，要使用下面这个代码：

```
gradApprox = (J(theta + EPSILON) - J(theta - EPSILON))/(2*EPSILON)
```

你的程序要调用`gradApprox`来计算这个函数。这个函数会通过这个公式：$\frac{J(\theta+ε) - J(\theta-ε)}{2ε}$，它会给出这点导数的数值估计。


### 当$\theta$是向量时

在之前的例子中，$\theta$是一个实数，接下来让我们来讨论更普遍的一种情况：当$\theta$是一个向量参数的情况。

假如说$\theta$是一个$n$维向量（它可能是我们的神经网络参数$Θ^{1}$，$Θ^{2}$，$Θ^{3}$的展开形式）

所以$\theta$是一个有n个元素的向量。

$$
\theta = [\theta\_{1},\theta\_{2},\theta\_{3},...,\theta\_{n}]
$$

---

我们可以用类似的想法来估计所有的偏导数项：

$$
\frac{\partial}{\partial \theta\_{1}}J(\theta)
≈
\frac{
J(\theta\_{1} + ε,\theta\_{2},\theta\_{3},...,\theta\_{n})
-
J(\theta\_{1} - ε,\theta\_{2},\theta\_{3},...,\theta\_{n})
}
{2ε}
$$

$$
\frac{\partial}{\partial \theta\_{2}}J(\theta)
≈
\frac{
J(\theta\_{1},\theta\_{2} + ε,\theta\_{3},...,\theta\_{n})
-
J(\theta\_{1},\theta\_{2} - ε,\theta\_{3},...,\theta\_{n})
}
{2ε}
$$

$$...$$

$$
\frac{\partial}{\partial \theta\_{n}}J(\theta)
≈
\frac{
J(\theta\_{1},\theta\_{2},\theta\_{3},...,\theta\_{n} + ε)
-
J(\theta\_{1},\theta\_{2},\theta\_{3},...,\theta\_{n} - ε)
}
{2ε}
$$

分别对$\theta$向量的每个元素使用**双侧差分**来计算导数。

上面的这些公式给出了一个队任意参数求近似偏导数的方法。具体地说，你要实现的是下面这个程序：

```
for i = 1:n,
	thetaPlus = theta;
	thetaPlus(i) = thetaPlus(i) + EPSILON;
	thetaMinus = theta;
	thetaMinus(i) = thetaMinus(i) - EPSILON;
	gradApprox(i) = (J(thetaPlus) - J(thetaMinus))/(2*EPSILON);
end;
```

我们把这个用在Octave里，来计算数值导数。

我们实现神经网络时，我们用`for`循环来计算代价函数对每个网络中的参数的偏导数`gradApprox`，然后和我们从反向传播得到的导数`DVec`进行对比，看是否相等或近似于`DVec`。

$$
Check\ that\ gradApprox≈DVec
$$

如果这两种计算导数的方法给了你相同的结果，或者非常接近的结果，那么我就非常确信我实现的反向传播是正确的。然后我把这些`DVec`向量用在梯度下降法，或者其他高级优化算法里。

### 总结

最后，我想把所有的东西放在一起，然后告诉你怎样实现这个数值梯度检验。

**实现步骤:**

- 实现反向传播来计算`DVec`($D^{(1)}$，$D^{(2)}$，$D^{(3)}$)。
- 用`gradApprox`实现数值梯度检验
- 然后确定`DVec`和`gradApprox`给出的结果非常相近
- 在使用你的代码去学习训练你的网络之前，重要的是要关掉梯度检验，不在使用`gradApprox`这个数值导数公式（这么做的原因是，这个梯度检验的计算量非常大，它是一个非常慢的计算近似导数的方法。而相对的反向传播算法是一个在计算导数上效率更高的方法。）

再次重申一下，在为了训练分类器运行你的算法，做很多次梯度下降或高级优化算法的迭代之前，要确定你不再使用梯度检验的程序，具体来说，如果你在每次的梯度下降法迭代时，都运行数值梯度检验，你的程序会变得非常慢，因为数值检验程序比反向传播算法要慢得多。

## 随机初始化$Θ$

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/ND5G5/random-initialization)

> 这一节将介绍神经网络训练中的最后一个知识点：**随机初始化$Θ$**

当你运行一个算法（例如梯度下降算法，或者其他高级优化算法）时，我们需要给变量$\theta$一些初始值。

```
optTheta = fminunc(@costFunction, initialTheta, options)
```

现在考虑一下梯度下降算法，同样我们需给定$\theta$一些初始值，接下来使用梯度下降方法慢慢地执行这些步骤使其下降，使$J(\theta)$下降到最小。

那么$\theta$的初始值该设置为多少呢？是否可以设置为一个0向量呢？

$$
Set\ \ initialTheta = zeros(n,1)\ ?
$$

虽然说在逻辑回归时，初始化所有变量为0是可行的，但在训练神经网络时，这样做是不可行的。

以训练下面这个神经网络为例：

![](/img/16_10_13/013.png)

照之前所说，将所有变量初始化为0：

$$
Θ\_{ij}^{(l)}=0 \ \ for\ all\ i,j,l.
$$

如果是这样的话，当初始化下面这些颜色两两相同的权重时，这些权重都被赋予相同的初始值0：

![](/img/16_10_13/014.png)

那么这就意味着经过计算后，这两个隐藏单元$a\_{1}$，$a\_{2}$的值是相同的：

$$
a\_{1}^{(2)}=a\_{2}^{(2)}
$$

同样的原因，由于权重相同，也可以证明：

$$
δ\_{1}^{(2)}=δ\_{2}^{(2)}
$$

同时，如果你更深入地挖掘一下，你不难得出这些变量对参数的偏导数满足以下条件：

以这两条红色的权重为例：

![](/img/16_10_13/015.png)

即代价函数的关于这两个权重的偏导数是相等的：

$$
\frac{\partial}{\partial Θ\_{01}^{(1)}}J(Θ)
=
\frac{\partial}{\partial Θ\_{02}^{(1)}}J(Θ)
$$

这也意味着，一旦更新梯度下降方法，第一个红色权重也会更新，等于学习率乘以这个式子:$\frac{\partial}{\partial Θ\_{01}^{(1)}}J(Θ)$

第二条红色权重更新为学习率乘以这个式子：$\frac{\partial}{\partial Θ\_{02}^{(1)}}J(Θ)$。

这也就意味着，一旦更新梯度下降，这两条红色权重的值，在最后将互为相等：

$$
Θ\_{01}^{(1)}=Θ\_{02}^{(1)}
$$

因此，即使权重现在不都为0，但参数的值最后也互为相等。

同样地，即使更新一个梯度下降，下面这两条红色的权重也会互为相等：

![](/img/16_10_13/016.png)

同理，最下面的两个权重也会互为相等。

所以每次更新后，两个隐藏单元的输入的对应的参数将是相同的。这就意味着即使经过一次梯度下降的循环后，你会发现两个隐藏单元任然是两个完全相同的输入函数：

$$
a\_{1}^{(2)}=a\_{2}^{(2)}
$$

这也意味着，这个神经网络并不能计算出什么更有价值的东西。

想象一下，不止有两个隐藏单元，而是有很多的隐藏单元，这就是会导致所有的隐藏单元都在计算相同的特征，这是完全多余的表达，因为这意味着最后的逻辑回归单元只会得到一种特征。这样便阻止了神经网络学习出更有价值的信息。

### 随机初始化$Θ$引入

为了解决这个神经网络变量初始化的问题，我们采用**随机初始化**的方法。

具体的说，上面我们说到的所有权重相同的问题，有时被我们也称为**对称权重**。所以随机初始化解决的就是如何**打破这种对称性(Symmetry breaking)**。

所以我们需要做的是对$Θ\_{ij}^{(l)}$的每个值进行初始化，范围在$[-ε,ε]$之间（$-ε\le Θ\_{ij}^{(l)} \le ε$）。

在Octave中初始化$Θ$：

```
Theta1 = rand(10,11)*(2*INIT_EPSILON) - INIT_EPSILON;
Theta2 = rand(1,11)*(2*INIT_EPSILON) - INIT_EPSILON;
```

其中`rand(10,11)`代表一个$10×11$的随机矩阵，这个`rand()`函数就是用来得到一个任意的随机矩阵的方法，并且所有的值都是介于0到1之间的实数。

因此，如果取0到1之间的一个数和$2ε$相乘再减去$ε$，然后得到的结果就是一个在$[-ε,ε]$之间的数。

> 顺便说一句，这里的这个$ε$和在进行梯度检查中用的那个$ε$不是一回事，这也是为什么上面这段代码要使用`INIT_EPSILON`而不是`EPSILON`的原因。(在梯度检查中用到的是`EPSILON`)

### 总结

总的来说，为了训练神经网络，应该对权重进行随机初始化为$[-ε,ε]$之间的值。$ε$是接近于0的小数，然后进行反向传播，执行梯度检查，使用梯度下降或者高级的优化算法，试着使代价函数$J(Θ)$达到最小，从某个随机选取的参数$Θ$开始。通过打破对称性的过程，我们希望梯度下降或者其他高级优化算法可以找到$Θ$的最优值。

## 神经网络总体回顾：所有算法合体吧！

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/Wh6s3/putting-it-together)

> 这一节中，我们将对神经网络的所有内容进行一个整体回顾，看看这些零散的内容相互之间有怎样的联系，以及神经网络学习算法的总体实现过程。

### 第一步，选择一个合适的神经网络结构

当我们在训练一个神经网络的时候，我们要做的第一件事就是搭建网络的大体框架，这里我说的框架意思是神经元之间的链接模式。我们可能会从以下几种结构中选择：

![](/img/16_10_13/017.png)

- 第一种网络结构包含三个输入单元、五个隐藏单元、和四个输出单元。
- 第二种包含三个输入单元，两组五个隐藏单元作为隐藏层，四个输出单元。
- 第三种组合是三个输入单元，三组五个隐藏单元作为隐藏层，四个输出单元。

这些就是可能选择的结构，每一层可以选择多少个隐藏单元，以及可以选择多少个隐藏层。这些都是你构建时的选择，那么我们该如何做出选择呢？

首先，我们知道我们已经定义了输入单元的数量，一旦你确定了特征集$x^{(i)}$对应的输入单元数目，也就确定了特征$x^{(i)}$的维度，输入单元的数目将会由此确定。

其次如果你正在进行多类别分类，那么输出层的单元数目将会由你分类问题中所要区分的类别个数确定。

> 值得一提的是，在多类别分类问题中，若$y$的取值范围是在${1,2,3,..,10}$之间，那么你就有10个可能的分类，别忘了把你的y重新写成向量的形式，例如：

$$
y=
\begin{bmatrix}
   1 \\\\
   0 \\\\
   0 \\\\
   ... \\\\
   0
  \end{bmatrix}
$$

> 假设现在要表示第5个分类，也就是说$y=5$，那么在你的神经网络中，就不能直接使用数值5来表达，因为这种情况下，神经网络将有10个输出单元，你应该用一个向量来表示：

$$
y=
\begin{bmatrix}
  	0 \\\\
	0 \\\\
	0 \\\\
	0 \\\\
   	1 \\\\
   	0 \\\\
   	0 \\\\
	0 \\\\
	0 \\\\
   	0
  \end{bmatrix}
$$

所以对于输入和输出单元的数目的选择，是比较容易理解的。而对于隐藏层单元的个数，以及隐藏层的数目，我们有一个默认的规则，那就是**只使用单个隐藏层**，所以第一种类型的神经网络架构是最常见的：

![](/img/16_10_13/018.png)

或者如果你使用超过一层的隐藏层的话，同样我们也有一个默认规则，那就是**每一个隐藏层通常都应该拥有相同的单元数**。所以后面的两种神经网络结构的隐藏层都拥有相同的单元数：

![](/img/16_10_13/019.png)

但实际上通常来说，只使用一层隐藏层的结构是较为合理的默认结构。

而对于隐藏单元的个数，通常情况下**隐藏单元越多越好**，不过我们需要注意的是，如果有大量的隐藏单元，计算量一般会比较大。并且，一般来说，每个隐藏层所包含的单元数量还应该和输入$x$的维度相匹配，也要和特征的数目相匹配。可能隐藏单元的数目和输入特征的数量相同，或者是它的二倍或者三倍、四倍。因此，隐藏单元的数目需要和其他参数相匹配。

一般来说隐藏单元的数目取稍大于输入特征数目都是可以接受的。

### 训练神经网络的步骤

接下来，我们就来具体介绍如何实现神经网络的训练过程，下面是训练神经网络的六个步骤：

- 1.构建一个神经网络并且随机初始化权值（**Randomly initialize Weight**）

> 我们通常把权值初始化为很小的值，接近于0

- 2.执行向前传播算法，也就是对于神经网络的任意一个输入$x^{(i)}$计算出对应的$h\_{Θ}(x^{(i)})$。
- 3.通过代码计算出代价函数$J(Θ)$
- 4.执行反向传播算法(**Backprop**)来算出这些偏导数：$\frac{\partial}{\partial Θ\_{jk}^{(l)}}J(Θ)$

> 具体来说，我们要对所有训练集数据使用一个`for`循环进行遍历没一个样本（实际上有更复杂的方式来替代`for`循环来实现，但对于第一次实现神经网络的训练过程，我非常不建议使用`for`循环以为的方式，因为这种方式更有助于第一次使用时的理解）：
> 
> ```
for i = 1:m
 ```
  	
> 注意：下面这部分是在for循环内，但markdown的代码片段不支持显示Letex所以写在了外部：
> 
> ---for循环内部开始---
> 
> 对样本$(x^{(i)},y^{(i)})$使用向前传播和反向传播算法
 	(具体来说，就是把输入项带入后，得出每个节点的激励值$a^{(l)}$和delta项$δ^{(l)}$)
> $$
△^{(l)} := △^{(l)} + δ^{(l+1)}(a^{(l)})^{T}
$$
>
> ---for循环内部结束---
> 
> 
> 计算出这些$△$的累加值之后，我们将用别的程序来计算出偏导数项：
> $$
> \frac{\partial}{\partial Θ\_{jk}^{(l)}}J(Θ)
> $$

- 5.使用梯度检查来校验结果。用梯度检查来比较这些已经用反向传播算法得到的偏导数值$\frac{\partial}{\partial Θ\_{jk}^{(l)}}J(Θ)$与用数值方法得到的估计值进行比较，来检查，确保这两种方法得到值是基本相近的。

> 通过梯度检查，我们能确保我们的反向传播算法得到的结果是正确的，但必须要说明的一点是，检查结束后我们需要去掉梯度检查的代码，因为梯度检查计算非常慢。

- 6.使用一个最优化算法（比如说梯度下降算法或者其他更加高级的优化方法，比如说BFGS算法，共轭梯度法，或者其他一些已经内置到`fminunc`函数中的方法），将所有这些优化方法和反向传播算法相结合，这样我们就能计算出这些偏导数项的值$\frac{\partial}{\partial Θ\_{jk}^{(l)}}J(Θ)$。

> 到现在，我们已经知道了如何计算代价函数$J(Θ)$，我们知道了如何使用反向传播算法来计算偏导数$\frac{\partial}{\partial Θ\_{jk}^{(l)}}J(Θ)$，那么我们就能使用某个最优化方法来最小化$J(Θ)$关于$Θ$的函数值。

顺便提一下，对于神经网络代价函数$J(Θ)$是一个非凸函数，因此理论上是能够停留在局部最小值的位置。实际上，梯度下降算法和其他一些高级优化方法理论上都能收敛于局部最小值，但一般来讲这个问题其实并不是什么要紧的事，尽管我们不能保证这些优化算法一定会得到全局最优值，但通常来讲，像梯度下降这类的算法在最小化代价函数$J(Θ)$的过程中，还是表现的很不错的，通常能够得到一个很小的局部最小值，尽管这可能不一定是全局最优值。

### 梯度下降法在神经网络中的直观理解

最后，梯度下降算法，似乎对于神经网络来说还是比较神秘的，希望下面这幅图能让你对梯度下降法在神经网络中的应用产生一个更直观的理解：

![](/img/16_10_13/020.png)

这实际上有点类似我们早先时候解释梯度下降时的思路：我们有一个代价函数$J(Θ)$，并且在我们的神经网络中有一系列参数值，这里我之写下了两个参数值$Θ\_{12}^{(1)}$,$Θ\_{11}^{(1)}$，当然实际上在神经网络里，我们可以有很多很多的参数值：$Θ^{(1)}$,$Θ^{(2)}$...。因此我们参数的维度就会很高了，也无法绘制成直观的图像。所以这里我们假设这个神经网络中只有两个参数值：$Θ\_{12}^{(1)}$,$Θ\_{11}^{(1)}$。

那么代价函数$J(Θ)$度量的就是这个神经网络对训练数据的拟合情况。

所以，如果你取某个参数，比如说在这样一个局部最优值：

![](/img/16_10_13/021.png)

这一点的位置所对应的参数$Θ$的情况是对于大部分的训练数据，我的假设函数的输出会非常接近于$y^{(i)}$:

$$
h\_{Θ}(x^{(i)})≈y^{(i)}
$$

那么如果是这样的话，那么我们的代价函数$J(Θ)$值就会很小。

而反过来，如果我们取这个值：

![](/img/16_10_13/022.png)

我们的代价函数$J(Θ)$值就会很大。

因此**梯度下降的原理是我们从某个随机的初始点开始，它将会不停的下降，那么反向传播算法的目的就是算出梯度下降的方向，而梯度下降的过程就是沿着这个方向一点点的下降，一直到我们希望得到的点，这一点就是我们希望找到的局部最优点**。

所以，当你在执行反向传播算法并使用梯度下降或者更高级的优化方法时，上面的图片很好地帮你解释了基本的原理，也就是视图找到某个最优的参数值。这个值使得我们的神经网络的输出值与$y^{(i)}$的实际值（也就是训练集的输出观测值）尽可能的接近