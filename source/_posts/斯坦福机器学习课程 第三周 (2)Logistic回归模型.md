title: 斯坦福机器学习课程 第三周 (2)Logistic回归模型
tags:
  - 算法
categories:
  - 算法
  - 机器学习
comments: true
date: 2016-08-25 23:54:00
mathjax: true
---

## 逻辑回归的代价函数

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/1XG8G/cost-function)

这节课将讲解逻辑回归中，如何定义用来拟合参数的**代价函数**。

![](/img/16_08_25/001.png)

如上图所示，我们现在有一组训练集，其中有$m$个训练样本，由于是一个分类问题，我们的$y$取值范围就是0和1。并且我们给出了假设函数$h\_{\theta}(x)$。现在的问题就是，我们如何确定我们的参数$\theta$的值呢？也就是说如何**拟合参数$\theta$**呢？

![](/img/16_08_25/002.png)

上图是之前求线性回归问题时的代价函数，现在我将上图的公式进行改写：

$$
Cost(h\_{\theta}(x^{(i)}),y^{(i)})=
\frac{1}{2}(h\_{θ}(x^{(i)})-y^{(i)})^{2}
$$

为了简写方便，去掉上标之后的代价函数如下：

$$
Cost(h\_{\theta}(x),y)=
\frac{1}{2}(h\_{θ}(x)-y)^{2}
$$

在线性回归问题中，代价函数会被定义为以上这种形式，但在逻辑回归里，如果我们最小化代价函数后，使用这个最小代价的值也是可以正常工作的，但是我们的这个代价函数会变成参数$\theta$的非凸函数。

因为这里：

$$
\begin{align\*}
h\_{\theta}(x)
= \frac{1}{1+e^{-\theta^{T}x}}
\end{align*}
$$ 

$h\_{\theta}(x)$是非线性的，如果将这个值带入Cost函数，然后在求代价函数$J(\theta)$，我们会得到如下的有多个局部最优的函数：

![](/img/16_08_25/003.png)

这种函数的官方名称叫做：**非凸函数**。

你大概可以感觉到如果把梯度下降算法用在这样一个函数上，不能保证它会收敛到全局最小值。

相应的，我们期望我们的代价函数$J(\theta)$是一个凸函数：

![](/img/16_08_25/004.png)

对于这样的函数，我们使用梯度下降算法，才能够保证顺利的收敛到最小值。

这里导致我们的代价函数是非凸函数的根本原因就在于使用逻辑回归的那一步：

$$
\begin{align\*}
h\_{\theta}(x)
= \frac{1}{1+e^{-\theta^{T}x}}
\end{align*}
$$ 

所以我们想做的就是，**另找一个是凸函数的代价函数**使得我们能够方便的找到代价函数的全局最小值。

因此对于**逻辑回归的代价函数**，形式如下：

![](/img/16_08_25/005.png)

对应的函数的图形如下：

|$y=1$时|$y=0$时|
|:-:|:-:|
|![](/img/16_08_25/006.png)|![](/img/16_08_25/007.png)|

现在这种形式的代价函数，有着很多很有趣的性质：

- 在$y=1$的情况下：
	- 如果假设函数$h\_{\theta}(x) = 1$，那么代价函数为0:$Cost=0$。
	- 如果假设函数$h\_{\theta}(x) \rightarrow 0$，那么代价函数趋近于∞:$Cost \rightarrow ∞$
- 在$y=0$的情况下：
	- 如果假设函数$h\_{\theta}(x) \rightarrow 1$，那么代价函数为0:$Cost \rightarrow ∞ $。
	- 如果假设函数$h\_{\theta}(x) = 0$，那么代价函数等于0:$Cost = 0$
	
这就是我们所期望的效果：**当假设函数和期望值越接近时，代价函数值越小，反之越大。**

## 简化代价函数以及梯度下降

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/MtEaZ/simplified-cost-function-and-gradient-descent)

这节课我们来讲解一种**稍微简单一些的方式来写代价函数**，来替代我们现有的方法。同时也要讲清楚，**如何运用梯度下降法来拟合出逻辑回归的参数$\theta$**。因此，听了这节课，你应该就能够实现一个完整的逻辑回归算法了。

### 简化单个样本的代价函数$Cost(h\_{\theta}(x),y)$

之前我们讲解了逻辑回归中的代价函数：

![](/img/16_08_25/008.png)

上图中有：

- 我们定义的逻辑回归的整体的代价函数$J(\theta)$
- 针对于单个样本的代价函数$Cost(h\_{\theta}(x),y)$
- 并且我们知道，作为分类问题，我们的$y$的取值永远都是0或者1。

其中对于单个样本的代价函数$Cost(h\_{\theta}(x),y)$，我们可以把$y=0$和$y=1$的两种情况合二为一，写成一个统一的式子：

$$
Cost(h\_{\theta}(x),y)=-ylog(h\_{\theta}(x))-(1-y)log(1-h\_{\theta}(x))
$$

这个表达式和我们之前写的代价函数的表达式，效果是完全一样的，但后者更加紧凑。

> 我们知道在上面的式子中，$y$的取值非0即1，如果$y=1$那么$Cost(h\_{\theta}(x),y)=-log(h\_{\theta}(x))$，如果$y=0$那么$Cost(h\_{\theta}(x),y)=-log(1-h\_{\theta}(x))$。效果和分开写是完全一样的。

### 拟合逻辑回归的参数$\theta$

这样一来，我们就可以写出完整的逻辑回归的代价函数了：

![](/img/16_08_25/009.png)

> 似乎我们有其他方式来表示单个样本的代价函数$Cost(h\_{\theta}(x),y)$，但在这里不做详细的说明，但是我可以告诉你，现在我们使用的这种形式的代价函数的式子，是从统计学中的**极大似然法**得来的。不过如果你不理解什么是**极大似然法**，以及逻辑回归中的代价函数为什么是这种形式，也没关系，也不会影响你后面的学习。

接下来的问题就是找到使得代价函数$j(\theta)$最小的参数$\theta$了：

![](/img/16_08_25/010.png)

一旦我们得到了这个合适的$\theta$那么我们就可以对一个给定的样本进行预测了：

![](/img/16_08_25/011.png)

> 注意：$p(y=1|x;\theta)$就是指关于$x$以$\theta$为参数，$y=1$的概率。

由此可见，我们问题的核心在于求解最小化代价函数：

![](/img/16_08_25/012.png)

上图就是逻辑回归问题中最小化代价函数的方法，是通过梯度下降算法来实现。

对上图中的偏导数项展开后就是下面的形式：

![](/img/16_08_25/013.png)

如果你把上面的式子放到线性回归问题中进行对比的话，**你会发现这个式子正是用来做线性回归梯度下降的。**

那么我们不禁要问一下自己，线性回归算法和逻辑回归算法是一样的吗？

要回答这个问题，就要看从线性回归，到逻辑回归，到底发生了哪些变化。

实际上对于假设函数$h\_{\theta}(x)$的定义发生了变化：
  
  - 线性回归中，假设函数定义为$h\_{\theta}(x)=\theta^{T}x$
  - 在逻辑回归中，假设函数的定义为$h\_{\theta}(x)= \frac{1}{1+e^{-\theta^{T}x}}$

由于假设函数的不同，实际上线性回归和逻辑回归的梯度下降是两个完全不同的东西。

当我们在讨论线性回归的梯度下降算法时，我们谈到了如何监控梯度下降法以确保其收敛。其实我们通常也把这种方法运用在逻辑回归中，来检测梯度下降，以确保其正常收敛。这里就不多做介绍，可以参考**斯坦福机器学习课程 第一周 (5)参数学习-梯度下降算法**来实现。

## 高级优化

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/licwf/advanced-optimization)

这节课中会介绍一些高级优化概念和技巧。利用这些技巧，我们就使通过梯度下降进行逻辑回归的速度大大提高，这也将使得算法更加适合解决大型的机器学习问题。

### 优化算法概念引入

现在我们换个角度来看看什么是梯度下降：

我们有个代价函数$J(\theta)$，并且我们希望最小化代价函数$min\_{\theta}J(\theta)$。

为了得到最小化代价函数$min\_{\theta}J(\theta)$，我们需要计算出$J(\theta)$关于每一项$\theta$的偏导：

![](/img/16_08_25/014.png)

有了上面的$J(\theta)$关于每一项$\theta$的偏导，为了求得合适的$\theta$，我们就可以利用梯度下降算法来递减$\theta$，使其接近全局最小值了：

![](/img/16_08_25/015.png)

但事实上，**梯度下降并不是我们可以使用的唯一算法**，下面是我们常用的几种算法：

- **梯度下降算法(Gradient descent)**
- **共轭梯度法(Conjugate gradient)**
- **变尺度法(BFGS)**
- **限制变尺度法(L-BFGS)**

除了我们常说的梯度下降算法外的其他三种算法，都有着更复杂的方式来求最小化代价函数。但是这三种算法的细节，超出了本门课程的范畴(实际上如果你想要研究这些算法，可能你需要花费几周的时间，你可以专门学一门课程来提高数值计算能力)。不过我会告诉你他们的一些特性。

### 优缺点

这三种算法有许多优点：

**优点**：

- 不需要手动选择学习率$a$
	- 所以对这些算法的一种思路是 给出计算导数项和代价函数$J(\theta)$的方法，你可以认为算法有一个智能的内部循环，这种智能的内部循环被称为**线性搜索(line search)**算法，它可以自动尝试不同的学习速率$a$，并自动选择一个好的学习速率$a$。因此它甚至可以在每次迭代时都选择不同的学习速率，那么你就不需要自己选择$a$了。
- 通常情况下收敛速度比梯度下降算法更快
	- 这些算法实际上在做更复杂的事情，而不仅仅是选择一个好的学习速率$a$，所以他们往往最终收敛的远远快于梯度下降。不过关于它们是如何做到的细节，已经超过了本门课程的范畴。


> 实际上，我过去十年我都在相当频繁的使用这几种算法。但直到前几年，我才真正搞清楚共轭梯度法、BFGS和L-BFGS的细节。因此，实际上你完全可以在不了解这些算法的内环间在做什么的的情况下使用这些算法，并应用于许多不同的学习问题。

如果说这些算法优缺点的话，那么它的缺点就是：

**缺点**

- 比梯度下降法复杂多了
	- 如果你不是数值计算方面的专家，不建议你亲自去写共轭梯度法、BFGS和L-BFGS，而是去使用一些现成的库。实际上Octave和Matlab都有很理想的库来实现这些先进的优化算法。值得一提的是，这些算法在不同语言上的实现，是有差别的，有的语言上的库可能会表现的不太好。所以建议对比选择合适的实现。

### 使用实例

接下来来举例说明如何使用这些算法。

比如你有一个包含两个参数的问题：

![](/img/16_08_25/016.png)

对于上图中的代价函数，我们可以求得当$\theta\_{1}=5$,$\theta\_{2}=5$时，$J(\theta)$的值最小。

下面就看看怎么使用Octave程序来计算$\theta\_{1}$和$\theta\_{2}$吧。

```
function [jVal, gradient] = costFunction(theta)

jVal = (theta(1)-5)^2 + (theta(2)-5)^2;

gradient = zeros(2,1);
gradient(1) = 2*(theta(1)-5);
gradient(2) = 2*(theta(2)-5);
```

上面这段代码定义了一个函数`costFunction(theta)`，参数是一个`theta`向量，包含$\theta\_{1}$和$\theta\_{2}$，返回值是`jVal`和`gradient`。通过函数的定义，我们可以看出来`jVal`表示的是代价函数$J(\theta)$：

![](/img/16_08_25/018.png)

`gradient`是一个列量，其中两个值分别代表对$\theta\_{1}$和$\theta\_{2}$的偏导：

![](/img/16_08_25/019.png)

接下来，调用高级优化函数`fminunc`：

```
options = optimset('GradObj', 'on', 'MaxIter', '100');
initialTheta = zeros(2,1);
[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);
```

`fminunc`表示Octave里无约束最小化函数，调用这个函数时，需要传入一个存有配置信息的变量`options`。上面的代码中，我们的设置项中`'GradObj', 'on',`代表设置梯度目标参数为打开状态(on)，这也意味着你现在确实要给这个算法提供一个梯度。`'MaxIter', '100'`代表设置最大迭代次数为100次。`initialTheta`代表我们给出的一个$\theta$的猜测初始值。

然后我们调用`fminunc`这个函数，传入三个参数，其中第一个参数`@costFunction`这里的`@`符号代表指向之前我们定义的`costFunction`函数的指针。后面两个参数分别是我们定义的$theta$初始值和配置信息`options`。

当我们调用这个`fminunc`函数时，它会自动的从众多高级优化算法中挑选一个来使用(你也可以把它当做一个可以自动选择合适的学习速率$a$的梯度下降算法)。

最终我们会得到三个返回值，分别是满足最小化代价函数$J(\theta)$的$\theta$值`optTheta`，`costFunction`中定义的`jVal`的值`functionVal`，以及标记是否已经收敛的状态值`exitFlag`，如果已收敛，标记为`1`，否则为`0`。

下面我们看看在Octave中具体怎么操作：

首先在当前工作目录下创建costFunction.m脚本，写入costFunction函数:

![](/img/16_08_25/020.png)

然后在Octave终端下带入`fminunc`函数：

![](/img/16_08_25/021.png)

### 在逻辑回归中使用优化算法

上面的例子是一个简单的二次函数中使用优化算法的例子，下面我们介绍一些在逻辑回归中使用这些算法：

![](/img/16_08_25/022.png)

上图就是逻辑回归问题的代价函数的求解代码。可以看到大体流程和之前的例子是一致的，你只需要把相应的计算`jVal`以及各个`gradient`的代码，按照逻辑回归的规则填写完整即可。

> 使用了这些复杂的优化算法之后，虽然它将使得调试变得更为困难，但是这些算法的速度远远大于普通的梯度下降算法的速度，因此可以用来处理很大的机器学习问题的时候，可以使用这些高级算法，而不是梯度下降算法。