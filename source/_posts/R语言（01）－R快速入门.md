title: R语言（01）
date: 2016-02-29 22:08:55
tags:
  - R
categories:
  - 算法
  - 工具包
comments: true
---

## What's R?

### R的起源

R是S语言的一种实现。S语言是由AT&T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman和Ross Ihaka及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。

### R is free

R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。

R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言；可操纵数据的输入和输出，可实现分支、循环，用户可自定义功能。

R是一个免费的自由软件，它有UNIX、MacOS和Windows版本，都是可以免费下载和使用的。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。

官方网站：[http://www.r-project.org](http://www.r-project.org)

### R的特点

* 有效的数据处理和保存机制。
* 拥有一整套数组和矩阵的操作运算符。
* 一系列连贯而又完整多数据分析中间工具。
* 图形统计可以数据直接进行分析和显示，可用于多种图形设备。
* 一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数，以及输入输出接口。
* R语言是彻底面向对象的统计编程语言。
* R语言和其他编程语言、数据库之间有很好的接口。
* R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。
* R语言具有丰富的网上资源。

## 运行R

### R的运行界面：

![R的运行界面](/img/r_01_01.png)

### 安装第三方包

![安装第三方包](/img/r_01_02.png)
![安装第三方包](/img/r_01_03.png)

选择需要安装的包，点击安装即可

安装成功之后可以看到：

![安装第三方包](/img/r_01_04.png)

`假如安装a包需要依赖到b包和c包，那么在安装a包之前，R会自动去安装好所依赖的b包和c包。`

## 相关函数介绍

R能通过手动输入数据，读取文本中的数据，以及orical之类的数据（前提是只要安装好对应的包），基本上所有的数据源都可以读取。

---
### 基本函数

#### c()

函数c()是最基本的一个函数，用于创建数列。数列是R中最基本的一个数据结构.

```r
> x=c(1,3,4,5,2,4,3)
> x
[1] 1 3 4 5 2 4 3
```

#### mode()

查看数据类型，使用mode( )函数

```r
> x=c(1,3,4,5,2,4,3)
> mode(x)
[1] "numeric"
```

由于上例中x中存放的都是数值类型，所以mode输出”numeric"

如果存放字符类型，则产生”character”的输出：

```r
> y = c("aaa","bbb","ccc")
> mode(y)
[1] "character"
```

#### length()
length( ) 用来看一个向量的长度

```r
> x = c(1,3,5,4,7,2)
> length(x)
[1] 6
```

#### 1:100
c(1:100)  相当于 c(1,2,3,4…100)

#### rbind(x1,x2)和cbind(x1,x2)

rbind(x1,x2) 把两个向量合成一个矩阵，把x1和x2当成两个行来处理

cbind(x1,x2) 同rbind(x1,x2) 不过把x1和x2当成两个列向量来处理

`这里x1和x2必须长度相等，或者长度为1（如果长度为1，则不足的位置按照唯一的那个元素补齐）`

```r
> x1=c(2,4,6,8,0)
> x2=c(1,3,5,7,9)
> rbind(x1,x2)
   [,1] [,2] [,3] [,4] [,5]
x1    2    4    6    8    0
x2    1    3    5    7    9
> cbind(x1,x2)
     x1 x2
[1,]  2  1
[2,]  4  3
[3,]  6  5
[4,]  8  7
[5,]  0  9
```
---
### 求平均值，和，连乘，最值，方差，标准差

#### mean()
- mean() 传入数列，求平均值

```r
> x=c(1:100)
> mean(x)
[1] 50.5
```

#### sum()
- sum() 传入数列，求和

```r
> sum(x)
[1] 5050
```

#### max()
- max() 传入数列，求最大值

```r
> max(x)
[1] 100
```

#### min()
- min() 传入数列，求最小值

```r
> min(x)
[1] 1
```

#### var()
- var() 传入数列，求方差（每一项减去平均值之后再平方，然后把平方和加起来 的值就是方差，方差的大小反应的是数据的离散程度，方差越大，离散程度越大）

```
> var(x)
[1] 841.6667
```

#### prod()
- prod() 传入数列，求连乘

```r
> prod(x)
[1] 9.332622e+157
```

#### sd()
- sd() 传入数列，求标准差（标准差也是反应离散程度，和求方差略有不同，自行学习）

```r
> sd(x)
[1] 29.01149
```

---

### help()

help() 传入命令名称，查看帮助文档

```r
help(mode)
```

会打开一个文档页面：

![文档页面](/img/r_01_05.png)

`可以看到里面有个“<-”的符号，这个符号在R中等同于”="，代表赋值符号。`

---

### 向量的操作

#### 产生向量

产生1到10的数字向量

```r
> 1:10
 [1]  1  2  3  4  5  6  7  8  9 10
```

产生1到10的数字向量，并且每一项-1

```r
> 1:10-1
 [1] 0 1 2 3 4 5 6 7 8 9
```

产生1到10的数字向量，并且每一项*2

```r
> 1:10*2
 [1]  2  4  6  8 10 12 14 16 18 20
```

产生2到60的数字向量，并且每一项*2+1

```r
> 2:60*2+1
 [1]   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37  39
[19]  41  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75
[37]  77  79  81  83  85  87  89  91  93  95  97  99 101 103 105 107 109 111
[55] 113 115 117 119 121
```

#### 取出向量的元素

a[5] 代表取出第5个元素

```r
> a = 2:60*2+1
> a
 [1]   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37  39  41
[20]  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75  77  79
[39]  81  83  85  87  89  91  93  95  97  99 101 103 105 107 109 111 113 115 117
[58] 119 121
> a[5]
[1] 13
```

取出a中的第1到5个元素

```r
> a[1:5]
[1]  5  7  9 11 13
```

代表a中第1到5个元素不显示，其他的显示出来。

```r
> a[-(1:5)]
 [1]  15  17  19  21  23  25  27  29  31  33  35  37  39  41  43  45  47  49  51
[20]  53  55  57  59  61  63  65  67  69  71  73  75  77  79  81  83  85  87  89
[39]  91  93  95  97  99 101 103 105 107 109 111 113 115 117 119 121
```

向量中传入一个数列，代表取出这个数列对应的a中的元素，即取出a中第2，4，7的元素。

`注意：这里一定要用c()函数`

```r
> a[c(2,4,7)]
[1]  7 11 17
```

把元素值小于20的全部列出来

```r
> a[a<20]
[1]  5  7  9 11 13 15 17 19
```

取出元素大于30并且小于50的元素

```r
> a[a>30 & a<50]
 [1] 31 33 35 37 39 41 43 45 47 49
```

取出a向量下标为3的元素对应的数值，作为下标的元素。这里a[3]是9，即取出a[9]对应的元素21.

```r
> a[a[3]]
[1] 21
```

### 通过 seq() 函数来产生向量

产生从5到20，并且公差为1的向量

```r
> seq(5,20)
 [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
```

产生从5到121，公差为2的向量

```r
> seq(5,121,by=2)
 [1]   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37  39  41
[20]  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75  77  79
[39]  81  83  85  87  89  91  93  95  97  99 101 103 105 107 109 111 113 115 117
[58] 119 121
```

给出从5到121的，长度为10的等差数列。

```r
> seq(5,121,length=10)
 [1]   5.00000  17.88889  30.77778  43.66667  56.55556  69.44444  82.33333
 [8]  95.22222 108.11111 121.00000
```

### 常量letters
产生字母序列letters，这是一个常数向量，包含26个字母。

```r
> letters[1:30]
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z" NA  NA  NA  NA 
```

### which()函数

which.max()函数给出数列中最大元素对应的下标值

```r
> a=c(2,3,4,2,5,1,6,3,2,5,8,5,7,3)
> which.max(a)
[1] 11
```

which.min()函数给出数列中最小元素对应的下标值

`(如果最大值，最小值有多个，默认只显示下标号最小的那个下标)`

```r
> which.min(a)
[1] 6
```

取出a中最大元素的值

```r
> a[which.max(a)]
[1] 8
```

取出元素值为2的下标

```r
> which(a==2)
[1] 1 4 9
```

取出元素值大于5的下标

```r
> which(a>5)
[1]  7 11 13
```

### rev() 向量翻转

rev()函数可以将向量翻转,但不改变原向量

```r
> a＝1:20
> a
 [1] 2 3 4 2 5 1 6 3 2 5 8 5 7 3
> rev(a)
 [1] 3 7 5 8 5 2 3 6 1 5 2 4 3 2
```

### sort() 排序

sort()函数，可以将向量按照从小到大的顺序排序，同样，也不改变原来的向量

```r
> a=c(5,2,3,1,4,6)
> a
[1] 5 2 3 1 4 6
> rev(sort(a))
[1] 6 5 4 3 2 1
```

---

### 矩阵操作

#### matrix()函数 生成矩阵

```r
> a1=c(1:12)
> matrix(a1,nrow=3,ncol=4)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> matrix(a1,nrow=4,ncol=3)
     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12
> matrix(a1,nrow=4,ncol=3,byrow=T)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
[4,]   10   11   12
```

如果向量长度大于等于创建矩阵所需要的元素个数，则可以创建矩阵，否则不行：

```r
> matrix(a1,nrow=3,ncol=3)
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> matrix(a1,nrow=3,ncol=5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    4    7   10    1
[2,]    2    5    8   11    2
[3,]    3    6    9   12    3
警告信息：
In matrix(a1, nrow = 3, ncol = 5) : 数据长度[12]不是矩阵列数[5]的整倍数
```

#### t()

t()函数，求矩阵的转置

```r
> a=matrix(a1,nrow=3,ncol=4)
> a
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12
> t(a)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
[4,]   10   11   12
```

#### 矩阵的运算

矩阵的加减法：

```r
> a=b=matrix(1:12,nrow=3,ncol=4)
> a+b
     [,1] [,2] [,3] [,4]
[1,]    2    8   14   20
[2,]    4   10   16   22
[3,]    6   12   18   24
> a-b
     [,1] [,2] [,3] [,4]
[1,]    0    0    0    0
[2,]    0    0    0    0
[3,]    0    0    0    0
```

矩阵相乘:

a%*%b

`注意不是a*b,如果是a*b的话，只是把对应的元素相乘。`

```r
> a=matrix(1:12,nrow=3,ncol=4)
> b=matrix(1:12,nrow=4,ncol=3)
> a%*%b
     [,1] [,2] [,3]
[1,]   70  158  246
[2,]   80  184  288
[3,]   90  210  330
```

#### diag()函数，求对角线

```r
> a=matrix(1:16,nrow=4,ncol=4)
> a
     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16
> diag(a)
[1]  1  6 11 16
> diag(diag(a))
     [,1] [,2] [,3] [,4]
[1,]    1    0    0    0
[2,]    0    6    0    0
[3,]    0    0   11    0
[4,]    0    0    0   16
```

得到一个行列数为4的对角线为1的单位矩阵：

```r
> diag(4)
     [,1] [,2] [,3] [,4]
[1,]    1    0    0    0
[2,]    0    1    0    0
[3,]    0    0    1    0
[4,]    0    0    0    1
```

#### rnorm()

rnorm()函数，按照正态分布，取出若干个随机数

```r
> a=matrix(rnorm(16),4,4)
> a
          [,1]         [,2]       [,3]       [,4]
[1,]  1.691672  0.154788749  0.7834991 -1.8964252
[2,]  1.388345  0.922029319 -0.2400506  0.1874301
[3,] -1.823898 -0.005734707 -1.3519814  0.9270790
[4,] -0.267829  0.763870795  0.6594918  0.9205407
```

#### solve()

solve()函数，求逆矩阵

```r
> solve(a)
            [,1]       [,2]       [,3]       [,4]
[1,] -0.44792192  0.4452669 -0.5585795 -0.4508867
[2,]  0.85187912  0.2515954  0.8583943  0.8392558
[3,]  0.01781248 -0.4399525 -0.3953840  0.5244663
[4,] -0.84997791  0.2359636 -0.5915584 -0.1170234
```

通过solve()函数解方程组：

```r
> a=matrix(rnorm(16),4,4)
> a
            [,1]        [,2]       [,3]       [,4]
[1,] -0.73318587  1.87980710  0.4991373 -0.1038004
[2,]  0.13700903 -0.19411509  0.5412432 -0.8160280
[3,] -0.07649991  0.01615857 -0.4907614 -2.3282147
[4,] -0.34977245  0.25837835 -0.6195753  0.1512799
> b=c(1:4)
> b
[1] 1 2 3 4
> solve(a,b)
[1] -29.246248 -12.182426   4.634966  -1.389123
```

相当于在解这样一个方程组：

-0.73318587 * x1 + 1.87980710 * x2 + 0.4991373 * x3 -0.1038004 * x4 = 1

0.13700903 * x1 - 0.19411509 * x2 + 0.5412432 * x3 -0.8160280 * x4 = 1

-0.07649991 * x1 + 0.01615857 * x2 - 0.4907614 * x3 -2.3282147 * x4 = 1

-0.34977245 * x1 + 0.25837835 * x2 - 0.6195753 * x3 + 0.1512799 * x4 = 1

最终解为：

x1= -29.246248

x2= -12.182426

x3= 4.634966

x4= -1.389123

#### eigen()

eigen()求矩阵的特征值函数

```r
> a=diag(4)+1
> a
     [,1] [,2] [,3] [,4]
[1,]    2    1    1    1
[2,]    1    2    1    1
[3,]    1    1    2    1
[4,]    1    1    1    2
> a.e=eigen(a,symmetric=T)
> a.e
$values
[1] 5 1 1 1

$vectors
     [,1]       [,2]       [,3]       [,4]
[1,] -0.5  0.8660254  0.0000000  0.0000000
[2,] -0.5 -0.2886751 -0.5773503 -0.5773503
[3,] -0.5 -0.2886751 -0.2113249  0.7886751
[4,] -0.5 -0.2886751  0.7886751 -0.2113249
> a.e$vectors%*%diag(a.e$values)%*%t(a.e$vectors)
     [,1] [,2] [,3] [,4]
[1,]    2    1    1    1
[2,]    1    2    1    1
[3,]    1    1    2    1
[4,]    1    1    1    2
```

### 数组

数组  相当于加了纬度的向量

向量不是数组，矩阵是数组的一种特殊情况

```r
> x=c(1:6)
> x
[1] 1 2 3 4 5 6
> is.vector(x)
[1] TRUE
> is.array(x)
[1] FALSE
> dim(x)<-c(2,3)
> x
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> is.array(x)
[1] TRUE
> is.matrix(x)
[1] TRUE
```

### 数据框

形式类似矩阵，但不同的地方是矩阵必须元素都是数字，而数据框每一列可以是不同类型的数据（可以某一列是数字，某一列是字符）。

一般情况，每列是一个变量，每行是一个观测值。

data.frame(x1,x2) 将两个等长的向量组合成一个数据框，(一定要是等长的向量才可以组合)

```r
> x1=c(10,13,45,26,23)
> x2=c(22,33,44,55,66)
> x=data.frame(x1,x2)
> x
  x1 x2
1 10 22
2 13 33
3 45 44
4 26 55
5 23 66
```

也可以制定表头

```r
> x=data.frame('重量'=x1,'运费'=x2)
> x
  重量 运费
1   10   22
2   13   33
3   45   44
4   26   55
5   23   66
```

plot()函数绘制散点图：

```r
> plot(x)
```

![plot散点图](/img/r_01_06.png)

---

### 从外部读取数据

先设置工作目录，把文本文件放于该目录下

首先工作目录下有一个”abc.txt”的文件：

![外部文件abc.txt](/img/r_01_07.png)

在R中通过read.table()函数 读取外部文件中的数据：

![读取外部文件](/img/r_01_08.png)

文本或excel的数据均可通过剪切板操作,”clipboard”是一个常量字符串，代表剪切板。

![读取粘贴板上的数据](/img/r_01_09.png)

#### 读取excel文件数据

**方法1:**先把excel另存为空格分割的prn文本格式（以空格来分隔数据）再读

![读取prn文件](/img/r_01_10.png)

或者可以另存为csv格式（以逗号来分隔数据），然后调用read.csv(“test.csv”,header=T)来读取。

**方法2:**安装RODBC包，再通过ODBC读

![通过ODBC读取csv](/img/r_01_11.png)

### 循环语句

#### for

```r
> for(i in 1:59){a[i]=i*2+3}
> a
 [1]   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37  39  41
[20]  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75  77  79
[39]  81  83  85  87  89  91  93  95  97  99 101 103 105 107 109 111 113 115 117
[58] 119 121
```

#### while

```r
> a[1]=5
> i=1
> while(a[i]<121){i=i+1;a[i]=a[i-1]+2}
> a
 [1]   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37  39  41
[20]  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75  77  79
[39]  81  83  85  87  89  91  93  95  97  99 101 103 105 107 109 111 113 115 117
[58] 119 121
```

### 执行外部脚本

#### source() print()

R语言出了在控制台中执行之外，也可以写成外部脚本。

![外部脚本](/img/r_01_12.png)

脚本中的内容：

```r
a = 1:10
print(a)
```

写入脚本中的输出，必须使用print()函数才能打印出来。

通过source()函数可以执行脚本文件：

```r
> source("h.r")
 [1]  1  2  3  4  5  6  7  8  9 10
```

---

### 分布函数

#### 正态分布函数 rnorm()

产生100个正态分布的随机数，平均值是80，标准差是7:

```r
> rnorm(100,mean=80,sd=7)
  [1] 91.84170 89.71842 67.23271 78.12520 81.08352 86.45421 79.95986 85.34710
  [9] 85.48449 78.31965 70.53613 84.61644 66.72502 81.31201 86.48955 86.44378
 [17] 74.86770 80.95906 79.46450 77.55159 93.15865 78.64119 80.11311 81.80865
 [25] 83.49396 83.78870 76.56467 75.66297 79.27340 74.28780 63.70250 81.05896
 [33] 86.11023 84.20057 73.15261 81.13779 89.98181 71.93431 70.49228 77.61948
 [41] 79.40982 78.53584 71.21602 73.33143 92.46275 75.92289 75.94395 75.28812
 [49] 74.10398 79.39188 73.27445 95.29717 84.59038 81.25490 87.83171 62.59891
 [57] 78.97906 91.78480 90.82124 83.91811 77.69758 78.35002 81.41204 78.43336
 [65] 78.50897 83.49485 86.27006 75.10600 73.42888 79.37818 82.71879 82.94783
 [73] 63.24346 82.08028 77.65782 81.06058 62.43572 79.50682 87.96813 70.42317
 [81] 78.87907 72.35188 76.39345 69.57194 77.76283 88.07266 68.14906 60.45371
 [89] 80.58541 80.46402 89.73413 82.27584 85.80826 80.18303 93.81132 83.20696
 [97] 85.48223 99.15548 80.25896 83.88441
```

#### 泊松分布函数rpois()

```r
> rpois(100,1:9)
  [1]  2  1  5  7  3  5  9  5  7  1  3  2  2  5  8 12  8 10  2  5  3  4  5  5  8
 [26]  8  5  0  3  4  4  6 12  8  4 10  2  3  3  4  4  3  6  8  6  0  0  5  4  4
 [51]  5  3 12 11  2  4  1  3  8  2  5  8  5  4  4  3  5  5 11  6 10  9  1  1  3
 [76]  5  8  4  9 11  5  0  4  2  5  6 10  9 12  7  0  2  4  4  5  2 10 11 13  1
```

#### 指数分布函数rexp()

#### gamma分布函数rgamma()

#### 均匀分布函数runif()

产生100个均匀分布的80到100的随机数

```r
> runif(100,min=80,max=100)
  [1] 82.32568 82.02504 94.93998 97.56770 88.23401 88.74055 98.43785 94.25619
  [9] 81.32116 84.68563 94.29525 92.97103 82.97045 99.32680 94.50783 96.61253
 [17] 98.53980 95.93528 92.12032 92.76401 85.38213 84.43117 96.86250 84.69108
 [25] 91.17830 82.79405 94.58394 84.90274 84.07085 83.87202 82.59535 88.50601
 [33] 83.38860 81.65984 95.71859 83.73108 88.13112 90.18066 96.21735 89.05043
 [41] 88.48573 96.24177 89.48188 85.85154 83.67180 84.38839 85.30037 93.55860
 [49] 81.74515 86.87908 89.86651 83.78685 96.95712 92.91492 80.78897 87.21055
 [57] 86.64808 80.24332 98.48211 91.42558 99.35341 81.53274 84.49945 80.28354
 [65] 89.47206 81.66101 85.38194 81.64460 98.43649 84.28751 85.85431 84.08602
 [73] 82.29368 95.23472 84.10213 89.61257 90.84469 94.17226 98.69019 87.96953
 [81] 91.89866 92.23568 94.01739 91.93723 93.71547 88.28105 88.27131 88.09687
 [89] 94.74121 86.47239 85.55283 94.90056 93.91155 86.16455 84.53169 97.29593
 [97] 93.21098 94.80586 80.71853 91.62332
```

#### 二项分布函数rbinom()

#### 几何分布函数rgeom()

---

### 四舍五入 round()

产生100个正态分布的随机数，平均值是80，标准差是7，对取出的元素进行四舍五入处理:

```r
> round(rnorm(100,mean=80,sd=7))
  [1]  79  75  93  96  82  70  83  77  78  84  79  80  78  81  77  67  73  76
 [19]  86  76  80  84  83  88  73  86  79  80  89  88  63  79  82  78  82  75
 [37]  81  87  89  89  79  76  81  93  75  73  77  74  71  83  69  77  88  74
 [55]  78  75  79  71  87  91  87  71  84  74  76  90 102  75  78  91  84  87
 [73]  71  78  75  83  76  78  80  78  83  79  92  90  92  78  74  80  86  82
 [91]  80  79  78  72  69  77  84  80  94  71
```

## 一个综合训练

模拟产生统计专业同学的名单（学号区分），记录数学分析，线性代数，概率统计三科成绩，然后进行一些统计分析。

产生一百个学号：

```r
> num=seq(10378001,10378100)
> num
  [1] 10378001 10378002 10378003 10378004 10378005 10378006 10378007 10378008
  [9] 10378009 10378010 10378011 10378012 10378013 10378014 10378015 10378016
 [17] 10378017 10378018 10378019 10378020 10378021 10378022 10378023 10378024
 [25] 10378025 10378026 10378027 10378028 10378029 10378030 10378031 10378032
 [33] 10378033 10378034 10378035 10378036 10378037 10378038 10378039 10378040
 [41] 10378041 10378042 10378043 10378044 10378045 10378046 10378047 10378048
 [49] 10378049 10378050 10378051 10378052 10378053 10378054 10378055 10378056
 [57] 10378057 10378058 10378059 10378060 10378061 10378062 10378063 10378064
 [65] 10378065 10378066 10378067 10378068 10378069 10378070 10378071 10378072
 [73] 10378073 10378074 10378075 10378076 10378077 10378078 10378079 10378080
 [81] 10378081 10378082 10378083 10378084 10378085 10378086 10378087 10378088
 [89] 10378089 10378090 10378091 10378092 10378093 10378094 10378095 10378096
 [97] 10378097 10378098 10378099 10378100
```

产生100个均匀分布的80到100的随机数，round()函数取整数部分进行四舍五入:

```r
> x1=round(runif(100,min=80,max=100))
> x1
  [1] 100 100  81  81  88  88  95  84  93  83  97  87  87  86  98  82  89  82
 [19]  87  82  82  86  90  83  98  91  90  94  94  88  85  92  87  88  88  93
 [37]  86  88  97  92  90  94 100  91  87  98  83  92  96  86  90  93  97  95
 [55]  80  89  86  81  98  90  82  90  95  90  87  81  92  88  81  86  88  97
 [73]  93  88  96  85  90  90  91  90  87  91  96  95  94  96  91  90  82  81
 [91]  88  98  89 100  92  85  81  82 100  83
```

产生100个随机元素，平均值是80，标准差是7：

```r
> x2=round(rnorm(100,mean=80,sd=7))
> x2
  [1] 75 78 81 66 86 80 77 80 79 74 76 82 76 74 77 84 75 77 86 68 88 71 83 83 61
 [26] 83 79 93 77 75 78 91 82 73 84 86 80 79 88 79 66 85 75 81 75 69 82 80 84 78
 [51] 67 92 97 90 65 77 74 84 82 83 74 86 83 79 80 90 74 81 72 83 79 80 70 71 95
 [76] 71 78 87 79 82 75 85 80 78 83 79 77 88 80 77 75 84 84 87 78 77 74 76 86 84
```

产生100个随机元素，平均值是83，标准差是18，由于标准差比较大，所以可能会产生大于100的错误数据，所以要对大于100的数据进行处理，通过which()函数取出大于100的元素下标，设置为100

```r
> x3=round(rnorm(100,mean=83,sd=18))
> x3
  [1]  81  81  74  80 102  88  65  80  82  66  70  76 102  58  63 122  70  71
 [19] 103  92  65  66  45  86  98  68  71  73  96  85  86 112  58  68 111  66
 [37]  90 104 112  48  94  83  74  81  84 120  94  79  79  44  95  71  68  86
 [55]  80  63  73  95  81 113  56  64 100  68 107  74 109 123 102  70  66  75
 [73]  70  48  86  56  74  86  79  75  67  50  68  96  93  60 124 111  77  82
 [91]  65  93 121  69  69 106  75  98  99  87
> x3[which(x3>100)]=100
> x3
  [1]  81  81  74  80 100  88  65  80  82  66  70  76 100  58  63 100  70  71
 [19] 100  92  65  66  45  86  98  68  71  73  96  85  86 100  58  68 100  66
 [37]  90 100 100  48  94  83  74  81  84 100  94  79  79  44  95  71  68  86
 [55]  80  63  73  95  81 100  56  64 100  68 100  74 100 100 100  70  66  75
 [73]  70  48  86  56  74  86  79  75  67  50  68  96  93  60 100 100  77  82
 [91]  65  93 100  69  69 100  75  98  99  87
```

通过data.frame()函数，将数据合成数据框：

```r
> x=data.frame(num,x1,x2,x3)
> x
         num  x1 x2  x3
1   10378001 100 75  81
2   10378002 100 78  81
3   10378003  81 81  74
4   10378004  81 66  80
5   10378005  88 86 100
6   10378006  88 80  88
7   10378007  95 77  65
8   10378008  84 80  80
9   10378009  93 79  82
10  10378010  83 74  66
11  10378011  97 76  70
12  10378012  87 82  76
13  10378013  87 76 100
14  10378014  86 74  58
...
```

通过write.table()函数，将数据保存到硬盘上。

```r
write.table(x,file="mark.txt",col.names=F,row.names=F,sep=" ")
```

`(这里也可以写绝对路径。默认路径就是当前工作空间。)`

![输出文件](/img/r_01_13.png)

---

开始分析数据：
计算各科平均分：

```r
> mean(x[1])
[1] NA
警告信息：
In mean.default(x[1]) : 参数不是数值也不是逻辑值：回覆NA
> colMeans(x)
        num          x1          x2          x3 
10378050.50       89.59       79.51       79.85 
> colMeans(x)[c("x1","x2","x3")]
   x1    x2    x3 
89.59 79.51 79.85 
> apply(x,2,mean)
        num          x1          x2          x3 
10378050.50       89.59       79.51       79.85 
```

cloMeans()对列求平均值

apply(x,2,mean)

     第一个参数代表要操作的数据框，
     第二个参数如果是1的话代表在行上做操作，如果是2的话，代表在列上做操作
     第三个参数代表操作类型，mean是求平均数
     
求各科的最高分，最低分

```r
> apply(x,2,max)
     num       x1       x2       x3 
10378100      100       97      100 
> apply(x,2,min)
     num       x1       x2       x3 
10378001       80       61       44 
```

求每个人的总分：

```r
> apply(x[c("x1","x2","x3")],1,sum)
  [1] 256 259 236 227 274 256 237 244 254 223 243 245 263 218 238 266 234 230
 [19] 273 242 235 223 218 252 257 242 240 260 267 248 249 283 227 229 272 245
 [37] 256 267 285 219 250 262 249 253 246 267 259 251 259 208 252 256 262 271
 [55] 225 229 233 260 261 273 212 240 278 237 267 245 266 269 253 239 233 252
 [73] 233 207 277 212 242 263 249 247 229 226 244 269 270 235 268 278 239 240
 [91] 228 275 273 256 239 262 230 256 285 254
```