title: 机器学习(01)kNN算法
date: 2015-12-6 21:39:55
tags:
  - 算法
categories:
  - 算法
  - 机器学习
comments: true
mathjax: true
---

## k-近邻算法概述

简单的说，k-近邻算法采用**测量不同特征值之间的距离方法进行分类**。

### kNN的工作原理是：
> 在一个样本数据集中（又称作训练样本集），每个样本都存在有**标签**，即我们知道样本数据集中每个数据所属分类的对应关系。输入**没有标签**的新数据时，将新数据的每个特征与样本集中数据的对应特征进行比较，然后算法**提取样本集中特征最相似数据**（最近邻）的分类标签。一般来说，我们只选择样本数据集中**前k个**最相似的数据，这就是k-近邻算法中k的出处，通常**k是不大于20**的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。


### k-近邻算法的优缺点
优点：精度高、对异常值不敏感、无数据输入假定。
缺点：计算复杂度高、空间复杂度高。
试用数据范围：数值型和标称型。

### k-近邻算法的一般流程
[1] 收集数据：可以使用任何方法。
[2] 准备数据：距离计算需要的数值，最好是结构化的数据格式。
[3] 分析数据：可以使用任何方法。
[4] 训练算法：此步骤不适用于k-近邻算法。
[5] 测试算法：计算错误率。
[6] 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。

## 举例：

### 使用k-近邻算法分类爱情片和动作片

有人曾经统计过很多电影的打斗镜头和接吻镜头，下图显示了6部电影的打斗和接吻镜头数。假如有一部未看过的电影，如何确定它是爱情片还是动作片呢？

![使用打斗和接吻镜头数分类电影](/img/ml_01_01.png)

首先我们需要知道这个未知电影存在多少个打斗镜头和接吻镜头。上图对应的数据如下：

每部电影的打斗镜头数、接吻镜头数以及电影评估类型：

| 电影名称      |    打斗镜头 | 接吻镜头  | 电影类型  |
| :-------- | --------:| :--: |:--: |
| California Man  | 3 |  104   | 爱情片|
| He's Not Really into Dudes  | 2 |  100   | 爱情片|
| Beautiful Woman  | 1 |  81   | 爱情片|
| Kevin Longblade  | 101 |  10   | 动作片|
| Robo Slayer 3000  | 99 |  5   | 动作片|
| Amped II  | 98 |  2   | 动作片|
| ?  | 18 |  90   | 未知|


即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先**计算未知电影与样本集中其他电影的距离**，如下表所示（暂时不要关心距离是如何计算的）：

已知电影与未知电影的距离

| 电影名称      |    与未知电影的距离  |
| :-------- | :--: |
| California Man  | 20.5|
| He's Not Really into Dudes  | 18.7 |
| Beautiful Woman  | 19.2 |
| Kevin Longblade  | 115.3 |
| Robo Slayer 3000  | 117.4 |
| Amped II  | 118.9|


现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到k个距离最近的电影。假定k=3，则三个最靠近的电影依次是*He's Not Really into Dudes*、*Beautiful Woman*和*California Man*。k-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。

## 代码实现kNN

### 创建样本数据集：

```python
from numpy import *
import operator

def createDataSet():
	group = array([1.0,1.1],[1.0,1.0],[0,0],[0,0.1])
	labels = ['A','A','B','B']
	return group,labels
```

命令行执行后得到：

```python
>>> group,labels = kNN.createDataSet()
>>> group
array([[1.0, 1.1],
	[1.0, 1.0],
	[0.0, 0.0],
	[0.0, 0.1]])
>>> labels
['A', 'A', 'B', 'B']
```

向量label包含了每个数据点的标签信息，label包含的元素个数等于group矩阵行数。这里，我们将数据点（1.0，1.1）定义为类A，数据点(0,0.1)定义为类B。

下图是四个点在坐标系中的表示：

![k-近邻算法：带有4个数据点的简单例子](/img/ml_01_02.png)

### 从文本文件中解析数据

将每组数据划分到某个类中，伪代码如下：

`对未知类别属性的数据集中的每个点依次执行以下操作：`
- (1) 计算已知类别数据集中的点与当前点之间的距离；
- (2) 按照距离递增次序排序；
- (3) 选取与当前点距离最小的k个点；
- (4) 确定前k个点所在类别的出现频率；
- (5) 返回前k个点出现频率最高的类别作为当前点的预测分类。

```python
# inX:用于分类的输入向量  
# dataSet:输入的训练样本集
# labels:标签向量
# k:用于选择最近邻的数量
def classify0(inX, dataSet, labels, k):
	# 距离计算
	dataSetSize = dataSet.shape[0] # 数据的条目数
	diffMat = tile(inX, (dataSetSize,1)) - dataSet
	sqDiffMat = diffMat**2
	sqDistances = sqDiffMat.sum(axis=1)
	distances = sqDistances**0.5
	
	# 将距离值按照从小到大排序
	sortedDistIndicies = distances.argsort()
	classCount={}
	
	# 取出前k个元素
	for i in rangs(k):
		# 取出对应的label
		voteIlabel = labels[sortedDistIndicies[i]]
		# 计算当前取出的label的数量
		classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1
	
	# 逆序排列label对应总数的列表 返回对应的label
	sortedClassCount = sorted(classCount.iteritems(),key=operator.itemgetter(1), reverse=True)
	return sortedClassCount[0][0]
```

`关于距离计算的部分`

参考欧式距离公式：
![欧式距离公式](/img/ml_01_03.png)

例如，计算点(0,0)到(1,2)之间的距离为：
![距离计算例子1](/img/ml_01_04.png)

计算点(1,0,0,1)与(7,6,9,4)之间的距离为：
![距离计算例子2](/img/ml_01_05.png)

为了预测数据所在的分类，在Python提示符中输入下列命令：

```python
>>> kNN.classify0([0,0], group, labels, 3)
```

输出的结果应该是B。

### 测试分类器

分类器并不会得到百分之百的正确的结果，为了测试分类器的效果，我们可以使用已知晓答案的数据，当然答案不能告诉分类器，检验分类器给出的结果是否符合预期结果。

通过大量的测试数据，我们可以得到分类器的错误率--分类器给出错误结果的词数 除以 测试执行的总数。

错误率是常用的评估方法，主要用于评估分类器在某个数据集上的执行效果。完美分类器的错误率为0，最差分类器的错误率是1.0，在这种情况下，分类器根本就无法找到一个正确答案。
