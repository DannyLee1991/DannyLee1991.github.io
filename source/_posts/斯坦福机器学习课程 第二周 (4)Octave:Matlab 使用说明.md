title: 斯坦福机器学习课程 第二周 (4)Octave/Matlab 使用说明
tags:
  - 算法
categories:
  - 算法
  - 机器学习
comments: true
date: 2016-08-13 17:28:00
mathjax: true
---

> 你现在已经掌握不少机器学习知识了，在这段视频中我将教你一种编程语言：Octave语言。你能够用它来非常迅速地实现这门课中我们已经学过或者将要学的机器学习算法。

> 过去我一直尝试用不同的编程语言来教授机器学习，包括C++、Java、 Python、Numpy 和 Octave。我发现当使用像Octave这样的高级语言时，学生能够更快、更好地学习并掌握这些算法。事实上，在硅谷我经常看到的情况是进行大规模的机器学习项目的人通常会使用的程序语言就是Octave。

> Octave是一种很好的原始语言(prototyping language)。使用Octave你能快速地实现你的算法，剩下的事情你只需要进行大规模的资源配置，你只用再花时间用C++或Java这些语言把算法重新实现就行了。因为我们知道，开发项目的时间或者说你的时间是很宝贵的，机器学习的时间也是很宝贵的。所以如果你能让你的学习算法在Octave上快速的实现，再用C++或者Java去改写，这样你就能节省出大量的时间。

> 据我所见人们使用最多的用于机器学习的原始语言是Octave、MATLAB、Python、NumPy和R。Octave很好因为它是开源的，当然 MATLAB也很好，但它不是每个人都买得起的。如果你能够使用MATLAB，Python、NumPy 或者R语言，你也可以在这门课里面使用。我也见过有人用R的，但是据我所知，这些人不得不中途放弃了，因为这些语言在开发上比较慢。而且因为Python、NumPy这些语言的语法相较于Octave来说还是更麻烦一点，正因为这样我强烈建议你不要用NumPy或者R来完整这门课的作业，我建议你在这门课中用Octave来写程序。

## 基本操作

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/9fHfl/basic-operations)

这是Octave的命令行界面：

![](/img/16_08_13/001.png)

### 数学运算

首先示范一下基本的加、减、乘、除、指数运算：

```
octave:1> 5+6
ans =  11
octave:2> 3-2
ans =  1
octave:3> 5*8
ans =  40
octave:4> 1/2
ans =  0.50000
octave:5> 2^6
ans =  64
```

### 逻辑运算：

```
octave:6> 1 == 2  % false
ans = 0
octave:7> 1 ~= 2
ans =  1
octave:8> 1 && 0  % AND
ans = 0
octave:9> 1 || 0  % OR
ans =  1
octave:10> xor(1,0)
ans =  1
```

> 值得说明的是，其中`%`代表注释符号，`~=`代表不等于，`xor()`是异或符号。

### 修改等待命令的快捷提示

通过`PS1()`命令来设置等待命令的快捷提示：

```
octave:11> PS1(">> ")
>> 
>> 
>> 
```

### 赋值运算：

赋值运算

```
>> a = 3
a =  3
>> 
```

如果不希望在屏幕上显示结果，只需要结尾加`;`即可抑制打印输出：

```
>> a = 3;  % semicolon supressing output
>> 
```

### 变量的打印输出

变量的赋值与打印：

```
>> b = "hi";
>> b
b = hi
>> c = (3>=1);
>> c
c =  1
>> 
```

对于一些复杂的输出，可以使用`disp`命令：

```
>> a = pi;
>> a
a =  3.1416
>> disp(a)
 3.1416
>> disp(sprintf('2 decimals: %0.2f', a))
2 decimals: 3.14
>> 
```

控制输出长短：

```
>> a
a =  3.1416
>> format long
>> a
a =  3.14159265358979
>> format short
>> a
a =  3.1416
>> 
```

### 矩阵的表示

表示一个三行两列的矩阵：

```
>> A = [1 2; 3 4; 5 6]
A =

   1   2
   3   4
   5   6

```

另外一种表示矩阵的方式：

```
>> A = [1 2;
> 3 4;
> 5 6]
A =

   1   2
   3   4
   5   6

```

分配一个一行三列的行向量：

```
>> v = [1 2 3]
v =

   1   2   3
   
```

分配一个三行一列的列向量：

```
>> v = [1; 2; 3]
v =

   1
   2
   3

```

表示一个行向量，其中第一个值是起始值，中间的值是步长，最后一个值是终止值：

```
>> v = 1:0.1:2
v =

 Columns 1 through 8:

    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000

 Columns 9 through 11:

    1.8000    1.9000    2.000
    
```

也可以不写步长，这样默认步长是1：

```
>> v = 1:6
v =

   1   2   3   4   5   6

```

### 生成元素为1的矩阵

生成一个2行3列，所有元素都为1的矩阵：

```
>> ones(2,3)
ans =

   1   1   1
   1   1   1

```

生成一个2行3列，所有元素都为2的矩阵：

```
>> 2*ones(2,3)
ans =

   2   2   2
   2   2   2

```

### 生成0矩阵

生成一个1行3列的0矩阵：

```
>> w = zeros(1,3)
w =

   0   0   0

```

### 生成随机数矩阵

生成一个元素为介于0到1之间随机数的1行3列的矩阵：

```
>> w = rand(1,3)
w =

   0.65555   0.77468   0.85729

```

均值为0的高斯分布：

```
>> w = randn(1,3)
w =

   0.61607   0.53219   1.48783

```

-6加上根号10乘以一个一行10000列的正太分布的随机向量。

```
>> w = -6 + sqrt(10)*(randn(1,10000));
```

### 绘制函数

绘制这个直方图：

```
>> hist(w)
```

![](/img/16_08_13/002.png)

绘制有50条的直方图：

```
>> hist(w,50)
```

![](/img/16_08_13/003.png)


### 生成单位矩阵

生成矩阵的特殊命令：`eye`，可用来生成单位矩阵：

```
>> A = eye(5)
A =

Diagonal Matrix

   1   0   0   0   0
   0   1   0   0   0
   0   0   1   0   0
   0   0   0   1   0
   0   0   0   0   1
   
```

### help

`help`命令，后面跟任何其他指令，都可以查看该指令的说明文档，包括help自身：

```
>> help eye
```

## 移动数据

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/SZJIc/moving-data-around)

这一节将介绍，如何加载外部数据到Octave中，以及存储Octave的数据到文件中的一些操作。

首先，创建一个3行2列的矩阵A：

```
>> A = [1 2; 3 4; 5 6]
A =

   1   2
   3   4
   5   6

```

### 查看矩阵尺寸

通过`size`命令，我们能看到这个矩阵的尺寸：

```
>> size(A)
ans =

   3   2

```

实际上`size`的这个输出结果自身也是一个矩阵：

```
>> sz = size(A)
sz =

   3   2

>> size(sz)
ans =

   1   2
   
```

分别查看A向量的size的输出结果中的两个值：

```
>> size(A,1)
ans =  3
>> size(A,2)
ans =  2
```

### 查看矩阵最大维度

`length`指令，来获取矩阵的最大维度，这个命令其实通常只对向量使用：

```
>> v = [1 2 3 4]
v =

   1   2   3   4

>> length(v)
ans =  4
>> A
A =

   1   2
   3   4
   5   6

>> length(A)
ans =  3
```

### 设置Octave当前路径

当我们打开Octave的时候，其实我们已经处在了一个默认路径下：

```
>> pwd
ans = /Users/lijianan
```

这个路径是Octave的安装位置。我们可以改变当前目录到桌面目录：

```
>> cd /Users/lijianan/Desktop
>> pwd
ans = /Users/lijianan/Desktop
```

### 加载外部文件

目前我的桌面目录下有两个存有数据的文件：

```
>> ls
FeaturesX.dat 	PriceY.dat
```

![](/img/16_08_13/004.gif)

通过`load`命令，加载外部文件：

```
>> load featuresX.dat
>> load priceY.dat
```

你也可以使用`load()`的方式来加载，效果相同：

```
>> load('featuresX.dat')
>> load('priceY.dat')
```

### 查看存储变量

我们可以使用`who`命令来查看当前Octave中存储的变量：

```
>> who
Variables in the current scope:

A          ans        c          priceY     v
a          b          featuresX  sz         w
```

`whos`命令可以查看更详细的信息，包括尺寸，内存占用，以及类型：

```
>> whos
Variables in the current scope:

   Attr Name           Size                     Bytes  Class
   ==== ====           ====                     =====  ===== 
        A              3x2                         48  double
        a              1x1                          8  double
        ans            1x2                         16  double
        b              1x2                          2  char
        c              1x1                          1  logical
        featuresX     47x2                        752  double
        priceY        47x1                        376  double
        sz             1x2                         16  double
        v              1x4                         32  double
        w              1x10000                  80000  double

Total is 10159 elements using 81251 bytes
```

可以看到`featuresX`和`priceY`已经被成功的被作为一个变量加载进来了，我们可以直接输入`featuresX`来查看这个变量的内容：

```
>> featuresX

featuresX =

   2104      3
   1600      3
   2400      3
   1416      2
   3000      4
   1985      4
   1534      3
   1427      3
   1380      3
   1494      3
   1940      4
   2000      3
   1890      3
	...
```

通过`size()`函数，我们可以看到`featuresX`是一个47行2列的矩阵，`priceY`是一个47行1列的矩阵：

```
>> size(featuresX)
ans =

   47    2

>> size(priceY)
ans =

   47    1
   
```

### 删除变量

可以使用`clear`命令来删除某个变量：

```
>> who
Variables in the current scope:

A       a       ans     b       c       priceY  sz      v       w
```

### 截取矩阵部分元素

将`priceY`的前10个元素存入变量`V`：

```
>> V = priceY(1:10)
V =

   3999
   3299
   3690
   2320
   5399
   2999
   3149
   1989
   2120
   2425

```

### 变量的存储

将变量`V`存入`hello.mat`文件中：

```
>> save hello.mat V
>> ls
FeaturesX.dat 	PriceY.dat	hello.mat
```

> 这里其实是把`V`按照压缩的二进制的形式进行存储，如果说`V`的数据很大，那么压缩的幅度也很大。
> 
> 如果想按照一个我们可以看得懂的格式进行存储的话，可以这样输入：`save hello.txt V -ascii`

### 清空所有变量

直接输入`clear`命令，会清空所有的变量：

```
>> clear
>> whos
```

### 索引

#### 用索引来查询

首先创建矩阵`A`：

```
>> A = [1 2; 3 4; 5 6]
A =

   1   2
   3   4
   5   6
   
```

你可以通过`A(3,2)`来访问矩阵的第三行第二列的元素：

```
>> A(3,2)
ans =  6
```

你也可以通过`A(2,:)`来访问第二行的所有元素，其中`:`代表该行/列的所有元素：

```
>> A(2,:)
ans =

   3   4

```

你可以通过`A([1 3], :)`来取矩阵第1行以及第3行的所有元素：

```
>> A([1 3], :)
ans =

   1   2
   5   6
   
```

通过`A(:)`来将所有的元素以一个列向量的形式展示：

```
>> A(:)
ans =

     1
     3
     5
    10
    11
    12
    
```

#### 用索引来赋值

你也可以通过索引来进行复制操作：

```
>> A
A =

   1   2
   3   4
   5   6

>> A(:,2) = [10; 11; 12]
A =

    1   10
    3   11
    5   12

```

在矩阵的右侧新增一列：

```
>> A
A =

    1   10
    3   11
    5   12

>> A = [A,[100; 101; 102]]
A =

     1    10   100
     3    11   101
     5    12   102
     
```

将两个行相等的向量按照从左到右的顺序连在一起：

```
>> A = [1 2;3 4;5 6]
A =

   1   2
   3   4
   5   6

>> B = [11 12;13 14;15 16]
B =

   11   12
   13   14
   15   16

>> C = [A B]
C =

    1    2   11   12
    3    4   13   14
    5    6   15   16

```

将两个列数相等的向量按照从上到下的顺序连在一起：

```
>> A
A =

   1   2
   3   4
   5   6

>> B
B =

   11   12
   13   14
   15   16

>> C = [A;B]
C =

    1    2
    3    4
    5    6
   11   12
   13   14
   15   16

```

## 对数据进行运算

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/Y6uuC/computing-on-data)

本节将介绍如何对数据进行运算。

### 矩阵乘法

矩阵的乘法：

```
>> A = [1 2; 3 4; 5 6]
A =

   1   2
   3   4
   5   6

>> C = [1 1; 2 2]
C =

   1   1
   2   2

>> A*C
ans =

    5    5
   11   11
   17   17

```

### 点乘操作

让两个矩阵中的每个对应位置的元素相乘(点乘操作)：

```
>> A = [1 2; 3 4; 5 6]
A =

   1   2
   3   4
   5   6

>> B = [11 12; 13 14; 15 16]
B =

   11   12
   13   14
   15   16
   
>> A.*B
ans =

   11   24
   39   56
   75   96
```

### 对每个元素求平方

对矩阵$A$中的每个元素求平方：

```
>> A .^ 2
ans =

    1    4
    9   16
   25   36
   
```

### 对每个元素求倒数

对矩阵中每个元素求倒数：

```
>> v = [1; 2; 3]
v =

   1
   2
   3

>> 1 ./ v
ans =

   1.00000
   0.50000
   0.33333

```

> 这里的`.`符号，表示对每个元素分别进行运算

### 对每个元素求对数

对每个元素求对数：

```
>> log(v)
ans =

   0.00000
   0.69315
   1.09861
```

### 自然数e的幂次运算

以$e$为低，以每个元素为幂的运算：

```
>> exp(v)
ans =

    2.7183
    7.3891
   20.0855

```

### 对每个元素求绝对值

对所有元素求绝对值：

```
>> abs([-1; 2; -3])
ans =

   1
   2
   3

```

### 求相反数运算

```
>> -v
ans =

  -1
  -2
  -3

```

> 其实就相当于`-1 * v`

### 对向量每个元素自增1

```
>> v + 1
ans =

   2
   3
   4

```

### 矩阵的转置

```
>> A
A =

   1   2
   3   4
   5   6

>> A'
ans =

   1   3   5
   2   4   6
   
```

### 获取向量中最大的元素

```
>> a = [1 15 2 0.5]
a =

    1.00000   15.00000    2.00000    0.50000

>> val = max(a)
val =  15

```

也可以获取最大元素的索引：

```
>> [val, ind] = max(a)
val =  15
ind =  2
```

> 值得注意的是，如果这里不是向量，而是矩阵，那么将得到每一列的最大值

```
>> D = [1 5;2 4; 3 3]
D =

   1   5
   2   4
   3   3

>> max(D)
ans =

   3   5
   
```

### 判断矩阵中每个元素是否满足某条件

```
>> a
a =

    1.00000   15.00000    2.00000    0.50000

>> a < 3
ans =

   1   0   1   1

```

> 这里1代表真，0代表假

### 获取魔幻方阵(magic squares)

魔幻方阵，指的是矩阵的**所有的行、列、以及对角线元素的和，都相等**的矩阵。

```
>> A = magic(3)
A =

   8   1   6
   3   5   7
   4   9   2

```

> 其实这个神奇的矩阵，在机器学习中基本用不上

### 找出矩阵中满足某条件元素的索引

```
>> A
A =

   8   1   6
   3   5   7
   4   9   2

>> [r,c] = find(A >= 7)
r =

   1
   3
   2

c =

   1
   2
   3

```

其中r是所在行的索引，c是所在列的索引。

比如：元素`(1,1)`，`(3,2)`，`(2,3)`。

### 求和函数

将矩阵中所有元素求和：

```
>> a
a =

    1.00000   15.00000    2.00000    0.50000

>> sum(a)
ans =  18.500
```

### 求积函数

将矩阵中所有元素求积：

```
>> a
a =

    1.00000   15.00000    2.00000    0.50000

>> prod(a)
ans =  15
```

### 四舍五入

向下四舍五入：

```
>> a
a =

    1.00000   15.00000    2.00000    0.50000

>> floor(a)
ans =

    1   15    2    0
    
```

向上四舍五入：

```
>> ceil(a)
ans =

    1   15    2    1

```

### max函数

获得一个3×3的方阵，元素为在0到1之间的随机数：

```
>> rand(3)
ans =

   0.315556   0.669565   0.192329
   0.449421   0.010167   0.389329
   0.282657   0.761167   0.600949
```

分别取两个矩阵中对应位置较大的一个元素，组成新矩阵：

```
>> max(rand(3),rand(3))
ans =

   0.53967   0.79306   0.62026
   0.90069   0.70636   0.55156
   0.98940   0.68021   0.85094

```

获取一个矩阵中每一列最大的元素组成的向量：

```
>> A
A =

   8   1   6
   3   5   7
   4   9   2

>> max(A,[],1)
ans =

   8   9   7
   
```

获取矩阵每一行的最大值：

```
>> max(A,[],2)
ans =

   8
   7
   9

```

找出矩阵$A$中最大元素的两种方法：

```
>> max(max(A))
ans =  9
>> max(A(:))
ans =  9
```

### 对矩阵的每一行(列)求和

```
>> A = magic(9)
A =

   47   58   69   80    1   12   23   34   45
   57   68   79    9   11   22   33   44   46
   67   78    8   10   21   32   43   54   56
   77    7   18   20   31   42   53   55   66
    6   17   19   30   41   52   63   65   76
   16   27   29   40   51   62   64   75    5
   26   28   39   50   61   72   74    4   15
   36   38   49   60   71   73    3   14   25
   37   48   59   70   81    2   13   24   35

>> sum(A,1)
ans =

   369   369   369   369   369   369   369   369   369
   
>> sum(A,2)
ans =

   369
   369
   369
   369
   369
   369
   369
   369
   369
```

求$A$的对角线元素的和：

```
>> A
A =

   47   58   69   80    1   12   23   34   45
   57   68   79    9   11   22   33   44   46
   67   78    8   10   21   32   43   54   56
   77    7   18   20   31   42   53   55   66
    6   17   19   30   41   52   63   65   76
   16   27   29   40   51   62   64   75    5
   26   28   39   50   61   72   74    4   15
   36   38   49   60   71   73    3   14   25
   37   48   59   70   81    2   13   24   35

>> eye(9)
ans =

Diagonal Matrix

   1   0   0   0   0   0   0   0   0
   0   1   0   0   0   0   0   0   0
   0   0   1   0   0   0   0   0   0
   0   0   0   1   0   0   0   0   0
   0   0   0   0   1   0   0   0   0
   0   0   0   0   0   1   0   0   0
   0   0   0   0   0   0   1   0   0
   0   0   0   0   0   0   0   1   0
   0   0   0   0   0   0   0   0   1

>> A.*eye(9)
ans =

   47    0    0    0    0    0    0    0    0
    0   68    0    0    0    0    0    0    0
    0    0    8    0    0    0    0    0    0
    0    0    0   20    0    0    0    0    0
    0    0    0    0   41    0    0    0    0
    0    0    0    0    0   62    0    0    0
    0    0    0    0    0    0   74    0    0
    0    0    0    0    0    0    0   14    0
    0    0    0    0    0    0    0    0   35
    
>> sum(sum(A.*eye(9)))
ans =  369
```

### 将矩阵上下翻转

```
>> magic(3)
ans =

   8   1   6
   3   5   7
   4   9   2
   
>> flipud(magic(3))
ans =

   4   9   2
   3   5   7
   8   1   6

```

### 求逆矩阵

```
>> A = magic(3)
A =

   8   1   6
   3   5   7
   4   9   2

>> temp = pinv(A)
temp =

   0.147222  -0.144444   0.063889
  -0.061111   0.022222   0.105556
  -0.019444   0.188889  -0.102778

>> temp * A
ans =

   1.00000   0.00000  -0.00000
  -0.00000   1.00000   0.00000
   0.00000   0.00000   1.00000
   
```

> 实际上，这里的`pinv()`函数求得的是伪逆矩阵。

## 数据可视化

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/I7gx3/plotting-data)

这段视频中，将介绍通过Octave来绘制数据。

### 绘制正弦余弦函数

绘制一个正弦函数：

```
>> t=[0:0.01:0.98];	% 生成一个0到0.98的等差数列，差值为0.01
>> y1 = sin(8*pi*t)
>> plot(t,y1);
```

![](/img/16_08_13/005.png)

同理，可以绘制余弦图：

```
>> y2 = cos(8*pi*t);
>> plot(t,y2)
```

这样会覆盖掉之前的图，得到新的图：

![](/img/16_08_13/006.png)

如果我们想将两个图重叠在一起绘制，可以使用`hold on`命令：

```
>> plot(t,y1);
>> hold on
>> plot(t,y2,'r');	%  这里第三个参数'r'代表颜色为红色
```

![](/img/16_08_13/007.png)

### 图的标记

可以用以下命令来对图进行标记：

```
>> xlabel('time')	%	标记x坐标
>> ylabel('value')	%	标记y坐标
>> legend('sin','cos')	%	标记图例
>> title('my plot')	%	标记标题
```

![](/img/16_08_13/008.png)

### 图片的保存与删除

将图片保存在Octave所在目录。可能会花费一些时间

```
>> print -dpng 'myPlot.png'
warning: print.m: fig2dev binary is not available.
Some output formats are not available.
```

这里其实可以保存多种格式，可以查看`help`来了解。

如果想删除这个文件，直接输入`close`即可。

```
>> close
```

这样就会关闭视图窗口，并且删除刚才生成的文件。

### 为图像标号

可以通过`figure`函数对图像进行标号：

```
>> figure(1);plot(t,y1);
```

![](/img/16_08_13/009.png)

```
>> figure(2);plot(t,y2);
```

![](/img/16_08_13/010.png)

这个时候界面上其实可以看到有两个图片：

![](/img/16_08_13/011.png)

### 使用subplot将图像分割显示

`subplot`函数接受三个参数，前两个参数代表获取一个a × b格子，第三个参数代表当前使用的格子的索引。

```
>> subplot(1,2,1); % 将图像划分成1×2的格子，并且使用第一个格子
```

![](/img/16_08_13/012.png)

如果这个时候输入:

```
>> plot(t,y1);
```

那么将会绘制在第一个格子里：

![](/img/16_08_13/013.png)

同理，我们可以通过以下命令，将`y2`绘制在第二个格子里：

```
>> subplot(1,2,2);
>> plot(t,y2);
```

![](/img/16_08_13/014.png)

另外，你可以使用`axis`函数，来改变当前图像的刻度：

```
>> axis([0.5 1 -1 1])	% 将x轴的范围调整到0.5到1之间，y轴的范围调整到-1到1之间
```

可以看到`y2`对应的图刻度发生了改变：

![](/img/16_08_13/015.png)

如果想清空图像，可以使用`clf`

```
>> clf;
```

可以看到图像被清空了：

![](/img/16_08_13/016.png)

### 矩阵的可视化

通过`imagesc`函数，将矩阵绘制出来，其中一种颜色代表一种数值。

```
>> A = magic(5)
A =

   17   24    1    8   15
   23    5    7   14   16
    4    6   13   20   22
   10   12   19   21    3
   11   18   25    2    9

>> imagesc(A)
```
![](/img/16_08_13/017.png)

设置用来显示的颜色：

```
>> imagesc(A), colorbar, colormap gray;
```

> 这里其实相当于连续输入了三条命令。

可以看到，颜色变为了灰色，并且颜色对应的数值范围也在右侧列出：

![](/img/16_08_13/018.png)

## 控制语句：for, while, if符号的使用

### for语句的使用

```
>> v = zeros(10,1)
v =

   0
   0
   0
   0
   0
   0
   0
   0
   0
   0

>> for i=1:10,
>    v(i) = 2^i;
>  end;
>> v
v =

      2
      4
      8
     16
     32
     64
    128
    256
    512
   1024

```

也可以通过`for`来访问一个索引序列：

```
>> indices=1:10;
>> indices
indices =

    1    2    3    4    5    6    7    8    9   10

>> for i=indices,
>    disp(i);
>  end;
 1
 2
 3
 4
 5
 6
 7
 8
 9
 10
```

### while的使用：

```
>> v
v =

      2
      4
      8
     16
     32
     64
    128
    256
    512
   1024

>> i = 1;
>> while i <= 5,
>    v(i) = 100;
>    i = i+1;
>  end;
>> v
v =

    100
    100
    100
    100
    100
     64
    128
    256
    512
   1024

```

### if 以及 break 的使用

```
>> v
v =

    100
    100
    100
    100
    100
     64
    128
    256
    512
   1024

>> i=1;
>> while true,
>    v(i) = 999;
>    i = i+1;
>    if i == 6,
>      break;
>    end;
>  end;
>> v
v =

    999
    999
    999
    999
    999
     64
    128
    256
    512
   1024

```

### else 的使用

```
>> v(1)
ans =  2
>> v(1)=2;
>> if v(1)==1,
>    disp('The value is one');
>  elseif v(1) == 2,
>    disp('The value is two');
>  else
>    disp('The value is not one or two.');
>  end;
The value is two
```

### 退出Octave

退出Octave只需输入：

```
>> exit
```

或者

```
>> quit
```

### 函数

#### 函数的定义以及调用

在当前Octave的目录下创建一个文件`squareThisNumber.m`

内容如下：

```
function y = squareThisNumber(x)
y = x^2;
```

在当前目录下就可以直接使用这个函数了：

```
>> squareThisNumber(5)
ans =  25
```

> 这里`y`是函数`squareThisNumber`的返回值，函数体是`y = x^2;`，参数是`x`。
> 如果想要正常使用这个函数，必须把这个函数所在的文件放到当前目录下。

#### 添加搜索路径

如果你想在其他目录下也正常的使用这个函数，那么你需要将这个文件路径添加到Octave的搜索路径下(`addpath`)：

```
>> addpath('/Users/lijianan/Desktop')
>> cd ~
>> pwd
ans = /Users/lijianan
>> squareThisNumber(5)
ans =  25
```

#### 多个返回值

Octave的函数有一个其他大多数语言不具备的一个特性，就是允许返回多个参数。

例如：

```
function [y1,y2] = squareAndCubeThisNumber(x)

y1 = x^2;
y2 = x^3;
```

可以看到函数`squareAndCubeThisNumber`返回两个值，分别为`y1`和`y2`。

使用这个函数：

```
>> [a,b] = squareAndCubeThisNumber(5);
>> a
a =  25
>> b
b =  125
```

### 使用函数求解代价函数值：

![](/img/16_08_13/019.png)

定义函数`costFunctionJ.m`，入参分别为`X`,`y`以及$\theta$：

```
function J = costFunctionJ(X, y, theta)

% X is the "design matrix" containing our training examples.
% y is the class labels

m = size(X,1); 		% number of training examples
predictions = X*theta; 	% predictions of hypothesis on all m examples
sqrErrors = (predictions-y).^2;	% squaed errors

J = 1/(2*m) * sum(sqrErrors);
```

使用这个方法求解代价函数$J(\theta)$值：

```
>> X = [1 1; 1 2; 1 3]
X =

   1   1
   1   2
   1   3

>> y = [1; 2; 3]
y =

   1
   2
   3

>> theta = [0; 1];
>>  j = costFunctionJ(X,y,theta)
j = 0
```

其中`X`矩阵第一列代表$x\_{0}$项，第二列代表$x\_{1}$项。
`y`矩阵代表$y$的值。`theta`的两个值分别代表$\theta\_{0}$和$\theta\_{1}$。
 
可以看到`X`和`y`对应的值能够被所给的$\theta$值完全拟合，所以得到$J(\theta)=0$

如果我们换一组$\theta$值，就会得到不一样的结果了：

```
>> theta = [0;0];
>>  j = costFunctionJ(X,y,theta)
j =  2.3333
```

我们也可以算一下来验证这个结果是否正确：

$$
((1 - 0)^{2} + (2 - 0)^{2} + (3 - 0)^{2}) / (2*3) = 2.3333
$$

结果正确。

## 向量化

[视频地址](https://www.coursera.org/learn/machine-learning/lecture/WnQWH/vectorization)

> 无论你使用Octave还是别的语言，比如matlab或者你正在使用python Numpy或者Java、C 、C++所有这些语言都具有线性代数的库。这些库已经经过高度优化，通常是数值计算方面的博士或者专业人士开发的，而当你实现机器学习算法时，如果你能好好利用这些线性代数库，并联合调用它们，而不是自己去实现这些库可以实现的功能，那么通常情况下，运行速度会更快一些。出错的概率也更小一些。

为了能使用库函数提供的矩阵乘法之类的API，我们通常情况下解决问题的思路应该是向着把参数**向量化**的方向努力。这样你就会有一个简单得多，也有效得多的代码。

例如：

$$
h\_{\theta}(x) = \sum\_{j=0}^{n}\theta\_{j}x\_{j}
$$

这个式子如果我们自己来计算，可能会从0到n去遍历$\theta x$的和。但如果向量化处理之后，我们可以得到$h\_{\theta}(x)$的另外一种表示方式：

$$
h\_{\theta}(x) = \theta^{T}x
$$

我们可以看一下向量化处理前后的Octave代码对比：

|非向量化的实现|向量化的实现|
|:-:|:-:|
|![](/img/16_08_13/020.png)|![](/img/16_08_13/021.png)|

接下来看一个更为复杂的例子：

下面是线性回归算法梯度下降的更新规则：

![](/img/16_08_13/022.png)

当我们更新对象有$\theta\_{0}$、$\theta\_{1}$、$\theta\_{2}$时：

![](/img/16_08_13/023.png)

> 这里你可能已经忘了 在之前提到的**同步更新**，就是我们需要同时更新$\theta\_{0}$、$\theta\_{1}$、$\theta\_{2}$。

这里我们可以通过向量化的代码实现**同步更新**:

首先，上面的三行式子可以压缩为下面这种形式：

$$
\theta := \theta - αδ
$$

其中：

$$
δ = 
\frac{1}{m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})x^{(i)}
$$

好了，接下来我们来解释一下上面的这两个式子：

我们把$\theta$看做一个$n+1$维的向量，$α$是一个常量，$δ$也是一个$n+1$维的向量。所以$\theta := \theta - αδ$这个式子，其实是一个向量减法的运算。

$δ$向量其实是这样的：

$$
δ = 
\begin{bmatrix}
δ\_{0} \\\\
δ\_{1} \\\\
δ\_{2} 
\end{bmatrix}
$$

其中$δ\_{0}$代表着：

$$
δ\_{0} = 
\frac{1}{m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})x^{(i)}\_{0}
$$

因此在这个式子中：

$$
δ = 
\frac{1}{m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})x^{(i)}
$$

其实$(h_{θ}(x^{(i)}) - y^{(i)})$部分可以看做是常量，而$x^{(i)}$则代表着下面的向量:

$$
x^{(i)} = 
\begin{bmatrix}
x^{(i)}\_{0} \\\\
x^{(i)}\_{1} \\\\
x^{(i)}\_{2} 
\end{bmatrix}
$$