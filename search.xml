<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10分钟上手Pandas</title>
    <url>/2017/11/30/10%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BPandas/</url>
    <content><![CDATA[<p><a href="http://pandas.pydata.org/pandas-docs/stable/10min.html">原文地址</a></p>
<p>这是关于pandas的一个简短的介绍，主要面向的是新手用户。你可以在<a href="http://pandas.pydata.org/pandas-docs/stable/cookbook.html#cookbook">Cookbook</a>查看更多复杂的使用方式。</p>
<p>通常情况下，我们按照下面这种方式引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: import pandas as pd</span><br><span class="line"></span><br><span class="line">In [2]: import numpy as np</span><br><span class="line"></span><br><span class="line">In [3]: import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>见<a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dsintro">数据结构介绍部分</a>。</p>
<p>通过传入一个list的数值来创建一个<code>Series</code>，pandas会创建一个默认的整数索引:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [4]: s &#x3D; pd.Series([1,3,5,np.nan,6,8])</span><br><span class="line"></span><br><span class="line">In [5]: s</span><br><span class="line">Out[5]: </span><br><span class="line">0    1.0</span><br><span class="line">1    3.0</span><br><span class="line">2    5.0</span><br><span class="line">3    NaN</span><br><span class="line">4    6.0</span><br><span class="line">5    8.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过传入一个numpy数组来创建一个’DataFrame’，带有一个datetime的索引以及标签列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [6]: dates &#x3D; pd.date_range(&#39;20130101&#39;, periods&#x3D;6)</span><br><span class="line"></span><br><span class="line">In [7]: dates</span><br><span class="line">Out[7]: </span><br><span class="line">DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;,</span><br><span class="line">               &#39;2013-01-05&#39;, &#39;2013-01-06&#39;],</span><br><span class="line">              dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;&#39;D&#39;)</span><br><span class="line"></span><br><span class="line">In [8]: df &#x3D; pd.DataFrame(np.random.randn(6,4), index&#x3D;dates, columns&#x3D;list(&#39;ABCD&#39;))</span><br><span class="line"></span><br><span class="line">In [9]: df</span><br><span class="line">Out[9]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span><br></pre></td></tr></table></figure>
<p>通过传入一个可以转换为类series（series-like）的字典对象来创建一个<code>DataFrame</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [10]: df2 &#x3D; pd.DataFrame(&#123; &#39;A&#39; : 1.,</span><br><span class="line">   ....:                      &#39;B&#39; : pd.Timestamp(&#39;20130102&#39;),</span><br><span class="line">   ....:                      &#39;C&#39; : pd.Series(1,index&#x3D;list(range(4)),dtype&#x3D;&#39;float32&#39;),</span><br><span class="line">   ....:                      &#39;D&#39; : np.array([3] * 4,dtype&#x3D;&#39;int32&#39;),</span><br><span class="line">   ....:                      &#39;E&#39; : pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]),</span><br><span class="line">   ....:                      &#39;F&#39; : &#39;foo&#39; &#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [11]: df2</span><br><span class="line">Out[11]: </span><br><span class="line">     A          B    C  D      E    F</span><br><span class="line">0  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">1  1.0 2013-01-02  1.0  3  train  foo</span><br><span class="line">2  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">3  1.0 2013-01-02  1.0  3  train  foo</span><br></pre></td></tr></table></figure>
<p>查看不同列的数据类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [12]: df2.dtypes</span><br><span class="line">Out[12]: </span><br><span class="line">A           float64</span><br><span class="line">B    datetime64[ns]</span><br><span class="line">C           float32</span><br><span class="line">D             int32</span><br><span class="line">E          category</span><br><span class="line">F            object</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>如果你正在使用IPython，使用Tab自动补全功能会自动识别所有的属性以及自定义的列，下图中是所有能够被自动识别的属性的一个子集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [13]: df2.&lt;TAB&gt;</span><br><span class="line">df2.A                  df2.bool</span><br><span class="line">df2.abs                df2.boxplot</span><br><span class="line">df2.add                df2.C</span><br><span class="line">df2.add_prefix         df2.clip</span><br><span class="line">df2.add_suffix         df2.clip_lower</span><br><span class="line">df2.align              df2.clip_upper</span><br><span class="line">df2.all                df2.columns</span><br><span class="line">df2.any                df2.combine</span><br><span class="line">df2.append             df2.combine_first</span><br><span class="line">df2.apply              df2.compound</span><br><span class="line">df2.applymap           df2.consolidate</span><br><span class="line">df2.D</span><br></pre></td></tr></table></figure>
<p>正如你所看的，这里的列<code>A</code>,<code>B</code>,<code>C</code>和<code>D</code>是自动补全的，为了简洁，其余的属性被截断。</p>
<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><p>详情请参阅:<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics">Basics section</a></p>
<p>查看frame中头部和尾部的行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [14]: df.head()</span><br><span class="line">Out[14]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br><span class="line"></span><br><span class="line">In [15]: df.tail(3)</span><br><span class="line">Out[15]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span><br></pre></td></tr></table></figure>
<p>显示索引，列和底层numpy数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [16]: df.index</span><br><span class="line">Out[16]: </span><br><span class="line">DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;,</span><br><span class="line">               &#39;2013-01-05&#39;, &#39;2013-01-06&#39;],</span><br><span class="line">              dtype&#x3D;&#39;datetime64[ns]&#39;, freq&#x3D;&#39;D&#39;)</span><br><span class="line"></span><br><span class="line">In [17]: df.columns</span><br><span class="line">Out[17]: Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], dtype&#x3D;&#39;object&#39;)</span><br><span class="line"></span><br><span class="line">In [18]: df.values</span><br><span class="line">Out[18]: </span><br><span class="line">array([[ 0.4691, -0.2829, -1.5091, -1.1356],</span><br><span class="line">       [ 1.2121, -0.1732,  0.1192, -1.0442],</span><br><span class="line">       [-0.8618, -2.1046, -0.4949,  1.0718],</span><br><span class="line">       [ 0.7216, -0.7068, -1.0396,  0.2719],</span><br><span class="line">       [-0.425 ,  0.567 ,  0.2762, -1.0874],</span><br><span class="line">       [-0.6737,  0.1136, -1.4784,  0.525 ]])</span><br></pre></td></tr></table></figure>
<p><code>describe()</code>函数对于数据的快速统计汇总：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [19]: df.describe()</span><br><span class="line">Out[19]: </span><br><span class="line">              A         B         C         D</span><br><span class="line">count  6.000000  6.000000  6.000000  6.000000</span><br><span class="line">mean   0.073711 -0.431125 -0.687758 -0.233103</span><br><span class="line">std    0.843157  0.922818  0.779887  0.973118</span><br><span class="line">min   -0.861849 -2.104569 -1.509059 -1.135632</span><br><span class="line">25%   -0.611510 -0.600794 -1.368714 -1.076610</span><br><span class="line">50%    0.022070 -0.228039 -0.767252 -0.386188</span><br><span class="line">75%    0.658444  0.041933 -0.034326  0.461706</span><br><span class="line">max    1.212112  0.567020  0.276232  1.071804</span><br></pre></td></tr></table></figure>
<p>对数据的转置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [20]: df.T</span><br><span class="line">Out[20]: </span><br><span class="line">   2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06</span><br><span class="line">A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690</span><br><span class="line">B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648</span><br><span class="line">C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427</span><br><span class="line">D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按轴进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [21]: df.sort_index(axis&#x3D;1, ascending&#x3D;False)</span><br><span class="line">Out[21]: </span><br><span class="line">                   D         C         B         A</span><br><span class="line">2013-01-01 -1.135632 -1.509059 -0.282863  0.469112</span><br><span class="line">2013-01-02 -1.044236  0.119209 -0.173215  1.212112</span><br><span class="line">2013-01-03  1.071804 -0.494929 -2.104569 -0.861849</span><br><span class="line">2013-01-04  0.271860 -1.039575 -0.706771  0.721555</span><br><span class="line">2013-01-05 -1.087401  0.276232  0.567020 -0.424972</span><br><span class="line">2013-01-06  0.524988 -1.478427  0.113648 -0.673690</span><br></pre></td></tr></table></figure>
<p>按值进行排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [22]: df.sort_values(by&#x3D;&#39;B&#39;)</span><br><span class="line">Out[22]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br></pre></td></tr></table></figure>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote>
<p><strong>注意：</strong>虽然用于选择和设置的标准的Python/Numpy表达式非常直观，可用于交互式工作，但对于生产代码，我们推荐优化的pandas数据访问方法<code>.at</code>，<code>.iat</code>，<code>.loc</code>，<code>.iloc</code>和<code>.ix</code>。</p>
</blockquote>
<p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing">Indexing and Selecing Data</a>和 <a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#advanced">MultiIndex / Advanced Indexing</a>。</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>选择一个单独的列，这将会返回一个<code>Series</code>，等同于<code>df.A</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [23]: df[&#39;A&#39;]</span><br><span class="line">Out[23]: </span><br><span class="line">2013-01-01    0.469112</span><br><span class="line">2013-01-02    1.212112</span><br><span class="line">2013-01-03   -0.861849</span><br><span class="line">2013-01-04    0.721555</span><br><span class="line">2013-01-05   -0.424972</span><br><span class="line">2013-01-06   -0.673690</span><br><span class="line">Freq: D, Name: A, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过<code>[]</code>进行选择，这将会对行进行切片:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [24]: df[0:3]</span><br><span class="line">Out[24]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line"></span><br><span class="line">In [25]: df[&#39;20130102&#39;:&#39;20130104&#39;]</span><br><span class="line">Out[25]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br></pre></td></tr></table></figure>
<h3 id="通过标签选择"><a href="#通过标签选择" class="headerlink" title="通过标签选择"></a>通过标签选择</h3><p>详情请参加<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-label">Selection by Label</a></p>
<p>使用标签获取横截面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [26]: df.loc[dates[0]]</span><br><span class="line">Out[26]: </span><br><span class="line">A    0.469112</span><br><span class="line">B   -0.282863</span><br><span class="line">C   -1.509059</span><br><span class="line">D   -1.135632</span><br><span class="line">Name: 2013-01-01 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure>
<p>通过标签选择多轴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [27]: df.loc[:,[&#39;A&#39;,&#39;B&#39;]]</span><br><span class="line">Out[27]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-01  0.469112 -0.282863</span><br><span class="line">2013-01-02  1.212112 -0.173215</span><br><span class="line">2013-01-03 -0.861849 -2.104569</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br><span class="line">2013-01-05 -0.424972  0.567020</span><br><span class="line">2013-01-06 -0.673690  0.113648</span><br></pre></td></tr></table></figure>
<p>显示包括两个端点的标签切片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [28]: df.loc[&#39;20130102&#39;:&#39;20130104&#39;,[&#39;A&#39;,&#39;B&#39;]]</span><br><span class="line">Out[28]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-02  1.212112 -0.173215</span><br><span class="line">2013-01-03 -0.861849 -2.104569</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br></pre></td></tr></table></figure>
<p>减少返回的对象的尺寸:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [29]: df.loc[&#39;20130102&#39;,[&#39;A&#39;,&#39;B&#39;]]</span><br><span class="line">Out[29]: </span><br><span class="line">A    1.212112</span><br><span class="line">B   -0.173215</span><br><span class="line">Name: 2013-01-02 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure>
<p>获得标量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [30]: df.loc[dates[0],&#39;A&#39;]</span><br><span class="line">Out[30]: 0.46911229990718628</span><br></pre></td></tr></table></figure>
<p>快速访问一个标量（与上一个方法等价）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [31]: df.at[dates[0],&#39;A&#39;]</span><br><span class="line">Out[31]: 0.46911229990718628</span><br></pre></td></tr></table></figure>
<h3 id="按位置选择"><a href="#按位置选择" class="headerlink" title="按位置选择"></a>按位置选择</h3><p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-integer">Selection by Position</a></p>
<p>通过传入的整数位置来选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [32]: df.iloc[3]</span><br><span class="line">Out[32]: </span><br><span class="line">A    0.721555</span><br><span class="line">B   -0.706771</span><br><span class="line">C   -1.039575</span><br><span class="line">D    0.271860</span><br><span class="line">Name: 2013-01-04 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure>
<p>可以做类似numpy/python的整数切片操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [33]: df.iloc[3:5,0:2]</span><br><span class="line">Out[33]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br><span class="line">2013-01-05 -0.424972  0.567020</span><br></pre></td></tr></table></figure>
<p>可以做类似于numpy/python风格的列出指定索引位置的行列列表的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [34]: df.iloc[[1,2,4],[0,2]]</span><br><span class="line">Out[34]: </span><br><span class="line">                   A         C</span><br><span class="line">2013-01-02  1.212112  0.119209</span><br><span class="line">2013-01-03 -0.861849 -0.494929</span><br><span class="line">2013-01-05 -0.424972  0.276232</span><br></pre></td></tr></table></figure>
<p>选择具体的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [35]: df.iloc[1:3,:]</span><br><span class="line">Out[35]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br></pre></td></tr></table></figure>
<p>选择具体的列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [36]: df.iloc[:,1:3]</span><br><span class="line">Out[36]: </span><br><span class="line">                   B         C</span><br><span class="line">2013-01-01 -0.282863 -1.509059</span><br><span class="line">2013-01-02 -0.173215  0.119209</span><br><span class="line">2013-01-03 -2.104569 -0.494929</span><br><span class="line">2013-01-04 -0.706771 -1.039575</span><br><span class="line">2013-01-05  0.567020  0.276232</span><br><span class="line">2013-01-06  0.113648 -1.478427</span><br></pre></td></tr></table></figure>
<p>明确地获取一个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [37]: df.iloc[1,1]</span><br><span class="line">Out[37]: -0.17321464905330858</span><br></pre></td></tr></table></figure>
<p>快速访问一个标量（等同于上面的方法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [38]: df.iat[1,1]</span><br><span class="line">Out[38]: -0.17321464905330858</span><br></pre></td></tr></table></figure>
<h3 id="布尔索引操作"><a href="#布尔索引操作" class="headerlink" title="布尔索引操作"></a>布尔索引操作</h3><p>使用单一列的值来选取数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [39]: df[df.A &gt; 0]</span><br><span class="line">Out[39]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br></pre></td></tr></table></figure>
<p>从DataFrame选取符合布尔判断条件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [40]: df[df &gt; 0]</span><br><span class="line">Out[40]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112       NaN       NaN       NaN</span><br><span class="line">2013-01-02  1.212112       NaN  0.119209       NaN</span><br><span class="line">2013-01-03       NaN       NaN       NaN  1.071804</span><br><span class="line">2013-01-04  0.721555       NaN       NaN  0.271860</span><br><span class="line">2013-01-05       NaN  0.567020  0.276232       NaN</span><br><span class="line">2013-01-06       NaN  0.113648       NaN  0.524988</span><br></pre></td></tr></table></figure>
<p>使用<code>isin()</code>方法来过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [41]: df2 &#x3D; df.copy()</span><br><span class="line"></span><br><span class="line">In [42]: df2[&#39;E&#39;] &#x3D; [&#39;one&#39;, &#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;three&#39;]</span><br><span class="line"></span><br><span class="line">In [43]: df2</span><br><span class="line">Out[43]: </span><br><span class="line">                   A         B         C         D      E</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three</span><br><span class="line"></span><br><span class="line">In [44]: df2[df2[&#39;E&#39;].isin([&#39;two&#39;,&#39;four&#39;])]</span><br><span class="line">Out[44]: </span><br><span class="line">                   A         B         C         D     E</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four</span><br></pre></td></tr></table></figure>
<h3 id="设置数据"><a href="#设置数据" class="headerlink" title="设置数据"></a>设置数据</h3><p>设置新列，自动按索引排列数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [45]: s1 &#x3D; pd.Series([1,2,3,4,5,6], index&#x3D;pd.date_range(&#39;20130102&#39;, periods&#x3D;6))</span><br><span class="line"></span><br><span class="line">In [46]: s1</span><br><span class="line">Out[46]: </span><br><span class="line">2013-01-02    1</span><br><span class="line">2013-01-03    2</span><br><span class="line">2013-01-04    3</span><br><span class="line">2013-01-05    4</span><br><span class="line">2013-01-06    5</span><br><span class="line">2013-01-07    6</span><br><span class="line">Freq: D, dtype: int64</span><br><span class="line"></span><br><span class="line">In [47]: df[&#39;F&#39;] &#x3D; s1</span><br></pre></td></tr></table></figure>
<p>通过标签来设定数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [48]: df.at[dates[0],&#39;A&#39;] &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>通过位置索引来设定数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [49]: df.iat[0,1] &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>通过分配一个numpy数组来设定数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [50]: df.loc[:,&#39;D&#39;] &#x3D; np.array([5] * len(df))</span><br></pre></td></tr></table></figure>
<p>之前操作的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [51]: df</span><br><span class="line">Out[51]: </span><br><span class="line">                   A         B         C  D    F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  NaN</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232  5  4.0</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  5  5.0</span><br></pre></td></tr></table></figure>
<p>带有<code>where</code>操作的设值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [52]: df2 &#x3D; df.copy()</span><br><span class="line"></span><br><span class="line">In [53]: df2[df2 &gt; 0] &#x3D; -df2</span><br><span class="line"></span><br><span class="line">In [54]: df2</span><br><span class="line">Out[54]: </span><br><span class="line">                   A         B         C  D    F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059 -5  NaN</span><br><span class="line">2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0</span><br><span class="line">2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0</span><br><span class="line">2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0</span><br><span class="line">2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0</span><br></pre></td></tr></table></figure>
<h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>pandas主要使用<code>np.nan</code>来代表缺失数据。这些值将默认不会包含在计算中，详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/missing_data.html#missing-data">Missing Data section</a></p>
<p>Reindexing允许您更改/添加/删除指定轴上的索引。这将返回数据的副本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [55]: df1 &#x3D; df.reindex(index&#x3D;dates[0:4], columns&#x3D;list(df.columns) + [&#39;E&#39;])</span><br><span class="line"></span><br><span class="line">In [56]: df1.loc[dates[0]:dates[1],&#39;E&#39;] &#x3D; 1</span><br><span class="line"></span><br><span class="line">In [57]: df1</span><br><span class="line">Out[57]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  NaN  1.0</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  NaN</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  NaN</span><br></pre></td></tr></table></figure>
<p>删除所有具有缺失值的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [58]: df1.dropna(how&#x3D;&#39;any&#39;)</span><br><span class="line">Out[58]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br></pre></td></tr></table></figure>
<p>填充缺失数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [59]: df1.fillna(value&#x3D;5)</span><br><span class="line">Out[59]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0</span><br></pre></td></tr></table></figure>
<p>获取值为nan的布尔值掩码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [60]: pd.isna(df1)</span><br><span class="line">Out[60]: </span><br><span class="line">                A      B      C      D      F      E</span><br><span class="line">2013-01-01  False  False  False  False   True  False</span><br><span class="line">2013-01-02  False  False  False  False  False  False</span><br><span class="line">2013-01-03  False  False  False  False  False   True</span><br><span class="line">2013-01-04  False  False  False  False  False   True</span><br></pre></td></tr></table></figure>
<h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics-binop">Basic section on Binary Ops</a></p>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>一般操作不包括丢失的数据。</p>
<p>执行描述性统计操作(沿数值方向求均值)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [61]: df.mean()</span><br><span class="line">Out[61]: </span><br><span class="line">A   -0.004474</span><br><span class="line">B   -0.383981</span><br><span class="line">C   -0.687758</span><br><span class="line">D    5.000000</span><br><span class="line">F    3.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>在另一个轴上做相同的操作(沿水平方向求均值)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [62]: df.mean(1)</span><br><span class="line">Out[62]: </span><br><span class="line">2013-01-01    0.872735</span><br><span class="line">2013-01-02    1.431621</span><br><span class="line">2013-01-03    0.707731</span><br><span class="line">2013-01-04    1.395042</span><br><span class="line">2013-01-05    1.883656</span><br><span class="line">2013-01-06    1.592306</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<p>使用具有不同维度且需要对齐的对象进行操作。另外，pandas会沿指定的尺寸自动广播。</p>
<blockquote>
<p>注意：1-np.nan 输出结果为NaN</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [63]: s &#x3D; pd.Series([1,3,5,np.nan,6,8], index&#x3D;dates).shift(2)</span><br><span class="line"></span><br><span class="line">In [64]: s</span><br><span class="line">Out[64]: </span><br><span class="line">2013-01-01    NaN</span><br><span class="line">2013-01-02    NaN</span><br><span class="line">2013-01-03    1.0</span><br><span class="line">2013-01-04    3.0</span><br><span class="line">2013-01-05    5.0</span><br><span class="line">2013-01-06    NaN</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [65]: df.sub(s, axis&#x3D;&#39;index&#39;)</span><br><span class="line">Out[65]: </span><br><span class="line">                   A         B         C    D    F</span><br><span class="line">2013-01-01       NaN       NaN       NaN  NaN  NaN</span><br><span class="line">2013-01-02       NaN       NaN       NaN  NaN  NaN</span><br><span class="line">2013-01-03 -1.861849 -3.104569 -1.494929  4.0  1.0</span><br><span class="line">2013-01-04 -2.278445 -3.706771 -4.039575  2.0  0.0</span><br><span class="line">2013-01-05 -5.424972 -4.432980 -4.723768  0.0 -1.0</span><br><span class="line">2013-01-06       NaN       NaN       NaN  NaN  NaN</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>将函数应用于数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 累加操作</span><br><span class="line">In [66]: df.apply(np.cumsum)</span><br><span class="line">Out[66]: </span><br><span class="line">                   A         B         C   D     F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059   5   NaN</span><br><span class="line">2013-01-02  1.212112 -0.173215 -1.389850  10   1.0</span><br><span class="line">2013-01-03  0.350263 -2.277784 -1.884779  15   3.0</span><br><span class="line">2013-01-04  1.071818 -2.984555 -2.924354  20   6.0</span><br><span class="line">2013-01-05  0.646846 -2.417535 -2.648122  25  10.0</span><br><span class="line">2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0</span><br><span class="line"></span><br><span class="line">In [67]: df.apply(lambda x: x.max() - x.min())</span><br><span class="line">Out[67]: </span><br><span class="line">A    2.073961</span><br><span class="line">B    2.671590</span><br><span class="line">C    1.785291</span><br><span class="line">D    0.000000</span><br><span class="line">F    4.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics-discretization">Histogramming and Discretization</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [68]: s &#x3D; pd.Series(np.random.randint(0, 7, size&#x3D;10))</span><br><span class="line"></span><br><span class="line">In [69]: s</span><br><span class="line">Out[69]: </span><br><span class="line">0    4</span><br><span class="line">1    2</span><br><span class="line">2    1</span><br><span class="line">3    2</span><br><span class="line">4    6</span><br><span class="line">5    4</span><br><span class="line">6    4</span><br><span class="line">7    6</span><br><span class="line">8    4</span><br><span class="line">9    4</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [70]: s.value_counts()</span><br><span class="line">Out[70]: </span><br><span class="line">4    5</span><br><span class="line">6    2</span><br><span class="line">2    2</span><br><span class="line">1    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>Series对象在其str属性中配备了一组字符串处理方法，可以很容易的应用到数组中的每个元素，如下段代码所示。更多详情请参考：<a href="http://pandas.pydata.org/pandas-docs/stable/text.html#text-string-methods">Vectorized String Methods</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [71]: s &#x3D; pd.Series([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;Aaba&#39;, &#39;Baca&#39;, np.nan, &#39;CABA&#39;, &#39;dog&#39;, &#39;cat&#39;])</span><br><span class="line"></span><br><span class="line">In [72]: s.str.lower()</span><br><span class="line">Out[72]: </span><br><span class="line">0       a</span><br><span class="line">1       b</span><br><span class="line">2       c</span><br><span class="line">3    aaba</span><br><span class="line">4    baca</span><br><span class="line">5     NaN</span><br><span class="line">6    caba</span><br><span class="line">7     dog</span><br><span class="line">8     cat</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p>Pandas提供了大量的方法能够轻松的对Series，DataFrame和Panel对象进行各种符合各种逻辑关系的合并操作。</p>
<p>具体请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#merging">Merging section</a></p>
<p>通过使用<code>concat()</code>来将pandas对象链接起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [73]: df &#x3D; pd.DataFrame(np.random.randn(10, 4))</span><br><span class="line"></span><br><span class="line">In [74]: df</span><br><span class="line">Out[74]: </span><br><span class="line">          0         1         2         3</span><br><span class="line">0 -0.548702  1.467327 -1.015962 -0.483075</span><br><span class="line">1  1.637550 -1.217659 -0.291519 -1.745505</span><br><span class="line">2 -0.263952  0.991460 -0.919069  0.266046</span><br><span class="line">3 -0.709661  1.669052  1.037882 -1.705775</span><br><span class="line">4 -0.919854 -0.042379  1.247642 -0.009920</span><br><span class="line">5  0.290213  0.495767  0.362949  1.548106</span><br><span class="line">6 -1.131345 -0.089329  0.337863 -0.945867</span><br><span class="line">7 -0.932132  1.956030  0.017587 -0.016692</span><br><span class="line">8 -0.575247  0.254161 -1.143704  0.215897</span><br><span class="line">9  1.193555 -0.077118 -0.408530 -0.862495</span><br><span class="line"></span><br><span class="line"># break it into pieces</span><br><span class="line">In [75]: pieces &#x3D; [df[:3], df[3:7], df[7:]]</span><br><span class="line"></span><br><span class="line">In [76]: pd.concat(pieces)</span><br><span class="line">Out[76]: </span><br><span class="line">          0         1         2         3</span><br><span class="line">0 -0.548702  1.467327 -1.015962 -0.483075</span><br><span class="line">1  1.637550 -1.217659 -0.291519 -1.745505</span><br><span class="line">2 -0.263952  0.991460 -0.919069  0.266046</span><br><span class="line">3 -0.709661  1.669052  1.037882 -1.705775</span><br><span class="line">4 -0.919854 -0.042379  1.247642 -0.009920</span><br><span class="line">5  0.290213  0.495767  0.362949  1.548106</span><br><span class="line">6 -1.131345 -0.089329  0.337863 -0.945867</span><br><span class="line">7 -0.932132  1.956030  0.017587 -0.016692</span><br><span class="line">8 -0.575247  0.254161 -1.143704  0.215897</span><br><span class="line">9  1.193555 -0.077118 -0.408530 -0.862495</span><br></pre></td></tr></table></figure>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p>类似于SQL类型的合并</p>
<p>具体请参阅：<a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#merging-join">Database style joining</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [77]: left &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;foo&#39;, &#39;foo&#39;], &#39;lval&#39;: [1, 2]&#125;)</span><br><span class="line"></span><br><span class="line">In [78]: right &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;foo&#39;, &#39;foo&#39;], &#39;rval&#39;: [4, 5]&#125;)</span><br><span class="line"></span><br><span class="line">In [79]: left</span><br><span class="line">Out[79]: </span><br><span class="line">   key  lval</span><br><span class="line">0  foo     1</span><br><span class="line">1  foo     2</span><br><span class="line"></span><br><span class="line">In [80]: right</span><br><span class="line">Out[80]: </span><br><span class="line">   key  rval</span><br><span class="line">0  foo     4</span><br><span class="line">1  foo     5</span><br><span class="line"></span><br><span class="line">In [81]: pd.merge(left, right, on&#x3D;&#39;key&#39;)</span><br><span class="line">Out[81]: </span><br><span class="line">   key  lval  rval</span><br><span class="line">0  foo     1     4</span><br><span class="line">1  foo     1     5</span><br><span class="line">2  foo     2     4</span><br><span class="line">3  foo     2     5</span><br></pre></td></tr></table></figure>
<p>另一个可以给出的例子是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [82]: left &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;lval&#39;: [1, 2]&#125;)</span><br><span class="line"></span><br><span class="line">In [83]: right &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;rval&#39;: [4, 5]&#125;)</span><br><span class="line"></span><br><span class="line">In [84]: left</span><br><span class="line">Out[84]: </span><br><span class="line">   key  lval</span><br><span class="line">0  foo     1</span><br><span class="line">1  bar     2</span><br><span class="line"></span><br><span class="line">In [85]: right</span><br><span class="line">Out[85]: </span><br><span class="line">   key  rval</span><br><span class="line">0  foo     4</span><br><span class="line">1  bar     5</span><br><span class="line"></span><br><span class="line">In [86]: pd.merge(left, right, on&#x3D;&#39;key&#39;)</span><br><span class="line">Out[86]: </span><br><span class="line">   key  lval  rval</span><br><span class="line">0  foo     1     4</span><br><span class="line">1  bar     2     5</span><br></pre></td></tr></table></figure>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>将一行连接到一个DataFrame上。</p>
<p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/merging.html#merging-concatenation">Appending</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [87]: df &#x3D; pd.DataFrame(np.random.randn(8, 4), columns&#x3D;[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])</span><br><span class="line"></span><br><span class="line">In [88]: df</span><br><span class="line">Out[88]: </span><br><span class="line">          A         B         C         D</span><br><span class="line">0  1.346061  1.511763  1.627081 -0.990582</span><br><span class="line">1 -0.441652  1.211526  0.268520  0.024580</span><br><span class="line">2 -1.577585  0.396823 -0.105381 -0.532532</span><br><span class="line">3  1.453749  1.208843 -0.080952 -0.264610</span><br><span class="line">4 -0.727965 -0.589346  0.339969 -0.693205</span><br><span class="line">5 -0.339355  0.593616  0.884345  1.591431</span><br><span class="line">6  0.141809  0.220390  0.435589  0.192451</span><br><span class="line">7 -0.096701  0.803351  1.715071 -0.708758</span><br><span class="line"></span><br><span class="line">In [89]: s &#x3D; df.iloc[3]</span><br><span class="line"></span><br><span class="line">In [90]: df.append(s, ignore_index&#x3D;True)</span><br><span class="line">Out[90]: </span><br><span class="line">          A         B         C         D</span><br><span class="line">0  1.346061  1.511763  1.627081 -0.990582</span><br><span class="line">1 -0.441652  1.211526  0.268520  0.024580</span><br><span class="line">2 -1.577585  0.396823 -0.105381 -0.532532</span><br><span class="line">3  1.453749  1.208843 -0.080952 -0.264610</span><br><span class="line">4 -0.727965 -0.589346  0.339969 -0.693205</span><br><span class="line">5 -0.339355  0.593616  0.884345  1.591431</span><br><span class="line">6  0.141809  0.220390  0.435589  0.192451</span><br><span class="line">7 -0.096701  0.803351  1.715071 -0.708758</span><br><span class="line">8  1.453749  1.208843 -0.080952 -0.264610</span><br></pre></td></tr></table></figure>
<h2 id="分组（Grouping）"><a href="#分组（Grouping）" class="headerlink" title="分组（Grouping）"></a>分组（Grouping）</h2><p>对于”group by”操作，我们通常是指以下一个或多个操作步骤：</p>
<ul>
<li><strong>（Splitting）</strong>按照一些规则将数据分为不同的组；</li>
<li><strong>（Applying）</strong>对于每组数据分别执行一个函数；</li>
<li><strong>（Combining）</strong>将结果组合到一个数据结构中；</li>
</ul>
<p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/groupby.html#groupby">Grouping section</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [91]: df &#x3D; pd.DataFrame(&#123;&#39;A&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;,</span><br><span class="line">   ....:                           &#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;foo&#39;],</span><br><span class="line">   ....:                    &#39;B&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,</span><br><span class="line">   ....:                           &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],</span><br><span class="line">   ....:                    &#39;C&#39; : np.random.randn(8),</span><br><span class="line">   ....:                    &#39;D&#39; : np.random.randn(8)&#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [92]: df</span><br><span class="line">Out[92]: </span><br><span class="line">     A      B         C         D</span><br><span class="line">0  foo    one -1.202872 -0.055224</span><br><span class="line">1  bar    one -1.814470  2.395985</span><br><span class="line">2  foo    two  1.018601  1.552825</span><br><span class="line">3  bar  three -0.595447  0.166599</span><br><span class="line">4  foo    two  1.395433  0.047609</span><br><span class="line">5  bar    two -0.392670 -0.136473</span><br><span class="line">6  foo    one  0.007207 -0.561757</span><br><span class="line">7  foo  three  1.928123 -1.623033</span><br></pre></td></tr></table></figure>
<p>分组，然后将函数总和<code>sum</code>应用于结果组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [93]: df.groupby(&#39;A&#39;).sum()</span><br><span class="line">Out[93]: </span><br><span class="line">            C        D</span><br><span class="line">A                     </span><br><span class="line">bar -2.802588  2.42611</span><br><span class="line">foo  3.146492 -0.63958</span><br></pre></td></tr></table></figure>
<p>按多列分组会形成一个分层索引，然后我们应用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [94]: df.groupby([&#39;A&#39;,&#39;B&#39;]).sum()</span><br><span class="line">Out[94]: </span><br><span class="line">                  C         D</span><br><span class="line">A   B                        </span><br><span class="line">bar one   -1.814470  2.395985</span><br><span class="line">    three -0.595447  0.166599</span><br><span class="line">    two   -0.392670 -0.136473</span><br><span class="line">foo one   -1.195665 -0.616981</span><br><span class="line">    three  1.928123 -1.623033</span><br><span class="line">    two    2.414034  1.600434</span><br></pre></td></tr></table></figure>
<h2 id="Reshaping"><a href="#Reshaping" class="headerlink" title="Reshaping"></a>Reshaping</h2><p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/advanced.html#advanced-hierarchical">Hierarchical Indexing</a>和<a href="http://pandas.pydata.org/pandas-docs/stable/reshaping.html#reshaping-stacking">Reshaping</a>。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [95]: tuples &#x3D; list(zip(*[[&#39;bar&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;baz&#39;,</span><br><span class="line">   ....:                      &#39;foo&#39;, &#39;foo&#39;, &#39;qux&#39;, &#39;qux&#39;],</span><br><span class="line">   ....:                     [&#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;,</span><br><span class="line">   ....:                      &#39;one&#39;, &#39;two&#39;, &#39;one&#39;, &#39;two&#39;]]))</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [96]: index &#x3D; pd.MultiIndex.from_tuples(tuples, names&#x3D;[&#39;first&#39;, &#39;second&#39;])</span><br><span class="line"></span><br><span class="line">In [97]: df &#x3D; pd.DataFrame(np.random.randn(8, 2), index&#x3D;index, columns&#x3D;[&#39;A&#39;, &#39;B&#39;])</span><br><span class="line"></span><br><span class="line">In [98]: df2 &#x3D; df[:4]</span><br><span class="line"></span><br><span class="line">In [99]: df2</span><br><span class="line">Out[99]: </span><br><span class="line">                     A         B</span><br><span class="line">first second                    </span><br><span class="line">bar   one     0.029399 -0.542108</span><br><span class="line">      two     0.282696 -0.087302</span><br><span class="line">baz   one    -1.575170  1.771208</span><br><span class="line">      two     0.816482  1.100230</span><br></pre></td></tr></table></figure>
<p><code>stack()</code>方法“压缩”了DataFrame列中的级别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [100]: stacked &#x3D; df2.stack()</span><br><span class="line"></span><br><span class="line">In [101]: stacked</span><br><span class="line">Out[101]: </span><br><span class="line">first  second   </span><br><span class="line">bar    one     A    0.029399</span><br><span class="line">               B   -0.542108</span><br><span class="line">       two     A    0.282696</span><br><span class="line">               B   -0.087302</span><br><span class="line">baz    one     A   -1.575170</span><br><span class="line">               B    1.771208</span><br><span class="line">       two     A    0.816482</span><br><span class="line">               B    1.100230</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>对于“堆叠的(stacked)”DataFrame或Series（以MultiIndex为索引），<code>stack()</code>的反向操作是<code>unstack()</code>，默认情况下，它将卸载<strong>最后一层</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [102]: stacked.unstack()</span><br><span class="line">Out[102]: </span><br><span class="line">                     A         B</span><br><span class="line">first second                    </span><br><span class="line">bar   one     0.029399 -0.542108</span><br><span class="line">      two     0.282696 -0.087302</span><br><span class="line">baz   one    -1.575170  1.771208</span><br><span class="line">      two     0.816482  1.100230</span><br><span class="line"></span><br><span class="line">In [103]: stacked.unstack(1)</span><br><span class="line">Out[103]: </span><br><span class="line">second        one       two</span><br><span class="line">first                      </span><br><span class="line">bar   A  0.029399  0.282696</span><br><span class="line">      B -0.542108 -0.087302</span><br><span class="line">baz   A -1.575170  0.816482</span><br><span class="line">      B  1.771208  1.100230</span><br><span class="line"></span><br><span class="line">In [104]: stacked.unstack(0)</span><br><span class="line">Out[104]: </span><br><span class="line">first          bar       baz</span><br><span class="line">second                      </span><br><span class="line">one    A  0.029399 -1.575170</span><br><span class="line">       B -0.542108  1.771208</span><br><span class="line">two    A  0.282696  0.816482</span><br><span class="line">       B -0.087302  1.100230</span><br></pre></td></tr></table></figure>
<h3 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h3><p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/reshaping.html#reshaping-pivot">Pivot Tables</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [105]: df &#x3D; pd.DataFrame(&#123;&#39;A&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;] * 3,</span><br><span class="line">   .....:                    &#39;B&#39; : [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] * 4,</span><br><span class="line">   .....:                    &#39;C&#39; : [&#39;foo&#39;, &#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;bar&#39;, &#39;bar&#39;] * 2,</span><br><span class="line">   .....:                    &#39;D&#39; : np.random.randn(12),</span><br><span class="line">   .....:                    &#39;E&#39; : np.random.randn(12)&#125;)</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [106]: df</span><br><span class="line">Out[106]: </span><br><span class="line">        A  B    C         D         E</span><br><span class="line">0     one  A  foo  1.418757 -0.179666</span><br><span class="line">1     one  B  foo -1.879024  1.291836</span><br><span class="line">2     two  C  foo  0.536826 -0.009614</span><br><span class="line">3   three  A  bar  1.006160  0.392149</span><br><span class="line">4     one  B  bar -0.029716  0.264599</span><br><span class="line">5     one  C  bar -1.146178 -0.057409</span><br><span class="line">6     two  A  foo  0.100900 -1.425638</span><br><span class="line">7   three  B  foo -1.035018  1.024098</span><br><span class="line">8     one  C  foo  0.314665 -0.106062</span><br><span class="line">9     one  A  bar -0.773723  1.824375</span><br><span class="line">10    two  B  bar -1.170653  0.595974</span><br><span class="line">11  three  C  bar  0.648740  1.167115</span><br></pre></td></tr></table></figure>
<p>我们可以很容易地从这些数据生成数据透视表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [107]: pd.pivot_table(df, values&#x3D;&#39;D&#39;, index&#x3D;[&#39;A&#39;, &#39;B&#39;], columns&#x3D;[&#39;C&#39;])</span><br><span class="line">Out[107]: </span><br><span class="line">C             bar       foo</span><br><span class="line">A     B                    </span><br><span class="line">one   A -0.773723  1.418757</span><br><span class="line">      B -0.029716 -1.879024</span><br><span class="line">      C -1.146178  0.314665</span><br><span class="line">three A  1.006160       NaN</span><br><span class="line">      B       NaN -1.035018</span><br><span class="line">      C  0.648740       NaN</span><br><span class="line">two   A       NaN  0.100900</span><br><span class="line">      B -1.170653       NaN</span><br><span class="line">      C       NaN  0.536826</span><br></pre></td></tr></table></figure>
<h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>Pandas在对频率转换进行重新采样时拥有简单、强大且高效的功能（如将按秒采样的数据转换为按5分钟为单位进行采样的数据）。这种操作在金融领域非常常见。</p>
<p>详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#timeseries">Time Series section</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [108]: rng &#x3D; pd.date_range(&#39;1&#x2F;1&#x2F;2012&#39;, periods&#x3D;100, freq&#x3D;&#39;S&#39;)</span><br><span class="line"></span><br><span class="line">In [109]: ts &#x3D; pd.Series(np.random.randint(0, 500, len(rng)), index&#x3D;rng)</span><br><span class="line"></span><br><span class="line">In [110]: ts.resample(&#39;5Min&#39;).sum()</span><br><span class="line">Out[110]: </span><br><span class="line">2012-01-01    25083</span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure>
<p>时区表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [111]: rng &#x3D; pd.date_range(&#39;3&#x2F;6&#x2F;2012 00:00&#39;, periods&#x3D;5, freq&#x3D;&#39;D&#39;)</span><br><span class="line"></span><br><span class="line">In [112]: ts &#x3D; pd.Series(np.random.randn(len(rng)), rng)</span><br><span class="line"></span><br><span class="line">In [113]: ts</span><br><span class="line">Out[113]: </span><br><span class="line">2012-03-06    0.464000</span><br><span class="line">2012-03-07    0.227371</span><br><span class="line">2012-03-08   -0.496922</span><br><span class="line">2012-03-09    0.306389</span><br><span class="line">2012-03-10   -2.290613</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [114]: ts_utc &#x3D; ts.tz_localize(&#39;UTC&#39;)</span><br><span class="line"></span><br><span class="line">In [115]: ts_utc</span><br><span class="line">Out[115]: </span><br><span class="line">2012-03-06 00:00:00+00:00    0.464000</span><br><span class="line">2012-03-07 00:00:00+00:00    0.227371</span><br><span class="line">2012-03-08 00:00:00+00:00   -0.496922</span><br><span class="line">2012-03-09 00:00:00+00:00    0.306389</span><br><span class="line">2012-03-10 00:00:00+00:00   -2.290613</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<p>转换成其他时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [116]: ts_utc.tz_convert(&#39;US&#x2F;Eastern&#39;)</span><br><span class="line">Out[116]: </span><br><span class="line">2012-03-05 19:00:00-05:00    0.464000</span><br><span class="line">2012-03-06 19:00:00-05:00    0.227371</span><br><span class="line">2012-03-07 19:00:00-05:00   -0.496922</span><br><span class="line">2012-03-08 19:00:00-05:00    0.306389</span><br><span class="line">2012-03-09 19:00:00-05:00   -2.290613</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure>
<p>在时间跨度表示之间进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [117]: rng &#x3D; pd.date_range(&#39;1&#x2F;1&#x2F;2012&#39;, periods&#x3D;5, freq&#x3D;&#39;M&#39;)</span><br><span class="line"></span><br><span class="line">In [118]: ts &#x3D; pd.Series(np.random.randn(len(rng)), index&#x3D;rng)</span><br><span class="line"></span><br><span class="line">In [119]: ts</span><br><span class="line">Out[119]: </span><br><span class="line">2012-01-31   -1.134623</span><br><span class="line">2012-02-29   -1.561819</span><br><span class="line">2012-03-31   -0.260838</span><br><span class="line">2012-04-30    0.281957</span><br><span class="line">2012-05-31    1.523962</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [120]: ps &#x3D; ts.to_period()</span><br><span class="line"></span><br><span class="line">In [121]: ps</span><br><span class="line">Out[121]: </span><br><span class="line">2012-01   -1.134623</span><br><span class="line">2012-02   -1.561819</span><br><span class="line">2012-03   -0.260838</span><br><span class="line">2012-04    0.281957</span><br><span class="line">2012-05    1.523962</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [122]: ps.to_timestamp()</span><br><span class="line">Out[122]: </span><br><span class="line">2012-01-01   -1.134623</span><br><span class="line">2012-02-01   -1.561819</span><br><span class="line">2012-03-01   -0.260838</span><br><span class="line">2012-04-01    0.281957</span><br><span class="line">2012-05-01    1.523962</span><br><span class="line">Freq: MS, dtype: float64</span><br></pre></td></tr></table></figure>
<p>周期和时间戳之间的转换可以使用一些方便的算术功能。在下面的例子中，我们将季度结束时间从11月份转换为季末结束时的上午9点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [123]: prng &#x3D; pd.period_range(&#39;1990Q1&#39;, &#39;2000Q4&#39;, freq&#x3D;&#39;Q-NOV&#39;)</span><br><span class="line"></span><br><span class="line">In [124]: ts &#x3D; pd.Series(np.random.randn(len(prng)), prng)</span><br><span class="line"></span><br><span class="line">In [125]: ts.index &#x3D; (prng.asfreq(&#39;M&#39;, &#39;e&#39;) + 1).asfreq(&#39;H&#39;, &#39;s&#39;) + 9</span><br><span class="line"></span><br><span class="line">In [126]: ts.head()</span><br><span class="line">Out[126]: </span><br><span class="line">1990-03-01 09:00   -0.902937</span><br><span class="line">1990-06-01 09:00    0.068159</span><br><span class="line">1990-09-01 09:00   -0.057873</span><br><span class="line">1990-12-01 09:00   -0.368204</span><br><span class="line">1991-03-01 09:00   -1.144073</span><br><span class="line">Freq: H, dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="Categorical"><a href="#Categorical" class="headerlink" title="Categorical"></a>Categorical</h2><p>pandas可以在DataFrame中引入categorical数据。详情请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/categorical.html#categorical">categorical introduction</a>和<a href="http://pandas.pydata.org/pandas-docs/stable/api.html#api-categorical">API documentation</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [127]: df &#x3D; pd.DataFrame(&#123;&quot;id&quot;:[1,2,3,4,5,6], &quot;raw_grade&quot;:[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;e&#39;]&#125;)</span><br></pre></td></tr></table></figure>
<p>将原始的grade转换为Categorical数据类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [128]: df[&quot;grade&quot;] &#x3D; df[&quot;raw_grade&quot;].astype(&quot;category&quot;)</span><br><span class="line"></span><br><span class="line">In [129]: df[&quot;grade&quot;]</span><br><span class="line">Out[129]: </span><br><span class="line">0    a</span><br><span class="line">1    b</span><br><span class="line">2    b</span><br><span class="line">3    a</span><br><span class="line">4    a</span><br><span class="line">5    e</span><br><span class="line">Name: grade, dtype: category</span><br><span class="line">Categories (3, object): [a, b, e]</span><br></pre></td></tr></table></figure>
<p>将类别重命名为更有意义的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [130]: df[&quot;grade&quot;].cat.categories &#x3D; [&quot;very good&quot;, &quot;good&quot;, &quot;very bad&quot;]</span><br></pre></td></tr></table></figure>
<p>重新排列类别并同时添加缺少的类别（Series .cat下的方法默认返回一个新的系列）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [131]: df[&quot;grade&quot;] &#x3D; df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;])</span><br><span class="line"></span><br><span class="line">In [132]: df[&quot;grade&quot;]</span><br><span class="line">Out[132]: </span><br><span class="line">0    very good</span><br><span class="line">1         good</span><br><span class="line">2         good</span><br><span class="line">3    very good</span><br><span class="line">4    very good</span><br><span class="line">5     very bad</span><br><span class="line">Name: grade, dtype: category</span><br><span class="line">Categories (5, object): [very bad, bad, medium, good, very good]</span><br></pre></td></tr></table></figure>
<p>排序是按类别排序的，而不是词汇顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [133]: df.sort_values(by&#x3D;&quot;grade&quot;)</span><br><span class="line">Out[133]: </span><br><span class="line">   id raw_grade      grade</span><br><span class="line">5   6         e   very bad</span><br><span class="line">1   2         b       good</span><br><span class="line">2   3         b       good</span><br><span class="line">0   1         a  very good</span><br><span class="line">3   4         a  very good</span><br><span class="line">4   5         a  very good</span><br></pre></td></tr></table></figure>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p><a href="http://pandas.pydata.org/pandas-docs/stable/visualization.html#visualization">Plotting</a>文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [135]: ts &#x3D; pd.Series(np.random.randn(1000), index&#x3D;pd.date_range(&#39;1&#x2F;1&#x2F;2000&#39;, periods&#x3D;1000))</span><br><span class="line"></span><br><span class="line">In [136]: ts &#x3D; ts.cumsum()</span><br><span class="line"></span><br><span class="line">In [137]: ts.plot()</span><br><span class="line">Out[137]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x1122ad630&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://pandas.pydata.org/pandas-docs/stable/_images/series_plot_basic.png" alt=""></p>
<p>在DataFrame上，<code>plot()</code>方便绘制所有带标签的列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [138]: df &#x3D; pd.DataFrame(np.random.randn(1000, 4), index&#x3D;ts.index,</span><br><span class="line">   .....:                   columns&#x3D;[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [139]: df &#x3D; df.cumsum()</span><br><span class="line"></span><br><span class="line">In [140]: plt.figure(); df.plot(); plt.legend(loc&#x3D;&#39;best&#39;)</span><br><span class="line">Out[140]: &lt;matplotlib.legend.Legend at 0x115033cf8&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://pandas.pydata.org/pandas-docs/stable/_images/frame_plot_basic.png" alt=""></p>
<h2 id="导入和保存数据"><a href="#导入和保存数据" class="headerlink" title="导入和保存数据"></a>导入和保存数据</h2><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p><a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-store-in-csv">Writing to a csv file</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [141]: df.to_csv(&#39;foo.csv&#39;)</span><br></pre></td></tr></table></figure>
<p><a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-read-csv-table">Reading from a csv file</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [142]: pd.read_csv(&#39;foo.csv&#39;)</span><br><span class="line">Out[142]: </span><br><span class="line">     Unnamed: 0          A          B         C          D</span><br><span class="line">0    2000-01-01   0.266457  -0.399641 -0.219582   1.186860</span><br><span class="line">1    2000-01-02  -1.170732  -0.345873  1.653061  -0.282953</span><br><span class="line">2    2000-01-03  -1.734933   0.530468  2.060811  -0.515536</span><br><span class="line">3    2000-01-04  -1.555121   1.452620  0.239859  -1.156896</span><br><span class="line">4    2000-01-05   0.578117   0.511371  0.103552  -2.428202</span><br><span class="line">5    2000-01-06   0.478344   0.449933 -0.741620  -1.962409</span><br><span class="line">6    2000-01-07   1.235339  -0.091757 -1.543861  -1.084753</span><br><span class="line">..          ...        ...        ...       ...        ...</span><br><span class="line">993  2002-09-20 -10.628548  -9.153563 -7.883146  28.313940</span><br><span class="line">994  2002-09-21 -10.390377  -8.727491 -6.399645  30.914107</span><br><span class="line">995  2002-09-22  -8.985362  -8.485624 -4.669462  31.367740</span><br><span class="line">996  2002-09-23  -9.558560  -8.781216 -4.499815  30.518439</span><br><span class="line">997  2002-09-24  -9.902058  -9.340490 -4.386639  30.105593</span><br><span class="line">998  2002-09-25 -10.216020  -9.480682 -3.933802  29.758560</span><br><span class="line">999  2002-09-26 -11.856774 -10.671012 -3.216025  29.369368</span><br><span class="line"></span><br><span class="line">[1000 rows x 5 columns]</span><br></pre></td></tr></table></figure>
<h3 id="HDF5"><a href="#HDF5" class="headerlink" title="HDF5"></a>HDF5</h3><p>从<a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-hdf5">HDFStores</a>读取和写入数据</p>
<p>写入HDF5存储：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [143]: df.to_hdf(&#39;foo.h5&#39;,&#39;df&#39;)</span><br></pre></td></tr></table></figure>
<p>从HDF5存储中读取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [144]: pd.read_hdf(&#39;foo.h5&#39;,&#39;df&#39;)</span><br><span class="line">Out[144]: </span><br><span class="line">                    A          B         C          D</span><br><span class="line">2000-01-01   0.266457  -0.399641 -0.219582   1.186860</span><br><span class="line">2000-01-02  -1.170732  -0.345873  1.653061  -0.282953</span><br><span class="line">2000-01-03  -1.734933   0.530468  2.060811  -0.515536</span><br><span class="line">2000-01-04  -1.555121   1.452620  0.239859  -1.156896</span><br><span class="line">2000-01-05   0.578117   0.511371  0.103552  -2.428202</span><br><span class="line">2000-01-06   0.478344   0.449933 -0.741620  -1.962409</span><br><span class="line">2000-01-07   1.235339  -0.091757 -1.543861  -1.084753</span><br><span class="line">...               ...        ...       ...        ...</span><br><span class="line">2002-09-20 -10.628548  -9.153563 -7.883146  28.313940</span><br><span class="line">2002-09-21 -10.390377  -8.727491 -6.399645  30.914107</span><br><span class="line">2002-09-22  -8.985362  -8.485624 -4.669462  31.367740</span><br><span class="line">2002-09-23  -9.558560  -8.781216 -4.499815  30.518439</span><br><span class="line">2002-09-24  -9.902058  -9.340490 -4.386639  30.105593</span><br><span class="line">2002-09-25 -10.216020  -9.480682 -3.933802  29.758560</span><br><span class="line">2002-09-26 -11.856774 -10.671012 -3.216025  29.369368</span><br><span class="line"></span><br><span class="line">[1000 rows x 4 columns]</span><br></pre></td></tr></table></figure>
<h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h3><p>从<a href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-excel">MS Excel</a>中读取和写入数据</p>
<p>写入一个excel文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [145]: df.to_excel(&#39;foo.xlsx&#39;, sheet_name&#x3D;&#39;Sheet1&#39;)</span><br></pre></td></tr></table></figure>
<p>读取一个excel文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [146]: pd.read_excel(&#39;foo.xlsx&#39;, &#39;Sheet1&#39;, index_col&#x3D;None, na_values&#x3D;[&#39;NA&#39;])</span><br><span class="line">Out[146]: </span><br><span class="line">                    A          B         C          D</span><br><span class="line">2000-01-01   0.266457  -0.399641 -0.219582   1.186860</span><br><span class="line">2000-01-02  -1.170732  -0.345873  1.653061  -0.282953</span><br><span class="line">2000-01-03  -1.734933   0.530468  2.060811  -0.515536</span><br><span class="line">2000-01-04  -1.555121   1.452620  0.239859  -1.156896</span><br><span class="line">2000-01-05   0.578117   0.511371  0.103552  -2.428202</span><br><span class="line">2000-01-06   0.478344   0.449933 -0.741620  -1.962409</span><br><span class="line">2000-01-07   1.235339  -0.091757 -1.543861  -1.084753</span><br><span class="line">...               ...        ...       ...        ...</span><br><span class="line">2002-09-20 -10.628548  -9.153563 -7.883146  28.313940</span><br><span class="line">2002-09-21 -10.390377  -8.727491 -6.399645  30.914107</span><br><span class="line">2002-09-22  -8.985362  -8.485624 -4.669462  31.367740</span><br><span class="line">2002-09-23  -9.558560  -8.781216 -4.499815  30.518439</span><br><span class="line">2002-09-24  -9.902058  -9.340490 -4.386639  30.105593</span><br><span class="line">2002-09-25 -10.216020  -9.480682 -3.933802  29.758560</span><br><span class="line">2002-09-26 -11.856774 -10.671012 -3.216025  29.369368</span><br><span class="line"></span><br><span class="line">[1000 rows x 4 columns]</span><br></pre></td></tr></table></figure>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>如果你正在尝试一个操作，你会看到一个异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; if pd.Series([False, True, False]):</span><br><span class="line">    print(&quot;I was true&quot;)</span><br><span class="line">Traceback</span><br><span class="line">    ...</span><br><span class="line">ValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all().</span><br></pre></td></tr></table></figure>
<p>请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics-compare">Comparisons</a>以获取解释以及如何处理。</p>
<p>同时请参阅<a href="http://pandas.pydata.org/pandas-docs/stable/gotchas.html#gotchas">Gotchas</a>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门Part1-定位和设置</title>
    <url>/2018/04/25/Docker%E5%85%A5%E9%97%A8Part1-%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>翻译自<a href="https://docs.docker.com/get-started/">docker官方文档</a>。</p>
</blockquote>
<p>欢迎！我们很高兴您来学习Docker。 Docker入门教程将教你如何：</p>
<ul>
<li>1.设置您的Docker环境（本节内容）</li>
<li>2.构建一个镜像，并将其作为一个容器运行</li>
<li>3.通过运行多个容器来缩放你的应用</li>
<li>4.通过集群来分发你的应用</li>
<li>5.通过添加后端数据库来堆叠服务</li>
<li>6.发布你的应用到生产环境</li>
</ul>
<h2 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h2><p>Docker是开发人员和系统管理员使用容器<strong>开发</strong>、<strong>部署</strong>和<strong>运行</strong>应用程序的平台。使用Linux容器来部署应用程序称为<em>集装箱化</em>(Containerization)。容器的概念并不新，但它们用于部署应用程序会很轻松。</p>
<p>集装箱化越来越受欢迎，因为集装箱是：</p>
<ul>
<li>灵活：即使是最复杂的应用也可以被集装箱化。</li>
<li>轻量级：容器利用并共享主机内核。</li>
<li>通用：您可以即时部署更新和升级。</li>
<li>轻便：你可以在本地构建，发布到云端，并且在任何地方运行。</li>
<li>可扩展：您可以增加和自动分发容器副本。</li>
<li>可堆叠：您可以及时的纵向堆叠服务。</li>
</ul>
<p><img src="/img/18_04_25/001.png" alt=""></p>
<h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>一个容器通过运行一个镜像来启动。一个<strong>镜像</strong>是一个可执行的程序包，其中包含运行该程序所需的所有内容，包括代码，运行时，库，环境变量和配置文件。</p>
<p><strong>容器</strong>是镜像的运行时实例 - 即执行时将镜像加载到内存中，这个内存中的部分就是容器（即具有状态或用户进程的镜像）。Linux环境下，你可以通过命令<code>docker ps</code>来查看你当前正在运行的容器。</p>
<h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>一个<strong>容器</strong>在Linux的<em>本地</em>运行，并与其他容器共享主机的内核。它运行在一个独立的进程，不占用任何其他可执行文件的内存，从而达到轻量化。</p>
<p>对比之下，<strong>虚拟机（VM）</strong>运行一个完整的“guest”操作系统，通过虚拟机管理程序虚拟访问主机资源。一般来说，虚拟机提供的环境比大多数应用程序需要的资源更多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/18_04_25/002.png" alt=""></td>
<td style="text-align:center"><img src="/img/18_04_25/003.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<h2 id="准备你的Docker环境"><a href="#准备你的Docker环境" class="headerlink" title="准备你的Docker环境"></a>准备你的Docker环境</h2><p>在支持的平台上安装Docker社区版本(CE)或者企业版(EE)。</p>
<blockquote>
<p>对于完整的Kubernetes集成</p>
<ul>
<li><p>Docker for Mac上的Kubernetes在17.12 Edge（mac45）或17.12 Stable（mac46）及更高版本中可用。</p>
</li>
<li><p>Docker for Windows上的Kubernetes仅在18.02 Edge（win50）和更高边缘通道中可用。</p>
</li>
</ul>
</blockquote>
<p><a href="https://docs.docker.com/engine/installation/">安装Docker</a></p>
<h3 id="测试Docker版本号"><a href="#测试Docker版本号" class="headerlink" title="测试Docker版本号"></a>测试Docker版本号</h3><ul>
<li>1.运行<code>docker --version</code>并确保您拥有支持的Docker版本：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --version</span><br><span class="line"></span><br><span class="line">Docker version 17.12.0-ce, build c97c6d6</span><br></pre></td></tr></table></figure>
<ul>
<li>2.运行<code>docker info</code>或者(<code>docker version</code>没有<code>--</code>)来查看关于您的Docker安装的更多细节：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br><span class="line"></span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.12.0-ce</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了避免权限错误（以及<code>sudo</code>的使用），将您的用户添加到<code>docker</code>组。<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/">更多</a>。</p>
</blockquote>
<h3 id="测试Docker的安装"><a href="#测试Docker的安装" class="headerlink" title="测试Docker的安装"></a>测试Docker的安装</h3><ul>
<li>1.通过运行简单的Docker镜像<a href="https://hub.docker.com/_/hello-world/">hello-world</a>来测试您的安装是否工作正常：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>2.列出下载到你机器上的<code>hello-world</code>镜像：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<ul>
<li>3.列出显示其消息后退出的<code>hello-world</code>容器（由镜像生成）。如果它仍在运行，则不需要<code>--all</code>选项：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line">CONTAINER ID     IMAGE           COMMAND      CREATED            STATUS</span><br><span class="line">54f4984ed6a8     hello-world     &quot;&#x2F;hello&quot;     20 seconds ago     Exited (0) 19 seconds ago</span><br></pre></td></tr></table></figure>
<h2 id="本节回顾"><a href="#本节回顾" class="headerlink" title="本节回顾"></a>本节回顾</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## List Docker CLI commands</span><br><span class="line">docker</span><br><span class="line">docker container --help</span><br><span class="line"></span><br><span class="line">## Display Docker version and info</span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">## Execute Docker image</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">## List Docker images</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">## List Docker containers (running, all, all in quiet mode)</span><br><span class="line">docker container ls</span><br><span class="line">docker container ls --all</span><br><span class="line">docker container ls -aq</span><br></pre></td></tr></table></figure>
<h2 id="Part1结论"><a href="#Part1结论" class="headerlink" title="Part1结论"></a>Part1结论</h2><p>容器化使<a href="https://www.docker.com/use-cases/cicd">CI/CD</a>无缝衔接。例如：</p>
<ul>
<li>应用程序没有系统依赖关系</li>
<li>更新可以推送到分布式应用程序的任何部分</li>
<li>资源密度可以被优化。</li>
</ul>
<p>使用Docker，扩展应用程序的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门Part2-容器</title>
    <url>/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li><a href="https://docs.docker.com/engine/installation/">安装Docker1.13或更高版本</a>。</li>
<li>阅读Part1部分。</li>
<li>让您的环境快速测试运行，以确保您全部设置完毕：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在是开始以Docker方式构建应用程序的时候了。我们从这种应用程序的层次结构的容器的底部开始，进行详细介绍。在这个层次上面是一个服务，它定义了容器在生产中的行为方式，如Part3部分所述。最后，在顶层的堆栈部分定义了Part5部分中涵盖的所有服务的交互。</p>
<ul>
<li>Stack （堆栈）</li>
<li>Services （服务）</li>
<li><strong>Container</strong>（容器，你在这里）</li>
</ul>
<h2 id="您的新开发环境"><a href="#您的新开发环境" class="headerlink" title="您的新开发环境"></a>您的新开发环境</h2><p>之前，如果您要开始编写Python应用程序，您第一个要做的事情就是在您的机器上安装Python运行环境。但是，这会造成您的计算机上的环境需要完美适合您的应用程序按预期运行，并且还需要与您的生产环境相匹配。</p>
<p>使用Docker，您可以将一个可移植的Python运行环境作为一个镜像获取，无需安装。然后，您的构建可以将基础Python镜像与应用程序代码一起包括在内，确保您的应用程序，依赖项和运行环境都在一起。</p>
<p>这些可移植的镜像是由称为<code>Dockerfile</code>的东西定义的。</p>
<h2 id="通过Dockerfile定义一个容器"><a href="#通过Dockerfile定义一个容器" class="headerlink" title="通过Dockerfile定义一个容器"></a>通过<code>Dockerfile</code>定义一个容器</h2><p><code>Dockerfile</code>定义了容器内的环境发生的事情。像访问网络接口以及磁盘驱动器等资源是在此环境内虚拟化的，这与系统的其余部分是隔离开的，因此您需要将端口映射到外部世界，并明确指定要将哪些文件“复制”到该环境中。但是，在完成这些之后，您可以预期，在此<code>Dockerfile</code>中定义的应用程序构建在运行时的行为完全相同。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><code>Dockerfile</code></h3><p>创建一个空目录。改变目录(<code>cd</code>)到这个新的目录下，创建一个叫做<code>Dockerfile</code>的文件，将下面的内容复制粘贴到这个文件中，并保存。注意记下<code>Dockerfile</code>中的注释部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line"># 使用一个官方的Python运行时环境作为父镜像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to &#x2F;app</span><br><span class="line"># 设置工作目录到&#x2F;app目录下</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at &#x2F;app</span><br><span class="line"># 复制当前目录内容到容器的&#x2F;app目录下</span><br><span class="line">ADD . &#x2F;app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line"># 安装所有requirements.txt中指定的需要的包</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line"># 使得该容器的80端口对外可用</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line"># 当容器加载时，运行app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<p>这个<code>Dockerfile</code>提到了我们尚未创建的两个文件，名叫<code>app.py</code>和<code>requirements.txt</code>。接下来让我们来创建出来。</p>
<h2 id="应用程序本身"><a href="#应用程序本身" class="headerlink" title="应用程序本身"></a>应用程序本身</h2><p>创建两个文件<code>requirements.txt</code>和<code>app.py</code>，并把他们放在和<code>Dockerfile</code>相同的目录下。这就完成了我们的应用程序，正如你看到的一样，非常简单。当上面的<code>Dockerfile</code>被内置到镜像中时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>存在，并且<code>app.py</code>的输出可以通过HTTP访问，这要归功于<code>EXPOSE</code>命令。</p>
<h3 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a><code>requirements.txt</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>
<h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a><code>app.py</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis &#x3D; Redis(host&#x3D;&quot;redis&quot;, db&#x3D;0, socket_connect_timeout&#x3D;2, socket_timeout&#x3D;2)</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits &#x3D; redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits &#x3D; &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;&#x2F;i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html &#x3D; &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;&#x2F;h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;&#x2F;b&gt; &#123;hostname&#125;&lt;br&#x2F;&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;&#x2F;b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name&#x3D;os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname&#x3D;socket.gethostname(), visits&#x3D;visits)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;80)</span><br></pre></td></tr></table></figure>
<p>现在我们看到<code>pip install -r requirements.txt</code>命令安装了Python的Flask和Redis库，并且应用打印出了环境变量<code>NAME</code>，同时输出了方法<code>socket.gethostname()</code>输出的内容。最后，因为Redis没有运行（因为我们只安装了Python库，而不是Redis本身），所以这里应该会失败，并产生错误消息。</p>
<blockquote>
<p>注意：在容器内部访问主机的名称将检索容器ID，这与正在运行的可执行文件的进程ID相似。</p>
</blockquote>
<p>就是这样！你的系统上不需要Python或者任何<code>requirements.txt</code>文件，也不需要在你的系统上安装或运行此镜像。这看起来你并没有真正用Python和Flask建立一个运行环境，但事实上已经建立好了。</p>
<h2 id="构建一个应用"><a href="#构建一个应用" class="headerlink" title="构建一个应用"></a>构建一个应用</h2><p>我们准备构建应用程序。确保您仍然处于新目录的顶层。以下是<code>ls</code>命令应该显示的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile		app.py			requirements.txt</span><br></pre></td></tr></table></figure>
<p>现在运行build命令。这会创建一个Docker镜像，我们将使用<code>-t</code>标记它，这样可以给它指定一个友好的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure>
<p>你构建的镜像在哪里？它在你的机器的本地Docker镜像注册表中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest   </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Linux用户的故障排除</p>
<p><em>DNS设置</em></p>
<p>代理服务器在启动并运行后可以阻止与您的网络应用程序的连接。如果您位于代理服务器的后面，请使用<code>ENV</code>命令为您的代理服务器指定主机和端口，将以下行添加到<code>Dockerfile</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set proxy server, replace host:port with values for your servers</span><br><span class="line">ENV http_proxy host:port</span><br><span class="line">ENV https_proxy host:port</span><br></pre></td></tr></table></figure>
<p><em>代理服务设置</em></p>
<p>DNS错误配置可能会导致<code>pip</code>出现问题。您需要设置您自己的DNS服务器地址以使<code>pip</code>正常工作。您可能需要更改Docker守护程序的DNS设置。您可以按照以下方式来编辑（或者创建）带有<code>dns</code>信息的配置文件<code>/etc/docker/daemon.json</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;dns&quot;: [&quot;your_dns_address&quot;, &quot;8.8.8.8&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，列表的第一个元素是你的DNS服务器的地址。第二项是Google的DNS，当第一项不可用时可以使用它。</p>
<p>在继续之前，保存`daemon.json并重新启动docker服务。</p>
<p><code>sudo service docker restart</code></p>
<p>修复后，重试运行<code>build</code>命令。</p>
</blockquote>
<h2 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h2><p>运行应用程序，使用<code>-p</code>将机器的端口4000映射到容器的已发布端口<code>80</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>你可以在<code>http://0.0.0.0:80</code>看到一条消息，Python正在为你的应用程序提供服务。但是，该消息来自容器内部，它不知道您将该容器的端口<code>80</code>映射到<code>4000</code>，从而制作正确的URL<code>http://localhost:4000</code>。</p>
<p>在网络浏览器中转到该URL以查看网页上显示的显示内容。</p>
<p><img src="/img/18_04_25/004.png" alt=""></p>
<blockquote>
<p>注意：如果你正在在Windows7上使用Docker Toolbox，使用Docker Machine IP来替代<code>localhost</code>。例如：<a href="http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine">http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine</a> ip`。</p>
</blockquote>
<p>您也可以在shell中使用<code>curl</code>命令来查看相同的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:4000</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;Hello World!&lt;&#x2F;h3&gt;&lt;b&gt;Hostname:&lt;&#x2F;b&gt; 8fc990912a14&lt;br&#x2F;&gt;&lt;b&gt;Visits:&lt;&#x2F;b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>
<p>这个<code>4000:80</code>的端口重映射是为了演示<code>Dockerfile</code>中的<code>EXPOSE</code>与使用<code>docker run -p</code>发布的内容之间的区别。在后面的步骤中，我们只需将主机上的端口80映射到容器中的端口80并使用<code>http://localhost</code>。</p>
<p>在终端中点击<code>CTRL + C</code>退出。</p>
<blockquote>
<p><strong>在Windows下，显式的停止容器</strong></p>
<p>在Windows系统下，<code>CTRL+C</code>不会停止容器。到目前为止，首先键入<code>CTRL+C</code>以获取提示（或打开另一个shell），然后输入<code>docker container ls</code>来列出运行中的容器，其次是<code>docker container stop &lt;Container NAME or ID&gt;</code>来停止容器。否则，你会在下一步重新运行容器时得到一个来自守护进程的错误消息。</p>
</blockquote>
<p>现在让我们以分离模式在后台运行应用程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>您可以获取应用的长容器ID，然后将其显示到终端。你的容器在后台运行。你也可以通过<code>docker container ls</code>来看到简短的容器ID（并且在运行命令时可以互换使用）。</p>
<p>注意到<code>CONTAINER ID</code>与<code>http://localhost:4000</code>上的内容匹配。</p>
<p>现在我们使用<code>docker container stop</code>来结束指定<code>CONTAINER ID</code><br>的进程，像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container stop 1fa4ab2cf395</span><br></pre></td></tr></table></figure>
<h2 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h2><p>为了演示我们刚才创建的可移植性，我们上传我们构建的镜像并在其他地方运行它。毕竟，当您想要将容器部署到生产环境时，您需要知道如何推送注册表。</p>
<p>注册表是存储库的集合，而存储库是镜像的集合 - 有点像GitHub存储库，但不同的是这里代码已经创建。注册表上的帐户可以创建许多存储库。 <code>docker</code> CLI默认使用Docker的公共注册表。</p>
<blockquote>
<p>注意：我们在这里使用Docker的公共注册表仅仅是因为它是免费和预先配置的，但是有许多公共选项可供选择，您甚至可以使用<a href="https://docs.docker.com/datacenter/dtr/2.2/guides/">Docker Trusted Registry</a>设置您自己的私有注册表。</p>
</blockquote>
<h3 id="登录你的Docker-ID"><a href="#登录你的Docker-ID" class="headerlink" title="登录你的Docker ID"></a>登录你的Docker ID</h3><p>如果你没有Docker账号，需要在<a href="cloud.docker.com">cloud.docker.com</a>上注册一个。记下你的用户名。</p>
<p>登录到本地计算机上的Docker公共注册表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
<h3 id="给镜像打标签"><a href="#给镜像打标签" class="headerlink" title="给镜像打标签"></a>给镜像打标签</h3><p>将本地镜像与注册表中的存储库相关联的符号是<code>username/repository:tag</code>。该tag是可选的，但建议使用，因为它是注册管理机构用于为Docker镜像提供版本的机制。为该上下文提供存储库并标记有意义的名称，例如<code>get-started:part2</code>。这将镜像置于启动存储库中，并将其标记为<code>part2</code>。</p>
<p>现在，给镜像整体的打上标签。带入你的用户名、仓库名、和标签名运行<code>docker tag image</code>以便将镜像上传到你想要的地址。命令的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag image username&#x2F;repository:tag</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag friendlyhello john&#x2F;get-started:part2</span><br></pre></td></tr></table></figure>
<p>运行<code>docker image ls</code>来查看你的新的带有标签信息的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello            latest              d9e555c53008        3 minutes ago       195MB</span><br><span class="line">john&#x2F;get-started         part2               d9e555c53008        3 minutes ago       195MB</span><br><span class="line">python                   2.7-slim            1c7128a655f6        5 days ago          183MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>上传带有标签信息的镜像到仓库中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push username&#x2F;repository:tag</span><br></pre></td></tr></table></figure>
<p>完成后，此上传的结果将公开发布。如果你登录到<a href="https://hub.docker.com/">Docker Hub</a>，你会在那里看到带有pull命令的新的镜像文件。</p>
<h3 id="从远程仓库中下拉并且运行镜像"><a href="#从远程仓库中下拉并且运行镜像" class="headerlink" title="从远程仓库中下拉并且运行镜像"></a>从远程仓库中下拉并且运行镜像</h3><p>截止到目前，你可以使用<code>docker run</code>命令来在任何机器上运行你的应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 4000:80 username&#x2F;repository:tag</span><br></pre></td></tr></table></figure>
<p>如果镜像在本地机器上不可用，Docker会从远程仓库中下拉到本地。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -p 4000:80 john&#x2F;get-started:part2</span><br><span class="line">Unable to find image &#39;john&#x2F;get-started:part2&#39; locally</span><br><span class="line">part2: Pulling from john&#x2F;get-started</span><br><span class="line">10a267c67f42: Already exists</span><br><span class="line">f68a39a6a5e4: Already exists</span><br><span class="line">9beaffc0cf19: Already exists</span><br><span class="line">3c1fe835fb6b: Already exists</span><br><span class="line">4c9f1fa8fcb8: Already exists</span><br><span class="line">ee7d8f576a14: Already exists</span><br><span class="line">fbccdcced46e: Already exists</span><br><span class="line">Digest: sha256:0601c866aab2adcc6498200efd0f754037e909e5fd42069adeff72d1e2439068</span><br><span class="line">Status: Downloaded newer image for john&#x2F;get-started:part2</span><br><span class="line"> * Running on http:&#x2F;&#x2F;0.0.0.0:80&#x2F; (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>
<p>不管<code>docker run</code>在哪里运行，它都会将你的镜像以及Python和<code>requirements.txt</code>中所有的依赖关系一起提取出来，并运行您的代码。它们都在一个整洁的小包中一起旅行，并且Docker不需要您在主机上安装任何东西来运行它。</p>
<h2 id="Part2结论"><a href="#Part2结论" class="headerlink" title="Part2结论"></a>Part2结论</h2><p>这里列出了这个页面的基本Docker命令，以及一些相关的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t friendlyhello .  # Create image using this directory&#39;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyhello  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username&#x2F;repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username&#x2F;repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username&#x2F;repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门Part3-服务</title>
    <url>/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>获取<a href="https://docs.docker.com/compose/overview/">Docker Compose</a>。在<a href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/">Docker for Windows</a>中，它已预先安装，这一步很方便。在Linux系统上，您需要<a href="https://github.com/docker/compose/releases">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统上，使用<a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>。</li>
<li>阅读Part1部分。</li>
<li>学习Part2中如何创建容器。</li>
<li>确定你已经通过<a href="https://docs.docker.com/get-started/part2/#share-your-image">上传到仓库</a>的方式发布了<code>friendlyhello</code>镜像。我们在这里使用共享镜像。</li>
<li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在第三部分，我们将扩展我们的应用并实现负载均衡。为了做到这一点，我们必须在分布式应用程序的层次结构中升一级：<strong>service(服务)</strong>。</p>
<ul>
<li>Stack</li>
<li><strong>Services(服务 你在这里)</strong></li>
<li>Container（参见 part2）</li>
</ul>
<h2 id="关于Services"><a href="#关于Services" class="headerlink" title="关于Services"></a>关于Services</h2><p>在一个分布式应用中，应用的不同部分被称为”services”。例如，想象你有一个影片分享站点，它也许包括一个关于将应用数据存储在数据库中的service，一个在用户上传一些东西之后在后台对其进行转码操作的service，一个前端的服务，等等。</p>
<p>Services实际上只是“生产中的容器”。service只运行一个镜像，但用于编纂镜像的运行方式—应该使用哪个端口，应该运行多少个容器副本以便服务具有所需的容量，等等。缩放service会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p>
<p>幸运的是，使用Docker平台定义，运行和扩展services非常简单 — 仅仅写一个<code>docker-compose.yml</code>文件即可。</p>
<h2 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h2><p>一个<code>docker-compose.yml</code>文件是一个用于定义Docker容器在生产环境中的行为的YAML文件。</p>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><p>将此文件另存为<code>docker-compose.yml</code>，无论你在哪里。确保您已将第2部分中创建的镜像推送到注册表中，并通根据你的镜像的具体的信息替换掉<code>username/repo:tag</code>部分来更新此<code>.yml</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: username&#x2F;repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>这个<code>docker-compose.yml</code>文件告诉Docker要做以下事情：</p>
<ul>
<li>按照Part2中的方式从仓库中下拉我们的镜像。</li>
<li>运行镜像的5个实例作为一个名为<code>web</code>的service，限制每个实例，最多占用10%CPU(所有的核)、50MB的RAM。</li>
<li>如果一个容器失败了立刻重启。</li>
<li>将主机上的端口80映射到<code>web</code>的端口80。</li>
<li>指示<code>web</code>容器通过名为<code>webnet</code>负载均衡网络共享80端口。（在内部，容器本身在临时端口上发布到<code>web</code>的80端口）。</li>
<li>使用默认设置（这是一个负载均衡覆盖网络）定义<code>webnet</code>网络。</li>
</ul>
<h2 id="运行你的全新的负载均衡应用"><a href="#运行你的全新的负载均衡应用" class="headerlink" title="运行你的全新的负载均衡应用"></a>运行你的全新的负载均衡应用</h2><p>在我们可以使用<code>docker stack deploy</code>命令之前，我们首先运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：我们在Part4部分深入了解该命令的含义。如果你不运行<code>docker swarm init</code>命令的话，你会得到这样一条错误信息：”this node is not a swarm manager.”。</p>
</blockquote>
<p>现在，让我们来运行它吧。你需要给你的应用起一个名字。这里我们起名为<code>getstartedlab</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>我们的单个service堆栈在一台主机上运行了5个部署映像的容器实例。让我们来进一步了解。</p>
<p>在我们的应用程序中获取一项service的service ID：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure>
<p>查找<code>web</code>service的输出信息，找到那个以你的应用程序名称作为前缀信息。如果您将其命名为与此示例中显示的相同，那么这里的名称为<code>getstartedlab_web</code>。还列出了service ID以及副本数量，镜像名称和对外暴露的端口。</p>
<p>在service中运行的单个容器称为<strong>task(任务)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service ps getstartedlab_web</span><br></pre></td></tr></table></figure>
<p>如果您只列出系统中的所有容器，任务也会显示出来，它不会被service所过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls -q</span><br></pre></td></tr></table></figure>
<p>你可以运行几次<code>curl -4 http://localhost</code>，或者通过浏览器打开这个链接尝试刷新几次。</p>
<p><img src="/img/18_04_26/001.png" alt=""></p>
<p>无论哪种方式，容器ID都会发生变化，从而显示负载均衡;在每个请求中，以循环方式选择5个任务中的一个来响应。容器ID与前一个命令(<code>docker container ls -q</code>)的输出相匹配。</p>
<blockquote>
<p><strong>在Windows10下运行？</strong></p>
<p>Windows10的PowerShell可以使用<code>curl</code>命令，但如果不行的话，你可以尝试获取一个Linux终端模拟器，例如<a href="https://git-for-windows.github.io/">Git BASH</a>或者下载很相似的<a href="http://gnuwin32.sourceforge.net/packages/wget.htm">wget for Windows</a>。</p>
<p><strong>响应时间慢？</strong></p>
<p>根据您的环境的网络配置，容器可能需要长达30秒才能响应HTTP请求。这并不代表Docker或群集性能，而是我们稍后在本教程中讨论的未满足的Redis依赖项。就目前而言，访客柜台并不是出于同样的原因;我们还没有添加service来保存数据。</p>
</blockquote>
<h2 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h2><p>你可以通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值来扩展应用，保存<code>docker-compose.yml</code>的改变之后，重新运行<code>docker stack deploy</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>Docker执行一个就地更新，不需要先撤下堆栈或杀死任何容器。</p>
<p>现在，重新运行<code>docker container ls -q</code>以查看重新配置的已部署实例。如果您扩大副本，则会启动更多任务，因此还会启动更多容器。</p>
<h3 id="撤下应用和swarm"><a href="#撤下应用和swarm" class="headerlink" title="撤下应用和swarm"></a>撤下应用和swarm</h3><ul>
<li>通过指令<code>docker stack rm</code>来撤下应用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>
<ul>
<li>撤下swarm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>
<p>用Docker新建并扩展您的应用程序非常简单。您已经朝着学习如何在生产中运行容器迈出了一大步。接下来，您将学习如何将这个应用程序作为Docker机器群集上的真正群体运行。</p>
<blockquote>
<p>注意：像这里的Compose文件是用于通过Docker来定义应用程序，并且可以通过<a href="https://docs.docker.com/docker-cloud/">Docker Cloud</a>上传到云端，或者任何带有<a href="https://www.docker.com/enterprise-edition">Docker 企业版</a>的云服务上。</p>
</blockquote>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>总而言之，在输入<code>docker run</code>运行时非常简单，生产中的容器真正实现将其作为服务运行。服务在Compose文件中编写容器的行为，此文件可用于缩放，限制和重新部署我们的应用程序。对服务的更改可以在运行时适用，使用启动服务的相同命令：<code>docker stack deploy</code>。</p>
<p>现阶段需要学习的一些命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack ls                                            # List stacks or apps</span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose file</span><br><span class="line">docker service ls                 # List running services associated with an app</span><br><span class="line">docker service ps &lt;service&gt;                  # List tasks associated with an app</span><br><span class="line">docker inspect &lt;task or container&gt;                   # Inspect task or container</span><br><span class="line">docker container ls -q                                      # List container IDs</span><br><span class="line">docker stack rm &lt;appname&gt;                             # Tear down an application</span><br><span class="line">docker swarm leave --force      # Take down a single node swarm from the manager</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门Part4-Swarms</title>
    <url>/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/">Docker Compos</a>。</li>
<li>获取预装<a href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a>和<a href="https://docs.docker.com/docker-for-windows/">Docker for Windows</a>的<a href="https://docs.docker.com/machine/overview/">Docker Machine</a>，但在Linux系统上需要<a href="https://docs.docker.com/machine/install-machine/#installing-machine-directly">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统之前以及Windows 10 Home中，使用<a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>。</li>
<li>阅读Part1。</li>
<li>学习Part2中的如何创建容器。</li>
<li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li>
<li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li>
<li>有一份Part3中的<code>docker-compose.yml</code>。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Part3中，你介绍了在Part2中编写的应用程序，并通过将其转化为service来定义应该如何在生产环境中运行，并在其进程内扩大5倍。</p>
<p>在Part4部分，您将此应用程序部署到集群上，并在多台机器上运行它。通过将多台机器连接到称为<strong>swarm</strong>的“Dockerized”群集，使多容器，多机器应用成为可能。</p>
<h2 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h2><p>Swarm是一组运行Docker并加入到集群中的机器。发生这种情况后，您将继续运行您习惯的Docker命令，但现在它们将由<strong>swarm manager</strong>在群集上执行。swarm中的机器可以是物理的或虚拟的。加入swarm后，他们被称为节点。</p>
<p>swarm管理器可以使用几种策略来运行容器，例如“emptiest node”—它用容器填充最少使用的机器。或者“global”，它可以确保每台机器只获取指定容器的一个实例。您指示swarm manager在Compose文件中使用这些策略，就像您已经使用的策略一样。</p>
<p>swarm manager是群体中唯一可以执行你的命令，或者授权其他机器作为<strong>worker</strong>加入群体的机器。worker只是提供能力，并没有权力告诉任何其他机器它能做什么和不能做什么。</p>
<p>到目前为止，您已经在本地机器上以单主机模式使用Docker。但是Docker也可以切换到<strong>swarm模式</strong>，这就是使用群集的原因。立即启用swarm模式使当前的机器成为swarm manager。从此，Docker将运行您在您管理的swarm上执行的命令，而不仅仅是在当前机器上执行。</p>
<h2 id="设置你的swarm"><a href="#设置你的swarm" class="headerlink" title="设置你的swarm"></a>设置你的swarm</h2><p>一个swarm是由多个节点组成，这些节点可以是物理机或虚拟机。基本概念很简单：运行<code>docker swarm init</code>来启用swarm模式，并使您当前的机器成为swarm管理器，然后在其他机器上运行<code>docker swarm join</code>，使其他机器以worker的身份加入到swarm中。我们将使用虚拟机快速创建一个双机群集，并将其变成swarm。</p>
<h3 id="创建一个集群"><a href="#创建一个集群" class="headerlink" title="创建一个集群"></a>创建一个集群</h3><h4 id="本地虚拟机（Mac，Linux，Windows-7和8）"><a href="#本地虚拟机（Mac，Linux，Windows-7和8）" class="headerlink" title="本地虚拟机（Mac，Linux，Windows 7和8）"></a>本地虚拟机（Mac，Linux，Windows 7和8）</h4><p>您需要一个可以创建虚拟机（VM）的虚拟机管理程序，因此请为您的计算机的操作系统<a href="https://www.virtualbox.org/wiki/Downloads">安装Oracle VirtualBox</a>。</p>
<blockquote>
<p>注意：如果你在Windows系统下，并且已经安装了Hyper-V，例如Windows 10，那就没必要安装VirtualBox了，你可以使用Hyper-V替代。如果你正在使用<a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>，你应该已经安装好了VirtualBox。</p>
</blockquote>
<p>现在，使用<code>docker-machine</code>创建两个虚拟机VM，使用VirtualBox驱动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1</span><br><span class="line">docker-machine create --driver virtualbox myvm2</span><br></pre></td></tr></table></figure>
<h4 id="本地虚拟机（Windows-10-Hyper-V）"><a href="#本地虚拟机（Windows-10-Hyper-V）" class="headerlink" title="本地虚拟机（Windows 10/Hyper-V）"></a>本地虚拟机（Windows 10/Hyper-V）</h4><p>首先，快速为您的虚拟机（VM）创建一个虚拟交换机以便共享，以便它们可以相互连接。</p>
<ul>
<li>1.开启 Hyper-V Manager</li>
<li>2.点击右上角菜单中的<strong>Virtual Switch Manager</strong></li>
<li>3.单击创建类型为<strong>External</strong>的<strong>虚拟交换机</strong></li>
<li>4.将它命名为<code>myswitch</code>，然后选中复选框以共享主机的活动网络适配器</li>
</ul>
<p>现在，使用我们的节点管理工具<code>docker-machine</code>创建几个虚拟机：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm2</span><br></pre></td></tr></table></figure></h2><h3 id="列出虚拟机，并显示其IP地址"><a href="#列出虚拟机，并显示其IP地址" class="headerlink" title="列出虚拟机，并显示其IP地址"></a>列出虚拟机，并显示其IP地址</h3><p>你现在创建了两个虚拟机，名叫<code>myvm1</code>和<code>myvm2</code>。</p>
<p>使用下面的命令来列出这些虚拟机以及他们的IP地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure>
<p>这里是这个命令的输出示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce   </span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce   </span><br></pre></td></tr></table></figure>
<h3 id="初始化swarm和节点"><a href="#初始化swarm和节点" class="headerlink" title="初始化swarm和节点"></a>初始化swarm和节点</h3><p>第一台机器作为manager，它负责执行管理命令并认证worker机器加入集群，第二台机器是worker。</p>
<p>你可以对你的虚拟机通过<code>docker-machine ssh</code>来发送命令。通过执行<code>docker swarm init</code>来指导<code>myvm1</code>来成为swarm manager，然后你会看到像下面这样的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line">Swarm initialized: current node &lt;node ID&gt; is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">  docker swarm join \</span><br><span class="line">  --token &lt;token&gt; \</span><br><span class="line">  &lt;myvm ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>端口2377和2376</strong></p>
<p>始终使用端口2377（群管理端口）运行<code>docker swarm init</code>和<code>docker swarm join</code>，或根本不指定运行端口，并让其采用默认值。</p>
<p>由<code>docker-machine ls</code>返回的计算机IP地址包括端口2376，它是Docker守护进程端口。请勿使用此端口，否则<a href="https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2">可能会遇到错误</a>。</p>
<p><strong>无法使用SSH？试试—native-ssh标志</strong></p>
<p>如果由于某些原因，您无法将命令发送给Swarm管理器，Docker Machine可以<a href="https://docs.docker.com/machine/reference/ssh/#different-types-of-ssh">选择让您使用自己的系统的SSH</a>。只需在调用<code>ssh</code>命令时指定<code>--native-ssh</code>标志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine --native-ssh ssh myvm1 ...</span><br></pre></td></tr></table></figure>
<p>如您所见，对<code>docker swarm init</code>的响应包含一个预配置的<code>docker swarm join</code>命令，您可以在要添加的任何节点上运行该命令。复制这条命令，并通过<code>docker-machine ssh</code>发送到<code>myvm2</code>，使<code>myvm2</code>作为woker的角色来加入到你新创建的集群中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 &quot;docker swarm join \</span><br><span class="line">--token &lt;token&gt; \</span><br><span class="line">&lt;ip&gt;:2377&quot;</span><br><span class="line"></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>
<p>恭喜，您已经创建了您的第一个swarm集群！</p>
<p>在manager机器上运行<code>docker node ls</code>来查看swarm中的node：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker node ls&quot;</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</span><br><span class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               Active</span><br><span class="line">rihwohkh3ph38fhillhhb84sk *   myvm1               Ready               Active              Leader</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>离开一个swarm</strong></p>
<p>如果你的某个节点想要退出集群，你可以在节点上运行<code>docker swarm leave</code>。</p>
</blockquote>
<h2 id="发布你的应用到swarm集群"><a href="#发布你的应用到swarm集群" class="headerlink" title="发布你的应用到swarm集群"></a>发布你的应用到swarm集群</h2><p>最困难的部分已经结束了。现在你只需重复第3部分用于部署新swarm的流程即可。请记住，只有像<code>myvm1</code>这样的群集管理器才能执行Docker命令；worker机器只是提供使用而已。</p>
<h3 id="为swarm-manager配置docker-machine-shell"><a href="#为swarm-manager配置docker-machine-shell" class="headerlink" title="为swarm manager配置docker-machine shell"></a>为swarm manager配置<code>docker-machine</code> shell</h3><p>到目前为止，你已经可以在<code>docker-machine ssh</code>中包裹Docker命令来在虚拟机上执行指令了。另一种选择是运行<code>docker-machine env &lt;machine&gt;</code>来获取并执行一个命令，该命令将当前shell配置为与虚拟机上的Docker守护进程进行通信。此方法对下一步更有利，因为它允许您使用本地<code>docker-compose.yml</code>文件“远程”部署应用程序，而无需将其复制到任何位置。</p>
<p>键入<code>docker-machine env myvm1</code>，然后复制粘贴并运行作为输出最后一行提供的命令，这样可以将shell配置为swarm manager可以与<code>myvm1</code>进行对话。</p>
<p>配置shell的命令根据你是Mac，Linux还是Windows而有所不同。</p>
<h4 id="Mac，Linux"><a href="#Mac，Linux" class="headerlink" title="Mac，Linux"></a>Mac，Linux</h4><p>Mac或Linux上的Docker Machine shell</p>
<p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line">export DOCKER_TLS_VERIFY&#x3D;&quot;1&quot;</span><br><span class="line">export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH&#x3D;&quot;&#x2F;Users&#x2F;sam&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;myvm1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME&#x3D;&quot;myvm1&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce   </span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce   </span><br></pre></td></tr></table></figure>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\sam\sandbox\get-started&gt; docker-machine env myvm1</span><br><span class="line">$Env:DOCKER_TLS_VERIFY &#x3D; &quot;1&quot;</span><br><span class="line">$Env:DOCKER_HOST &#x3D; &quot;tcp:&#x2F;&#x2F;192.168.203.207:2376&quot;</span><br><span class="line">$Env:DOCKER_CERT_PATH &#x3D; &quot;C:\Users\sam\.docker\machine\machines\myvm1&quot;</span><br><span class="line">$Env:DOCKER_MACHINE_NAME &#x3D; &quot;myvm1&quot;</span><br><span class="line">$Env:COMPOSE_CONVERT_WINDOWS_PATHS &#x3D; &quot;true&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># &amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:PATH&gt; docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER   STATE     URL                          SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        hyperv   Running   tcp:&#x2F;&#x2F;192.168.203.207:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        hyperv   Running   tcp:&#x2F;&#x2F;192.168.200.181:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure>
<h3 id="在swarm-manager上发布应用"><a href="#在swarm-manager上发布应用" class="headerlink" title="在swarm manager上发布应用"></a>在swarm manager上发布应用</h3><p>现在你已经拥有了<code>myvm1</code>，你可以使用它的权力作为swarm manager来部署你的应用，方法是使用第三部分中的<code>docker stack deploy</code>命令将你的本地副本<code>docker-compose.yml</code>发布到<code>myvm1</code>。这个命令也许会花费几秒钟时间来完成这一操作，部署需要花一段时间才能完成。在swarm manager上使用<code>docker service ps &lt;service_name&gt;</code>命令验证所有服务是否已被重新部署。</p>
<p>您通过<code>docker-machine shell</code>配置链接到<code>myvm1</code>，并且您仍然可以访问本地主机上的文件。确保你和之前在同一个目录下，并且其中包括你在第3部分中创建的<code>docker-compose.yml</code>文件。</p>
<p>就像之前一样，运行以下命令在<code>myvm1</code>上部署应用程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>就是这样，该应用程序就成功部署在了swarm集群上了！</p>
<blockquote>
<p>注意：如果你的镜像保存在了一个私有仓库而不是Docker Hub上，你需要登录到通过命令<code>docker login &lt;your-registry&gt;</code>来登录到这个仓库，并且然后你需要在上面的命令添加<code>--with-registry-auth</code>指令。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login registry.example.com</span><br><span class="line"></span><br><span class="line">docker stack deploy --with-registry-auth -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>这使用加密的WAL日志将登录令牌从本地客户端传递到部署服务的群集节点。有了这些信息，这些节点就能够登录到仓库并提取镜像。</p>
</blockquote>
<p>现在你可以使用Part3中的docker命令。只有这次注意到services（和相关容器）已经在<code>myvm1</code>和<code>myvm2</code>之间分配了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker stack ps getstartedlab</span><br><span class="line"></span><br><span class="line">ID            NAME                  IMAGE                   NODE   DESIRED STATE</span><br><span class="line">jq2g3qp8nzwx  getstartedlab_web.1   john&#x2F;get-started:part2  myvm1  Running</span><br><span class="line">88wgshobzoxl  getstartedlab_web.2   john&#x2F;get-started:part2  myvm2  Running</span><br><span class="line">vbb1qbkb0o2z  getstartedlab_web.3   john&#x2F;get-started:part2  myvm2  Running</span><br><span class="line">ghii74p9budx  getstartedlab_web.4   john&#x2F;get-started:part2  myvm1  Running</span><br><span class="line">0prmarhavs87  getstartedlab_web.5   john&#x2F;get-started:part2  myvm2  Running</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用<code>docker-machine env</code>和<code>docker-machine ssh</code>连接到VM</strong></p>
<ul>
<li><p>要将shell设置为与<code>myvm2</code>等其他机器通信，只需在相同或不同的shell中重新运行<code>docker-machine env</code>，然后运行给定的命令以指向<code>myvm2</code>。这里指的是当前的shell。如果你更改为未配置的shell或打开一个新的shell，则需要重新运行这些命令。使用<code>docker-machine ls</code>列出机器列表，查看它们所处的状态，获取IP地址，如果有的话，并找出具体连接到的是哪一个地址。更多请参阅<a href="https://docs.docker.com/machine/get-started/#create-a-machine">Docker Machine getting started topics</a>。</p>
</li>
<li><p>或者，你可以以<code>docker-machine ssh &lt;machine&gt; &quot;&lt;command&gt;&quot;</code>的形式来打包Docker命令，该命令可以直接登陆到VM，但不会立即访问本地主机上的文件。</p>
</li>
<li><p>在Mac和Linux上，你可以使用<code>docker-machine scp &lt;file&gt; &lt;machine&gt;:~</code>来在机器间复制文件，但在Windows上，需要使用一个Linux类似<a href="https://git-for-windows.github.io/">Git Bash</a>的终端模拟器来完成这类工作。</p>
</li>
</ul>
<p>本教程演示了<code>docker-machine ssh</code>和<code>docker-machine env</code>因为这些都可以通过<code>docker-machine</code>CLI在平台上使用。</p>
</blockquote>
<h3 id="访问你的集群"><a href="#访问你的集群" class="headerlink" title="访问你的集群"></a>访问你的集群</h3><p>你可以从<code>myvm1</code>或<code>myvm2</code>的IP地址访问您的应用程序。</p>
<p>你创建的网络在它们之间共享负载均衡。运行<code>docker-machine ls</code>来获取你的VM的IP地址，并通过浏览器访问其中的任何一个，点击刷新（或者仅仅使用<code>curl</code>来访问）</p>
<p><img src="/img/18_04_26/002.png" alt=""></p>
<p>有五个可能的容器ID全部随机循环，体现了负载均衡。</p>
<p>两个IP地址工作的原因是群中的节点参与<strong>入口路由网格</strong>。这可以确保部署在集群中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。以下是三节点swarm的端口8080上发布的名为<code>my-web</code>的服务的路由网络示意图：</p>
<p><img src="/img/18_04_26/003.png" alt=""></p>
<blockquote>
<p><strong>连接有问题？</strong></p>
<p>请记住，要使用swarm中的入口网络，在启用swarm模式之前，需要在swarm节点之间打开以下端口：</p>
<ul>
<li>端口7946 TCP/UDP （用于容器网络发现）</li>
<li>端口4789 UDP （用于容器入口网络）</li>
</ul>
</blockquote>
<h2 id="迭代和缩放你的应用程序"><a href="#迭代和缩放你的应用程序" class="headerlink" title="迭代和缩放你的应用程序"></a>迭代和缩放你的应用程序</h2><p>在这里，你可以完成你在Part2和Part3中学到的一切。</p>
<p>通过修改<code>docker-compose.yml</code>文件，可以缩放应用程序。</p>
<p>通过编辑代码，来改变应用的行为，然后重新构建，并将新的镜像push上去。（要做到这一点，请按照之前用于构建应用程序和发布镜像的相同步骤）。</p>
<p>无论是哪种情况，只需要通过再次运行<code>docker stack deploy</code>就可以发布这些变更。</p>
<p>你可以加入任何虚拟的或物理的机器到这个swarm中，对<code>myvm2</code>使用相同的<code>docker swarm join</code>命令，然后集群的容量就被扩大了。在运行<code>docker stack deploy</code>之后，你的应用程序就可以利用到这些资源了。</p>
<h2 id="清空并重启"><a href="#清空并重启" class="headerlink" title="清空并重启"></a>清空并重启</h2><h3 id="堆栈和swarm"><a href="#堆栈和swarm" class="headerlink" title="堆栈和swarm"></a>堆栈和swarm</h3><p>你可以通过运行<code>docker stack rm</code>来卸下堆栈。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>保留或删除swarm</strong>？</p>
<p>在稍后，如果您想要使某个worker离开swarm，可以在worker上使用<code>docker-machine ssh myvm2 &quot;docker swarm leave&quot;</code>来卸下woker，如果是manager的话，可以这样执行<code>docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;</code>，但在后面的Part5的教学中，你还需要它，所以暂时保留。</p>
</blockquote>
<h3 id="重置docker-machine-shell变量设置"><a href="#重置docker-machine-shell变量设置" class="headerlink" title="重置docker-machine shell变量设置"></a>重置docker-machine shell变量设置</h3><p>你可以通过你当前的shell执行以下命令来重置<code>docker-machine</code>环境变量。</p>
<p>在Mac或Linux上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval $(docker-machine env -u)</span><br></pre></td></tr></table></figure>
<p>在Windows上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env -u | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>这将shell与<code>docker-machine</code>创建的虚拟机断开连接，并允许你继续在同一个shell中工作，现在使用本机docker命令。更多信息，请见<a href="https://docs.docker.com/machine/get-started/#unset-environment-variables-in-the-current-shell">Machine topic on unsetting environment variables</a>。</p>
<p>重启Docker machines</p>
<p>如果你关闭本地主机，Docker machines将停止运行。你可以通过运行<code>docker-machine ls</code>来检查机器运行的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORS</span><br><span class="line">myvm1   -        virtualbox   Stopped                 Unknown</span><br><span class="line">myvm2   -        virtualbox   Stopped                 Unknown</span><br></pre></td></tr></table></figure>
<p>重启已经停止的机器，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine start &lt;machine-name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine start myvm1</span><br><span class="line">Starting &quot;myvm1&quot;...</span><br><span class="line">(myvm1) Check network to re-create if needed...</span><br><span class="line">(myvm1) Waiting for an IP...</span><br><span class="line">Machine &quot;myvm1&quot; was started.</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Started machines may have new IP addresses. You may need to re-run the &#96;docker-machine env&#96; command.</span><br><span class="line"></span><br><span class="line">$ docker-machine start myvm2</span><br><span class="line">Starting &quot;myvm2&quot;...</span><br><span class="line">(myvm2) Check network to re-create if needed...</span><br><span class="line">(myvm2) Waiting for an IP...</span><br><span class="line">Machine &quot;myvm2&quot; was started.</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Started machines may have new IP addresses. You may need to re-run the &#96;docker-machine env&#96; command.</span><br></pre></td></tr></table></figure>
<h2 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h2><p>在part4部分，你学习到了什么是swarm，节点在swarm中可以作为worker，也可以作为manager，创建一个swarm，并在上面发布一个应用。你看到Docker的核心命令和part3中并没有什么不同，他们只需要将目标锁定在swarm主机上运行。你还看到了Docker网络的力量，即使它们运行在不同的机器上，也可以跨容器保持请求负载均衡。最后，你学习了如何在集群上迭代和缩放应用程序。以下是您可能想要运行的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1 # Win10</span><br><span class="line">docker-machine env myvm1                # View basic information about your node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node ls&quot;         # List the nodes in your swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node inspect &lt;node ID&gt;&quot;        # Inspect a node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm join-token -q worker&quot;   # View join token</span><br><span class="line">docker-machine ssh myvm1   # Open an SSH session with the VM; type &quot;exit&quot; to end</span><br><span class="line">docker node ls                # View nodes in swarm (while logged on to manager)</span><br><span class="line">docker-machine ssh myvm2 &quot;docker swarm leave&quot;  # Make the worker leave the swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm leave -f&quot; # Make master leave, kill swarm</span><br><span class="line">docker-machine ls # list VMs, asterisk shows which VM this shell is talking to</span><br><span class="line">docker-machine start myvm1            # Start a VM that is currently not running</span><br><span class="line">docker-machine env myvm1      # show environment variables and command for myvm1</span><br><span class="line">eval $(docker-machine env myvm1)         # Mac command to connect shell to myvm1</span><br><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression   # Windows command to connect shell to myvm1</span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ # Copy file to node&#39;s home dir (only required if you use ssh to connect to manager and deploy the app)</span><br><span class="line">docker-machine ssh myvm1 &quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;   # Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span><br><span class="line">eval $(docker-machine env -u)     # Disconnect shell from VMs, use native docker</span><br><span class="line">docker-machine stop $(docker-machine ls -q)               # Stop all running VMs</span><br><span class="line">docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门Part5-堆栈</title>
    <url>/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/">Docker Compos</a>。</li>
<li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/">Docker Machine</a>。</li>
<li>阅读Part1。</li>
<li>学习Part2中的如何创建容器。</li>
<li>确保您已发布了那个<a href="https://docs.docker.com/get-started/part2/#share-your-image">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li>
<li>确保你在part4中设置的机器处于运行状态。运行<code>docker-machine ls</code>来验证这一点。如果机器处于停止状态，运行<code>docker-machine start myvm1</code>来启动manager，然后执行<code>docker-machine start myvm2</code>来启动worker。</li>
<li>让你在Part4创建的swarm处于运行状态并准备就绪。运行<code>docker-machine ssh myvm1 &quot;docker node ls&quot;</code>来验证这一点。如果swarm起来了，那么两个node的状态都是<code>ready</code>。如果不是这样，重新初始化swarm，并按照part4中的方式将worker加入到swarm中。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在part4中，你学到了如何设置一个swarm，这是一群运行Docker的机器，并为其部署了一个应用程序，其中容器在多台机器上运行。</p>
<p>在这里的Part5中，您将学习到分布式应用程序层次结构的顶部部分：<strong>堆栈(stack)</strong>。堆栈是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个堆栈）。</p>
<p>一些好消息是，从Part3部分开始，在创建Compose文件并使用<code>docker stack deploy</code>时，从技术上讲，您其实一直都在使用堆栈。但这是在单个主机上运行的单个服务堆栈，通常不会发生在生产环境中。在这里，你可以把你学到的东西，使多个服务相互关联，并在多台机器上运行它们。</p>
<p>你做得很好，这就是你的主场！</p>
<h2 id="添加一项新服务并重新部署"><a href="#添加一项新服务并重新部署" class="headerlink" title="添加一项新服务并重新部署"></a>添加一项新服务并重新部署</h2><p>将服务添加到我们的<code>docker-compose.yml</code>文件很容易。首先，我们添加一个免费的可视化工具，让我们看看我们的swarm是如何安排容器的。</p>
<ul>
<li>1.打开<code>docker-compose.yml</code>文件，并用以下内容替换它。确保你的<code>username/repo:tag</code>是正确的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: username&#x2F;repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples&#x2F;visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role &#x3D;&#x3D; manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>这里唯一新增的东西就是<code>visualizer</code>。注意到这里有两个新的东西：一个<code>volumes</code>键，让visualizer可以访问Docker主机的socket文件，这项服务职能在swarm manager上运行。这是因为这个容器是由Docker创建的<a href="https://github.com/ManoMarks/docker-swarm-visualizer">一个开源项目</a>构建的，它显示了一个图表中的swarm运行的Docker服务。</p>
<p>我们稍后会详细讨论放置约束和体积。</p>
<ul>
<li><p>2.确保你的shell被配置为与myvm1进行通信（完整的例子在<a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager">这里</a>）。</p>
<ul>
<li>运行<code>docker-machine ls</code>来列出机器，并确保您已连接到<code>myvm1</code>，如旁边的星号所示。</li>
<li><p>如果需要，重新运行<code>docker-machine env myvm1</code>，然后运行给定的命令来配置shell。</p>
<p>在Mac或者Linux上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>在Windows命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3.在manager上重新运行<code>docker stack deploy</code>命令，并且需要更新的任何服务都会更新：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Updating service getstartedlab_web (id: angi1bf5e4to03qu9f93trnxm)</span><br><span class="line">Creating service getstartedlab_visualizer (id: l9mnwkeq2jiononb5ihz9u7a4)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>4.看一下visualizer。</p>
<p>  你可以看到compose文件中的<code>visualizer</code>运行在了8080端口。通过运行<code>docker-machine ls</code>可以获取每个节点的IP地址信息。分别访问任意一个IP地址的8080端口，你可以看到visualizer的运行效果：</p>
<p>  <img src="/img/18_05_02/001.png" alt=""></p>
<p>  <code>visualizer</code>的单个副本按照您的预期在manager上运行，并且<code>web</code>的5个实例遍布整个swarm。你可以通过运行<code>docker stack ps &lt;stack&gt;</code>来确认可视化的结果：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack ps getstartedlab</span><br></pre></td></tr></table></figure>
<p>  可视化器是一个独立的服务，可以在包含它的任何应用程序中运行。它不依赖于其他任何东西。现在让我们创建一个具有依赖关系的服务：提供访问者计数器的Redis服务。</p>
</li>
</ul>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p>
<ul>
<li>1.保存这个在最后位置添加Redis服务的新的<code>docker-compose.yml</code>文件。确保替换镜像详情部分的<code>username/repo:tag</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: username&#x2F;repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples&#x2F;visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role &#x3D;&#x3D; manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;home&#x2F;docker&#x2F;data:&#x2F;data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role &#x3D;&#x3D; manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>Redis在Docker库中有一个官方镜像，并已被授予<code>redis</code>作为镜像的简称，所以在这里没有<code>username/repo</code>符号。Redis端口6379已经由Redis预配置为从容器暴露给主机，在我们的Compose文件中，我们将它从主机展示给全世界，因此，如果您愿意，您可以将任何节点的IP输入到Redis桌面管理器中，并管理此Redis实例。</p>
<p>最重要的是，<code>redis</code>规范中有几件事情使数据在这个堆栈的部署之间持续存在：</p>
<ul>
<li><code>redis</code>总是在manager上运行，所以它总是使用相同的文件系统。</li>
<li><code>redis</code>在主机文件系统中访问任意目录作为容器内的<code>/data</code>，这是Redis存储数据的地方。</li>
</ul>
<p>这就是在您的主机物理文件系统中为Redis数据创建“真相源”。如果没有这个，Redis会将其数据存储在容器文件系统中的<code>/data</code>中，如果该容器曾经被重新部署，该数据将被清除。</p>
<p>这个真相的来源有两个组成部分：</p>
<ul>
<li>放置在Redis服务上的放置约束，确保它始终使用相同的主机。</li>
<li>您创建的容器，允许容器作为<code>./data</code>（位于Redis容器内）访问<code>./data</code>（在主机上）。在容器来来去去时，存储在指定主机上的<code>./data</code>文件仍然存在，从而保持连续性。</li>
</ul>
<p>您已准备好部署新的供Redis使用的堆栈了。</p>
<ul>
<li>2.在manager上创建一个<code>./data</code>目录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine ssh myvm1 &quot;mkdir .&#x2F;data&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>3.确保你的shell被配置为与<code>myvm1</code>进行通信(完整的例子在<a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager">这里</a>)。</p>
<ul>
<li>运行<code>docker-machine ls</code>列出机器，并确保你已经连接到了<code>myvm1</code>，由旁边的星号所指示。</li>
<li><p>如果需要的话，重新运行<code>docker-machine env myvm1</code>，然后运行下面给出的命令来配置shell。</p>
<p>在Mac或Linux上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>在Windows上命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>4.再次运行<code>docker stack deploy</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<ul>
<li>5.运行<code>docker service ls</code>来验证三个服务处于运行状态：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">x7uij6xb4foj        getstartedlab_redis        replicated          1&#x2F;1                 redis:latest                      *:6379-&gt;6379&#x2F;tcp</span><br><span class="line">n5rvhm52ykq7        getstartedlab_visualizer   replicated          1&#x2F;1                 dockersamples&#x2F;visualizer:stable   *:8080-&gt;8080&#x2F;tcp</span><br><span class="line">mifd433bti1d        getstartedlab_web          replicated          5&#x2F;5                 orangesnap&#x2F;getstarted:latest    *:80-&gt;80&#x2F;tcp</span><br></pre></td></tr></table></figure>
<ul>
<li>6.检查位于你的某个节点的网页，例如<code>http://192.168.99.101</code>，然后看访问者计数器的结果，该计数器现在已经存在并将信息存储在Redis上。</li>
</ul>
<p><img src="/img/18_05_02/002.png" alt=""></p>
<p>另外，请检查任一节点IP地址的端口8080处的可视化工具，并注意查看随<code>web</code>和<code>visualizer</code>工具一起运行的<code>redis</code>服务。</p>
<p><img src="/img/18_05_02/003.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门Part6-发布你的app</title>
    <url>/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/</url>
    <content><![CDATA[<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>按照Part3部分，获取<a href="https://docs.docker.com/compose/overview/">Docker Compos</a>。</li>
<li>按照Part4部分，获取<a href="https://docs.docker.com/machine/overview/">Docker Machine</a>。</li>
<li>阅读Part1。</li>
<li>学习Part2中的如何创建容器。</li>
<li>确保您的镜像作为一个发布容器在运行。运行这条插入了<code>username</code>、<code>repo</code>和<code>tag</code>信息的命令:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li>
<li>获取到Part5中的最终版本的<code>compose.yml</code>文件。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>您一直在为整个教程编辑相同的Compose文件。那么，我们有一个好消息，这个Compose文件在生产环境中的效果与你的计算机上的效果是相同的。在这里，我们通过一些选项来运行Docker化的程序。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="Docker社区版（云服务提供者）"><a href="#Docker社区版（云服务提供者）" class="headerlink" title="Docker社区版（云服务提供者）"></a>Docker社区版（云服务提供者）</h3><p>如果您可以在生产环境中使用Docker社区版，那么你可以使用Docker Cloud来帮助您管理应用程序，例如Amazon Web Services，DigitalOcean，和Microsoft Azure等常用的服务提供商。</p>
<p>设置和部署：</p>
<ul>
<li>将Docker Cloud与您的首选提供商连接，授予Docker Cloud权限，以便为您自动配置以及为您”Docker化”VM。</li>
<li>使用Docker Cloud创建您的计算资源并创建您的swarm。</li>
<li>部署您的应用。</li>
</ul>
<blockquote>
<p>注意：我们没有链接到Docker Cloud文档。请务必在完成每个步骤后回到此页面。</p>
</blockquote>
<h4 id="连接Docker-Cloud"><a href="#连接Docker-Cloud" class="headerlink" title="连接Docker Cloud"></a>连接Docker Cloud</h4><p>你可以在<a href="https://docs.docker.com/docker-cloud/infrastructure/">标准模式</a>或<a href="https://docs.docker.com/docker-cloud/cloud-swarm/">swarm模式</a>下运行Docker Cloud。</p>
<p>如果你正在标准模式下运行Docker Cloud，请按照以下说明将您的服务提供商链接到Docker Cloud。</p>
<ul>
<li><a href="https://docs.docker.com/docker-cloud/cloud-swarm/link-aws-swarm/">Amazon Web Services 设置说明</a>。</li>
<li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-do/">DigitalOcean 设置说明</a>。</li>
<li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-azure/">Microsoft Azure 设置说明</a>。</li>
<li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-packet/">Packet 设置说明</a>。</li>
<li><a href="https://docs.docker.com/docker-cloud/infrastructure/link-softlayer/">SoftLayer 设置说明</a>。</li>
<li><a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/">使用Docker Cloud 代理来访问自己的主机</a>。</li>
</ul>
<p>如果您在Swarm模式下运行（推荐用于Amazon Web Services或Microsoft Azure），那么请跳至下一节关于如何<a href="#创建你的swarm">创建swarm</a>的部分。</p>
<h3 id="创建你的swarm"><a href="#创建你的swarm" class="headerlink" title="创建你的swarm"></a>创建你的swarm</h3><p>准备好创建一个swarm了吗？</p>
<ul>
<li>如果你在使用Amazon Web Services(AWS)，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-aws/">在AWS上自动地创建一个swarm</a>。</li>
<li>如果你在使用Microsoft Azure，那么你可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-azure/">在Azure上自动地创建一个swarm</a>。</li>
<li>否则，在Docker Cloud UI界面<a href="https://docs.docker.com/docker-cloud/getting-started/your_first_node/">创建你的节点</a>，然后运行<code>docker swarm init</code>并执行在Part4部分所学的<code>docker swarm join</code>命令。最后，通过点击屏幕顶部的开关<a href="https://docs.docker.com/docker-cloud/cloud-swarm/using-swarm-mode/">启用swarm模式</a>，并<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/">注册你刚刚创建的swarm</a>。</li>
</ul>
<blockquote>
<p>注意：如果您<a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/">使用Docker云代理来自带主机</a>，则此提供程序不支持swarm模式。您可以使用Docker Cloud<a href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/">注册您自己的现有的swarm</a>。</p>
</blockquote>
<h3 id="在云服务平台上部署你的应用程序"><a href="#在云服务平台上部署你的应用程序" class="headerlink" title="在云服务平台上部署你的应用程序"></a>在云服务平台上部署你的应用程序</h3><ul>
<li><p>1.<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/">通过Docker Cloud连接到你自己的swarm</a>。有几种不同的连接方式：</p>
<ul>
<li><p>从Swarm模式的Docker Cloud Web界面中，选择页面顶部的Swarms，单击要连接的swarm，然后将给定的命令复制粘贴到命令行终端中。</p>
<p><img src="/img/18_05_02/004.png" alt=""></p>
<p>或者。。。</p>
</li>
<li><p>在Docker for Mac或Docker for Windows上，您可以<a href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/#use-docker-for-mac-or-windows-edge-to-connect-to-swarms">通过桌面应用菜单直接连接到swarm</a>。</p>
<p><img src="/img/18_05_02/005.png" alt=""></p>
<p>无论哪种方式，都将打开一个终端，其上下文是本地计算机，但其Docker命令会路由到云服务提供商上运行的swarm。您可以直接访问本地文件系统和远程swarm，从而启用纯粹的<code>docker</code>命令。</p>
</li>
</ul>
</li>
<li><p>2.运行<code>docker stack deploy -c docker-compose.yml getstartedlab</code>在云托管swarm上部署应用程序。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">	</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">Creating service getstartedlab_visualizer</span><br><span class="line">Creating service getstartedlab_redis</span><br></pre></td></tr></table></figure>
<p>  您的应用现在运行在了云服务平台上了。</p>
</li>
</ul>
<p><strong>运行一些swarm命令来验证部署：</strong></p>
<p>你可以使用swarm命令行，就像你之前做的那样，浏览并管理你的swarm。这里有一些你比较熟悉的例子：</p>
<ul>
<li>使用<code>docker node ls</code>列出节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[getstartedlab] ~ $ docker node ls</span><br><span class="line">ID                            HOSTNAME                                      STATUS              AVAILABILITY        MANAGER STATUS</span><br><span class="line">9442yi1zie2l34lj01frj3lsn     ip-172-31-5-208.us-west-1.compute.internal    Ready               Active              </span><br><span class="line">jr02vg153pfx6jr0j66624e8a     ip-172-31-6-237.us-west-1.compute.internal    Ready               Active              </span><br><span class="line">thpgwmoz3qefdvfzp7d9wzfvi     ip-172-31-18-121.us-west-1.compute.internal   Ready               Active              </span><br><span class="line">n2bsny0r2b8fey6013kwnom3m *   ip-172-31-20-217.us-west-1.compute.internal   Ready               Active              Leader</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>docker service ls</code>列出服务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[getstartedlab] ~&#x2F;sandbox&#x2F;getstart $ docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">x3jyx6uukog9        dockercloud-server-proxy   global              1&#x2F;1                 dockercloud&#x2F;server-proxy          *:2376-&gt;2376&#x2F;tcp</span><br><span class="line">ioipby1vcxzm        getstartedlab_redis        replicated          0&#x2F;1                 redis:latest                      *:6379-&gt;6379&#x2F;tcp</span><br><span class="line">u5cxv7ppv5o0        getstartedlab_visualizer   replicated          0&#x2F;1                 dockersamples&#x2F;visualizer:stable   *:8080-&gt;8080&#x2F;tcp</span><br><span class="line">vy7n2piyqrtr        getstartedlab_web          replicated          5&#x2F;5                 sam&#x2F;getstarted:part6    *:80-&gt;80&#x2F;tcp</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>docker service ps &lt;service&gt;</code>查看service的任务列表。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[getstartedlab] ~&#x2F;sandbox&#x2F;getstart $ docker service ps vy7n2piyqrtr</span><br><span class="line">ID                  NAME                  IMAGE                            NODE                                          DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">qrcd4a9lvjel        getstartedlab_web.1   sam&#x2F;getstarted:part6   ip-172-31-5-208.us-west-1.compute.internal    Running             Running 20 seconds ago                       </span><br><span class="line">sknya8t4m51u        getstartedlab_web.2   sam&#x2F;getstarted:part6   ip-172-31-6-237.us-west-1.compute.internal    Running             Running 17 seconds ago                       </span><br><span class="line">ia730lfnrslg        getstartedlab_web.3   sam&#x2F;getstarted:part6   ip-172-31-20-217.us-west-1.compute.internal   Running             Running 21 seconds ago                       </span><br><span class="line">1edaa97h9u4k        getstartedlab_web.4   sam&#x2F;getstarted:part6   ip-172-31-18-121.us-west-1.compute.internal   Running             Running 21 seconds ago                       </span><br><span class="line">uh64ez6ahuew        getstartedlab_web.5   sam&#x2F;getstarted:part6   ip-172-31-18-121.us-west-1.compute.internal   Running             Running 22 seconds ago        </span><br></pre></td></tr></table></figure>
<p><strong>在云供应商机器上开放服务端口</strong></p>
<p>此时，您的应用作为一个swarm部署在您的云提供商服务器上，正如刚刚运行的<code>docker</code>命令所证明的那样。但是，您仍然需要在云服务器上打开端口，以便：</p>
<ul>
<li>允许在工作节点上的<code>redis</code>服务和<code>web</code>服务之间进行通信</li>
<li>允许入站流量通过worker节点上的<code>web</code>服务，以便可以在浏览器访问Hello World和Visualizer。</li>
<li>允许运行<code>manager</code>的服务器上的入站SSH流量（这可能已在您的云提供商上设置）</li>
</ul>
<p>这些是您需要为每项服务公开的端口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Service</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">协议</th>
<th style="text-align:left">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>web</code></td>
<td style="text-align:left">HTTP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">80</td>
</tr>
<tr>
<td style="text-align:left"><code>visualizer</code></td>
<td style="text-align:left">HTTP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">8080</td>
</tr>
<tr>
<td style="text-align:left"><code>redis</code></td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">6379</td>
</tr>
</tbody>
</table>
</div>
<p>具体的做法取决于云服务平台。</p>
<p>我们以Amazon Web Services（AWS）为例。</p>
<blockquote>
<p><strong>redis如何持久化数据？</strong></p>
<p>为了使<code>redis</code>服务正常工作，在运行<code>docker stack deploy</code>之前，需要<code>ssh</code>进入manager运行的云服务器，并在<code>/home/docker/</code>中创建<code>data/</code>目录。另一种选择是将<code>docker-stack.yml</code>中的数据路径更改为manager服务器上已存在的一个路径。此示例不包含此步骤，因此示例输出中的<code>redis</code>服务未启动。</p>
</blockquote>
<p><strong>示例：AWS</strong></p>
<ul>
<li>1.登录<a href="https://aws.amazon.com/">AWS控制台</a>，转到EC2仪表板，然后单击进入<strong>Running Instances</strong>查看节点。</li>
<li><p>2.在左侧的按钮，进入Network &amp; Security &gt; <strong>Security Groups</strong>。</p>
<p>  请参阅<code>getstartedlab-Manager-&lt;xxx&gt;</code>, <code>getstartedlab-Nodes-&lt;xxx&gt;</code>, 和 <code>getstartedlab-SwarmWide-&lt;xxx&gt;</code>的与swarm相关的安全组。</p>
</li>
<li><p>3.为swarm选择“节点”安全组。组名是这样的：<code>getstartedlab-NodeVpcSG-9HV9SMHDZT8C</code>。</p>
</li>
<li>4.为<code>web</code>，<code>visualizer</code>和<code>redis</code>服务添加入站规则，为每个服务设置类型，协议和端口（如上表所示），然后单击保存以应用规则。</li>
</ul>
<p><img src="/img/18_05_02/006.png" alt=""></p>
<blockquote>
<p>提示：当你保存新的规则时，会为IPv4和IPv6地址自动创建HTTP和TCP端口。</p>
</blockquote>
<p><img src="/img/18_05_02/007.png" alt=""></p>
<ul>
<li>5.进入<strong>Running Instances</strong>列表，获取其中一个worker的公共DNS名称，并将其粘贴到浏览器地址栏中。</li>
</ul>
<p><img src="/img/18_05_02/008.png" alt=""></p>
<p>就像本教程的前几部分一样，Hello World应用程序显示在端口<code>80</code>上，而Visualizer显示在端口<code>8080</code>上。</p>
<p><img src="/img/18_05_02/009.png" alt=""></p>
<p><img src="/img/18_05_02/010.png" alt=""></p>
<h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><p>从这里你可以完成你在教程前面部分学到的所有知识。</p>
<ul>
<li>通过修改<code>docker-compose.yml</code>文件并使用命令<code>docker stack deploy</code>重新发布来扩展你的应用程序。</li>
<li>通过编辑代码更改应用程序行为，然后重新构建并推送新镜像。（要做到这一点，请按照之前用于<a href="https://docs.docker.com/get-started/part2/#build-the-app">构建应用程序</a>和<a href="https://docs.docker.com/get-started/part2/#publish-the-image">发布镜像</a>的相同步骤）。</li>
<li>您可以使用<code>docker stack rm</code>命令来拆卸堆栈。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>
<p>与在本地Docker机器虚拟机上运行swarm的场景不同，不管您是否关闭本地主机，您的swarm和部署在其上的任何应用程序都将继续在云服务器上运行。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloDjango!--Django开发极速入门</title>
    <url>/2016/01/12/HelloDjango!/</url>
    <content><![CDATA[<h2 id="About-Django"><a href="#About-Django" class="headerlink" title="About Django"></a>About Django</h2><blockquote>
<p><strong><a href="https://www.djangoproject.com/">Django</a></strong>是一个开源的python web应用框架，最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站，即是CMS（内容管理系统）软件。于2005年7月在BSD许可证下发布。</p>
<p>截至目前，Django的最新版本是1.9.1。Django的名字来源于上世纪五十年代的一位吉普赛吉他手的名字Django Reinhardt，其中‘d’是不发音的，为此django官方还录制了一个<a href="http://red-bean.com/~adrian/django_pronunciation.mp3">音频</a>来更正大家的读音。</p>
</blockquote>
<h3 id="Django的理念"><a href="#Django的理念" class="headerlink" title="Django的理念"></a>Django的理念</h3><p>django是一个高级的python web框架，鼓励开发人员快速开发出<strong>干净务实</strong>的设计。由于是由有经验的web开发者创建的，所以它避免了很多web开发的麻烦。</p>
<p>可以使得开发人员更加专注的写应用程序而不需要重新造轮子。而且django是免费开源的。</p>
<p><strong>三个特点：</strong></p>
<ul>
<li>快速：帮助开发人员快速将想法变成现实</li>
<li>安全：可以帮助开发人员避免很多常见的安全方面的问题</li>
<li>可伸缩性：一些很复杂繁琐的web项目也可以由django来构建</li>
</ul>
<h3 id="都有谁用过Django呢？"><a href="#都有谁用过Django呢？" class="headerlink" title="都有谁用过Django呢？"></a>都有谁用过Django呢？</h3><p>Disqus, Instagram, Pinterest以及Mozilla 都已经使用Django很多年了，而且Django目前已经可以承受每秒最高5万的访问量。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在配置好python2.7运行环境之后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install Django&#x3D;&#x3D;1.9.1</span><br></pre></td></tr></table></figure>
<p>即可自动下载并安装Django，如果提示权限不足，可以尝试<code>sudo pip install Django==1.9.1</code>。</p>
<p>如果选择通过<a href="https://www.djangoproject.com/download/1.9.1/tarball/">下载zip包</a>安装，下载成功后，解压zip包，命令行进入到Django-1.9.1目录下，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="创建第一个django项目"><a href="#创建第一个django项目" class="headerlink" title="创建第一个django项目"></a>创建第一个django项目</h2><p>命令行执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>
<p>创建mysite项目，<code>cd</code> 进入到mysite，我们可以看到生成了如下几个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysite&#x2F;</span><br><span class="line">    manage.py			＃这是一个与django交互的命令行工具</span><br><span class="line">    mysite&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py		＃配置设置</span><br><span class="line">        urls.py			＃声明一系列django用来处理分发的url</span><br><span class="line">        wsgi.py			＃PythonWeb服务器网关接口，相当于一种协议，使得python的web应用可以部署到所有遵循这个协议点服务器上。用于部署django项目的</span><br></pre></td></tr></table></figure>
<p>在这里，我们执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp polls</span><br></pre></td></tr></table></figure>
<p>来创建一个名叫polls的app。</p>
<p>我们会发现，在mysite下会多产生一个polls的目录，这个目录的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polls&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py 		#定义moudle</span><br><span class="line">    tests.py</span><br><span class="line">    views.py 		＃定义view</span><br></pre></td></tr></table></figure>
<h3 id="配置url，让我们的项目run起来"><a href="#配置url，让我们的项目run起来" class="headerlink" title="配置url，让我们的项目run起来"></a>配置url，让我们的项目run起来</h3><p>django通过urls.py文件作为路由文件，将获取到的url通过正则匹配去分发到各个app下的urls.py，然后再由app内的urls.py通过正则匹配分发到各个view层中，并执行相关方法。</p>
<p>这里我们分别配置我们主项目和子项目中的urls.py文件：</p>
<p>mysite/urls.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include</span><br><span class="line">	url(r&#39;^polls&#x2F;&#39;, include(&#39;polls.urls&#39;)), </span><br></pre></td></tr></table></figure>
<p>polls/urls.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line"></span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^$&#39;, views.index, name&#x3D;&#39;index&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看到子项目中的url指向了views中的index方法，那么我们把views的index进行完善：</p>
<p>polls/views.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&quot;Hello Django&quot;)</span><br></pre></td></tr></table></figure>
<p>这个时候我们在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>把项目跑起来之后，在浏览器输入：<a href="http://localhost:8000/polls/">http://localhost:8000/polls/</a> 就可以看到以下输出结果了。</p>
<p><img src="/img/django_01_01.png" alt="Hello Django"></p>
<h3 id="定义models，创建数据库"><a href="#定义models，创建数据库" class="headerlink" title="定义models，创建数据库"></a>定义models，创建数据库</h3><p>django遵循DRY原则（Don’t repeat yourself），其实道理很简单，避免数据冗余，它认为冗余的就是坏的。<br>所以django中定义的每一个model，都应该是单一的，明确的，包含了所有必要信息的。<br>这样做的目的就是，你在一处定义好model，在任何其他的地方，就可以通过这个model来获取到由他派生出的信息。</p>
<p>修改models.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    question_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&#x27;date published&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#当前model的字符串表示</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.question_text</span><br><span class="line"></span><br><span class="line">	<span class="comment">#判断这条Question是否是当天发出的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">was_published_recently</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.pub_date &gt;= timezone.now() - datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Choice</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    votes = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.choice_text</span><br></pre></td></tr></table></figure>
<p>mysite下的settings.py:</p>
<p>的INSTALLED_APPS中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;polls.apps.PollsConfig&#39;,</span><br></pre></td></tr></table></figure>
<p>现在，我们可以执行<code>python manage.py makemigrations</code>,这条命令会去遍历所有在settings.py中INSTALLED_APPS下配置的app，如果发现对应app的models文件有改动，就会在这个app下的<code>migrations</code>目录下生成一个数据库的scheme文件，这里我们可以看到生成了一个<code>0001_initial.py</code>文件，这个文件描述了model对应的数据库操作，这个文件是可编辑的。</p>
<p>我们还可以通过执行<code>python manage.py sqlmigrate polls 0001</code>命令，查看上面那个scheme文件所对应的SQL语句。</p>
<p>这个时候，其实我们的sql语句并没有执行，数据库也并没有创建，我们需要执行下面这条语句，来让我们的scheme文件生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>这下，我们的表就创建成功了。</p>
<p>看似繁琐的操作，其实我们只要记住三步走的套路，就很容易掌握：</p>
<ul>
<li>1.修改models.py文件</li>
<li>2.执行python manage.py makemigrations</li>
<li>3.执行python manage.py migrate</li>
</ul>
<p>这里我有一个疑问，就是2，3的操作明明可以一步执行完，为什么还需要分成两条命令呢？</p>
<p>这里官方的解释是：</p>
<blockquote>
<p>The reason that there are separate commands to make and apply migrations is because you’ll commit migrations to your version control system and ship them with your app; they not only make your development easier, they’re also useable by other developers and in production.</p>
</blockquote>
<p>我表示依然不理解。</p>
<h3 id="通过django的shell来插入数据"><a href="#通过django的shell来插入数据" class="headerlink" title="通过django的shell来插入数据"></a>通过django的shell来插入数据</h3><p>django 给我们提供了一个shell，通过执行<code>python manage.py shell</code>进入。</p>
<p>下面通过这个shell来插入一些数据，也顺便体验一下django的orm数据库操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from polls.models import Question, Choice </span><br><span class="line">&gt;&gt;&gt; from django.utils import timezone</span><br><span class="line">&gt;&gt;&gt; Question.objects.all()</span><br><span class="line">&gt;&gt;&gt; []</span><br><span class="line">&gt;&gt;&gt; q &#x3D; Question(question_text&#x3D;&quot;What&#39;s new?&quot;, pub_date&#x3D;timezone.now())</span><br><span class="line">&gt;&gt;&gt; q.save()</span><br><span class="line">&gt;&gt;&gt; q.id</span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line">&gt;&gt;&gt; q.question_text</span><br><span class="line">&gt;&gt;&gt; &quot;What&#39;s new?&quot;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.create(choice_text&#x3D;&#39;Not much&#39;, votes&#x3D;0)</span><br><span class="line">&gt;&gt;&gt; &lt;Choice: Not much&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.create(choice_text&#x3D;&#39;The sky&#39;, votes&#x3D;0)</span><br><span class="line">&gt;&gt;&gt; &lt;Choice: The sky&gt;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; q.choice_set.create(choice_text&#x3D;&#39;Just hacking again&#39;, votes&#x3D;0)</span><br><span class="line">&gt;&gt;&gt; c.question</span><br><span class="line">&gt;&gt;&gt; &lt;Question: What&#39;s new?&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.all()</span><br><span class="line">&gt;&gt;&gt; [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]</span><br><span class="line">&gt;&gt;&gt; exit()</span><br></pre></td></tr></table></figure>
<p>至此，我们已经添加了一部分数据到db中了，我们可以通过django下的一个后台管理模块来查看我们插入的数据。</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>
<p>创建用户。</p>
<p>将我们的app注册到admin中。</p>
<p>polls/admin.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure>
<p>输入<a href="http://localhost:8000/admin/">http://localhost:8000/admin/</a> 就可以访问后台了。</p>
<p><img src="/img/django_01_02.png" alt="admin page"></p>
<h3 id="配置views-和-urls"><a href="#配置views-和-urls" class="headerlink" title="配置views 和 urls"></a>配置views 和 urls</h3><p>views写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line"></span><br><span class="line">def detail(request, question_id):</span><br><span class="line">    return HttpResponse(&quot;You&#39;re looking at question %s.&quot; % question_id)</span><br><span class="line"></span><br><span class="line">def results(request, question_id):</span><br><span class="line">    response &#x3D; &quot;You&#39;re looking at the results of question %s.&quot;</span><br><span class="line">    return HttpResponse(response % question_id)</span><br><span class="line"></span><br><span class="line">def vote(request, question_id):</span><br><span class="line">    return HttpResponse(&quot;You&#39;re voting on question %s.&quot; % question_id)</span><br></pre></td></tr></table></figure>
<p>polls/urls.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line"></span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    # ex: &#x2F;polls&#x2F;</span><br><span class="line">    url(r&#39;^$&#39;, views.index, name&#x3D;&#39;index&#39;),</span><br><span class="line">    # ex: &#x2F;polls&#x2F;5&#x2F;</span><br><span class="line">    url(r&#39;^(?P&lt;question_id&gt;[0-9]+)&#x2F;$&#39;, views.detail, name&#x3D;&#39;detail&#39;),</span><br><span class="line">    # ex: &#x2F;polls&#x2F;5&#x2F;results&#x2F;</span><br><span class="line">    url(r&#39;^(?P&lt;question_id&gt;[0-9]+)&#x2F;results&#x2F;$&#39;, views.results, name&#x3D;&#39;results&#39;),</span><br><span class="line">    # ex: &#x2F;polls&#x2F;5&#x2F;vote&#x2F;</span><br><span class="line">    url(r&#39;^(?P&lt;question_id&gt;[0-9]+)&#x2F;vote&#x2F;$&#39;, views.vote, name&#x3D;&#39;vote&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>其中：<br>?P<question_id>定义的名称，是用于识别和匹配模式；[0-9]是一个正则表达式匹配一个数字序列（即一个数）</p>
<p>当然如果你想要的话，也可以写死一个url：<br><code>url(r&#39;^polls/latest\.html$&#39;, views.index),</code><br>但是django不建议这么做。</p>
<p>接下来我们可以将models的数据信息显示在view界面上了：</p>
<p>views.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from .models import Question</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    latest_question_list &#x3D; Question.objects.order_by(&#39;-pub_date&#39;)[:5]</span><br><span class="line">    output &#x3D; &#39;, &#39;.join([q.question_text for q in latest_question_list])</span><br><span class="line">    return HttpResponse(output)</span><br></pre></td></tr></table></figure>
<p>但是这样写前台界面实在太不友好，我们要引入模版机制，将数据信息渲染到html页面上：</p>
<p>创建polls/templates/polls/index.html</p>
<p>用django特有的模版语言写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        &lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;polls&#x2F;&#123;&#123; question.id &#125;&#125;&#x2F;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;p&gt;No polls are available.&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>这些模版语言都是比较易懂的流程控制语句，相信不用解释也可以理解。</p>
<p>修改views.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line">from django.template import loader</span><br><span class="line"></span><br><span class="line">from .models import Question</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    latest_question_list &#x3D; Question.objects.order_by(&#39;-pub_date&#39;)[:5]</span><br><span class="line">    template &#x3D; loader.get_template(&#39;polls&#x2F;index.html&#39;)</span><br><span class="line">    context &#x3D; &#123;</span><br><span class="line">        &#39;latest_question_list&#39;: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    return HttpResponse(template.render(context, request))</span><br></pre></td></tr></table></figure>
<p>还有一种更快捷的写法，使用django封装好的render()方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">from .models import Question</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    latest_question_list &#x3D; Question.objects.order_by(&#39;-pub_date&#39;)[:5]</span><br><span class="line">    context &#x3D; &#123;&#39;latest_question_list&#39;: latest_question_list&#125;</span><br><span class="line">    return render(request, &#39;polls&#x2F;index.html&#39;, context)</span><br></pre></td></tr></table></figure>
<p>创建polls/templates/polls/detail.html,并写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; question &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>polls/views.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import get_object_or_404, render</span><br><span class="line"></span><br><span class="line">from .models import Question</span><br><span class="line"># ...</span><br><span class="line">def detail(request, question_id):</span><br><span class="line">    question &#x3D; get_object_or_404(Question, pk&#x3D;question_id)</span><br><span class="line">    return render(request, &#39;polls&#x2F;detail.html&#39;, &#123;&#39;question&#39;: question&#125;)</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到404的处理都单独封装了一个方法，django这么处理的原因是为了防止模型层和视图层的耦合，因为404是比较常见的一种错误，而且处理404的判断如果放在了界面层，那么对models的处理就和view层耦合太重。</p>
<p>现在访问：<code>http://localhost:8000/polls</code>就能看到载入模版之后的样子了。</p>
<p><img src="/img/django_01_03.png" alt="add template"></p>
<p>内容页面：</p>
<p><img src="/img/django_01_04.png" alt="details"></p>
<p>注意这里有个细节：</p>
<p>polls/index.html中的a标签的链接我们用了硬编码，为了更好的实现可扩展性，我们将其中的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;polls&#x2F;&#123;&#123; question.id &#125;&#125;&#x2F;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href&#x3D;&quot;&#123;% url &#39;detail&#39; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出来新的写法会去找<code>name</code>属性为<code>ditail</code>的url进行匹配。</p>
<h3 id="form的实现"><a href="#form的实现" class="headerlink" title="form的实现"></a>form的实现</h3><p>修改我们的<br><code>polls/templates/polls/detail.html</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;form action&#x3D;&quot;&#123;% url &#39;polls:vote&#39; question.id %&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;choice&quot; id&#x3D;&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot; value&#x3D;&quot;&#123;&#123; choice.id &#125;&#125;&quot; &#x2F;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot;&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;&#x2F;label&gt;&lt;br &#x2F;&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Vote&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p>view界面加入投票逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import get_object_or_404, render</span><br><span class="line">from django.http import HttpResponseRedirect, HttpResponse</span><br><span class="line">from django.core.urlresolvers import reverse</span><br><span class="line"></span><br><span class="line">from .models import Choice, Question</span><br><span class="line"># ...</span><br><span class="line">def vote(request, question_id):</span><br><span class="line">    question &#x3D; get_object_or_404(Question, pk&#x3D;question_id)</span><br><span class="line">    try:</span><br><span class="line">        selected_choice &#x3D; question.choice_set.get(pk&#x3D;request.POST[&#39;choice&#39;])</span><br><span class="line">    except (KeyError, Choice.DoesNotExist):</span><br><span class="line">        # Redisplay the question voting form.</span><br><span class="line">        return render(request, &#39;polls&#x2F;detail.html&#39;, &#123;</span><br><span class="line">            &#39;question&#39;: question,</span><br><span class="line">            &#39;error_message&#39;: &quot;You didn&#39;t select a choice.&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    else:</span><br><span class="line">        selected_choice.votes +&#x3D; 1</span><br><span class="line">        selected_choice.save()</span><br><span class="line">        # Always return an HttpResponseRedirect after successfully dealing</span><br><span class="line">        # with POST data. This prevents data from being posted twice if a</span><br><span class="line">        # user hits the Back button.</span><br><span class="line">        return HttpResponseRedirect(reverse(&#39;polls:results&#39;, args&#x3D;(question.id,)))from django.shortcuts import get_object_or_404, render</span><br><span class="line">from django.http import HttpResponseRedirect, HttpResponse</span><br><span class="line">from django.core.urlresolvers import reverse</span><br><span class="line"></span><br><span class="line">from .models import Choice, Question</span><br><span class="line"># ...</span><br><span class="line">def vote(request, question_id):</span><br><span class="line">    question &#x3D; get_object_or_404(Question, pk&#x3D;question_id)</span><br><span class="line">    try:</span><br><span class="line">        selected_choice &#x3D; question.choice_set.get(pk&#x3D;request.POST[&#39;choice&#39;])</span><br><span class="line">    except (KeyError, Choice.DoesNotExist):</span><br><span class="line">        # Redisplay the question voting form.</span><br><span class="line">        return render(request, &#39;polls&#x2F;detail.html&#39;, &#123;</span><br><span class="line">            &#39;question&#39;: question,</span><br><span class="line">            &#39;error_message&#39;: &quot;You didn&#39;t select a choice.&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    else:</span><br><span class="line">        selected_choice.votes +&#x3D; 1</span><br><span class="line">        selected_choice.save()</span><br><span class="line">        # Always return an HttpResponseRedirect after successfully dealing</span><br><span class="line">        # with POST data. This prevents data from being posted twice if a</span><br><span class="line">        # user hits the Back button.</span><br><span class="line">        return HttpResponseRedirect(reverse(&#39;polls:results&#39;, args&#x3D;(question.id,)))</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>reverse()方法  用于返回一个url，这里直接返回polls/1/vote/</p>
<p>定义投票的结果页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def results(request, question_id):</span><br><span class="line">    question &#x3D; get_object_or_404(Question, pk&#x3D;question_id)</span><br><span class="line">    return render(request, &#39;polls&#x2F;results.html&#39;, &#123;&#39;question&#39;: question&#125;)</span><br></pre></td></tr></table></figure>
<p>以及模版页面：<br><code>polls/results.html</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href&#x3D;&quot;&#123;% url &#39;polls:detail&#39; question.id %&#125;&quot;&gt;Vote again?&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h3 id="静态文件的加载"><a href="#静态文件的加载" class="headerlink" title="静态文件的加载"></a>静态文件的加载</h3><p>创建一个css文件：<code>polls/static/polls/style.css</code>并写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li a &#123;</span><br><span class="line">    color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在polls/templates/polls/index.html文件中引入这个css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&#123;% static &#39;polls&#x2F;style.css&#39; %&#125;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>接下来添加一个图片：<br><code>polls/static/polls/images/background.gif.</code></p>
<p>修改<code>polls/static/polls/style.css</code>加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background: white url(&quot;images&#x2F;background.gif&quot;) no-repeat right bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可看到执行效果：</p>
<p><img src="/img/django_01_05.png" alt="css"></p>
<h3 id="自定义后台页面"><a href="#自定义后台页面" class="headerlink" title="自定义后台页面"></a>自定义后台页面</h3><p>Django经常被用来开发后台应用，因为它有一个非常强大的，可灵活配置的后台应用。这个admin应用就是<code>settings.py</code>中的<code>INSTALLED_APPS</code>下的<code>django.contrib.admin</code>。</p>
<p>前面我们在polls项目下的admin.py中将我们的<code>Question</code>注册到了admin中，我们在后台页面可以看到了Question表的相关信息。那么如果我们想把<code>Choice</code>的相关信息也显示出来需要怎么处理呢？</p>
<p>有一种做法就是也仿照<code>Question</code>将<code>Choice</code>注册进入admin：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question,Choice</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br><span class="line">admin.site.register(Choice)</span><br></pre></td></tr></table></figure>
<p>但这样并不好，因为Choice和Question存在一对多的外键关联，我们直接显示出来，并不能很好的体现出这层含义。为了解决这个问题，我们可以引入<code>ModelAdmin</code>，将Question注册到一个自定义的<code>ModelAdmin</code>上，定义其内联元素为一个Choice。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from .models import Question,Choice</span><br><span class="line"></span><br><span class="line">class ChoiceInline(admin.StackedInline):</span><br><span class="line">    model &#x3D; Choice</span><br><span class="line">    extra &#x3D; 0</span><br><span class="line"></span><br><span class="line">class QuestionAdmin(admin.ModelAdmin):</span><br><span class="line">    inlines &#x3D; [ChoiceInline]</span><br><span class="line"></span><br><span class="line">admin.site.register(Question,QuestionAdmin)</span><br></pre></td></tr></table></figure>
<p>在Question的详情页面里，我们就可以看到作为内联样式展示的Choices了：</p>
<p><img src="/img/django_01_06.png" alt="内联"></p>
<p>接下来我们可以通过对<code>QuestionAdmin</code>简单的配置，实现一个功能更加强大的后台界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class QuestionAdmin(admin.ModelAdmin):</span><br><span class="line">	# 详情页加入更多字段的显示</span><br><span class="line">    fieldsets &#x3D; [</span><br><span class="line">        (None,               &#123;&#39;fields&#39;: [&#39;question_text&#39;]&#125;),</span><br><span class="line">        (&#39;Date information&#39;, &#123;&#39;fields&#39;: [&#39;pub_date&#39;], &#39;classes&#39;: [&#39;collapse&#39;]&#125;),</span><br><span class="line">    ]</span><br><span class="line">    inlines &#x3D; [ChoiceInline]</span><br><span class="line">    </span><br><span class="line">    # 列表页面加入更多字段的显示</span><br><span class="line">    list_display &#x3D; (&#39;question_text&#39;, &#39;pub_date&#39;, &#39;was_published_recently&#39;)</span><br><span class="line">    </span><br><span class="line">    # 在列表页面右侧加入过滤功能</span><br><span class="line">    list_filter &#x3D; [&#39;pub_date&#39;]</span><br><span class="line">    # 加入搜索功能</span><br><span class="line">    search_fields &#x3D; [&#39;question_text&#39;]</span><br></pre></td></tr></table></figure>
<p>实现效果如下：</p>
<p><img src="/img/django_01_07.png" alt="完整后台"></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记（1）基本操作</title>
    <url>/2016/05/08/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ctrl + c</td>
<td style="text-align:left">结束当前程序</td>
</tr>
<tr>
<td style="text-align:left">ctrl + d</td>
<td style="text-align:left">键盘输入结束或退出终端</td>
</tr>
<tr>
<td style="text-align:left">ctrl + s</td>
<td style="text-align:left">暂停当前程序，暂停后按下任意键恢复运行</td>
</tr>
<tr>
<td style="text-align:left">ctrl + z</td>
<td style="text-align:left">将当前程序放到后台运行，恢复到前台的命令fg</td>
</tr>
<tr>
<td style="text-align:left">ctrl + a</td>
<td style="text-align:left">将光标移至输入行头，相当于Home键</td>
</tr>
<tr>
<td style="text-align:left">ctrl + e</td>
<td style="text-align:left">将光标移至输入行末，相当于End键</td>
</tr>
<tr>
<td style="text-align:left">ctrl + k</td>
<td style="text-align:left">删除从光标所在位置到行末</td>
</tr>
<tr>
<td style="text-align:left">Alt + Backspace</td>
<td style="text-align:left">向前删除一个单词</td>
</tr>
<tr>
<td style="text-align:left">Shift + pgUp</td>
<td style="text-align:left">将终端显示向上滚动</td>
</tr>
<tr>
<td style="text-align:left">Shift + PgDn</td>
<td style="text-align:left">将终端显示向下滚动</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h2><p>shell常用通配符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配0或多个字符</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配任意一个字符</td>
</tr>
<tr>
<td style="text-align:left">[list]</td>
<td style="text-align:left">匹配list中的任意单一字符</td>
</tr>
<tr>
<td style="text-align:left">[!list]</td>
<td style="text-align:left">匹配 除list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td style="text-align:left">[c1-c2]</td>
<td style="text-align:left">匹配c1-c2中的任意单一字符 如：[0-9][a-z]</td>
</tr>
<tr>
<td style="text-align:left">{string1,string2,…}</td>
<td style="text-align:left">匹配string1或string2（或更多）其一字符串</td>
</tr>
<tr>
<td style="text-align:left">{c1..c2}</td>
<td style="text-align:left">匹配c1-c2中全部字符如{1..10}</td>
</tr>
</tbody>
</table>
</div>
<p>通过通配符创建十个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch love_&#123;1..10&#125;_linux.txt</span><br></pre></td></tr></table></figure>
<h2 id="使用man命令来查看帮助文档"><a href="#使用man命令来查看帮助文档" class="headerlink" title="使用man命令来查看帮助文档"></a>使用man命令来查看帮助文档</h2><p>不再赘述</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记（2）用户管理，文件操作，权限管理</title>
    <url>/2016/05/08/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%EF%BC%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="who-命令"><a href="#who-命令" class="headerlink" title="who 命令"></a>who 命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-a</td>
<td style="text-align:left">打印能打印的全部</td>
</tr>
<tr>
<td style="text-align:left">-d</td>
<td style="text-align:left">打印死掉的进程</td>
</tr>
<tr>
<td style="text-align:left">-m</td>
<td style="text-align:left">同am i，mom likes</td>
</tr>
<tr>
<td style="text-align:left">-q</td>
<td style="text-align:left">打印当前登陆用户数及用户名</td>
</tr>
<tr>
<td style="text-align:left">-u</td>
<td style="text-align:left">打印当前登录用户登录信息</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td style="text-align:left">打印运行等级</td>
</tr>
</tbody>
</table>
</div>
<p>查看当前用户信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ who am i</span><br></pre></td></tr></table></figure>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>创建用户需要<code>root</code>权限，这里就需要用到<code>sudo</code>这个命令了，不过使用这个命令有两个大前提：<strong>一是你要知道当前登录用户的密码，二是当前用户必须在<code>sudo</code>用户组</strong>。</p>
<h3 id="su，su-与-sudo"><a href="#su，su-与-sudo" class="headerlink" title="su，su - 与 sudo"></a>su，su - 与 sudo</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">su [user]</td>
<td style="text-align:left">可以切换到用户user，执行时需要输入目标用户的密码。</td>
</tr>
<tr>
<td style="text-align:left">su - [user]</td>
<td style="text-align:left">也是切换用户，同时环境变量也会跟着改变成目标的环境变量。</td>
</tr>
<tr>
<td style="text-align:left">sudo [cmd]</td>
<td style="text-align:left">可以以特权级别运行cmd命令，需要当前用户属于sudo组，且需要输入当前用户密码。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="查看用户组："><a href="#查看用户组：" class="headerlink" title="查看用户组："></a>查看用户组：</h3><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1:"></a>方式1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ groups lijianan</span><br></pre></td></tr></table></figure>
<p>可以看到冒号之前表示用户，冒号之后表示用户所在的组。如果新建用户时不指定用户组的话，默认会自动创建一个与用户名相同的用户组。</p>
<p>这里如果当前用户组不是sudo用户组，却也可以执行sudo命令，可以查看一下/etc/sudoers.d/目录下是否有lijianan文件，如果有，则给lijianan用户赋予了sudo权限。</p>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2:"></a>方式2:</h4><p>查看/etc/group文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;group | sort</span><br></pre></td></tr></table></figure>
<p><code>/etc/group</code> 的内容包括用户组(Group)、用户组口令、GID及该用户组所包含的用户(User)，每个用户组一条记录。<br>格式如下：</p>
<p><code>group_name:password:GID:user_list</code></p>
<h3 id="将其它用户加入sudo用户组："><a href="#将其它用户加入sudo用户组：" class="headerlink" title="将其它用户加入sudo用户组："></a>将其它用户加入sudo用户组：</h3><p>默认情况下新创建的用户是不具有root权限的，也不在sudo用户组，可以让其加入sudo用户组从而获取root权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su -l lilei</span><br><span class="line">$ sudo ls</span><br></pre></td></tr></table></figure>
<p>会提示lilei不在sudoers文件中，意思就是lilei不在sudo用户组中，至于<code>sudoers</code>文件(<code>/etc/sudoers</code>)你现在最好不要动它，操作不慎会导致比较麻烦的后果。</p>
<p>使用<code>usermod</code>命令可以为用户添加用户组，同样使用该命令你必须有<code>root</code>权限，你可以直接使用<code>root</code>用户为其它用户添加用户组，或者用其他已经在sudo用户组的用户使用<code>sudo</code>命令获取权限来执行该命令</p>
<p>这里我使用lijianan用户执行<code>sudo</code>命令将lilei添加到<code>sudo</code>用户组，让它也可以使用<code>sudo</code>命令获得<code>root</code>权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su lijianan</span><br><span class="line">$ groups lilei</span><br><span class="line">$ sudo usermod -G sudo lilei</span><br><span class="line">$ groups lilei</span><br></pre></td></tr></table></figure>
<p>然后你再切换回lilei用户，现在就可以使用sudo获取root权限了。</p>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>删除用户是很简单的事：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo deluser lilei --remove-home</span><br></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="关于文件需要知道的事："><a href="#关于文件需要知道的事：" class="headerlink" title="关于文件需要知道的事："></a>关于文件需要知道的事：</h3><ul>
<li>.代表当前目录</li>
<li>..代表父目录</li>
<li>目录也是一个文件</li>
<li>当前目录下的 . 文件就是当前目录 .. 文件就是父目录。</li>
<li>不过在linux下.开头的文件是隐藏文件</li>
</ul>
<h3 id="关于文件操作，需要记住的命令："><a href="#关于文件操作，需要记住的命令：" class="headerlink" title="关于文件操作，需要记住的命令："></a>关于文件操作，需要记住的命令：</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cd</td>
<td style="text-align:left">进入目录</td>
</tr>
<tr>
<td style="text-align:left">pwd</td>
<td style="text-align:left">获取当前路径</td>
</tr>
<tr>
<td style="text-align:left">touch</td>
<td style="text-align:left">新建空白文件／更新文件时间戳</td>
</tr>
<tr>
<td style="text-align:left">mkdir</td>
<td style="text-align:left">新建目录</td>
</tr>
<tr>
<td style="text-align:left">mkdir -p father/son/grandson</td>
<td style="text-align:left">创建多级目录</td>
</tr>
<tr>
<td style="text-align:left">cp test father/son/grandson</td>
<td style="text-align:left">复制文件到指定目录</td>
</tr>
<tr>
<td style="text-align:left">cp -r father family</td>
<td style="text-align:left">复制目录到指定目录</td>
</tr>
<tr>
<td style="text-align:left">rm test</td>
<td style="text-align:left">删除文件</td>
</tr>
<tr>
<td style="text-align:left">rm -f test</td>
<td style="text-align:left">删除一个文件（忽略提示,比如删除一个只有只读权限的文件）</td>
</tr>
<tr>
<td style="text-align:left">rm -r family</td>
<td style="text-align:left">删除一个目录1</td>
</tr>
<tr>
<td style="text-align:left">mv file1 Documents</td>
<td style="text-align:left">移动文件到指定目录</td>
</tr>
<tr>
<td style="text-align:left">mv file1 file2</td>
<td style="text-align:left">重命名文件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="关于文件查看，需要记住的命令"><a href="#关于文件查看，需要记住的命令" class="headerlink" title="关于文件查看，需要记住的命令"></a>关于文件查看，需要记住的命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cat    file1</td>
<td style="text-align:left">查看文件</td>
</tr>
<tr>
<td style="text-align:left">tac    file1</td>
<td style="text-align:left">倒叙查看文件</td>
</tr>
<tr>
<td style="text-align:left">nl    file1</td>
<td style="text-align:left">查看文件并显示行号</td>
</tr>
<tr>
<td style="text-align:left">more file1</td>
<td style="text-align:left">分页查看文件，Enter向下滚动一行，Space向下滚动一屏，h帮助，q退出</td>
</tr>
<tr>
<td style="text-align:left">head file1</td>
<td style="text-align:left">查看文件前10行</td>
</tr>
<tr>
<td style="text-align:left">tail -n 1 file1</td>
<td style="text-align:left">查看文件第一行</td>
</tr>
<tr>
<td style="text-align:left">tail</td>
<td style="text-align:left">还可以根据参数-f 实现不停地读取某个文件内容并且显示，可以实现日志监控功能。</td>
</tr>
<tr>
<td style="text-align:left">file /bin/ls</td>
<td style="text-align:left">查看文件类型</td>
</tr>
</tbody>
</table>
</div>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h3><p>查看文件权限，使用较长的格式列出文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br></pre></td></tr></table></figure>
<p>从左往右依次列出了 <strong>文件类型</strong>和<strong>权限</strong>，<strong>链接数*</strong>，<strong>*所有者</strong>，<strong>所有用户组</strong>，<strong>文件大小</strong>，<strong>最后修改时间</strong>，<strong>文件名</strong></p>
<p>首先来说说文件类型和权限：</p>
<p>表示文件类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:left">目录</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:left">软链接，类似windows的快捷方式</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:left">块设备</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:left">字符设备</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:left">socket</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:left">管道</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:left">普通文件</td>
</tr>
</tbody>
</table>
</div>
<p>表示权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:left">表示允许读权限</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:left">表示允许写权限</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:left">表示允许执行权限</td>
</tr>
</tbody>
</table>
</div>
<p>表示文件类型和权限的字段，第一位代表文件类型，2到4位表示拥有者权限，5到7位表示所属用户组权限，8到10位表示其他用户权限。</p>
<blockquote>
<p><strong>关于文件权限</strong></p>
<p>一个目录要同时具有读权限和执行权限才可以打开，而一个目录要有写权限才允许在其中创建其他文件，这是因为目录文件实际保存着该目录里面的文件等列表等信息。</p>
<p><strong>链接数</strong></p>
<p>链接到该文件所在的inode结点的文件名数目</p>
</blockquote>
<h3 id="ls常用命令"><a href="#ls常用命令" class="headerlink" title="ls常用命令"></a>ls常用命令</h3><p>显示隐藏文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -A</span><br></pre></td></tr></table></figure>
<p>查看某一个目录的完整属性，而不是现实目录里面的文件属性    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -dl &lt;目录名&gt;</span><br></pre></td></tr></table></figure>
<p>现实所有文件大小，并以普通人类能看懂的方式显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -AsSh</span><br></pre></td></tr></table></figure>
<p>其中s为显示文件大小，S为按文件大小排序。</p>
<h3 id="改变文件的所有者"><a href="#改变文件的所有者" class="headerlink" title="改变文件的所有者"></a>改变文件的所有者</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chown &lt;用户名&gt; &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><h4 id="方式1-二进制数字表示"><a href="#方式1-二进制数字表示" class="headerlink" title="方式1: 二进制数字表示"></a>方式1: 二进制数字表示</h4><p><code>2^0 (1)</code>代表可执行权限，<code>2^1 (2)</code>代表可写权限, <code>2^2 (4)</code>代表可读权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod 700 &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
<h4 id="方式2-加减赋值操作"><a href="#方式2-加减赋值操作" class="headerlink" title="方式2: 加减赋值操作"></a>方式2: 加减赋值操作</h4><p><code>&#39;g&#39;</code>,<code>&#39;o&#39;</code>还有<code>&#39;u&#39;</code>，分别表示<code>group</code>，<code>others</code>，<code>user</code>,<code>&#39;+&#39;</code>，<code>&#39;-&#39;</code>就分别表示增加和去掉相应的权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod go-rw &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记（3）环境变量与文件查找</title>
    <url>/2016/05/09/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="环境变量的声明"><a href="#环境变量的声明" class="headerlink" title="环境变量的声明"></a>环境变量的声明</h3><p>变量是不用声明直接使用即可创建，创建一个指定类型的变量时，可以使用<code>declare</code>来声明变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare tmp</span><br><span class="line">tmp&#x3D;dennylee1991</span><br><span class="line">echo $tmp</span><br></pre></td></tr></table></figure>
<h3 id="环境变量的原理及作用域"><a href="#环境变量的原理及作用域" class="headerlink" title="环境变量的原理及作用域"></a>环境变量的原理及作用域</h3><p>shell的环境变量作用于自身和它的子进程。在unix和类unix系统当中，每个子进程都有其各自的环境变量设置，且默认情况下，<br>当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。</p>
<p>shell程序也作为一个进程运行在操作系统之上，而我们在shell中运行的大部分命令都将以shell的子进程的方式运行。</p>
<p>以下三个命令用于打印相关环境变量，区别在于涉及的是不同范围的环境变量</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:left">显示当前shell所有环境变量，包括其内建环境变量，用户自定义变量，以及导出的环境变量</td>
</tr>
<tr>
<td style="text-align:left">env</td>
<td style="text-align:left">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</td>
</tr>
<tr>
<td style="text-align:left">export</td>
<td style="text-align:left">显示从shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量</td>
</tr>
</tbody>
</table>
</div>
<p>简单的说 set 包涵 env 包涵 export</p>
<p>更直观的，可以使用<code>vimdiff</code>工具比较三者值的不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp&#x3D;dannylee</span><br><span class="line">export temp_env&#x3D;dannylee</span><br><span class="line">env|sort&gt;env.txt</span><br><span class="line">export|sort&gt;export.txt</span><br><span class="line">set|sort&gt;set.txt</span><br></pre></td></tr></table></figure>
<p>上述操作将命令输出通过管道<code>|</code>使用<code>sort</code>命令排序，再重定向到对应文本文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimdiff env.txt export.txt set.txt</span><br></pre></td></tr></table></figure>
<p>使用<code>vimdiff</code>工具比较导出的几个文件的内容。</p>
<h3 id="将自己的脚本添加到环境变量－命令的查找路径与顺序"><a href="#将自己的脚本添加到环境变量－命令的查找路径与顺序" class="headerlink" title="将自己的脚本添加到环境变量－命令的查找路径与顺序"></a>将自己的脚本添加到环境变量－命令的查找路径与顺序</h3><p><code>shell</code>中之所以能执行命令，是通过环境变量<code>PATH</code>来进行搜索的。</p>
<p>当我们在<code>shell</code>中执行一个命令时，系统就会按照<code>PATH</code>中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。</p>
<p>接下来创建一个<code>shell</code>脚本以及<code>c</code>程序，并配置到环境变量中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim hello_shell.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;zsh</span><br><span class="line"></span><br><span class="line">for((i&#x3D;0; i&lt;10; i++));do</span><br><span class="line">	echo &quot;hello shell&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>为文件添加可执行权限:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod 755 hello_shell.sh</span><br></pre></td></tr></table></figure>
<p>创建一个c程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim hello_world.c</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;hello world!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc</code>编译生成可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o hello_world hello_world.c</span><br></pre></td></tr></table></figure>
<p><code>gcc</code>生成二进制文件默认具有可执行权限，不需要更改权限。</p>
<p>在<code>home</code>目录下创建一个<code>mybin</code>目录，并且将上面两个可执行文件放入<code>mybin</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir mybin</span><br><span class="line">$ mv hello_shell.sh hello_world mybin&#x2F;</span><br></pre></td></tr></table></figure>
<p>将可执行文件添加到环境变量中：</p>
<h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1:"></a>方式1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ PATH&#x3D;$PATH:&#x2F;home&#x2F;lijianan&#x2F;mybin</span><br></pre></td></tr></table></figure>
<p>记得这里要写绝对路径。但是这种写法只在当前shell有效，一旦退出终端，就会失效。</p>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2:"></a>方式2:</h4><p>每个用户的<code>home</code>目录中有一个<code>Shell</code>每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等待。<br><code>zsh</code>的配置文件是<code>.zshrc</code>,相应<code>bash</code>的配置文件为<code>.bashrc</code>。它们在<code>etc</code>下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。</p>
<p>我们可以简单的使用下面的命令直接添加内容到<code>.zshrc</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;PATH&#x3D;$PATH:&#x2F;home&#x2F;lijianan&#x2F;mybin&quot; &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：上述命令中<code>&gt;&gt;</code>表示将标准输出以<strong>追加到</strong>的方式重定向到一个文件中，注意前面用到的<code>&gt;</code>是以<strong>覆盖到</strong>方式重定向到一个文件中，使用时要注意辨别。</p>
<h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><p>删除变量可以使用<code>unset</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unset temp</span><br></pre></td></tr></table></figure>
<h3 id="让环境变量立刻生效"><a href="#让环境变量立刻生效" class="headerlink" title="让环境变量立刻生效"></a>让环境变量立刻生效</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source .zshrc</span><br></pre></td></tr></table></figure>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p>四个常用指令:</p>
<p>whereis, locate, which, find.</p>
<h3 id="wiereis"><a href="#wiereis" class="headerlink" title="wiereis"></a>wiereis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ whereis who</span><br></pre></td></tr></table></figure>
<p><code>whereis</code>只能搜索二进制文件<code>(-b)</code>，<code>man</code>帮助文件<code>(-m)</code>和源代码文件<code>(-s)</code>，如果想获得更全面的结果，需要使用<code>locate</code>命令</p>
<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ locate &#x2F;etc&#x2F;sh</span><br></pre></td></tr></table></figure>
<p><code>locate</code>用来查找指定目录下的不同文件类型，如上所示查找<code>/etc</code>下所有以<code>sh</code>开头的文件<strong>（它不仅仅是在<code>etc</code>目录下查找，而且会递归子目录进行查找）</strong></p>
<p>查找<code>/usr/share/</code>下所有<code>jpg</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ locate &#x2F;usr&#x2F;share&#x2F;\*.jpg</span><br></pre></td></tr></table></figure>
<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p><code>which</code>只从<code>PATH</code>环境变量指定的路径中去搜索命令，是<code>shell</code>内建的一个命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ which man</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code>是最强大的了，不仅可以通过文件类型、文件名查找，而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ~ -mtime 0	#列出用户home目录中，当天（24小时之内）有改动的文件</span><br><span class="line">$ find ~ -newer &#x2F;home&#x2F;shiyanlou&#x2F;Code 	#列出用户home目录下比Code文件夹新的文件</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>运行“数字雨”</p>
<p><code>ubuntu</code>安装<code>cmatrix</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update;sudo aptget install cmatrix</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmatrix</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记（4）文件打包与压缩</title>
    <url>/2016/05/09/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="使用zip打包文件夹"><a href="#使用zip打包文件夹" class="headerlink" title="使用zip打包文件夹"></a>使用zip打包文件夹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zip -r -q -o lijianan.zip &#x2F;home&#x2F;lijianan</span><br><span class="line">$ du -h lijianan.zip</span><br><span class="line">$ file lijianan.zip</span><br></pre></td></tr></table></figure>
<p>上面命令将<code>lijianan</code>的<code>home</code>目录打包成一个文件，并查看了打包后文件的大小和类型。</p>
<p>第一行命令中，<code>-r</code>参数表示递归打包包含子目录全部内容，<code>-q</code>参数表示为安静模式，即不向屏幕输出信息,<code>-o</code>表示输出文件，需在其后紧跟打包输出文件名。</p>
<p>后面使用<code>du</code>命令查看打包后文件的大小.</p>
<p>设置压缩级别为<code>9</code>和<code>1</code>（<code>9</code>最大，<code>1</code>最小），重新打包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zip -r -9 -q -o lijianan_9.zip &#x2F;home&#x2F;lijianan -x ~&#x2F;*.zip</span><br><span class="line">$ zip -r -1 -q -o lijianan_1.zip &#x2F;home&#x2F;lijianan -x ~&#x2F;*.zip</span><br></pre></td></tr></table></figure>
<p>这里添加了一个参数用于设置压缩级别<code>-[1-9]</code>，<code>1</code>表示最快压缩但体积大，<code>9</code>表示体积最小但耗时最久。</p>
<p>最后那个<code>-x</code>是为了排除我们上一次创建的<code>zip</code>文件，否则又会被打包进这一次的压缩文件中，<strong>注意：这里压缩文件存放路径只能使用绝对路径，否则不起作用。</strong></p>
<p>我们用<code>du</code>命令来查看几种压缩的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ du -h -d 0 *.zip ~ | sort</span><br></pre></td></tr></table></figure>
<p>这里<code>-h</code>是<code>human-readable</code>人类可读的模式。<code>-d</code>是<code>max-depth</code>所查看文件的深度.这里<code>-d 0</code>就是指在当前这一层目录下。</p>
<h2 id="创建加密zip包"><a href="#创建加密zip包" class="headerlink" title="创建加密zip包"></a>创建加密zip包</h2><p>使用<code>-e</code>参数可以创建加密压缩包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zip -r -e -o lijianan_encryption.zip &#x2F;home&#x2F;lijianan</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>由于在<code>linux</code>和<code>windows</code>上对换行符处理的不同，想要做到<code>linux</code>上创建的<code>zip</code>文件在<code>windows</code>上解压后可以正常显示，那么还需要做一些修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zip -r -l -o lijianan.zip &#x2F;home&#x2F;lijianan</span><br></pre></td></tr></table></figure>
<p>需要加上<code>-l</code>参数将<code>LF</code>(<code>linux</code>换行)转换为<code>CR+LF</code>(<code>windows</code>换行)。</p>
<h2 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h2><p>将<code>lijianan.zip</code>解压到当前目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip lijianan.zip</span><br></pre></td></tr></table></figure>
<p>使用安静模式，将文件解压到指定目录，如果指定目录不存在，将会自动创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip -q lijianan.zip -d ziptest</span><br></pre></td></tr></table></figure>
<p>如果不想解压缩，只想查看压缩包的内容，可以使用<code>-l</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip -l lijianan.zip</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>使用unzip解压文件时，同样需要考虑兼容问题。这里我们需要考虑的是中文编码问题。通常在<code>windows</code>上创建的压缩文件，如果包涵有中文的文档或者以中文作为文件名的文件时默认会采用<code>GBK</code>或其它编码，而<code>Linux</code>上面默认使用的是<code>UTF-8</code>编码，如果不做任何处理，直接解压可能会出现中文乱码的问题，为了解决这个问题，我们可以在解压时指定编码类型。</p>
<p>使用 <code>-O</code>(不是数字0，是<code>o</code>的大写)参数指定编码类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip -O GBK 中文压缩文件.zip</span><br></pre></td></tr></table></figure>
<h2 id="rar打包压缩命令"><a href="#rar打包压缩命令" class="headerlink" title="rar打包压缩命令"></a>rar打包压缩命令</h2><p>安装<code>rar</code>和<code>unrar</code>工具：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install rar unrar</span><br></pre></td></tr></table></figure>
<p>使用<code>rar</code>压缩:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rar a lijianan.rar .</span><br></pre></td></tr></table></figure>
<p>上面的命令使用<code>a</code>参数添加一个目录.到一个归档文件中，如果改文件不存在就会自动创建。</p>
<p><strong>注意：</strong><code>rar</code>的命令没有<code>-</code>，如果加上会报错。</p>
<p>从指定压缩包文件中删除某个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rar d lijianan.rar .zshrc</span><br></pre></td></tr></table></figure>
<p>查看不解压文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rar l lijianan.rar</span><br></pre></td></tr></table></figure>
<p>使用<code>unrar</code>解压<code>rar</code>文件：</p>
<p>全路径解压：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unrar x lijianan.rar</span><br></pre></td></tr></table></figure>
<p>去掉路径解压：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir tmp</span><br><span class="line">$ unrar e lijianan.rar tmp&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h2><p>在<code>Linux</code>上更常用的是<code>tar</code>工具，<code>tar</code>原本只是一个打包工具，只是同时还实现了对7z，gzip，xz，bzip2等工具的支持。<code>tar</code>的解压和压缩都是同一个命令，只需要参数不同，使用比较方便。</p>
<p>不压缩只打包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar cf lijianan.tar ~</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>-c</code>表示创建一个<code>tar</code>包文件，<code>-f</code>用于指定创建的文件名，注意：文件名必须紧跟在 <code>-f</code>参数后。还可以加上<code>-v</code>参数以可视的方式输出打包文件。上面会自动取掉表示绝对路径的<code>/</code>，你也可以使用<code>-P</code>保留绝对路径符。</p>
<p>解包一个文件(<code>-x</code>参数)到指定路径的已存在目录(<code>-C</code>参数)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir tardir</span><br><span class="line">$ tar -xf lijianan.tar -C tardir</span><br></pre></td></tr></table></figure>
<p>只查看不解包<code>-t</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -tf lijianan.tar</span><br></pre></td></tr></table></figure>
<p>保留文件属性和跟随链接（符号链接或软连接），有时候我们使用<code>tar</code>备份文档当你在其它主机还原时希望保留文件的属性(<code>-p</code>参数)和备份链接指向的源文件而不是链接本身(<code>-h</code>参数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -cphf etc.tar &#x2F;etc</span><br></pre></td></tr></table></figure>
<p>对于创建不同的压缩格式文件，对于<code>tar</code>来说时相当简单的，需要的只是换一个参数，这里我们使用<code>gzip</code>工具创建<code>*.tar.gz</code>文件为例来说明。</p>
<p>我们只需要在创建<code>tar</code>文件的基础上添加<code>-z</code>参数，使用<code>gzip</code>来压缩文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -czf lijianan.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压<code>*.tar.gz</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar -xzf lijianan.tar.gz</span><br></pre></td></tr></table></figure>
<p>现在外面要使用其它的压缩工具创建或解压相应的文件只需要更改一个参数即可：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">压缩文件格式</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*.tar.gz</td>
<td style="text-align:left">-z</td>
</tr>
<tr>
<td style="text-align:center">*.tar.xz</td>
<td style="text-align:left">-J</td>
</tr>
<tr>
<td style="text-align:center">*.tar.bz2</td>
<td style="text-align:left">-j</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>NumPy入门教程</title>
    <url>/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下<a href="http://docs.python.org/tut/">这份教程</a>。</p>
<p>如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅<a href="http://scipy.org/install.html">http://scipy.org/install.html</a>。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组来索引。在NumPy中维度称之为<strong><em>axis（轴）</em></strong>。</p>
<p>例如，在3D空间中的一个坐标点<code>[1, 2, 1]</code>拥有一个axis。这个axis拥有3个元素，所以我们说它的长度是3。在下面的例子中，有2个axis。第一个axis的长度是2，第二个axis的长度是3。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[ <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>[[1.0, 0.0, 0.0], [0.0, 1.0, 2.0]]
</code></pre><p>NumPy的数组class称之为<code>ndarray</code>。它还有另外一个别名：<code>array</code>。注意<code>numpy.array</code>与标准Python库中的<code>array.array</code>不一样，标准库中的<code>array</code>只可以操作以为数组，并且只能提供少量的方法。<code>ndarray</code>更重要的一些属性如下：</p>
<p><strong>ndarray.ndim</strong></p>
<pre><code>数组的axis(维度)数量
</code></pre><p><strong>ndarray.shape</strong></p>
<pre><code>数组的维度。这是一个整数类型的元组，指示了数组在每个维度下的尺寸信息。对于一个n行m列的矩阵来说，它的`shape`是`(n,m)`。因此`shape`元组的长度，也是axis的数量，即`ndim`。
</code></pre><p><strong>ndarray.size</strong></p>
<pre><code>数组的元素总数。值等于`shape`中的元素的乘积。
</code></pre><p><strong>ndarray.dtype</strong></p>
<pre><code>一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外，也可以使用NumPy自己提供的一些类型。例如`numpy.int32`,`numpy.int16`和`numpy.float64`。
</code></pre><p><strong>ndarray.itemsize</strong></p>
<pre><code>数组中每个元素占用的bytes大小。例如，一个数组的元素类型为`float64`，它的`itemsize`就是8(=64/8)，另一个数组的元素类型为`complex32`的`itemsize`值为4(=32/8)。这个值相当于`ndarray.dtype.itemsize`。
</code></pre><p><strong>ndarray.data</strong></p>
<pre><code>该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引来访问数组中的元素。
</code></pre><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 5)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.ndim</span><br></pre></td></tr></table></figure>
<pre><code>2
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;int64&#39;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.itemsize</span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.size</span><br></pre></td></tr></table></figure>
<pre><code>15
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>numpy.ndarray
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([6, 7, 8])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>numpy.ndarray
</code></pre><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><p>有几种可以创建数组的方式。</p>
<p>例如，你可以通过使用<code>array</code>方法，从一个标准的Python列表或元组来创建一个numpy数组。数组的类型由序列中元素的类型自动推导得出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 3, 4])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.dtype</span><br></pre></td></tr></table></figure>
<pre><code>dtype(&#39;int64&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</span><br><span class="line">b.dtype</span><br></pre></td></tr></table></figure>
<pre><code>dtype(&#39;float64&#39;)
</code></pre><p>在调用<code>array</code>方法来创建数组时，有一种常见的错误，就是在方法中传入了多个数字，而不是通过传入一个包含一组数字的list作为参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.array(1,2,3,4)   # WRONG</span><br><span class="line">a &#x3D; np.array([1,2,3,4]) # RIGHT</span><br></pre></td></tr></table></figure>
<p><code>array</code>函数将序列的序列转换为二维数组，将序列的序列的序列转换成3维数组，等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.array([(<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])
</code></pre><p>数组的类型也可以在创建的时候，显式的指定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=<span class="built_in">complex</span>)</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])
</code></pre><p>通常，数组的元素在初始状态下是未知的，但尺寸已知。因此，NumPy提供了一些方法来创建以初始化占位符填充的数组。这最大限度地减少了增加数组的开销，这是一项昂贵的操作。</p>
<p>方法<code>zeros</code>创建一个全部由0填充的数组，方法<code>ones</code>创建一个全部由1填充的数组，方法<code>empty</code>创建了一个全部由随机的数字填充的数组，随机数的值取决于内存当前的状态。默认情况下，创建出来的数组类型为<code>folat64</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dtype=np.int16) <span class="comment"># dtype可以被指定</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int16)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 未初始化，输出可能不同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
</code></pre><p>为了创建数字序列，NumPy提供了一个类似于<code>range</code>的返回数组而不是列表的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([10, 15, 20, 25])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span>) <span class="comment"># 可以接受float类型的参数</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
</code></pre><p>当<code>arange</code>与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数<code>linspace</code>来接收我们想要的元素数量作为参数，而不是步长：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)  <span class="comment"># 创建9个数字，均匀分布在0到2之间</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linspace( <span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</span><br><span class="line">f = np.sin(x)</span><br></pre></td></tr></table></figure>
<h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p>当你打印一个数组时，NumPy以一种类似嵌套列表的形式来展示，同时具有以下布局：</p>
<ul>
<li>最后一个axis从左向右打印</li>
<li>倒数第二个axis从上到下打印</li>
<li>其余的也是从上到下打印的，每个切片与下一个由空行分开。</li>
</ul>
<p>然后将一维数组打印为行，将二维数组作为矩阵，将三维数组作为矩阵列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># 一维数组</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)  <span class="comment"># 二维数组</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 三维数组</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
</code></pre><p>如果数组太大而无法打印，NumPy将自动跳过数组的中心部分并仅打印角点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(np.arange(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[   0    1    2 ..., 9997 9998 9999]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[   0    1    2 ...,   97   98   99]
 [ 100  101  102 ...,  197  198  199]
 [ 200  201  202 ...,  297  298  299]
 ..., 
 [9700 9701 9702 ..., 9797 9798 9799]
 [9800 9801 9802 ..., 9897 9898 9899]
 [9900 9901 9902 ..., 9997 9998 9999]]
</code></pre><p>要禁用此行为并强制NumPy打印整个数组，可以使用<code>set_printoptions</code>更改打印选项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.set_printoptions(threshold=np.nan)</span><br></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>数组上的算术运算符应用于元素。一个新的数组被创建并填充结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a-b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>array([20, 29, 38, 47])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b**<span class="number">2</span></span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 4, 9])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>*np.sin(a)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a&lt;<span class="number">35</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True, False, False], dtype=bool)
</code></pre><p>不像其他的矩阵语言那样，<code>*</code>操作符在NumPy中是元素间的乘法。矩阵乘法可以使用<code>dot</code>方法来实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">A*B    <span class="comment"># 元素间的乘积</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[2, 0],
       [0, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.dot(B)   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[5, 4],
       [3, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.dot(A, B) <span class="comment"># 矩阵乘法的另一种实现</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[5, 4],
       [3, 4]])
</code></pre><p>一些例如<code>+=</code>和<code>-=</code>的操作符，实现的方式是通过修改现有的矩阵而不是创建新的矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a *= <span class="number">3</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[3, 3, 3],
       [3, 3, 3]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b += a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 3.05432455,  3.59941571,  3.65058751],
       [ 3.85091779,  3.45890823,  3.55943444]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a += b <span class="comment"># b 不会自动的转型成为 integer 类型</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-87-3054fce39e6f&gt; in &lt;module&gt;()
----&gt; 1 a += b


TypeError: Cannot cast ufunc add output from dtype(&#39;float64&#39;) to dtype(&#39;int64&#39;) with casting rule &#39;same_kind&#39;
</code></pre><p>在使用不同类型的数组时，结果数组的类型对应于更一般或精确的数组（称为向上转型）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.ones(<span class="number">3</span>, dtype=np.int32)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, pi, <span class="number">3</span>)</span><br><span class="line">b.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;float64&#39;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a+b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>array([ 1.        ,  2.57079633,  4.14159265])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;float64&#39;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = np.exp(c*<span class="number">1j</span>)</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;complex128&#39;
</code></pre><p>许多一元运算，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法来实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.48681264,  0.52685408,  0.53980305],
       [ 0.27958753,  0.55125855,  0.70834892]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>3.0926647737313067
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>
<pre><code>0.27958753466020847
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<pre><code>0.70834891569018965
</code></pre><p>默认情况下，这些操作适用于数组，就好像它是数字列表一样，无论其形状如何。但是，通过指定<code>axis</code>参数，可以沿着数组的指定轴(axis)应用操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">sum</span>(axis=<span class="number">0</span>)    <span class="comment"># 每一列的和</span></span><br></pre></td></tr></table></figure>
<pre><code>array([12, 15, 18, 21])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.<span class="built_in">min</span>(axis=<span class="number">1</span>)    <span class="comment"># 每一行的最小值</span></span><br></pre></td></tr></table></figure>
<pre><code>array([0, 4, 8])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.cumsum(axis=<span class="number">1</span>)   <span class="comment"># 每行的累加值</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]])
</code></pre><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>NumPy提供了一些常见的数学运算方法，例如sin，cos和exp。在NumPy中，这些方法被称作”通用方法”(<code>ufunc</code>)。在NumPy中，这些方法操作在数组中的每个元素上，产生一个数组作为输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = np.arange(<span class="number">3</span>)</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.exp(B)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 1.        ,  2.71828183,  7.3890561 ])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.sqrt(B)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.        ,  1.        ,  1.41421356])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C = np.array([<span class="number">2.</span>, -<span class="number">1.</span>, <span class="number">4.</span>])</span><br><span class="line">np.add(B, C)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 2.,  0.,  6.])
</code></pre><h4 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h4><p><strong>一维</strong>数组可以像Python中的list或其他序列一样进行索引、切片和迭代操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)**<span class="number">3</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([ 8, 27, 64])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:<span class="number">6</span>:<span class="number">2</span>] = -<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i**(<span class="number">1</span>/<span class="number">3.</span>))</span><br></pre></td></tr></table></figure>
<pre><code>nan
1.0
nan
3.0
nan
5.0
6.0
7.0
8.0
9.0


/usr/local/Homebrew/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power
</code></pre><p><strong>多维</strong>数组每个轴（axis）都有一个索引。这些索引以逗号分隔的元组给出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>*x + y</span><br><span class="line"></span><br><span class="line">b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<pre><code>23
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>] <span class="comment"># 输出第2列的每一行的元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 1, 11, 21, 31, 41])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[:, <span class="number">1</span>] <span class="comment"># 与上一步操作等价</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 1, 11, 21, 31, 41])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">1</span>:<span class="number">3</span>, :] <span class="comment"># 输出第2和第3行的每个列元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[10, 11, 12, 13],
       [20, 21, 22, 23]])
</code></pre><p>当提供的索引数量少于axis的数量时，缺失的索引被视为完整的切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[-<span class="number">1</span>] <span class="comment"># 输出最后一行。相当于 b[-1,:]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([40, 41, 42, 43])
</code></pre><p>表达式<code>b[i]</code>的这种表示形式，意味着在<code>i</code>后面还有多个<code>:</code>，<code>:</code>的数量取决于剩余的axis数量。NumPy也允许你使用<code>...</code>来表示这一形式：<code>b[i,...]</code>。</p>
<p><strong>点</strong>(<code>...</code>)表示产生完整索引元组所需要的冒号。例如，如果<code>x</code>是一个5轴数组，那么：</p>
<ul>
<li><code>x[1,2,...]</code>等价于<code>x[1,2,:,:,:]</code>，</li>
<li><code>x[...,3]</code>等价于<code>x[:,:,:,:,3]</code>，</li>
<li><code>x[4,...,5,:]</code>等价于<code>x[4,:,:,5,:]</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个3D数组（由两个2D数组粘贴而成）</span></span><br><span class="line">c = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line">              [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line">              [<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]</span><br><span class="line">             ])</span><br><span class="line">c.shape</span><br></pre></td></tr></table></figure>
<pre><code>(2, 2, 3)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="number">1</span>,...]  <span class="comment"># 相当于 c[1,:,:] 或 c[1]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[100, 101, 102],
       [110, 112, 113]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[...,<span class="number">2</span>]  <span class="comment"># 相当于 c[:,:,2]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[  2,  13],
       [102, 113]])
</code></pre><p><strong>迭代</strong>多维数组是相对于第一个axis完成的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
</code></pre><p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组中所有元素的迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line">    print(element)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
10
11
12
13
20
21
22
23
30
31
32
33
40
41
42
43
</code></pre><h3 id="Shape操作"><a href="#Shape操作" class="headerlink" title="Shape操作"></a>Shape操作</h3><h4 id="改变一个array的shape"><a href="#改变一个array的shape" class="headerlink" title="改变一个array的shape"></a>改变一个array的shape</h4><p>一个数组的形状由这个数组每个轴上的元素数量给出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><p>数组的形状可以通过各种命令进行更改。请注意，以下三个命令都返回一个修改后的数组，但都没有改变原数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.ravel()  <span class="comment"># 返回展开的数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 8.,  3.,  6.,  4.,  7.,  5.,  7.,  7.,  3.,  1.,  8.,  8.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.reshape(<span class="number">6</span>,<span class="number">2</span>)  <span class="comment"># 返回一个改变了shape的数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.],
       [ 6.,  4.],
       [ 7.,  5.],
       [ 7.,  7.],
       [ 3.,  1.],
       [ 8.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.T  <span class="comment"># 返回数组的转置</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  7.,  3.],
       [ 3.,  5.,  1.],
       [ 6.,  7.,  8.],
       [ 4.,  7.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.T.shape</span><br></pre></td></tr></table></figure>
<pre><code>(4, 3)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><p>由ravel()产生的数组元素的顺序通常是”C-style”的，即最右边的索引“变化最快”，因此[0,0]之后的元素是[0,1]。如果一个数组变形为其他形状，数组再次被视为”C-style”。NumPy通常创建按次顺序存储的数组，因此<code>ravel()</code>通常不需要复制数组，但如果数组是通过对另一个数组进行切片操作，或者使用不寻常的方式创建的，则可能需要复制它。函数<code>ravel()</code>和<code>reshape()</code>也可以通过使用可选参数来使用FORTRAN-style的数组，其中最左侧的索引更改速度最快。</p>
<p><code>reshape</code>方法返回的结果是一个变形后的数组，而<code>ndarray.resize</code>方法会更改数组本身的形状：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.resize((<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.,  7.,  5.],
       [ 7.,  7.,  3.,  1.,  8.,  8.]])
</code></pre><p>如果在reshape操作中将尺寸参数传入-1，则会自动计算这一位置的尺寸：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre><h4 id="将不同的数组粘贴起来"><a href="#将不同的数组粘贴起来" class="headerlink" title="将不同的数组粘贴起来"></a>将不同的数组粘贴起来</h4><p>多个数组可以按照不同的axis来粘贴起来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.],
       [ 8.,  6.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5.,  3.],
       [ 0.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.],
       [ 8.,  6.],
       [ 5.,  3.],
       [ 0.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.hstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.,  5.,  3.],
       [ 8.,  6.,  0.,  4.]])
</code></pre><p>函数<code>column_stack</code>将1D数组作为列堆叠到2D数组中。它相当于仅用于2D数组的<code>hstack</code>操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> newaxis</span><br><span class="line">np.column_stack((a,b))   <span class="comment"># 仅作用于2D数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.,  5.,  3.],
       [ 8.,  6.,  0.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">4.</span>, <span class="number">2.</span>])</span><br><span class="line">b = np.array([<span class="number">3.</span>, <span class="number">8.</span>])</span><br><span class="line">np.column_stack((a,b))  <span class="comment"># 返回一个2D数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.hstack((a,b))  <span class="comment"># 得到不同的结果</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 4.,  2.,  3.,  8.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:,newaxis]  <span class="comment"># 这将得到一个2D列向量</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.],
       [ 2.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.column_stack((a[:,newaxis],b[:,newaxis]))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.hstack((a[:,newaxis],b[:,newaxis]))  <span class="comment"># 结果是一样的</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre><p>另一方面，函数<code>row_stack</code>相当于对任何数组进行<code>vstack</code>操作。一般情况下，对于具有两个以上维度的数组，<code>hstack</code>操作沿着它的第二个axis进行堆叠，<code>vstack</code>沿着它的第一个axis堆叠，<code>concatenate</code>沿着指定axis的方向进度堆叠。</p>
<p><strong>注意</strong></p>
<p>在复杂的情况下，<code>r_</code>和<code>c_</code>可用于通过沿着一个轴堆积数字来创建数组。他们允许使用表示范围的<code>:</code>操作符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 0, 4])
</code></pre><p>当使用数组作为参数时，<code>r_</code>和<code>c_</code>与默认行为的<code>vstack</code>和<code>hstack</code>类似，可以通过可选参数指定所要连接的轴的序号。</p>
<h4 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h4><p>使用<code>hsplit</code>，可以沿着水平轴来切割数组，或者通过指定返回的数组的形状来切割数组，或者通过指定需要分割的列来分割数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.,  3.,  1.,  2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],
       [ 5.,  1.,  1.,  2.,  9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.hsplit(a,<span class="number">3</span>)  <span class="comment"># 将a切分成3份</span></span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 4.,  3.,  3.,  1.],
        [ 5.,  1.,  1.,  2.]]), array([[ 2.,  5.,  2.,  5.],
        [ 9.,  6.,  5.,  5.]]), array([[ 5.,  8.,  2.,  2.],
        [ 0.,  8.,  8.,  7.]])]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 沿着第3和第4列来切分数组</span></span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 4.,  3.,  3.],
        [ 5.,  1.,  1.]]), array([[ 1.],
        [ 2.]]), array([[ 2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],
        [ 9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])]
</code></pre><p><code>vspilt</code>沿着垂直轴进行分割，<code>array_split</code>允许指定沿着那个轴来进行分割。</p>
<h3 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h3><p>当操作一个数组时，它们的数据有时会被复制到一个新的数组中，有时则不会。这通常会让新手感到困惑。下面是3个例子：</p>
<h4 id="完全没有复制"><a href="#完全没有复制" class="headerlink" title="完全没有复制"></a>完全没有复制</h4><p>简单的赋值不会复制数组对象或数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a    <span class="comment"># 没有新的对象被创建</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># a 和 b 是同一个ndarray对象的两个名字</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.shape = <span class="number">3</span>,<span class="number">4</span>  <span class="comment"># 改变a的shape</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><p>Python将可变对象作为引用传递，所以函数调用不会执行复制操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="built_in">id</span>(x))</span><br><span class="line">    </span><br><span class="line"><span class="built_in">id</span>(a)      <span class="comment"># id 是一个对象的唯一标识</span></span><br></pre></td></tr></table></figure>
<pre><code>4449897488
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<pre><code>4449897488
</code></pre><h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>不同的数组对象可以共享相同的数据。<code>view</code>函数创建一个新的数组对象，但它和原数组持有相同的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = a.view()</span><br><span class="line">c <span class="keyword">is</span> a</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.base <span class="keyword">is</span> a  <span class="comment"># c 是 一个a数据所创建出来的视图</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.flags.owndata</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.shape = <span class="number">2</span>,<span class="number">6</span>  <span class="comment"># a的shape并不发生改变</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>  <span class="comment"># a的数据发生改变</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])
</code></pre><p>对一个数组进行切片操作，返回它的一个视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = a[ : , <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 也可以被写作 s = a[:,1:3]</span></span><br><span class="line">s[:] = <span class="number">10</span>  <span class="comment"># s[:] 是一个s的视图。注意这里 s = 10 和 s[:] = 10 的区别</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>copy</code>方法可以构造数组以及数据的完整副本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = a.copy()    <span class="comment"># 一个由新数据构成的新的数组对象被创建了</span></span><br><span class="line">d <span class="keyword">is</span> a</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d.base <span class="keyword">is</span> a     <span class="comment"># d 与 a 不共享任何东西</span></span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
</code></pre><h4 id="方法预览"><a href="#方法预览" class="headerlink" title="方法预览"></a>方法预览</h4><p>这里有一个NumPy中各种类型的比较有用的方法列表。</p>
<ul>
<li><p><strong>数组创建</strong></p>
<p><code>arange</code>,<code>array</code>,<code>copy</code>,<code>empty</code>,<code>empty_like</code>,<code>eye</code>,<code>fromfile</code>,<code>fromfunction</code>,<code>identity</code>,<code>linspace</code>,<code>logspace</code>,<code>mgrid</code>,<code>ogrid</code>,<code>ones</code>,<code>ones_like</code>,<code>zeros</code>,<code>zeros_like</code></p>
</li>
<li><p><strong>转换</strong></p>
<p>  <code>ndarray.astype</code>,<code>atleast_1d</code>,<code>atleast_2d</code>,<code>atleast_3d</code>,<code>mat</code></p>
</li>
<li><p><strong>手法</strong></p>
<p>  <code>array_split</code>, <code>column_stack</code>, <code>concatenate</code>, <code>diagonal</code>, <code>dsplit, dstack</code>, <code>hsplit</code>, <code>hstack</code>, <code>ndarray.item</code>, <code>newaxis</code>, <code>ravel</code>, <code>repeat</code>, <code>reshape</code>, <code>resize</code>, <code>squeeze</code>, <code>swapaxes</code>, <code>take</code>, <code>transpose</code>, <code>vsplit</code>, <code>vstack</code></p>
</li>
<li><p><strong>问题</strong></p>
<p>  <code>all</code>, <code>any</code>, <code>nonzero</code>, <code>where</code></p>
</li>
<li><p><strong>排序</strong></p>
<p>  <code>argmax</code>, <code>argmin</code>, <code>argsort</code>, <code>max</code>, <code>min</code>, <code>ptp</code>, <code>searchsorted</code>, <code>sort</code></p>
</li>
<li><p><strong>操作</strong></p>
<p>  <code>choose</code>, <code>compress</code>, <code>cumprod</code>, <code>cumsum</code>, <code>inner</code>, <code>ndarray.fill</code>, <code>imag</code>, <code>prod</code>, <code>put</code>, <code>putmask</code>, <code>real</code>, <code>sum</code></p>
</li>
<li><p><strong>基本统计</strong></p>
<p>  <code>cov</code>,<code>mean</code>,<code>std</code>,<code>var</code></p>
</li>
<li><p><strong>基本线性代数</strong></p>
<p>  <code>cross</code>,<code>dot</code>,<code>outer</code>,<code>linalg.svd</code>,<code>vdot</code></p>
</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>广播允许通用方法以有意义的方式处理形状不完全相同的输入。</p>
<p>广播第一法则是，如果所有的输入数组维度不都相同，一个“1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</p>
<p>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</p>
<p>应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">文档</a>找到。</p>
<h3 id="花哨的索引和索引技巧"><a href="#花哨的索引和索引技巧" class="headerlink" title="花哨的索引和索引技巧"></a>花哨的索引和索引技巧</h3><p>NumPy提供比常规Python序列更多的索引功能。正如我们前面看到的，除了通过整数和切片进行索引之外，还可以使用整数和布尔数组数组对索引进行索引。</p>
<h4 id="通过数组索引"><a href="#通过数组索引" class="headerlink" title="通过数组索引"></a>通过数组索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)**<span class="number">2</span>          <span class="comment"># 前12个方格</span></span><br><span class="line">i = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>])     <span class="comment"># 一个索引数组</span></span><br><span class="line">a[i]                          <span class="comment"># 一个在位置i的元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 1,  1,  9, 64, 25])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j = np.array([[ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span>]])  <span class="comment"># 一个二维索引数组</span></span><br><span class="line">a[j]                              <span class="comment"># 与j的shape相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9, 16],
       [81, 49]])
</code></pre><p>当被索引数组<code>a</code>是多维的时，每一个唯一的索引数列指向<code>a</code>的第一维。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">palette = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],           <span class="comment"># 黑</span></span><br><span class="line">                    [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],         <span class="comment"># 红</span></span><br><span class="line">                    [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],         <span class="comment"># 绿</span></span><br><span class="line">                    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],         <span class="comment"># 蓝</span></span><br><span class="line">                    [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]      <span class="comment"># 白</span></span><br><span class="line">                   ])</span><br><span class="line">image = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],           <span class="comment"># 每个值对应调色板中的颜色</span></span><br><span class="line">                  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>]</span><br><span class="line">                 ])</span><br><span class="line"></span><br><span class="line">palette[image]                         </span><br></pre></td></tr></table></figure>
<pre><code>array([[[  0,   0,   0],
        [255,   0,   0],
        [  0, 255,   0],
        [  0,   0,   0]],

       [[  0,   0,   0],
        [  0,   0, 255],
        [255, 255, 255],
        [  0,   0,   0]]])
</code></pre><p>我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = np.array([[<span class="number">0</span>,<span class="number">1</span>],    <span class="comment"># indices for the first dim of a</span></span><br><span class="line">             [<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">j = np.array([[<span class="number">2</span>,<span class="number">1</span>],    <span class="comment"># indices for the second dim</span></span><br><span class="line">             [<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">a[i,j]                  <span class="comment"># i 和 j必须拥有相同的shape</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[i,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  6],
       [ 6, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:,j]</span><br></pre></td></tr></table></figure>
<pre><code>array([[[ 2,  1],
        [ 3,  3]],

       [[ 6,  5],
        [ 7,  7]],

       [[10,  9],
        [11, 11]]])
</code></pre><p>当然，我们可以将<code>i</code>和<code>j</code>放入一个序列中（比如说一个列表），然后用列表进行索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [i,j]</span><br><span class="line">a[l]        <span class="comment"># 相当于一个[i,j]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre><p>但是，我们不能将<code>i</code>和<code>j</code>放进一个数组，因为这个数组将被解读为a的第一个维度的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = np.array([i,j])</span><br><span class="line">a[s]     <span class="comment"># 结果不是我们想要的</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-204-79ccae1d198c&gt; in &lt;module&gt;()
      1 s = np.array([i,j])
----&gt; 2 a[s]     # 结果不是我们想要的


IndexError: index 3 is out of bounds for axis 0 with size 3
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="built_in">tuple</span>(s)]     <span class="comment"># 与 a[i,j]相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre><p>另一个常用的数组索引用法是搜索时间序列最大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)    <span class="comment"># 时间尺度</span></span><br><span class="line">data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)  <span class="comment"># 4个时间依赖序列</span></span><br><span class="line">time</span><br></pre></td></tr></table></figure>
<pre><code>array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],
       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],
       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],
       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],
       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ind = data.argmax(axis=<span class="number">0</span>)    <span class="comment"># 每个序列的最大值的索引</span></span><br><span class="line">ind</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 0, 3, 1])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">time_max = time[ind]         <span class="comment"># 时间序列对应的最大值</span></span><br><span class="line">data_max = data[ind, <span class="built_in">range</span>(data.shape[<span class="number">1</span>])]  <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></span><br><span class="line"></span><br><span class="line">time_max</span><br></pre></td></tr></table></figure>
<pre><code>array([  82.5 ,   20.  ,  113.75,   51.25])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_max</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.<span class="built_in">all</span>(data_max == data.<span class="built_in">max</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>你也可以使用数组索引作为目标来赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3, 4])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 0, 2, 0, 0])
</code></pre><p>然而，当一个索引列表包含重复时，赋值被多次完成，保留最后一次的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 1, 3, 3, 4])
</code></pre><p>这足够合理，但是小心如果你想用Python的<code>+=</code>结构，可能结果并非你所期望：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]] += <span class="number">1</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 1, 3, 3, 4])
</code></pre><p>即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求<code>a+=1</code>和<code>a=a+1</code>等同。</p>
<h4 id="通过布尔数组索引"><a href="#通过布尔数组索引" class="headerlink" title="通过布尔数组索引"></a>通过布尔数组索引</h4><p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p>
<p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = a &gt; <span class="number">4</span></span><br><span class="line">b                   <span class="comment"># b 是一个和a形状相同的boolean数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[False, False, False, False],
       [False,  True,  True,  True],
       [ True,  True,  True,  True]], dtype=bool)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[b]                <span class="comment"># 经过筛选后的1维数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 5,  6,  7,  8,  9, 10, 11])
</code></pre><p>这个属性在赋值时非常有用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[b] = <span class="number">0</span>            <span class="comment"># 将a中所有比4大的元素赋值为0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2, 3],
       [4, 0, 0, 0],
       [0, 0, 0, 0]])
</code></pre><p>你可以参考曼德博集合示例看看如何使用布尔索引来生成<a href="http://en.wikipedia.org/wiki/Mandelbrot_set">曼德博集合</a>的图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span>(<span class="params">h,w,maxit=<span class="number">20</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个尺寸为（h,w）的曼德博分形图&quot;&quot;&quot;</span></span><br><span class="line">    y,x = np.ogrid[ -<span class="number">1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, -<span class="number">2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span>]</span><br><span class="line">    c = x+y * <span class="number">1j</span></span><br><span class="line">    z = c</span><br><span class="line">    divtime = maxit + np.zeros(z.shape,dtype=<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxit):</span><br><span class="line">        z = z**<span class="number">2</span> + c</span><br><span class="line">        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>    <span class="comment"># who is diverging</span></span><br><span class="line">        div_now = diverge &amp; (divtime == maxit)  <span class="comment"># who is diverging now</span></span><br><span class="line">        divtime[div_now] = i                    <span class="comment"># note when</span></span><br><span class="line">        z[diverge] = <span class="number">2</span>                          <span class="comment"># avoid diverging too much</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> divtime</span><br><span class="line"></span><br><span class="line">plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_05_11/output_194_0.png" alt="png"></p>
<p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b1 = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>])    <span class="comment"># 第一维的筛选</span></span><br><span class="line">b2 = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])  <span class="comment"># 第二维的筛选</span></span><br><span class="line"></span><br><span class="line">a[b1,:]       <span class="comment"># 选择行</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[b1]         <span class="comment"># 和上面相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:,b2]       <span class="comment"># 选择列</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[b1,b2]      <span class="comment"># 一个奇怪的结果</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 4, 10])
</code></pre><p>注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，<code>b1</code>是一个秩为1长度为三的数组(<code>a</code>的行数)，<code>b2</code>(长度为4)与<code>a</code>的第二秩(列)相一致。</p>
<h4 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a>ix_()函数</h4><p><code>ix_</code>函数可以为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算a+b*c：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line">c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line">ax,bx,cx = np.ix_(a,b,c)</span><br><span class="line">ax</span><br></pre></td></tr></table></figure>
<pre><code>array([[[2]],

       [[3]],

       [[4]],

       [[5]]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bx</span><br></pre></td></tr></table></figure>
<pre><code>array([[[8],
        [5],
        [4]]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cx</span><br></pre></td></tr></table></figure>
<pre><code>array([[[5, 4, 6, 8, 3]]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.shape, bx.shape, cx.shape</span><br></pre></td></tr></table></figure>
<pre><code>((4, 1, 1), (1, 3, 1), (1, 1, 5))
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = ax + bx * cx</span><br><span class="line">result</span><br></pre></td></tr></table></figure>
<pre><code>array([[[42, 34, 50, 66, 26],
        [27, 22, 32, 42, 17],
        [22, 18, 26, 34, 14]],

       [[43, 35, 51, 67, 27],
        [28, 23, 33, 43, 18],
        [23, 19, 27, 35, 15]],

       [[44, 36, 52, 68, 28],
        [29, 24, 34, 44, 19],
        [24, 20, 28, 36, 16]],

       [[45, 37, 53, 69, 29],
        [30, 25, 35, 45, 20],
        [25, 21, 29, 37, 17]]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>17
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">3</span>] + b[<span class="number">2</span>] * c[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>17
</code></pre><p>你也可以实行如下简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufunc_reduce</span>(<span class="params">ufct, *vectors</span>):</span></span><br><span class="line">    vs = np.ix_(*vectors)</span><br><span class="line">    r = ufct.identity</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> vs:</span><br><span class="line">        r = ufct(r,v)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>然后这样使用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ufunc_reduce(np.add,a,b,c)</span><br></pre></td></tr></table></figure>
<pre><code>array([[[15, 14, 16, 18, 13],
        [12, 11, 13, 15, 10],
        [11, 10, 12, 14,  9]],

       [[16, 15, 17, 19, 14],
        [13, 12, 14, 16, 11],
        [12, 11, 13, 15, 10]],

       [[17, 16, 18, 20, 15],
        [14, 13, 15, 17, 12],
        [13, 12, 14, 16, 11]],

       [[18, 17, 19, 21, 16],
        [15, 14, 16, 18, 13],
        [14, 13, 15, 17, 12]]])
</code></pre><p>这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。</p>
<h4 id="用字符串索引"><a href="#用字符串索引" class="headerlink" title="用字符串索引"></a>用字符串索引</h4><p>参加<a href="https://docs.scipy.org/doc/numpy/user/basics.rec.html#structured-arrays">结构化数组</a>。</p>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>继续前进，基本线性代数包含在这里。</p>
<h4 id="简单数组运算"><a href="#简单数组运算" class="headerlink" title="简单数组运算"></a>简单数组运算</h4><p>参考numpy文件夹中的linalg.py获得更多信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1.  2.]
 [ 3.  4.]]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.transpose()</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.,  3.],
       [ 2.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.inv(a)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-2. ,  1. ],
       [ 1.5, -0.5]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;  单位矩阵</span></span><br><span class="line">u</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.,  0.],
       [ 0.,  1.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j = np.array([[<span class="number">0.0</span>, -<span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">np.dot(j, j)   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[-1.,  0.],
       [ 0., -1.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.trace(u)    <span class="comment"># trace</span></span><br></pre></td></tr></table></figure>
<pre><code>2.0
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = np.array([[<span class="number">5.</span>],[<span class="number">7.</span>]])</span><br><span class="line">np.linalg.solve(a, y)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-3.],
       [ 4.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.eig(j)</span><br></pre></td></tr></table></figure>
<pre><code>(array([ 0.+1.j,  0.-1.j]),
 array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],
        [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parameters:</span><br><span class="line">    square matrix</span><br><span class="line">Returns</span><br><span class="line">    The eigenvalues, each repeated according to its multiplicity.</span><br><span class="line">    The normalized (unit &quot;length&quot;) eigenvectors, such that the</span><br><span class="line">    column &#96;&#96;v[:,i]&#96;&#96; is the eigenvector corresponding to the</span><br><span class="line">    eigenvalue &#96;&#96;w[i]&#96;&#96; .</span><br></pre></td></tr></table></figure>
<h3 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="技巧和提示"></a>技巧和提示</h3><p>下面我们给出简短和有用的提示。</p>
<h4 id="“自动”改变形状"><a href="#“自动”改变形状" class="headerlink" title="“自动”改变形状"></a>“自动”改变形状</h4><p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">30</span>)</span><br><span class="line">a.shape = <span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>  <span class="comment"># -1 意味着 “无论需要什么”</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(2, 5, 3)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11],
        [12, 13, 14]],

       [[15, 16, 17],
        [18, 19, 20],
        [21, 22, 23],
        [24, 25, 26],
        [27, 28, 29]]])
</code></pre><h4 id="向量组合-stacking"><a href="#向量组合-stacking" class="headerlink" title="向量组合(stacking)"></a>向量组合(stacking)</h4><p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果<code>x</code>和<code>y</code>是两个相同长度的向量，你仅仅需要做<code>m=[x;y]</code>。在NumPy中这个过程通过函数<code>column_stack</code>、<code>dstack</code>、<code>hstack</code>和<code>vstack</code>来完成，取决于你想要在那个维度上组合。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)      <span class="comment"># x = ([0,2,4,6,8])</span></span><br><span class="line">y = np.arange(<span class="number">5</span>)           <span class="comment"># y = ([0,1,2,3,4])</span></span><br><span class="line">m = np.vstack([x,y])       <span class="comment"># m=([[0,2,4,6,8],</span></span><br><span class="line">                           <span class="comment">#     [0,1,2,3,4]])</span></span><br><span class="line">m</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 2, 4, 6, 8],
       [0, 1, 2, 3, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xy = np.hstack([x,y])      <span class="comment"># xy = ([0,2,4,6,8,0,1,2,3,4])</span></span><br><span class="line">xy</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])
</code></pre><h4 id="直方图-histogram"><a href="#直方图-histogram" class="headerlink" title="直方图(histogram)"></a>直方图(histogram)</h4><p>NumPy中<code>histogram</code>函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：<code>matplotlib</code>也有一个用来建立直方图的函数(叫作<code>hist</code>,正如matlab中一样)与NumPy中的不同。主要的差别是<code>pylab.hist</code>自动绘制直方图，而<code>numpy.histogram</code>仅仅产生数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 简历一个拥有10000个元素的正态分布的向量，方差为0.5^2，均值为2</span></span><br><span class="line">mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></span><br><span class="line">v = np.random.normal(mu,sigma,<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># 绘制分成50份的正态分布直方图</span></span><br><span class="line">plt.hist(v, bins=<span class="number">50</span>, normed=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_05_11/output_232_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用numpy计算直方图然后绘制它</span></span><br><span class="line">(n, bins) = np.histogram(v, bins=<span class="number">50</span>, normed=<span class="literal">True</span>)  <span class="comment"># NumPy version (no plot)</span></span><br><span class="line">plt.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:-<span class="number">1</span>]), n)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_05_11/output_233_0.png" alt="png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>NumPy快速入门</title>
    <url>/2016/01/05/Numpy%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="NumPy快速入门"><a href="#NumPy快速入门" class="headerlink" title="NumPy快速入门"></a>NumPy快速入门</h2><h3 id="为什么需要NumPy"><a href="#为什么需要NumPy" class="headerlink" title="为什么需要NumPy?"></a>为什么需要NumPy?</h3><p>NumPy是python的一个矩阵类型，提供了大量的矩阵处理的函数。</p>
<p>由于其内部是通过<strong>C语言</strong>来实现，所以效率很高。</p>
<p>尽管声称是一个关于矩阵的库，NumPy实际上包含了两种基本的数据类型：数组和矩阵。二者在处理上稍有不同。在使用标准的python时，处理这两类数据，均需要使用循环语句，而使用NumPy则可以省去这些语句。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组相加"><a href="#数组相加" class="headerlink" title="数组相加"></a>数组相加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm=array((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp=array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp+mm</span><br><span class="line">array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>如果使用常规的python，就需要循环来处理了。</p>
<h3 id="数组的数乘运算"><a href="#数组的数乘运算" class="headerlink" title="数组的数乘运算"></a>数组的数乘运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp*<span class="number">2</span></span><br><span class="line">array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<h3 id="对每个元素求平方"><a href="#对每个元素求平方" class="headerlink" title="对每个元素求平方"></a>对每个元素求平方</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp**<span class="number">2</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<h3 id="可以像列表中一样访问数组里的元素："><a href="#可以像列表中一样访问数组里的元素：" class="headerlink" title="可以像列表中一样访问数组里的元素："></a>可以像列表中一样访问数组里的元素：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>NumPy中也支持多维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj = array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<p>多维数组中的元素也可以像列表中一样访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj[<span class="number">0</span>]</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>也可以用矩阵方式访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="把两个数组乘起来的时候，两个数组的元素将对应相乘："><a href="#把两个数组乘起来的时候，两个数组的元素将对应相乘：" class="headerlink" title="把两个数组乘起来的时候，两个数组的元素将对应相乘："></a>把两个数组乘起来的时候，两个数组的元素将对应相乘：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1=array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2=array([<span class="number">0.3</span>, <span class="number">0.2</span>, <span class="number">0.3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1*a2</span><br><span class="line">array([<span class="number">0.3</span>, <span class="number">0.4</span> <span class="number">0.9</span>])</span><br></pre></td></tr></table></figure>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="Numpy矩阵的引入"><a href="#Numpy矩阵的引入" class="headerlink" title="Numpy矩阵的引入"></a>Numpy矩阵的引入</h3><p>与数组一样，需要从NumPy中导入<code>matrix</code>或者<code>mat</code>模块(<code>mat</code>其实就是<code>matrix</code>的缩写)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> mat, matrix</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = mat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm = matrix([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<p>可以访问矩阵中的单个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="将python列表转换为NumPy矩阵"><a href="#将python列表转换为NumPy矩阵" class="headerlink" title="将python列表转换为NumPy矩阵"></a>将python列表转换为NumPy矩阵</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pyList = [<span class="number">5</span>, <span class="number">11</span>, <span class="number">1605</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mat(pyList)</span><br><span class="line">matrix([[   <span class="number">5</span>,   <span class="number">11</span>, <span class="number">1605</span>]]) </span><br></pre></td></tr></table></figure>
<h3 id="矩阵乘法的运算"><a href="#矩阵乘法的运算" class="headerlink" title="矩阵乘法的运算"></a>矩阵乘法的运算</h3><p>如果你不熟悉矩阵乘法的运算规则，请看<a href="./2015/11/29/线性代数01-矩阵乘法/">这里</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = mat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm = matrix([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm*ss.T</span><br><span class="line">matrix([[<span class="number">14</span>]])</span><br></pre></td></tr></table></figure>
<p>其中<code>ss.T</code>是将ss进行转置，因为做矩阵乘法运算的两个矩阵必须满足<code>左矩阵的列数与右矩阵的行数相等</code>的条件。</p>
<h3 id="获取矩阵的行列数"><a href="#获取矩阵的行列数" class="headerlink" title="获取矩阵的行列数"></a>获取矩阵的行列数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> shape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm = matrix([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(mm)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="两个矩阵对应元素相乘-multiply"><a href="#两个矩阵对应元素相乘-multiply" class="headerlink" title="两个矩阵对应元素相乘(multiply)"></a>两个矩阵对应元素相乘(multiply)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> multiply</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mm = matrix([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = matrix([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>multiply(mm, ss)</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="矩阵的排序"><a href="#矩阵的排序" class="headerlink" title="矩阵的排序"></a>矩阵的排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = matrix([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">matrix([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>
<p>注意：该方法是原地排序（即排序后到结果占用原始的存储空间），所以如果希望保存数据的原始顺序，必须事先拷贝一份。也可以使用argsort()方法得到矩阵中每个元素的排序序号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = matrix([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.argsort()</span><br><span class="line">matrix([[<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="计算矩阵的平均值"><a href="#计算矩阵的平均值" class="headerlink" title="计算矩阵的平均值"></a>计算矩阵的平均值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = matrix([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.mean()</span><br><span class="line"><span class="number">3.3333333333333335</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-去除矩阵中指定片段"><a href="#通过-去除矩阵中指定片段" class="headerlink" title="通过:去除矩阵中指定片段"></a>通过<code>:</code>去除矩阵中指定片段</h3><p>python中的切片用法简单，功能强大，NumPy中的矩阵同样也支持该操作，比如在想在下面一个2x3的矩阵中取出第一行元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj = mat([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],[<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(jj)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj[<span class="number">1</span>,:]</span><br><span class="line">matrix([[<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>
<p>也可以使用以下方法取出第一行第0列到第1列的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>jj[<span class="number">1</span>,<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">matrix([[<span class="number">8</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>更多NumPy的相关用法，建议浏览完整的官方文档</p>
<p><a href="http://docs.scipy.org/doc/">http://docs.scipy.org/doc/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言（01）</title>
    <url>/2016/02/29/R%E8%AF%AD%E8%A8%80%EF%BC%8801%EF%BC%89%EF%BC%8DR%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="What’s-R"><a href="#What’s-R" class="headerlink" title="What’s R?"></a>What’s R?</h2><h3 id="R的起源"><a href="#R的起源" class="headerlink" title="R的起源"></a>R的起源</h3><p>R是S语言的一种实现。S语言是由AT&amp;T贝尔实验室开发的一种用来进行数据探索、统计分析、作图的解释型语言。最初S语言的实现版本主要是S-PLUS。S-PLUS是一个商业软件，它基于S语言，并由MathSoft公司的统计科学部进一步完善。后来Auckland大学的Robert Gentleman和Ross Ihaka及其他志愿人员开发了一个R系统。R的使用与S-PLUS有很多类似之处，两个软件有一定的兼容性。</p>
<h3 id="R-is-free"><a href="#R-is-free" class="headerlink" title="R is free"></a>R is free</h3><p>R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。</p>
<p>R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言；可操纵数据的输入和输出，可实现分支、循环，用户可自定义功能。</p>
<p>R是一个免费的自由软件，它有UNIX、MacOS和Windows版本，都是可以免费下载和使用的。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。</p>
<p>官方网站：<a href="http://www.r-project.org">http://www.r-project.org</a></p>
<h3 id="R的特点"><a href="#R的特点" class="headerlink" title="R的特点"></a>R的特点</h3><ul>
<li>有效的数据处理和保存机制。</li>
<li>拥有一整套数组和矩阵的操作运算符。</li>
<li>一系列连贯而又完整多数据分析中间工具。</li>
<li>图形统计可以数据直接进行分析和显示，可用于多种图形设备。</li>
<li>一种相当完善、简洁和高效的程序设计语言。它包括条件语句、循环语句、用户自定义的递归函数，以及输入输出接口。</li>
<li>R语言是彻底面向对象的统计编程语言。</li>
<li>R语言和其他编程语言、数据库之间有很好的接口。</li>
<li>R语言是自由软件，可以放心大胆地使用，但其功能却不比任何其它同类软件差。</li>
<li>R语言具有丰富的网上资源。</li>
</ul>
<h2 id="运行R"><a href="#运行R" class="headerlink" title="运行R"></a>运行R</h2><h3 id="R的运行界面："><a href="#R的运行界面：" class="headerlink" title="R的运行界面："></a>R的运行界面：</h3><p><img src="/img/r_01_01.png" alt="R的运行界面"></p>
<h3 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h3><p><img src="/img/r_01_02.png" alt="安装第三方包"><br><img src="/img/r_01_03.png" alt="安装第三方包"></p>
<p>选择需要安装的包，点击安装即可</p>
<p>安装成功之后可以看到：</p>
<p><img src="/img/r_01_04.png" alt="安装第三方包"></p>
<p><code>假如安装a包需要依赖到b包和c包，那么在安装a包之前，R会自动去安装好所依赖的b包和c包。</code></p>
<h2 id="相关函数介绍"><a href="#相关函数介绍" class="headerlink" title="相关函数介绍"></a>相关函数介绍</h2><p>R能通过手动输入数据，读取文本中的数据，以及orical之类的数据（前提是只要安装好对应的包），基本上所有的数据源都可以读取。</p>
<hr>
<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><h4 id="c"><a href="#c" class="headerlink" title="c()"></a>c()</h4><p>函数c()是最基本的一个函数，用于创建数列。数列是R中最基本的一个数据结构.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="mode"><a href="#mode" class="headerlink" title="mode()"></a>mode()</h4><p>查看数据类型，使用mode( )函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">&gt; mode(x)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;numeric&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于上例中x中存放的都是数值类型，所以mode输出”numeric”</p>
<p>如果存放字符类型，则产生”character”的输出：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; y = <span class="built_in">c</span>(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>)</span><br><span class="line">&gt; mode(y)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;character&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h4><p>length( ) 用来看一个向量的长度</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">&gt; <span class="built_in">length</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="1-100"><a href="#1-100" class="headerlink" title="1:100"></a>1:100</h4><p>c(1:100)  相当于 c(1,2,3,4…100)</p>
<h4 id="rbind-x1-x2-和cbind-x1-x2"><a href="#rbind-x1-x2-和cbind-x1-x2" class="headerlink" title="rbind(x1,x2)和cbind(x1,x2)"></a>rbind(x1,x2)和cbind(x1,x2)</h4><p>rbind(x1,x2) 把两个向量合成一个矩阵，把x1和x2当成两个行来处理</p>
<p>cbind(x1,x2) 同rbind(x1,x2) 不过把x1和x2当成两个列向量来处理</p>
<p><code>这里x1和x2必须长度相等，或者长度为1（如果长度为1，则不足的位置按照唯一的那个元素补齐）</code></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x1=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>)</span><br><span class="line">&gt; x2=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">&gt; rbind(x1,x2)</span><br><span class="line">   [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">x1    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span>    <span class="number">8</span>    <span class="number">0</span></span><br><span class="line">x2    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">7</span>    <span class="number">9</span></span><br><span class="line">&gt; cbind(x1,x2)</span><br><span class="line">     x1 x2</span><br><span class="line">[<span class="number">1</span>,]  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>,]  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">[<span class="number">3</span>,]  <span class="number">6</span>  <span class="number">5</span></span><br><span class="line">[<span class="number">4</span>,]  <span class="number">8</span>  <span class="number">7</span></span><br><span class="line">[<span class="number">5</span>,]  <span class="number">0</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure></h2><h3 id="求平均值，和，连乘，最值，方差，标准差"><a href="#求平均值，和，连乘，最值，方差，标准差" class="headerlink" title="求平均值，和，连乘，最值，方差，标准差"></a>求平均值，和，连乘，最值，方差，标准差</h3><h4 id="mean"><a href="#mean" class="headerlink" title="mean()"></a>mean()</h4><ul>
<li>mean() 传入数列，求平均值</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">100</span>)</span><br><span class="line">&gt; mean(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">50.5</span></span><br></pre></td></tr></table></figure>
<h4 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h4><ul>
<li>sum() 传入数列，求和</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">sum</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5050</span></span><br></pre></td></tr></table></figure>
<h4 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h4><ul>
<li>max() 传入数列，求最大值</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">max</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h4 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h4><ul>
<li>min() 传入数列，求最小值</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">min</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h4><ul>
<li>var() 传入数列，求方差（每一项减去平均值之后再平方，然后把平方和加起来 的值就是方差，方差的大小反应的是数据的离散程度，方差越大，离散程度越大）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var(x)</span><br><span class="line">[1] 841.6667</span><br></pre></td></tr></table></figure>
<h4 id="prod"><a href="#prod" class="headerlink" title="prod()"></a>prod()</h4><ul>
<li>prod() 传入数列，求连乘</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">prod</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">9.332622e+157</span></span><br></pre></td></tr></table></figure>
<h4 id="sd"><a href="#sd" class="headerlink" title="sd()"></a>sd()</h4><ul>
<li>sd() 传入数列，求标准差（标准差也是反应离散程度，和求方差略有不同，自行学习）</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; sd(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">29.01149</span></span><br></pre></td></tr></table></figure></h2><h3 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h3><p>help() 传入命令名称，查看帮助文档</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">help(mode)</span><br></pre></td></tr></table></figure>
<p>会打开一个文档页面：</p>
<p><img src="/img/r_01_05.png" alt="文档页面"></p>
<p><code>可以看到里面有个“&lt;-”的符号，这个符号在R中等同于”=&quot;，代表赋值符号。</code></p>
<hr>
<h3 id="向量的操作"><a href="#向量的操作" class="headerlink" title="向量的操作"></a>向量的操作</h3><h4 id="产生向量"><a href="#产生向量" class="headerlink" title="产生向量"></a>产生向量</h4><p>产生1到10的数字向量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span>:<span class="number">10</span></span><br><span class="line"> [<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>产生1到10的数字向量，并且每一项-1</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span>:<span class="number">10</span>-<span class="number">1</span></span><br><span class="line"> [<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>产生1到10的数字向量，并且每一项*2</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">1</span>:<span class="number">10</span>*<span class="number">2</span></span><br><span class="line"> [<span class="number">1</span>]  <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>产生2到60的数字向量，并且每一项*2+1</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">2</span>:<span class="number">60</span>*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"> [<span class="number">1</span>]   <span class="number">5</span>   <span class="number">7</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span>  <span class="number">17</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">23</span>  <span class="number">25</span>  <span class="number">27</span>  <span class="number">29</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">37</span>  <span class="number">39</span></span><br><span class="line">[<span class="number">19</span>]  <span class="number">41</span>  <span class="number">43</span>  <span class="number">45</span>  <span class="number">47</span>  <span class="number">49</span>  <span class="number">51</span>  <span class="number">53</span>  <span class="number">55</span>  <span class="number">57</span>  <span class="number">59</span>  <span class="number">61</span>  <span class="number">63</span>  <span class="number">65</span>  <span class="number">67</span>  <span class="number">69</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">75</span></span><br><span class="line">[<span class="number">37</span>]  <span class="number">77</span>  <span class="number">79</span>  <span class="number">81</span>  <span class="number">83</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">89</span>  <span class="number">91</span>  <span class="number">93</span>  <span class="number">95</span>  <span class="number">97</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">103</span> <span class="number">105</span> <span class="number">107</span> <span class="number">109</span> <span class="number">111</span></span><br><span class="line">[<span class="number">55</span>] <span class="number">113</span> <span class="number">115</span> <span class="number">117</span> <span class="number">119</span> <span class="number">121</span></span><br></pre></td></tr></table></figure>
<h4 id="取出向量的元素"><a href="#取出向量的元素" class="headerlink" title="取出向量的元素"></a>取出向量的元素</h4><p>a[5] 代表取出第5个元素</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a = <span class="number">2</span>:<span class="number">60</span>*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">&gt; a</span><br><span class="line"> [<span class="number">1</span>]   <span class="number">5</span>   <span class="number">7</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span>  <span class="number">17</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">23</span>  <span class="number">25</span>  <span class="number">27</span>  <span class="number">29</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">37</span>  <span class="number">39</span>  <span class="number">41</span></span><br><span class="line">[<span class="number">20</span>]  <span class="number">43</span>  <span class="number">45</span>  <span class="number">47</span>  <span class="number">49</span>  <span class="number">51</span>  <span class="number">53</span>  <span class="number">55</span>  <span class="number">57</span>  <span class="number">59</span>  <span class="number">61</span>  <span class="number">63</span>  <span class="number">65</span>  <span class="number">67</span>  <span class="number">69</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">75</span>  <span class="number">77</span>  <span class="number">79</span></span><br><span class="line">[<span class="number">39</span>]  <span class="number">81</span>  <span class="number">83</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">89</span>  <span class="number">91</span>  <span class="number">93</span>  <span class="number">95</span>  <span class="number">97</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">103</span> <span class="number">105</span> <span class="number">107</span> <span class="number">109</span> <span class="number">111</span> <span class="number">113</span> <span class="number">115</span> <span class="number">117</span></span><br><span class="line">[<span class="number">58</span>] <span class="number">119</span> <span class="number">121</span></span><br><span class="line">&gt; a[<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>取出a中的第1到5个元素</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span> <span class="number">11</span> <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>代表a中第1到5个元素不显示，其他的显示出来。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[-(<span class="number">1</span>:<span class="number">5</span>)]</span><br><span class="line"> [<span class="number">1</span>]  <span class="number">15</span>  <span class="number">17</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">23</span>  <span class="number">25</span>  <span class="number">27</span>  <span class="number">29</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">37</span>  <span class="number">39</span>  <span class="number">41</span>  <span class="number">43</span>  <span class="number">45</span>  <span class="number">47</span>  <span class="number">49</span>  <span class="number">51</span></span><br><span class="line">[<span class="number">20</span>]  <span class="number">53</span>  <span class="number">55</span>  <span class="number">57</span>  <span class="number">59</span>  <span class="number">61</span>  <span class="number">63</span>  <span class="number">65</span>  <span class="number">67</span>  <span class="number">69</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">75</span>  <span class="number">77</span>  <span class="number">79</span>  <span class="number">81</span>  <span class="number">83</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">89</span></span><br><span class="line">[<span class="number">39</span>]  <span class="number">91</span>  <span class="number">93</span>  <span class="number">95</span>  <span class="number">97</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">103</span> <span class="number">105</span> <span class="number">107</span> <span class="number">109</span> <span class="number">111</span> <span class="number">113</span> <span class="number">115</span> <span class="number">117</span> <span class="number">119</span> <span class="number">121</span></span><br></pre></td></tr></table></figure>
<p>向量中传入一个数列，代表取出这个数列对应的a中的元素，即取出a中第2，4，7的元素。</p>
<p><code>注意：这里一定要用c()函数</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">7</span> <span class="number">11</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>把元素值小于20的全部列出来</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[a&lt;<span class="number">20</span>]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span> <span class="number">11</span> <span class="number">13</span> <span class="number">15</span> <span class="number">17</span> <span class="number">19</span></span><br></pre></td></tr></table></figure>
<p>取出元素大于30并且小于50的元素</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[a&gt;<span class="number">30</span> &amp; a&lt;<span class="number">50</span>]</span><br><span class="line"> [<span class="number">1</span>] <span class="number">31</span> <span class="number">33</span> <span class="number">35</span> <span class="number">37</span> <span class="number">39</span> <span class="number">41</span> <span class="number">43</span> <span class="number">45</span> <span class="number">47</span> <span class="number">49</span></span><br></pre></td></tr></table></figure>
<p>取出a向量下标为3的元素对应的数值，作为下标的元素。这里a[3]是9，即取出a[9]对应的元素21.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[a[<span class="number">3</span>]]</span><br><span class="line">[<span class="number">1</span>] <span class="number">21</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-seq-函数来产生向量"><a href="#通过-seq-函数来产生向量" class="headerlink" title="通过 seq() 函数来产生向量"></a>通过 seq() 函数来产生向量</h3><p>产生从5到20，并且公差为1的向量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seq(<span class="number">5</span>,<span class="number">20</span>)</span><br><span class="line"> [<span class="number">1</span>]  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>产生从5到121，公差为2的向量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seq(<span class="number">5</span>,<span class="number">121</span>,by=<span class="number">2</span>)</span><br><span class="line"> [<span class="number">1</span>]   <span class="number">5</span>   <span class="number">7</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span>  <span class="number">17</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">23</span>  <span class="number">25</span>  <span class="number">27</span>  <span class="number">29</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">37</span>  <span class="number">39</span>  <span class="number">41</span></span><br><span class="line">[<span class="number">20</span>]  <span class="number">43</span>  <span class="number">45</span>  <span class="number">47</span>  <span class="number">49</span>  <span class="number">51</span>  <span class="number">53</span>  <span class="number">55</span>  <span class="number">57</span>  <span class="number">59</span>  <span class="number">61</span>  <span class="number">63</span>  <span class="number">65</span>  <span class="number">67</span>  <span class="number">69</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">75</span>  <span class="number">77</span>  <span class="number">79</span></span><br><span class="line">[<span class="number">39</span>]  <span class="number">81</span>  <span class="number">83</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">89</span>  <span class="number">91</span>  <span class="number">93</span>  <span class="number">95</span>  <span class="number">97</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">103</span> <span class="number">105</span> <span class="number">107</span> <span class="number">109</span> <span class="number">111</span> <span class="number">113</span> <span class="number">115</span> <span class="number">117</span></span><br><span class="line">[<span class="number">58</span>] <span class="number">119</span> <span class="number">121</span></span><br></pre></td></tr></table></figure>
<p>给出从5到121的，长度为10的等差数列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seq(<span class="number">5</span>,<span class="number">121</span>,<span class="built_in">length</span>=<span class="number">10</span>)</span><br><span class="line"> [<span class="number">1</span>]   <span class="number">5.00000</span>  <span class="number">17.88889</span>  <span class="number">30.77778</span>  <span class="number">43.66667</span>  <span class="number">56.55556</span>  <span class="number">69.44444</span>  <span class="number">82.33333</span></span><br><span class="line"> [<span class="number">8</span>]  <span class="number">95.22222</span> <span class="number">108.11111</span> <span class="number">121.00000</span></span><br></pre></td></tr></table></figure>
<h3 id="常量letters"><a href="#常量letters" class="headerlink" title="常量letters"></a>常量letters</h3><p>产生字母序列letters，这是一个常数向量，包含26个字母。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">letters</span>[<span class="number">1</span>:<span class="number">30</span>]</span><br><span class="line"> [<span class="number">1</span>] <span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span> <span class="string">&quot;c&quot;</span> <span class="string">&quot;d&quot;</span> <span class="string">&quot;e&quot;</span> <span class="string">&quot;f&quot;</span> <span class="string">&quot;g&quot;</span> <span class="string">&quot;h&quot;</span> <span class="string">&quot;i&quot;</span> <span class="string">&quot;j&quot;</span> <span class="string">&quot;k&quot;</span> <span class="string">&quot;l&quot;</span> <span class="string">&quot;m&quot;</span> <span class="string">&quot;n&quot;</span> <span class="string">&quot;o&quot;</span> <span class="string">&quot;p&quot;</span> <span class="string">&quot;q&quot;</span> <span class="string">&quot;r&quot;</span> <span class="string">&quot;s&quot;</span></span><br><span class="line">[<span class="number">20</span>] <span class="string">&quot;t&quot;</span> <span class="string">&quot;u&quot;</span> <span class="string">&quot;v&quot;</span> <span class="string">&quot;w&quot;</span> <span class="string">&quot;x&quot;</span> <span class="string">&quot;y&quot;</span> <span class="string">&quot;z&quot;</span> <span class="literal">NA</span>  <span class="literal">NA</span>  <span class="literal">NA</span>  <span class="literal">NA</span> </span><br></pre></td></tr></table></figure>
<h3 id="which-函数"><a href="#which-函数" class="headerlink" title="which()函数"></a>which()函数</h3><p>which.max()函数给出数列中最大元素对应的下标值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>)</span><br><span class="line">&gt; which.max(a)</span><br><span class="line">[<span class="number">1</span>] <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>which.min()函数给出数列中最小元素对应的下标值</p>
<p><code>(如果最大值，最小值有多个，默认只显示下标号最小的那个下标)</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; which.min(a)</span><br><span class="line">[<span class="number">1</span>] <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>取出a中最大元素的值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[which.max(a)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>取出元素值为2的下标</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; which(a==<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">4</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>取出元素值大于5的下标</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; which(a&gt;<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">7</span> <span class="number">11</span> <span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="rev-向量翻转"><a href="#rev-向量翻转" class="headerlink" title="rev() 向量翻转"></a>rev() 向量翻转</h3><p>rev()函数可以将向量翻转,但不改变原向量</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a＝<span class="number">1</span>:<span class="number">20</span></span><br><span class="line">&gt; a</span><br><span class="line"> [<span class="number">1</span>] <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line">&gt; rev(a)</span><br><span class="line"> [<span class="number">1</span>] <span class="number">3</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort() 排序"></a>sort() 排序</h3><p>sort()函数，可以将向量按照从小到大的顺序排序，同样，也不改变原来的向量</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=<span class="built_in">c</span>(<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">&gt; a</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line">&gt; rev(sort(a))</span><br><span class="line">[<span class="number">1</span>] <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></h2><h3 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h3><h4 id="matrix-函数-生成矩阵"><a href="#matrix-函数-生成矩阵" class="headerlink" title="matrix()函数 生成矩阵"></a>matrix()函数 生成矩阵</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a1=<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">12</span>)</span><br><span class="line">&gt; matrix(a1,nrow=<span class="number">3</span>,ncol=<span class="number">4</span>)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">4</span>    <span class="number">7</span>   <span class="number">10</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">5</span>    <span class="number">8</span>   <span class="number">11</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">6</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line">&gt; matrix(a1,nrow=<span class="number">4</span>,ncol=<span class="number">3</span>)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">5</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">6</span>   <span class="number">10</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">7</span>   <span class="number">11</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">8</span>   <span class="number">12</span></span><br><span class="line">&gt; matrix(a1,nrow=<span class="number">4</span>,ncol=<span class="number">3</span>,byrow=<span class="built_in">T</span>)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">4</span>,]   <span class="number">10</span>   <span class="number">11</span>   <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>如果向量长度大于等于创建矩阵所需要的元素个数，则可以创建矩阵，否则不行：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; matrix(a1,nrow=<span class="number">3</span>,ncol=<span class="number">3</span>)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">4</span>    <span class="number">7</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">5</span>    <span class="number">8</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">6</span>    <span class="number">9</span></span><br><span class="line">&gt; matrix(a1,nrow=<span class="number">3</span>,ncol=<span class="number">5</span>)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">4</span>    <span class="number">7</span>   <span class="number">10</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">5</span>    <span class="number">8</span>   <span class="number">11</span>    <span class="number">2</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">6</span>    <span class="number">9</span>   <span class="number">12</span>    <span class="number">3</span></span><br><span class="line">警告信息：</span><br><span class="line">In matrix(a1, nrow = <span class="number">3</span>, ncol = <span class="number">5</span>) : 数据长度[<span class="number">12</span>]不是矩阵列数[<span class="number">5</span>]的整倍数</span><br></pre></td></tr></table></figure>
<h4 id="t"><a href="#t" class="headerlink" title="t()"></a>t()</h4><p>t()函数，求矩阵的转置</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=matrix(a1,nrow=<span class="number">3</span>,ncol=<span class="number">4</span>)</span><br><span class="line">&gt; a</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">4</span>    <span class="number">7</span>   <span class="number">10</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">5</span>    <span class="number">8</span>   <span class="number">11</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">6</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line">&gt; t(a)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span></span><br><span class="line">[<span class="number">4</span>,]   <span class="number">10</span>   <span class="number">11</span>   <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h4 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h4><p>矩阵的加减法：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=b=matrix(<span class="number">1</span>:<span class="number">12</span>,nrow=<span class="number">3</span>,ncol=<span class="number">4</span>)</span><br><span class="line">&gt; a+b</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">2</span>    <span class="number">8</span>   <span class="number">14</span>   <span class="number">20</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">4</span>   <span class="number">10</span>   <span class="number">16</span>   <span class="number">22</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">6</span>   <span class="number">12</span>   <span class="number">18</span>   <span class="number">24</span></span><br><span class="line">&gt; a-b</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>矩阵相乘:</p>
<p>a%*%b</p>
<p><code>注意不是a*b,如果是a*b的话，只是把对应的元素相乘。</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=matrix(<span class="number">1</span>:<span class="number">12</span>,nrow=<span class="number">3</span>,ncol=<span class="number">4</span>)</span><br><span class="line">&gt; b=matrix(<span class="number">1</span>:<span class="number">12</span>,nrow=<span class="number">4</span>,ncol=<span class="number">3</span>)</span><br><span class="line">&gt; a%*%b</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,]   <span class="number">70</span>  <span class="number">158</span>  <span class="number">246</span></span><br><span class="line">[<span class="number">2</span>,]   <span class="number">80</span>  <span class="number">184</span>  <span class="number">288</span></span><br><span class="line">[<span class="number">3</span>,]   <span class="number">90</span>  <span class="number">210</span>  <span class="number">330</span></span><br></pre></td></tr></table></figure>
<h4 id="diag-函数，求对角线"><a href="#diag-函数，求对角线" class="headerlink" title="diag()函数，求对角线"></a>diag()函数，求对角线</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=matrix(<span class="number">1</span>:<span class="number">16</span>,nrow=<span class="number">4</span>,ncol=<span class="number">4</span>)</span><br><span class="line">&gt; a</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">5</span>    <span class="number">9</span>   <span class="number">13</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">6</span>   <span class="number">10</span>   <span class="number">14</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">3</span>    <span class="number">7</span>   <span class="number">11</span>   <span class="number">15</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">4</span>    <span class="number">8</span>   <span class="number">12</span>   <span class="number">16</span></span><br><span class="line">&gt; diag(a)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">6</span> <span class="number">11</span> <span class="number">16</span></span><br><span class="line">&gt; diag(diag(a))</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">0</span>    <span class="number">6</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">0</span>    <span class="number">0</span>   <span class="number">11</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>得到一个行列数为4的对角线为1的单位矩阵：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; diag(<span class="number">4</span>)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="rnorm"><a href="#rnorm" class="headerlink" title="rnorm()"></a>rnorm()</h4><p>rnorm()函数，按照正态分布，取出若干个随机数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=matrix(rnorm(<span class="number">16</span>),<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">&gt; a</span><br><span class="line">          [,<span class="number">1</span>]         [,<span class="number">2</span>]       [,<span class="number">3</span>]       [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]  <span class="number">1.691672</span>  <span class="number">0.154788749</span>  <span class="number">0.7834991</span> -<span class="number">1.8964252</span></span><br><span class="line">[<span class="number">2</span>,]  <span class="number">1.388345</span>  <span class="number">0.922029319</span> -<span class="number">0.2400506</span>  <span class="number">0.1874301</span></span><br><span class="line">[<span class="number">3</span>,] -<span class="number">1.823898</span> -<span class="number">0.005734707</span> -<span class="number">1.3519814</span>  <span class="number">0.9270790</span></span><br><span class="line">[<span class="number">4</span>,] -<span class="number">0.267829</span>  <span class="number">0.763870795</span>  <span class="number">0.6594918</span>  <span class="number">0.9205407</span></span><br></pre></td></tr></table></figure>
<h4 id="solve"><a href="#solve" class="headerlink" title="solve()"></a>solve()</h4><p>solve()函数，求逆矩阵</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; solve(a)</span><br><span class="line">            [,<span class="number">1</span>]       [,<span class="number">2</span>]       [,<span class="number">3</span>]       [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,] -<span class="number">0.44792192</span>  <span class="number">0.4452669</span> -<span class="number">0.5585795</span> -<span class="number">0.4508867</span></span><br><span class="line">[<span class="number">2</span>,]  <span class="number">0.85187912</span>  <span class="number">0.2515954</span>  <span class="number">0.8583943</span>  <span class="number">0.8392558</span></span><br><span class="line">[<span class="number">3</span>,]  <span class="number">0.01781248</span> -<span class="number">0.4399525</span> -<span class="number">0.3953840</span>  <span class="number">0.5244663</span></span><br><span class="line">[<span class="number">4</span>,] -<span class="number">0.84997791</span>  <span class="number">0.2359636</span> -<span class="number">0.5915584</span> -<span class="number">0.1170234</span></span><br></pre></td></tr></table></figure>
<p>通过solve()函数解方程组：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=matrix(rnorm(<span class="number">16</span>),<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">&gt; a</span><br><span class="line">            [,<span class="number">1</span>]        [,<span class="number">2</span>]       [,<span class="number">3</span>]       [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,] -<span class="number">0.73318587</span>  <span class="number">1.87980710</span>  <span class="number">0.4991373</span> -<span class="number">0.1038004</span></span><br><span class="line">[<span class="number">2</span>,]  <span class="number">0.13700903</span> -<span class="number">0.19411509</span>  <span class="number">0.5412432</span> -<span class="number">0.8160280</span></span><br><span class="line">[<span class="number">3</span>,] -<span class="number">0.07649991</span>  <span class="number">0.01615857</span> -<span class="number">0.4907614</span> -<span class="number">2.3282147</span></span><br><span class="line">[<span class="number">4</span>,] -<span class="number">0.34977245</span>  <span class="number">0.25837835</span> -<span class="number">0.6195753</span>  <span class="number">0.1512799</span></span><br><span class="line">&gt; b=<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">4</span>)</span><br><span class="line">&gt; b</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">&gt; solve(a,b)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">29.246248</span> -<span class="number">12.182426</span>   <span class="number">4.634966</span>  -<span class="number">1.389123</span></span><br></pre></td></tr></table></figure>
<p>相当于在解这样一个方程组：</p>
<p>-0.73318587 <em> x1 + 1.87980710 </em> x2 + 0.4991373 <em> x3 -0.1038004 </em> x4 = 1</p>
<p>0.13700903 <em> x1 - 0.19411509 </em> x2 + 0.5412432 <em> x3 -0.8160280 </em> x4 = 1</p>
<p>-0.07649991 <em> x1 + 0.01615857 </em> x2 - 0.4907614 <em> x3 -2.3282147 </em> x4 = 1</p>
<p>-0.34977245 <em> x1 + 0.25837835 </em> x2 - 0.6195753 <em> x3 + 0.1512799 </em> x4 = 1</p>
<p>最终解为：</p>
<p>x1= -29.246248</p>
<p>x2= -12.182426</p>
<p>x3= 4.634966</p>
<p>x4= -1.389123</p>
<h4 id="eigen"><a href="#eigen" class="headerlink" title="eigen()"></a>eigen()</h4><p>eigen()求矩阵的特征值函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=diag(<span class="number">4</span>)+<span class="number">1</span></span><br><span class="line">&gt; a</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">1</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">&gt; a.e=eigen(a,symmetric=<span class="built_in">T</span>)</span><br><span class="line">&gt; a.e</span><br><span class="line">$values</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$vectors</span><br><span class="line">     [,<span class="number">1</span>]       [,<span class="number">2</span>]       [,<span class="number">3</span>]       [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,] -<span class="number">0.5</span>  <span class="number">0.8660254</span>  <span class="number">0.0000000</span>  <span class="number">0.0000000</span></span><br><span class="line">[<span class="number">2</span>,] -<span class="number">0.5</span> -<span class="number">0.2886751</span> -<span class="number">0.5773503</span> -<span class="number">0.5773503</span></span><br><span class="line">[<span class="number">3</span>,] -<span class="number">0.5</span> -<span class="number">0.2886751</span> -<span class="number">0.2113249</span>  <span class="number">0.7886751</span></span><br><span class="line">[<span class="number">4</span>,] -<span class="number">0.5</span> -<span class="number">0.2886751</span>  <span class="number">0.7886751</span> -<span class="number">0.2113249</span></span><br><span class="line">&gt; a.e$vectors%*%diag(a.e$values)%*%t(a.e$vectors)</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">3</span>,]    <span class="number">1</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line">[<span class="number">4</span>,]    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组  相当于加了纬度的向量</p>
<p>向量不是数组，矩阵是数组的一种特殊情况</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">6</span>)</span><br><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">&gt; is.vector(x)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; <span class="built_in">is.array</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></span><br><span class="line">&gt; <span class="built_in">dim</span>(x)&lt;-<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt; x</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span></span><br><span class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span></span><br><span class="line">&gt; <span class="built_in">is.array</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; <span class="built_in">is.matrix</span>(x)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<h3 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h3><p>形式类似矩阵，但不同的地方是矩阵必须元素都是数字，而数据框每一列可以是不同类型的数据（可以某一列是数字，某一列是字符）。</p>
<p>一般情况，每列是一个变量，每行是一个观测值。</p>
<p>data.frame(x1,x2) 将两个等长的向量组合成一个数据框，(一定要是等长的向量才可以组合)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x1=<span class="built_in">c</span>(<span class="number">10</span>,<span class="number">13</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">23</span>)</span><br><span class="line">&gt; x2=<span class="built_in">c</span>(<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>)</span><br><span class="line">&gt; x=data.frame(x1,x2)</span><br><span class="line">&gt; x</span><br><span class="line">  x1 x2</span><br><span class="line">1 <span class="number">10</span> <span class="number">22</span></span><br><span class="line">2 <span class="number">13</span> <span class="number">33</span></span><br><span class="line">3 <span class="number">45</span> <span class="number">44</span></span><br><span class="line">4 <span class="number">26</span> <span class="number">55</span></span><br><span class="line">5 <span class="number">23</span> <span class="number">66</span></span><br></pre></td></tr></table></figure>
<p>也可以制定表头</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=data.frame(<span class="string">&#x27;重量&#x27;</span>=x1,<span class="string">&#x27;运费&#x27;</span>=x2)</span><br><span class="line">&gt; x</span><br><span class="line">  重量 运费</span><br><span class="line">1   <span class="number">10</span>   <span class="number">22</span></span><br><span class="line">2   <span class="number">13</span>   <span class="number">33</span></span><br><span class="line">3   <span class="number">45</span>   <span class="number">44</span></span><br><span class="line">4   <span class="number">26</span>   <span class="number">55</span></span><br><span class="line">5   <span class="number">23</span>   <span class="number">66</span></span><br></pre></td></tr></table></figure>
<p>plot()函数绘制散点图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(x)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_01_06.png" alt="plot散点图"></p>
<hr>
<h3 id="从外部读取数据"><a href="#从外部读取数据" class="headerlink" title="从外部读取数据"></a>从外部读取数据</h3><p>先设置工作目录，把文本文件放于该目录下</p>
<p>首先工作目录下有一个”abc.txt”的文件：</p>
<p><img src="/img/r_01_07.png" alt="外部文件abc.txt"></p>
<p>在R中通过read.table()函数 读取外部文件中的数据：</p>
<p><img src="/img/r_01_08.png" alt="读取外部文件"></p>
<p>文本或excel的数据均可通过剪切板操作,”clipboard”是一个常量字符串，代表剪切板。</p>
<p><img src="/img/r_01_09.png" alt="读取粘贴板上的数据"></p>
<h4 id="读取excel文件数据"><a href="#读取excel文件数据" class="headerlink" title="读取excel文件数据"></a>读取excel文件数据</h4><p><strong>方法1:</strong>先把excel另存为空格分割的prn文本格式（以空格来分隔数据）再读</p>
<p><img src="/img/r_01_10.png" alt="读取prn文件"></p>
<p>或者可以另存为csv格式（以逗号来分隔数据），然后调用read.csv(“test.csv”,header=T)来读取。</p>
<p><strong>方法2:</strong>安装RODBC包，再通过ODBC读</p>
<p><img src="/img/r_01_11.png" alt="通过ODBC读取csv"></p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">59</span>)&#123;a[i]=i*<span class="number">2</span>+<span class="number">3</span>&#125;</span><br><span class="line">&gt; a</span><br><span class="line"> [<span class="number">1</span>]   <span class="number">5</span>   <span class="number">7</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span>  <span class="number">17</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">23</span>  <span class="number">25</span>  <span class="number">27</span>  <span class="number">29</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">37</span>  <span class="number">39</span>  <span class="number">41</span></span><br><span class="line">[<span class="number">20</span>]  <span class="number">43</span>  <span class="number">45</span>  <span class="number">47</span>  <span class="number">49</span>  <span class="number">51</span>  <span class="number">53</span>  <span class="number">55</span>  <span class="number">57</span>  <span class="number">59</span>  <span class="number">61</span>  <span class="number">63</span>  <span class="number">65</span>  <span class="number">67</span>  <span class="number">69</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">75</span>  <span class="number">77</span>  <span class="number">79</span></span><br><span class="line">[<span class="number">39</span>]  <span class="number">81</span>  <span class="number">83</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">89</span>  <span class="number">91</span>  <span class="number">93</span>  <span class="number">95</span>  <span class="number">97</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">103</span> <span class="number">105</span> <span class="number">107</span> <span class="number">109</span> <span class="number">111</span> <span class="number">113</span> <span class="number">115</span> <span class="number">117</span></span><br><span class="line">[<span class="number">58</span>] <span class="number">119</span> <span class="number">121</span></span><br></pre></td></tr></table></figure>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a[<span class="number">1</span>]=<span class="number">5</span></span><br><span class="line">&gt; i=<span class="number">1</span></span><br><span class="line">&gt; <span class="keyword">while</span>(a[i]&lt;<span class="number">121</span>)&#123;i=i+<span class="number">1</span>;a[i]=a[i-<span class="number">1</span>]+<span class="number">2</span>&#125;</span><br><span class="line">&gt; a</span><br><span class="line"> [<span class="number">1</span>]   <span class="number">5</span>   <span class="number">7</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span>  <span class="number">17</span>  <span class="number">19</span>  <span class="number">21</span>  <span class="number">23</span>  <span class="number">25</span>  <span class="number">27</span>  <span class="number">29</span>  <span class="number">31</span>  <span class="number">33</span>  <span class="number">35</span>  <span class="number">37</span>  <span class="number">39</span>  <span class="number">41</span></span><br><span class="line">[<span class="number">20</span>]  <span class="number">43</span>  <span class="number">45</span>  <span class="number">47</span>  <span class="number">49</span>  <span class="number">51</span>  <span class="number">53</span>  <span class="number">55</span>  <span class="number">57</span>  <span class="number">59</span>  <span class="number">61</span>  <span class="number">63</span>  <span class="number">65</span>  <span class="number">67</span>  <span class="number">69</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">75</span>  <span class="number">77</span>  <span class="number">79</span></span><br><span class="line">[<span class="number">39</span>]  <span class="number">81</span>  <span class="number">83</span>  <span class="number">85</span>  <span class="number">87</span>  <span class="number">89</span>  <span class="number">91</span>  <span class="number">93</span>  <span class="number">95</span>  <span class="number">97</span>  <span class="number">99</span> <span class="number">101</span> <span class="number">103</span> <span class="number">105</span> <span class="number">107</span> <span class="number">109</span> <span class="number">111</span> <span class="number">113</span> <span class="number">115</span> <span class="number">117</span></span><br><span class="line">[<span class="number">58</span>] <span class="number">119</span> <span class="number">121</span></span><br></pre></td></tr></table></figure>
<h3 id="执行外部脚本"><a href="#执行外部脚本" class="headerlink" title="执行外部脚本"></a>执行外部脚本</h3><h4 id="source-print"><a href="#source-print" class="headerlink" title="source() print()"></a>source() print()</h4><p>R语言出了在控制台中执行之外，也可以写成外部脚本。</p>
<p><img src="/img/r_01_12.png" alt="外部脚本"></p>
<p>脚本中的内容：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>写入脚本中的输出，必须使用print()函数才能打印出来。</p>
<p>通过source()函数可以执行脚本文件：</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; source(<span class="string">&quot;h.r&quot;</span>)</span><br><span class="line"> [<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></h2><h3 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h3><h4 id="正态分布函数-rnorm"><a href="#正态分布函数-rnorm" class="headerlink" title="正态分布函数 rnorm()"></a>正态分布函数 rnorm()</h4><p>产生100个正态分布的随机数，平均值是80，标准差是7:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; rnorm(<span class="number">100</span>,mean=<span class="number">80</span>,sd=<span class="number">7</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">91.84170</span> <span class="number">89.71842</span> <span class="number">67.23271</span> <span class="number">78.12520</span> <span class="number">81.08352</span> <span class="number">86.45421</span> <span class="number">79.95986</span> <span class="number">85.34710</span></span><br><span class="line">  [<span class="number">9</span>] <span class="number">85.48449</span> <span class="number">78.31965</span> <span class="number">70.53613</span> <span class="number">84.61644</span> <span class="number">66.72502</span> <span class="number">81.31201</span> <span class="number">86.48955</span> <span class="number">86.44378</span></span><br><span class="line"> [<span class="number">17</span>] <span class="number">74.86770</span> <span class="number">80.95906</span> <span class="number">79.46450</span> <span class="number">77.55159</span> <span class="number">93.15865</span> <span class="number">78.64119</span> <span class="number">80.11311</span> <span class="number">81.80865</span></span><br><span class="line"> [<span class="number">25</span>] <span class="number">83.49396</span> <span class="number">83.78870</span> <span class="number">76.56467</span> <span class="number">75.66297</span> <span class="number">79.27340</span> <span class="number">74.28780</span> <span class="number">63.70250</span> <span class="number">81.05896</span></span><br><span class="line"> [<span class="number">33</span>] <span class="number">86.11023</span> <span class="number">84.20057</span> <span class="number">73.15261</span> <span class="number">81.13779</span> <span class="number">89.98181</span> <span class="number">71.93431</span> <span class="number">70.49228</span> <span class="number">77.61948</span></span><br><span class="line"> [<span class="number">41</span>] <span class="number">79.40982</span> <span class="number">78.53584</span> <span class="number">71.21602</span> <span class="number">73.33143</span> <span class="number">92.46275</span> <span class="number">75.92289</span> <span class="number">75.94395</span> <span class="number">75.28812</span></span><br><span class="line"> [<span class="number">49</span>] <span class="number">74.10398</span> <span class="number">79.39188</span> <span class="number">73.27445</span> <span class="number">95.29717</span> <span class="number">84.59038</span> <span class="number">81.25490</span> <span class="number">87.83171</span> <span class="number">62.59891</span></span><br><span class="line"> [<span class="number">57</span>] <span class="number">78.97906</span> <span class="number">91.78480</span> <span class="number">90.82124</span> <span class="number">83.91811</span> <span class="number">77.69758</span> <span class="number">78.35002</span> <span class="number">81.41204</span> <span class="number">78.43336</span></span><br><span class="line"> [<span class="number">65</span>] <span class="number">78.50897</span> <span class="number">83.49485</span> <span class="number">86.27006</span> <span class="number">75.10600</span> <span class="number">73.42888</span> <span class="number">79.37818</span> <span class="number">82.71879</span> <span class="number">82.94783</span></span><br><span class="line"> [<span class="number">73</span>] <span class="number">63.24346</span> <span class="number">82.08028</span> <span class="number">77.65782</span> <span class="number">81.06058</span> <span class="number">62.43572</span> <span class="number">79.50682</span> <span class="number">87.96813</span> <span class="number">70.42317</span></span><br><span class="line"> [<span class="number">81</span>] <span class="number">78.87907</span> <span class="number">72.35188</span> <span class="number">76.39345</span> <span class="number">69.57194</span> <span class="number">77.76283</span> <span class="number">88.07266</span> <span class="number">68.14906</span> <span class="number">60.45371</span></span><br><span class="line"> [<span class="number">89</span>] <span class="number">80.58541</span> <span class="number">80.46402</span> <span class="number">89.73413</span> <span class="number">82.27584</span> <span class="number">85.80826</span> <span class="number">80.18303</span> <span class="number">93.81132</span> <span class="number">83.20696</span></span><br><span class="line"> [<span class="number">97</span>] <span class="number">85.48223</span> <span class="number">99.15548</span> <span class="number">80.25896</span> <span class="number">83.88441</span></span><br></pre></td></tr></table></figure>
<h4 id="泊松分布函数rpois"><a href="#泊松分布函数rpois" class="headerlink" title="泊松分布函数rpois()"></a>泊松分布函数rpois()</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; rpois(<span class="number">100</span>,<span class="number">1</span>:<span class="number">9</span>)</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">2</span>  <span class="number">1</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">9</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span> <span class="number">12</span>  <span class="number">8</span> <span class="number">10</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">5</span>  <span class="number">8</span></span><br><span class="line"> [<span class="number">26</span>]  <span class="number">8</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">6</span> <span class="number">12</span>  <span class="number">8</span>  <span class="number">4</span> <span class="number">10</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">6</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">4</span></span><br><span class="line"> [<span class="number">51</span>]  <span class="number">5</span>  <span class="number">3</span> <span class="number">12</span> <span class="number">11</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">5</span> <span class="number">11</span>  <span class="number">6</span> <span class="number">10</span>  <span class="number">9</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"> [<span class="number">76</span>]  <span class="number">5</span>  <span class="number">8</span>  <span class="number">4</span>  <span class="number">9</span> <span class="number">11</span>  <span class="number">5</span>  <span class="number">0</span>  <span class="number">4</span>  <span class="number">2</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">10</span>  <span class="number">9</span> <span class="number">12</span>  <span class="number">7</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">2</span> <span class="number">10</span> <span class="number">11</span> <span class="number">13</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="指数分布函数rexp"><a href="#指数分布函数rexp" class="headerlink" title="指数分布函数rexp()"></a>指数分布函数rexp()</h4><h4 id="gamma分布函数rgamma"><a href="#gamma分布函数rgamma" class="headerlink" title="gamma分布函数rgamma()"></a>gamma分布函数rgamma()</h4><h4 id="均匀分布函数runif"><a href="#均匀分布函数runif" class="headerlink" title="均匀分布函数runif()"></a>均匀分布函数runif()</h4><p>产生100个均匀分布的80到100的随机数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; runif(<span class="number">100</span>,<span class="built_in">min</span>=<span class="number">80</span>,<span class="built_in">max</span>=<span class="number">100</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">82.32568</span> <span class="number">82.02504</span> <span class="number">94.93998</span> <span class="number">97.56770</span> <span class="number">88.23401</span> <span class="number">88.74055</span> <span class="number">98.43785</span> <span class="number">94.25619</span></span><br><span class="line">  [<span class="number">9</span>] <span class="number">81.32116</span> <span class="number">84.68563</span> <span class="number">94.29525</span> <span class="number">92.97103</span> <span class="number">82.97045</span> <span class="number">99.32680</span> <span class="number">94.50783</span> <span class="number">96.61253</span></span><br><span class="line"> [<span class="number">17</span>] <span class="number">98.53980</span> <span class="number">95.93528</span> <span class="number">92.12032</span> <span class="number">92.76401</span> <span class="number">85.38213</span> <span class="number">84.43117</span> <span class="number">96.86250</span> <span class="number">84.69108</span></span><br><span class="line"> [<span class="number">25</span>] <span class="number">91.17830</span> <span class="number">82.79405</span> <span class="number">94.58394</span> <span class="number">84.90274</span> <span class="number">84.07085</span> <span class="number">83.87202</span> <span class="number">82.59535</span> <span class="number">88.50601</span></span><br><span class="line"> [<span class="number">33</span>] <span class="number">83.38860</span> <span class="number">81.65984</span> <span class="number">95.71859</span> <span class="number">83.73108</span> <span class="number">88.13112</span> <span class="number">90.18066</span> <span class="number">96.21735</span> <span class="number">89.05043</span></span><br><span class="line"> [<span class="number">41</span>] <span class="number">88.48573</span> <span class="number">96.24177</span> <span class="number">89.48188</span> <span class="number">85.85154</span> <span class="number">83.67180</span> <span class="number">84.38839</span> <span class="number">85.30037</span> <span class="number">93.55860</span></span><br><span class="line"> [<span class="number">49</span>] <span class="number">81.74515</span> <span class="number">86.87908</span> <span class="number">89.86651</span> <span class="number">83.78685</span> <span class="number">96.95712</span> <span class="number">92.91492</span> <span class="number">80.78897</span> <span class="number">87.21055</span></span><br><span class="line"> [<span class="number">57</span>] <span class="number">86.64808</span> <span class="number">80.24332</span> <span class="number">98.48211</span> <span class="number">91.42558</span> <span class="number">99.35341</span> <span class="number">81.53274</span> <span class="number">84.49945</span> <span class="number">80.28354</span></span><br><span class="line"> [<span class="number">65</span>] <span class="number">89.47206</span> <span class="number">81.66101</span> <span class="number">85.38194</span> <span class="number">81.64460</span> <span class="number">98.43649</span> <span class="number">84.28751</span> <span class="number">85.85431</span> <span class="number">84.08602</span></span><br><span class="line"> [<span class="number">73</span>] <span class="number">82.29368</span> <span class="number">95.23472</span> <span class="number">84.10213</span> <span class="number">89.61257</span> <span class="number">90.84469</span> <span class="number">94.17226</span> <span class="number">98.69019</span> <span class="number">87.96953</span></span><br><span class="line"> [<span class="number">81</span>] <span class="number">91.89866</span> <span class="number">92.23568</span> <span class="number">94.01739</span> <span class="number">91.93723</span> <span class="number">93.71547</span> <span class="number">88.28105</span> <span class="number">88.27131</span> <span class="number">88.09687</span></span><br><span class="line"> [<span class="number">89</span>] <span class="number">94.74121</span> <span class="number">86.47239</span> <span class="number">85.55283</span> <span class="number">94.90056</span> <span class="number">93.91155</span> <span class="number">86.16455</span> <span class="number">84.53169</span> <span class="number">97.29593</span></span><br><span class="line"> [<span class="number">97</span>] <span class="number">93.21098</span> <span class="number">94.80586</span> <span class="number">80.71853</span> <span class="number">91.62332</span></span><br></pre></td></tr></table></figure>
<h4 id="二项分布函数rbinom"><a href="#二项分布函数rbinom" class="headerlink" title="二项分布函数rbinom()"></a>二项分布函数rbinom()</h4><h4 id="几何分布函数rgeom"><a href="#几何分布函数rgeom" class="headerlink" title="几何分布函数rgeom()"></a>几何分布函数rgeom()</h4><hr>
<h3 id="四舍五入-round"><a href="#四舍五入-round" class="headerlink" title="四舍五入 round()"></a>四舍五入 round()</h3><p>产生100个正态分布的随机数，平均值是80，标准差是7，对取出的元素进行四舍五入处理:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">round</span>(rnorm(<span class="number">100</span>,mean=<span class="number">80</span>,sd=<span class="number">7</span>))</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">79</span>  <span class="number">75</span>  <span class="number">93</span>  <span class="number">96</span>  <span class="number">82</span>  <span class="number">70</span>  <span class="number">83</span>  <span class="number">77</span>  <span class="number">78</span>  <span class="number">84</span>  <span class="number">79</span>  <span class="number">80</span>  <span class="number">78</span>  <span class="number">81</span>  <span class="number">77</span>  <span class="number">67</span>  <span class="number">73</span>  <span class="number">76</span></span><br><span class="line"> [<span class="number">19</span>]  <span class="number">86</span>  <span class="number">76</span>  <span class="number">80</span>  <span class="number">84</span>  <span class="number">83</span>  <span class="number">88</span>  <span class="number">73</span>  <span class="number">86</span>  <span class="number">79</span>  <span class="number">80</span>  <span class="number">89</span>  <span class="number">88</span>  <span class="number">63</span>  <span class="number">79</span>  <span class="number">82</span>  <span class="number">78</span>  <span class="number">82</span>  <span class="number">75</span></span><br><span class="line"> [<span class="number">37</span>]  <span class="number">81</span>  <span class="number">87</span>  <span class="number">89</span>  <span class="number">89</span>  <span class="number">79</span>  <span class="number">76</span>  <span class="number">81</span>  <span class="number">93</span>  <span class="number">75</span>  <span class="number">73</span>  <span class="number">77</span>  <span class="number">74</span>  <span class="number">71</span>  <span class="number">83</span>  <span class="number">69</span>  <span class="number">77</span>  <span class="number">88</span>  <span class="number">74</span></span><br><span class="line"> [<span class="number">55</span>]  <span class="number">78</span>  <span class="number">75</span>  <span class="number">79</span>  <span class="number">71</span>  <span class="number">87</span>  <span class="number">91</span>  <span class="number">87</span>  <span class="number">71</span>  <span class="number">84</span>  <span class="number">74</span>  <span class="number">76</span>  <span class="number">90</span> <span class="number">102</span>  <span class="number">75</span>  <span class="number">78</span>  <span class="number">91</span>  <span class="number">84</span>  <span class="number">87</span></span><br><span class="line"> [<span class="number">73</span>]  <span class="number">71</span>  <span class="number">78</span>  <span class="number">75</span>  <span class="number">83</span>  <span class="number">76</span>  <span class="number">78</span>  <span class="number">80</span>  <span class="number">78</span>  <span class="number">83</span>  <span class="number">79</span>  <span class="number">92</span>  <span class="number">90</span>  <span class="number">92</span>  <span class="number">78</span>  <span class="number">74</span>  <span class="number">80</span>  <span class="number">86</span>  <span class="number">82</span></span><br><span class="line"> [<span class="number">91</span>]  <span class="number">80</span>  <span class="number">79</span>  <span class="number">78</span>  <span class="number">72</span>  <span class="number">69</span>  <span class="number">77</span>  <span class="number">84</span>  <span class="number">80</span>  <span class="number">94</span>  <span class="number">71</span></span><br></pre></td></tr></table></figure>
<h2 id="一个综合训练"><a href="#一个综合训练" class="headerlink" title="一个综合训练"></a>一个综合训练</h2><p>模拟产生统计专业同学的名单（学号区分），记录数学分析，线性代数，概率统计三科成绩，然后进行一些统计分析。</p>
<p>产生一百个学号：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; num=seq(<span class="number">10378001</span>,<span class="number">10378100</span>)</span><br><span class="line">&gt; num</span><br><span class="line">  [<span class="number">1</span>] <span class="number">10378001</span> <span class="number">10378002</span> <span class="number">10378003</span> <span class="number">10378004</span> <span class="number">10378005</span> <span class="number">10378006</span> <span class="number">10378007</span> <span class="number">10378008</span></span><br><span class="line">  [<span class="number">9</span>] <span class="number">10378009</span> <span class="number">10378010</span> <span class="number">10378011</span> <span class="number">10378012</span> <span class="number">10378013</span> <span class="number">10378014</span> <span class="number">10378015</span> <span class="number">10378016</span></span><br><span class="line"> [<span class="number">17</span>] <span class="number">10378017</span> <span class="number">10378018</span> <span class="number">10378019</span> <span class="number">10378020</span> <span class="number">10378021</span> <span class="number">10378022</span> <span class="number">10378023</span> <span class="number">10378024</span></span><br><span class="line"> [<span class="number">25</span>] <span class="number">10378025</span> <span class="number">10378026</span> <span class="number">10378027</span> <span class="number">10378028</span> <span class="number">10378029</span> <span class="number">10378030</span> <span class="number">10378031</span> <span class="number">10378032</span></span><br><span class="line"> [<span class="number">33</span>] <span class="number">10378033</span> <span class="number">10378034</span> <span class="number">10378035</span> <span class="number">10378036</span> <span class="number">10378037</span> <span class="number">10378038</span> <span class="number">10378039</span> <span class="number">10378040</span></span><br><span class="line"> [<span class="number">41</span>] <span class="number">10378041</span> <span class="number">10378042</span> <span class="number">10378043</span> <span class="number">10378044</span> <span class="number">10378045</span> <span class="number">10378046</span> <span class="number">10378047</span> <span class="number">10378048</span></span><br><span class="line"> [<span class="number">49</span>] <span class="number">10378049</span> <span class="number">10378050</span> <span class="number">10378051</span> <span class="number">10378052</span> <span class="number">10378053</span> <span class="number">10378054</span> <span class="number">10378055</span> <span class="number">10378056</span></span><br><span class="line"> [<span class="number">57</span>] <span class="number">10378057</span> <span class="number">10378058</span> <span class="number">10378059</span> <span class="number">10378060</span> <span class="number">10378061</span> <span class="number">10378062</span> <span class="number">10378063</span> <span class="number">10378064</span></span><br><span class="line"> [<span class="number">65</span>] <span class="number">10378065</span> <span class="number">10378066</span> <span class="number">10378067</span> <span class="number">10378068</span> <span class="number">10378069</span> <span class="number">10378070</span> <span class="number">10378071</span> <span class="number">10378072</span></span><br><span class="line"> [<span class="number">73</span>] <span class="number">10378073</span> <span class="number">10378074</span> <span class="number">10378075</span> <span class="number">10378076</span> <span class="number">10378077</span> <span class="number">10378078</span> <span class="number">10378079</span> <span class="number">10378080</span></span><br><span class="line"> [<span class="number">81</span>] <span class="number">10378081</span> <span class="number">10378082</span> <span class="number">10378083</span> <span class="number">10378084</span> <span class="number">10378085</span> <span class="number">10378086</span> <span class="number">10378087</span> <span class="number">10378088</span></span><br><span class="line"> [<span class="number">89</span>] <span class="number">10378089</span> <span class="number">10378090</span> <span class="number">10378091</span> <span class="number">10378092</span> <span class="number">10378093</span> <span class="number">10378094</span> <span class="number">10378095</span> <span class="number">10378096</span></span><br><span class="line"> [<span class="number">97</span>] <span class="number">10378097</span> <span class="number">10378098</span> <span class="number">10378099</span> <span class="number">10378100</span></span><br></pre></td></tr></table></figure>
<p>产生100个均匀分布的80到100的随机数，round()函数取整数部分进行四舍五入:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x1=<span class="built_in">round</span>(runif(<span class="number">100</span>,<span class="built_in">min</span>=<span class="number">80</span>,<span class="built_in">max</span>=<span class="number">100</span>))</span><br><span class="line">&gt; x1</span><br><span class="line">  [<span class="number">1</span>] <span class="number">100</span> <span class="number">100</span>  <span class="number">81</span>  <span class="number">81</span>  <span class="number">88</span>  <span class="number">88</span>  <span class="number">95</span>  <span class="number">84</span>  <span class="number">93</span>  <span class="number">83</span>  <span class="number">97</span>  <span class="number">87</span>  <span class="number">87</span>  <span class="number">86</span>  <span class="number">98</span>  <span class="number">82</span>  <span class="number">89</span>  <span class="number">82</span></span><br><span class="line"> [<span class="number">19</span>]  <span class="number">87</span>  <span class="number">82</span>  <span class="number">82</span>  <span class="number">86</span>  <span class="number">90</span>  <span class="number">83</span>  <span class="number">98</span>  <span class="number">91</span>  <span class="number">90</span>  <span class="number">94</span>  <span class="number">94</span>  <span class="number">88</span>  <span class="number">85</span>  <span class="number">92</span>  <span class="number">87</span>  <span class="number">88</span>  <span class="number">88</span>  <span class="number">93</span></span><br><span class="line"> [<span class="number">37</span>]  <span class="number">86</span>  <span class="number">88</span>  <span class="number">97</span>  <span class="number">92</span>  <span class="number">90</span>  <span class="number">94</span> <span class="number">100</span>  <span class="number">91</span>  <span class="number">87</span>  <span class="number">98</span>  <span class="number">83</span>  <span class="number">92</span>  <span class="number">96</span>  <span class="number">86</span>  <span class="number">90</span>  <span class="number">93</span>  <span class="number">97</span>  <span class="number">95</span></span><br><span class="line"> [<span class="number">55</span>]  <span class="number">80</span>  <span class="number">89</span>  <span class="number">86</span>  <span class="number">81</span>  <span class="number">98</span>  <span class="number">90</span>  <span class="number">82</span>  <span class="number">90</span>  <span class="number">95</span>  <span class="number">90</span>  <span class="number">87</span>  <span class="number">81</span>  <span class="number">92</span>  <span class="number">88</span>  <span class="number">81</span>  <span class="number">86</span>  <span class="number">88</span>  <span class="number">97</span></span><br><span class="line"> [<span class="number">73</span>]  <span class="number">93</span>  <span class="number">88</span>  <span class="number">96</span>  <span class="number">85</span>  <span class="number">90</span>  <span class="number">90</span>  <span class="number">91</span>  <span class="number">90</span>  <span class="number">87</span>  <span class="number">91</span>  <span class="number">96</span>  <span class="number">95</span>  <span class="number">94</span>  <span class="number">96</span>  <span class="number">91</span>  <span class="number">90</span>  <span class="number">82</span>  <span class="number">81</span></span><br><span class="line"> [<span class="number">91</span>]  <span class="number">88</span>  <span class="number">98</span>  <span class="number">89</span> <span class="number">100</span>  <span class="number">92</span>  <span class="number">85</span>  <span class="number">81</span>  <span class="number">82</span> <span class="number">100</span>  <span class="number">83</span></span><br></pre></td></tr></table></figure>
<p>产生100个随机元素，平均值是80，标准差是7：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x2=<span class="built_in">round</span>(rnorm(<span class="number">100</span>,mean=<span class="number">80</span>,sd=<span class="number">7</span>))</span><br><span class="line">&gt; x2</span><br><span class="line">  [<span class="number">1</span>] <span class="number">75</span> <span class="number">78</span> <span class="number">81</span> <span class="number">66</span> <span class="number">86</span> <span class="number">80</span> <span class="number">77</span> <span class="number">80</span> <span class="number">79</span> <span class="number">74</span> <span class="number">76</span> <span class="number">82</span> <span class="number">76</span> <span class="number">74</span> <span class="number">77</span> <span class="number">84</span> <span class="number">75</span> <span class="number">77</span> <span class="number">86</span> <span class="number">68</span> <span class="number">88</span> <span class="number">71</span> <span class="number">83</span> <span class="number">83</span> <span class="number">61</span></span><br><span class="line"> [<span class="number">26</span>] <span class="number">83</span> <span class="number">79</span> <span class="number">93</span> <span class="number">77</span> <span class="number">75</span> <span class="number">78</span> <span class="number">91</span> <span class="number">82</span> <span class="number">73</span> <span class="number">84</span> <span class="number">86</span> <span class="number">80</span> <span class="number">79</span> <span class="number">88</span> <span class="number">79</span> <span class="number">66</span> <span class="number">85</span> <span class="number">75</span> <span class="number">81</span> <span class="number">75</span> <span class="number">69</span> <span class="number">82</span> <span class="number">80</span> <span class="number">84</span> <span class="number">78</span></span><br><span class="line"> [<span class="number">51</span>] <span class="number">67</span> <span class="number">92</span> <span class="number">97</span> <span class="number">90</span> <span class="number">65</span> <span class="number">77</span> <span class="number">74</span> <span class="number">84</span> <span class="number">82</span> <span class="number">83</span> <span class="number">74</span> <span class="number">86</span> <span class="number">83</span> <span class="number">79</span> <span class="number">80</span> <span class="number">90</span> <span class="number">74</span> <span class="number">81</span> <span class="number">72</span> <span class="number">83</span> <span class="number">79</span> <span class="number">80</span> <span class="number">70</span> <span class="number">71</span> <span class="number">95</span></span><br><span class="line"> [<span class="number">76</span>] <span class="number">71</span> <span class="number">78</span> <span class="number">87</span> <span class="number">79</span> <span class="number">82</span> <span class="number">75</span> <span class="number">85</span> <span class="number">80</span> <span class="number">78</span> <span class="number">83</span> <span class="number">79</span> <span class="number">77</span> <span class="number">88</span> <span class="number">80</span> <span class="number">77</span> <span class="number">75</span> <span class="number">84</span> <span class="number">84</span> <span class="number">87</span> <span class="number">78</span> <span class="number">77</span> <span class="number">74</span> <span class="number">76</span> <span class="number">86</span> <span class="number">84</span></span><br></pre></td></tr></table></figure>
<p>产生100个随机元素，平均值是83，标准差是18，由于标准差比较大，所以可能会产生大于100的错误数据，所以要对大于100的数据进行处理，通过which()函数取出大于100的元素下标，设置为100</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x3=<span class="built_in">round</span>(rnorm(<span class="number">100</span>,mean=<span class="number">83</span>,sd=<span class="number">18</span>))</span><br><span class="line">&gt; x3</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">81</span>  <span class="number">81</span>  <span class="number">74</span>  <span class="number">80</span> <span class="number">102</span>  <span class="number">88</span>  <span class="number">65</span>  <span class="number">80</span>  <span class="number">82</span>  <span class="number">66</span>  <span class="number">70</span>  <span class="number">76</span> <span class="number">102</span>  <span class="number">58</span>  <span class="number">63</span> <span class="number">122</span>  <span class="number">70</span>  <span class="number">71</span></span><br><span class="line"> [<span class="number">19</span>] <span class="number">103</span>  <span class="number">92</span>  <span class="number">65</span>  <span class="number">66</span>  <span class="number">45</span>  <span class="number">86</span>  <span class="number">98</span>  <span class="number">68</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">96</span>  <span class="number">85</span>  <span class="number">86</span> <span class="number">112</span>  <span class="number">58</span>  <span class="number">68</span> <span class="number">111</span>  <span class="number">66</span></span><br><span class="line"> [<span class="number">37</span>]  <span class="number">90</span> <span class="number">104</span> <span class="number">112</span>  <span class="number">48</span>  <span class="number">94</span>  <span class="number">83</span>  <span class="number">74</span>  <span class="number">81</span>  <span class="number">84</span> <span class="number">120</span>  <span class="number">94</span>  <span class="number">79</span>  <span class="number">79</span>  <span class="number">44</span>  <span class="number">95</span>  <span class="number">71</span>  <span class="number">68</span>  <span class="number">86</span></span><br><span class="line"> [<span class="number">55</span>]  <span class="number">80</span>  <span class="number">63</span>  <span class="number">73</span>  <span class="number">95</span>  <span class="number">81</span> <span class="number">113</span>  <span class="number">56</span>  <span class="number">64</span> <span class="number">100</span>  <span class="number">68</span> <span class="number">107</span>  <span class="number">74</span> <span class="number">109</span> <span class="number">123</span> <span class="number">102</span>  <span class="number">70</span>  <span class="number">66</span>  <span class="number">75</span></span><br><span class="line"> [<span class="number">73</span>]  <span class="number">70</span>  <span class="number">48</span>  <span class="number">86</span>  <span class="number">56</span>  <span class="number">74</span>  <span class="number">86</span>  <span class="number">79</span>  <span class="number">75</span>  <span class="number">67</span>  <span class="number">50</span>  <span class="number">68</span>  <span class="number">96</span>  <span class="number">93</span>  <span class="number">60</span> <span class="number">124</span> <span class="number">111</span>  <span class="number">77</span>  <span class="number">82</span></span><br><span class="line"> [<span class="number">91</span>]  <span class="number">65</span>  <span class="number">93</span> <span class="number">121</span>  <span class="number">69</span>  <span class="number">69</span> <span class="number">106</span>  <span class="number">75</span>  <span class="number">98</span>  <span class="number">99</span>  <span class="number">87</span></span><br><span class="line">&gt; x3[which(x3&gt;<span class="number">100</span>)]=<span class="number">100</span></span><br><span class="line">&gt; x3</span><br><span class="line">  [<span class="number">1</span>]  <span class="number">81</span>  <span class="number">81</span>  <span class="number">74</span>  <span class="number">80</span> <span class="number">100</span>  <span class="number">88</span>  <span class="number">65</span>  <span class="number">80</span>  <span class="number">82</span>  <span class="number">66</span>  <span class="number">70</span>  <span class="number">76</span> <span class="number">100</span>  <span class="number">58</span>  <span class="number">63</span> <span class="number">100</span>  <span class="number">70</span>  <span class="number">71</span></span><br><span class="line"> [<span class="number">19</span>] <span class="number">100</span>  <span class="number">92</span>  <span class="number">65</span>  <span class="number">66</span>  <span class="number">45</span>  <span class="number">86</span>  <span class="number">98</span>  <span class="number">68</span>  <span class="number">71</span>  <span class="number">73</span>  <span class="number">96</span>  <span class="number">85</span>  <span class="number">86</span> <span class="number">100</span>  <span class="number">58</span>  <span class="number">68</span> <span class="number">100</span>  <span class="number">66</span></span><br><span class="line"> [<span class="number">37</span>]  <span class="number">90</span> <span class="number">100</span> <span class="number">100</span>  <span class="number">48</span>  <span class="number">94</span>  <span class="number">83</span>  <span class="number">74</span>  <span class="number">81</span>  <span class="number">84</span> <span class="number">100</span>  <span class="number">94</span>  <span class="number">79</span>  <span class="number">79</span>  <span class="number">44</span>  <span class="number">95</span>  <span class="number">71</span>  <span class="number">68</span>  <span class="number">86</span></span><br><span class="line"> [<span class="number">55</span>]  <span class="number">80</span>  <span class="number">63</span>  <span class="number">73</span>  <span class="number">95</span>  <span class="number">81</span> <span class="number">100</span>  <span class="number">56</span>  <span class="number">64</span> <span class="number">100</span>  <span class="number">68</span> <span class="number">100</span>  <span class="number">74</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span>  <span class="number">70</span>  <span class="number">66</span>  <span class="number">75</span></span><br><span class="line"> [<span class="number">73</span>]  <span class="number">70</span>  <span class="number">48</span>  <span class="number">86</span>  <span class="number">56</span>  <span class="number">74</span>  <span class="number">86</span>  <span class="number">79</span>  <span class="number">75</span>  <span class="number">67</span>  <span class="number">50</span>  <span class="number">68</span>  <span class="number">96</span>  <span class="number">93</span>  <span class="number">60</span> <span class="number">100</span> <span class="number">100</span>  <span class="number">77</span>  <span class="number">82</span></span><br><span class="line"> [<span class="number">91</span>]  <span class="number">65</span>  <span class="number">93</span> <span class="number">100</span>  <span class="number">69</span>  <span class="number">69</span> <span class="number">100</span>  <span class="number">75</span>  <span class="number">98</span>  <span class="number">99</span>  <span class="number">87</span></span><br></pre></td></tr></table></figure>
<p>通过data.frame()函数，将数据合成数据框：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=data.frame(num,x1,x2,x3)</span><br><span class="line">&gt; x</span><br><span class="line">         num  x1 x2  x3</span><br><span class="line">1   <span class="number">10378001</span> <span class="number">100</span> <span class="number">75</span>  <span class="number">81</span></span><br><span class="line">2   <span class="number">10378002</span> <span class="number">100</span> <span class="number">78</span>  <span class="number">81</span></span><br><span class="line">3   <span class="number">10378003</span>  <span class="number">81</span> <span class="number">81</span>  <span class="number">74</span></span><br><span class="line">4   <span class="number">10378004</span>  <span class="number">81</span> <span class="number">66</span>  <span class="number">80</span></span><br><span class="line">5   <span class="number">10378005</span>  <span class="number">88</span> <span class="number">86</span> <span class="number">100</span></span><br><span class="line">6   <span class="number">10378006</span>  <span class="number">88</span> <span class="number">80</span>  <span class="number">88</span></span><br><span class="line">7   <span class="number">10378007</span>  <span class="number">95</span> <span class="number">77</span>  <span class="number">65</span></span><br><span class="line">8   <span class="number">10378008</span>  <span class="number">84</span> <span class="number">80</span>  <span class="number">80</span></span><br><span class="line">9   <span class="number">10378009</span>  <span class="number">93</span> <span class="number">79</span>  <span class="number">82</span></span><br><span class="line">10  <span class="number">10378010</span>  <span class="number">83</span> <span class="number">74</span>  <span class="number">66</span></span><br><span class="line">11  <span class="number">10378011</span>  <span class="number">97</span> <span class="number">76</span>  <span class="number">70</span></span><br><span class="line">12  <span class="number">10378012</span>  <span class="number">87</span> <span class="number">82</span>  <span class="number">76</span></span><br><span class="line">13  <span class="number">10378013</span>  <span class="number">87</span> <span class="number">76</span> <span class="number">100</span></span><br><span class="line">14  <span class="number">10378014</span>  <span class="number">86</span> <span class="number">74</span>  <span class="number">58</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过write.table()函数，将数据保存到硬盘上。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write.table(x,file=<span class="string">&quot;mark.txt&quot;</span>,col.names=<span class="built_in">F</span>,row.names=<span class="built_in">F</span>,sep=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>(这里也可以写绝对路径。默认路径就是当前工作空间。)</code></p>
<p><img src="/img/r_01_13.png" alt="输出文件"></p>
<hr>
<p>开始分析数据：<br>计算各科平均分：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mean(x[<span class="number">1</span>])</span><br><span class="line">[<span class="number">1</span>] <span class="literal">NA</span></span><br><span class="line">警告信息：</span><br><span class="line">In mean.default(x[<span class="number">1</span>]) : 参数不是数值也不是逻辑值：回覆<span class="literal">NA</span></span><br><span class="line">&gt; colMeans(x)</span><br><span class="line">        num          x1          x2          x3 </span><br><span class="line">10378050.50       <span class="number">89.59</span>       <span class="number">79.51</span>       <span class="number">79.85</span> </span><br><span class="line">&gt; colMeans(x)[<span class="built_in">c</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;x3&quot;</span>)]</span><br><span class="line">   x1    x2    x3 </span><br><span class="line">89.59 <span class="number">79.51</span> <span class="number">79.85</span> </span><br><span class="line">&gt; apply(x,<span class="number">2</span>,mean)</span><br><span class="line">        num          x1          x2          x3 </span><br><span class="line">10378050.50       <span class="number">89.59</span>       <span class="number">79.51</span>       <span class="number">79.85</span> </span><br></pre></td></tr></table></figure>
<p>cloMeans()对列求平均值</p>
<p>apply(x,2,mean)</p>
<pre><code> 第一个参数代表要操作的数据框，
 第二个参数如果是1的话代表在行上做操作，如果是2的话，代表在列上做操作
 第三个参数代表操作类型，mean是求平均数
</code></pre><p>求各科的最高分，最低分</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; apply(x,<span class="number">2</span>,<span class="built_in">max</span>)</span><br><span class="line">     num       x1       x2       x3 </span><br><span class="line">10378100      <span class="number">100</span>       <span class="number">97</span>      <span class="number">100</span> </span><br><span class="line">&gt; apply(x,<span class="number">2</span>,<span class="built_in">min</span>)</span><br><span class="line">     num       x1       x2       x3 </span><br><span class="line">10378001       <span class="number">80</span>       <span class="number">61</span>       <span class="number">44</span> </span><br></pre></td></tr></table></figure>
<p>求每个人的总分：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; apply(x[<span class="built_in">c</span>(<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;x3&quot;</span>)],<span class="number">1</span>,<span class="built_in">sum</span>)</span><br><span class="line">  [<span class="number">1</span>] <span class="number">256</span> <span class="number">259</span> <span class="number">236</span> <span class="number">227</span> <span class="number">274</span> <span class="number">256</span> <span class="number">237</span> <span class="number">244</span> <span class="number">254</span> <span class="number">223</span> <span class="number">243</span> <span class="number">245</span> <span class="number">263</span> <span class="number">218</span> <span class="number">238</span> <span class="number">266</span> <span class="number">234</span> <span class="number">230</span></span><br><span class="line"> [<span class="number">19</span>] <span class="number">273</span> <span class="number">242</span> <span class="number">235</span> <span class="number">223</span> <span class="number">218</span> <span class="number">252</span> <span class="number">257</span> <span class="number">242</span> <span class="number">240</span> <span class="number">260</span> <span class="number">267</span> <span class="number">248</span> <span class="number">249</span> <span class="number">283</span> <span class="number">227</span> <span class="number">229</span> <span class="number">272</span> <span class="number">245</span></span><br><span class="line"> [<span class="number">37</span>] <span class="number">256</span> <span class="number">267</span> <span class="number">285</span> <span class="number">219</span> <span class="number">250</span> <span class="number">262</span> <span class="number">249</span> <span class="number">253</span> <span class="number">246</span> <span class="number">267</span> <span class="number">259</span> <span class="number">251</span> <span class="number">259</span> <span class="number">208</span> <span class="number">252</span> <span class="number">256</span> <span class="number">262</span> <span class="number">271</span></span><br><span class="line"> [<span class="number">55</span>] <span class="number">225</span> <span class="number">229</span> <span class="number">233</span> <span class="number">260</span> <span class="number">261</span> <span class="number">273</span> <span class="number">212</span> <span class="number">240</span> <span class="number">278</span> <span class="number">237</span> <span class="number">267</span> <span class="number">245</span> <span class="number">266</span> <span class="number">269</span> <span class="number">253</span> <span class="number">239</span> <span class="number">233</span> <span class="number">252</span></span><br><span class="line"> [<span class="number">73</span>] <span class="number">233</span> <span class="number">207</span> <span class="number">277</span> <span class="number">212</span> <span class="number">242</span> <span class="number">263</span> <span class="number">249</span> <span class="number">247</span> <span class="number">229</span> <span class="number">226</span> <span class="number">244</span> <span class="number">269</span> <span class="number">270</span> <span class="number">235</span> <span class="number">268</span> <span class="number">278</span> <span class="number">239</span> <span class="number">240</span></span><br><span class="line"> [<span class="number">91</span>] <span class="number">228</span> <span class="number">275</span> <span class="number">273</span> <span class="number">256</span> <span class="number">239</span> <span class="number">262</span> <span class="number">230</span> <span class="number">256</span> <span class="number">285</span> <span class="number">254</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言（02）绘图</title>
    <url>/2016/03/06/R%E8%AF%AD%E8%A8%80%EF%BC%8802%EF%BC%89%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="基本图形的绘制"><a href="#基本图形的绘制" class="headerlink" title="基本图形的绘制"></a>基本图形的绘制</h2><p>在<strong>R语言(01)</strong>中，最后的一个综合训练，我们生成了一部分数据，现在我们就用这些数据为例，来展示R是如何绘制一些图表的。</p>
<h3 id="数据的导入"><a href="#数据的导入" class="headerlink" title="数据的导入"></a>数据的导入</h3><p>通过读取数据文件，我们可以导入之前产生的数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x=read.table(<span class="string">&quot;mark.txt&quot;</span>,header=<span class="built_in">F</span>)</span><br><span class="line">&gt; x</span><br><span class="line">          V1  V2 V3  V4</span><br><span class="line">1   <span class="number">10378001</span>  <span class="number">99</span> <span class="number">73</span>  <span class="number">98</span></span><br><span class="line">2   <span class="number">10378002</span>  <span class="number">86</span> <span class="number">95</span>  <span class="number">90</span></span><br><span class="line">3   <span class="number">10378003</span>  <span class="number">98</span> <span class="number">85</span>  <span class="number">84</span></span><br><span class="line">4   <span class="number">10378004</span>  <span class="number">90</span> <span class="number">81</span> <span class="number">100</span></span><br><span class="line">5   <span class="number">10378005</span>  <span class="number">81</span> <span class="number">88</span>  <span class="number">96</span></span><br><span class="line">6   <span class="number">10378006</span>  <span class="number">99</span> <span class="number">63</span>  <span class="number">61</span></span><br><span class="line">7   <span class="number">10378007</span>  <span class="number">88</span> <span class="number">79</span> <span class="number">100</span></span><br><span class="line">8   <span class="number">10378008</span>  <span class="number">88</span> <span class="number">92</span>  <span class="number">95</span></span><br><span class="line">9   <span class="number">10378009</span>  <span class="number">91</span> <span class="number">91</span> <span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中V1列是学好，V2是均匀分布的成绩数据，V3和V4是正太分布的数据，其中V4对超过100的数据取100。</p>
<h3 id="直方图分析-hist"><a href="#直方图分析-hist" class="headerlink" title="直方图分析 hist()"></a>直方图分析 hist()</h3><p>绘制直方图函数hist()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; hist(x$V2)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_01.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; hist(x$V3)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_02.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; hist(x$V4)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_03.png" alt=""></p>
<h3 id="散点图-plot"><a href="#散点图-plot" class="headerlink" title="散点图 plot()"></a>散点图 plot()</h3><p>散点图绘制函数plot()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(x$V1,x$V2)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_04.png" alt=""></p>
<h3 id="柱状图barplot"><a href="#柱状图barplot" class="headerlink" title="柱状图barplot()"></a>柱状图barplot()</h3><p>列联函数table(),柱状图绘制函数barplot()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(x$V2)</span><br><span class="line"></span><br><span class="line"> <span class="number">80</span>  <span class="number">81</span>  <span class="number">82</span>  <span class="number">83</span>  <span class="number">84</span>  <span class="number">85</span>  <span class="number">86</span>  <span class="number">87</span>  <span class="number">88</span>  <span class="number">89</span>  <span class="number">90</span>  <span class="number">91</span>  <span class="number">92</span>  <span class="number">93</span>  <span class="number">94</span>  <span class="number">95</span>  <span class="number">96</span>  <span class="number">97</span>  <span class="number">98</span>  <span class="number">99</span> </span><br><span class="line">  <span class="number">1</span>   <span class="number">5</span>   <span class="number">7</span>   <span class="number">3</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span>   <span class="number">8</span>   <span class="number">7</span>   <span class="number">4</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">4</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">2</span>   <span class="number">6</span>   <span class="number">2</span>   <span class="number">4</span>   <span class="number">8</span> </span><br><span class="line">100 </span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">&gt; barplot(table(x$V2))</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_05.png" alt=""></p>
<h3 id="饼图-pie"><a href="#饼图-pie" class="headerlink" title="饼图 pie()"></a>饼图 pie()</h3><p>饼图绘制函数pie()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; pie(table(x$V2))</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_06.png" alt=""></p>
<h3 id="箱尾图"><a href="#箱尾图" class="headerlink" title="箱尾图"></a>箱尾图</h3><ul>
<li>箱子的上下横线为样本的25%和75%分为数</li>
<li>箱子中间的横线为样本的中位数</li>
<li>上下延伸的直线称为尾线，尾线的尽头为最高值和最低值</li>
<li>异常值是箱外部的个别与大多数样本相距很远的样本数据</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; boxplot(x$V2,x$V2,x$V3)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_07.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; boxplot(x[<span class="number">2</span>:<span class="number">4</span>],col=<span class="built_in">c</span>(<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>),notch=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>x[2:4] 是值第2到4列</p>
<p>col=c(“red”,”green”,”blue”) 分别指定每个箱尾图的颜色</p>
<p>notch=T 是控制中间的缺口的  主要是让用户更清楚的看到中位线</p>
<p><img src="/img/r_02_08.png" alt=""></p>
<p>水平放置的箱尾图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; boxplot(x$V2,x$V2,x$V3,horizontal=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>horizontal=T 设置水平显示</p>
<p><img src="/img/r_02_09.png" alt=""></p>
<h3 id="星相图-stars"><a href="#星相图-stars" class="headerlink" title="星相图 stars()"></a>星相图 stars()</h3><ul>
<li>每个观测单位的数值表示为一个图形</li>
<li>每个图的每个角表示一个变量，字符串类型会标注在图的下方</li>
<li>角线的长度表达值的大小</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; stars(x[<span class="built_in">c</span>(<span class="string">&quot;V2&quot;</span>,<span class="string">&quot;V3&quot;</span>,<span class="string">&quot;V4&quot;</span>)])</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_10.png" alt=""></p>
<p>星相图另一种表示：雷达图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; stars(x[<span class="built_in">c</span>(<span class="string">&quot;V2&quot;</span>,<span class="string">&quot;V3&quot;</span>,<span class="string">&quot;V4&quot;</span>)],full=<span class="built_in">T</span>,draw.segment=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_11.png" alt=""></p>
<h3 id="人脸图"><a href="#人脸图" class="headerlink" title="人脸图"></a>人脸图</h3><ul>
<li>用五官的宽度和高度来描绘数值</li>
<li>人对脸谱高度敏感和强记忆</li>
<li>适合较少样本的情况</li>
</ul>
<p>安装aplpack包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; require(<span class="string">&quot;aplpack&quot;</span>)</span><br><span class="line">&gt; faces(x[<span class="built_in">c</span>(<span class="string">&quot;V2&quot;</span>,<span class="string">&quot;V3&quot;</span>,<span class="string">&quot;V4&quot;</span>)])</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_12.png" alt=""></p>
<p>其它脸谱图</p>
<p>安装TeachingDemos包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; require(<span class="string">&quot;TeachingDemos&quot;</span>)</span><br><span class="line">&gt; faces2(x)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_13.png" alt=""></p>
<h3 id="茎叶图-stem"><a href="#茎叶图-stem" class="headerlink" title="茎叶图 stem()"></a>茎叶图 stem()</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; stem(x$V3)</span><br><span class="line"></span><br><span class="line">  The decimal point is <span class="number">1</span> digit(s) to the right of the |</span><br><span class="line"></span><br><span class="line">  <span class="number">6</span> | <span class="number">0233</span></span><br><span class="line">  <span class="number">6</span> | <span class="number">88</span></span><br><span class="line">  <span class="number">7</span> | <span class="number">000111222333333</span></span><br><span class="line">  <span class="number">7</span> | <span class="number">55556677888888888999999999</span></span><br><span class="line">  <span class="number">8</span> | <span class="number">0000011111112223333333444444</span></span><br><span class="line">  <span class="number">8</span> | <span class="number">5556666788888899</span></span><br><span class="line">  <span class="number">9</span> | <span class="number">001224</span></span><br><span class="line">  <span class="number">9</span> | <span class="number">559</span></span><br></pre></td></tr></table></figure>
<p>6 | 0233  代表60,62,63,63四个样本数据.茎叶图没有图像输出，是一种高密集型的数据展现形式。</p>
<h3 id="QQ图"><a href="#QQ图" class="headerlink" title="QQ图"></a>QQ图</h3><ul>
<li>可用于判断是否正态分布(服从正态分布的点基本都处于同一直线)</li>
<li>直线的斜率是标准差，截距是均值</li>
<li>点的散布越接近直线，则越接近正态分布</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qqnorm(x$V2)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_14.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qqline(x$V2)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_15.png" alt=""></p>
<p>x$V3 数据服从正态分布，点基本都处于同一直线上：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qqnorm(x$V3)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_16.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qqline(x$V3)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_17.png" alt=""></p>
<h2 id="图形绘制进阶"><a href="#图形绘制进阶" class="headerlink" title="图形绘制进阶"></a>图形绘制进阶</h2><h3 id="散点图进一步设置"><a href="#散点图进一步设置" class="headerlink" title="散点图进一步设置"></a>散点图进一步设置</h3><p>在mac上绘图时显示中文，需要安装以下安装包：</p>
<ul>
<li>showtext</li>
<li>showtextdb</li>
<li>sysfonts</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(sysfonts)</span><br><span class="line">&gt; library(showtext)</span><br><span class="line">&gt; dev.new() <span class="comment">#如果已打开图形设备，本句可以不用</span></span><br><span class="line">&gt; showtext.begin()</span><br></pre></td></tr></table></figure>
<p>加入这几句之后，绘制的图像中就可以正常显示中文了。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(x$V2,x$V3,</span><br><span class="line">main=<span class="string">&quot;数学分析与线性代数成绩的关系&quot;</span>,</span><br><span class="line">xlab=<span class="string">&quot;数学分析&quot;</span>,</span><br><span class="line">ylab=<span class="string">&quot;线性代数&quot;</span>,</span><br><span class="line">xlim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">100</span>),</span><br><span class="line">ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">100</span>),</span><br><span class="line">xaxs=<span class="string">&quot;i&quot;</span>, <span class="comment">#Set x axis style as internal</span></span><br><span class="line">yaxs=<span class="string">&quot;i&quot;</span>, <span class="comment">#Set y axis style as internal</span></span><br><span class="line">col=<span class="string">&quot;red&quot;</span>, <span class="comment">#Set the color of plotting symbol to red</span></span><br><span class="line">pch=<span class="number">19</span>) <span class="comment">#Set the plotting symbol to filled dots</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_18.png" alt=""></p>
<h3 id="连线图"><a href="#连线图" class="headerlink" title="连线图"></a>连线图</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">&gt; b=<span class="built_in">c</span>(<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>)</span><br><span class="line">&gt; plot(a,b,type=<span class="string">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>type=”l” 代表想字母”l”一样，是折现。</p>
<p><img src="/img/r_02_19.png" alt=""></p>
<h3 id="密度图-density"><a href="#密度图-density" class="headerlink" title="密度图 density()"></a>密度图 density()</h3><p>函数density()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(density(rnorm(<span class="number">1000</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_20.png" alt=""></p>
<h3 id="R中的内置数据集"><a href="#R中的内置数据集" class="headerlink" title="R中的内置数据集"></a>R中的内置数据集</h3><p>在R中输入data可查看内置数据集：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data()</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_21.png" alt=""></p>
<h3 id="热力图-heatmap"><a href="#热力图-heatmap" class="headerlink" title="热力图 heatmap()"></a>热力图 heatmap()</h3><p>利用内置的mtcars数据集绘制</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; heatmap(as.matrix(mtcars),</span><br><span class="line">Rowv=<span class="literal">NA</span>,</span><br><span class="line">Colv=<span class="literal">NA</span>,</span><br><span class="line">col=heat.colors(<span class="number">256</span>),</span><br><span class="line">scale=<span class="string">&quot;column&quot;</span>,</span><br><span class="line">margins=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">8</span>),</span><br><span class="line">main=<span class="string">&quot;Car characteristics by Model&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_22.png" alt=""></p>
<h3 id="Iris-鸢尾花-数据集"><a href="#Iris-鸢尾花-数据集" class="headerlink" title="Iris(鸢尾花)数据集"></a>Iris(鸢尾花)数据集</h3><ul>
<li>Sepal花萼</li>
<li>Petal花瓣</li>
<li>Species种属</li>
</ul>
<p>这是一个非常著名的数据集，Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集。通过花萼长度，花萼宽度，花瓣长度，花瓣宽度4个属性预测鸢尾花卉属于（Setosa，Versicolour，Virginica）三个种类中的哪一类。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; iris</span><br><span class="line">    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species</span><br><span class="line">1            <span class="number">5.1</span>         <span class="number">3.5</span>          <span class="number">1.4</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">2            <span class="number">4.9</span>         <span class="number">3.0</span>          <span class="number">1.4</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">3            <span class="number">4.7</span>         <span class="number">3.2</span>          <span class="number">1.3</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">4            <span class="number">4.6</span>         <span class="number">3.1</span>          <span class="number">1.5</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">5            <span class="number">5.0</span>         <span class="number">3.6</span>          <span class="number">1.4</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">6            <span class="number">5.4</span>         <span class="number">3.9</span>          <span class="number">1.7</span>         <span class="number">0.4</span>     setosa</span><br><span class="line">7            <span class="number">4.6</span>         <span class="number">3.4</span>          <span class="number">1.4</span>         <span class="number">0.3</span>     setosa</span><br><span class="line">8            <span class="number">5.0</span>         <span class="number">3.4</span>          <span class="number">1.5</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">9            <span class="number">4.4</span>         <span class="number">2.9</span>          <span class="number">1.4</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">10           <span class="number">4.9</span>         <span class="number">3.1</span>          <span class="number">1.5</span>         <span class="number">0.1</span>     setosa</span><br><span class="line">11           <span class="number">5.4</span>         <span class="number">3.7</span>          <span class="number">1.5</span>         <span class="number">0.2</span>     setosa</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="向日葵散点图-sunflowerplot"><a href="#向日葵散点图-sunflowerplot" class="headerlink" title="向日葵散点图 sunflowerplot()"></a>向日葵散点图 sunflowerplot()</h3><ul>
<li>用来克服散点图中数据点重叠问题</li>
<li>在有重叠的地方用一朵“向日葵花”的花瓣数目来表示重叠数据个数</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; sunflowerplot(iris[,<span class="number">3</span>:<span class="number">4</span>],col=<span class="string">&quot;gold&quot;</span>,seg.col=<span class="string">&quot;gold&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_23.png" alt=""></p>
<h3 id="散点图集"><a href="#散点图集" class="headerlink" title="散点图集"></a>散点图集</h3><ul>
<li>遍历样本中全部的变量配对画出二元图</li>
<li>直观地了解所有变量之间的关系</li>
</ul>
<p>将iris数据集的第1到4列的数据取出，两两组合，形成散点图。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; pairs(iris[,<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_24.png" alt=""></p>
<p>用plot也可以实现同样的效果</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; plot(iris[,<span class="number">1</span>:<span class="number">4</span>],</span><br><span class="line">main=<span class="string">&quot;Relationships between </span></span><br><span class="line"><span class="string">characteristics of iris flowers&quot;</span>,</span><br><span class="line">pch=<span class="number">19</span>,</span><br><span class="line">col=<span class="string">&quot;blue&quot;</span>,</span><br><span class="line">cex=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_25.png" alt=""></p>
<ul>
<li>利用par()在同一个device输出多个散点图</li>
<li>Par命令博大精深，用于设置绘图参数，help(par)</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; par(mfrow=<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">&gt; plot(x$V2,x$V3);plot(x$V3,x$V4);plot(x$V4,x$V1)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_26.png" alt=""></p>
<p>par(mfrow=c(3,1))   把屏幕划分成3个水平区域<br>plot(x1,x2);plot(x2,x3);plot(x3,x1);    分别将三个散点图显示在这三块区域中。</p>
<blockquote>
<p>如果想深入学习R语言图像绘制，建议对par()函数的文档深入学习，并且学习《R Graphs Cookbook》这本书，会有很大收获的。</p>
</blockquote>
<h3 id="颜色colors"><a href="#颜色colors" class="headerlink" title="颜色colors()"></a>颜色colors()</h3><p>查看有哪些颜色 colors()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; colors()</span><br><span class="line">  [<span class="number">1</span>] <span class="string">&quot;white&quot;</span>                <span class="string">&quot;aliceblue&quot;</span>            <span class="string">&quot;antiquewhite&quot;</span>        </span><br><span class="line">  [<span class="number">4</span>] <span class="string">&quot;antiquewhite1&quot;</span>        <span class="string">&quot;antiquewhite2&quot;</span>        <span class="string">&quot;antiquewhite3&quot;</span>       </span><br><span class="line">  [<span class="number">7</span>] <span class="string">&quot;antiquewhite4&quot;</span>        <span class="string">&quot;aquamarine&quot;</span>           <span class="string">&quot;aquamarine1&quot;</span>         </span><br><span class="line"> [<span class="number">10</span>] <span class="string">&quot;aquamarine2&quot;</span>          <span class="string">&quot;aquamarine3&quot;</span>          <span class="string">&quot;aquamarine4&quot;</span>         </span><br><span class="line"> [<span class="number">13</span>] <span class="string">&quot;azure&quot;</span>                <span class="string">&quot;azure1&quot;</span>               <span class="string">&quot;azure2&quot;</span>              </span><br><span class="line"> [<span class="number">16</span>] <span class="string">&quot;azure3&quot;</span>               <span class="string">&quot;azure4&quot;</span>               <span class="string">&quot;beige&quot;</span>               </span><br><span class="line"> [<span class="number">19</span>] <span class="string">&quot;bisque&quot;</span>               <span class="string">&quot;bisque1&quot;</span>              <span class="string">&quot;bisque2&quot;</span>             </span><br><span class="line"> [<span class="number">22</span>] <span class="string">&quot;bisque3&quot;</span>              <span class="string">&quot;bisque4&quot;</span>              <span class="string">&quot;black&quot;</span>               </span><br><span class="line"> [<span class="number">25</span>] <span class="string">&quot;blanchedalmond&quot;</span>       <span class="string">&quot;blue&quot;</span>                 <span class="string">&quot;blue1&quot;</span>               </span><br><span class="line"> [<span class="number">28</span>] <span class="string">&quot;blue2&quot;</span>                <span class="string">&quot;blue3&quot;</span>                <span class="string">&quot;blue4&quot;</span>               </span><br><span class="line"> [<span class="number">31</span>] <span class="string">&quot;blueviolet&quot;</span>           <span class="string">&quot;brown&quot;</span>                <span class="string">&quot;brown1&quot;</span>              </span><br><span class="line"> [<span class="number">34</span>] <span class="string">&quot;brown2&quot;</span>               <span class="string">&quot;brown3&quot;</span>               <span class="string">&quot;brown4&quot;</span>        </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>绘图设备</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; dev.cur() <span class="comment"># 当前图形窗</span></span><br><span class="line">&gt; dev.list() <span class="comment"># 查看现在所有的图形窗</span></span><br><span class="line">&gt; dev.next(which=dev.cur()) <span class="comment">#某个图形窗的后一个图形窗</span></span><br><span class="line">&gt; dev.prev(which=dev.cur()) <span class="comment">#某个图形窗的前一个图形窗</span></span><br><span class="line">&gt; dev.off(which=dev.cur()) <span class="comment">#关闭某个图形窗</span></span><br><span class="line">&gt; dev.set(which=dev.next()) <span class="comment">#设置图形窗</span></span><br><span class="line">&gt; dev.new(...) <span class="comment">#开启新的图形窗</span></span><br><span class="line">&gt; graphics.off() <span class="comment">#关闭整个窗口</span></span><br></pre></td></tr></table></figure>
<h3 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h3><p>安装scatterplot3d包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(scatterplot3d)</span><br><span class="line">&gt; scatterplot3d(x[<span class="number">2</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_27.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x&lt;-y&lt;-seq(-<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="built_in">pi</span>/<span class="number">15</span>)</span><br><span class="line">&gt; f&lt;-<span class="keyword">function</span>(x,y)<span class="built_in">sin</span>(x)*<span class="built_in">sin</span>(y)</span><br><span class="line">&gt; z&lt;-outer(x,y,f)</span><br><span class="line">&gt; contour(x,y,z,col=<span class="string">&quot;blue&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_28.png" alt=""></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; contour(x,y,z,col=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">&gt; persp(x,y,z,theta=<span class="number">30</span>,phi=<span class="number">30</span>,expand=<span class="number">0.7</span>,col=<span class="string">&quot;lightblue&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_29.png" alt=""></p>
<h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3><p>安装maps包</p>
<p>显示美国地图：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(maps)</span><br><span class="line">&gt; map(<span class="string">&quot;state&quot;</span>,interior=<span class="built_in">F</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_30.png" alt=""></p>
<blockquote>
<p>state 代表美国</p>
</blockquote>
<p>世界地图的绘制：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; map(<span class="string">&quot;world&quot;</span>,fill=<span class="built_in">T</span>,col=heat.colors(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/r_02_31.png" alt=""></p>
<h3 id="社交数据可视化"><a href="#社交数据可视化" class="headerlink" title="社交数据可视化"></a>社交数据可视化</h3><p>通过R可以画出如下的facebook社交关系图:</p>
<p><img src="/img/r_02_32.png" alt=""></p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala(01)</title>
    <url>/2016/01/06/Scala(01)%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Scala安装"><a href="#Scala安装" class="headerlink" title="Scala安装"></a>Scala安装</h2><h2 id="Scala解释器"><a href="#Scala解释器" class="headerlink" title="Scala解释器"></a>Scala解释器</h2>]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图基本关系</title>
    <url>/2016/05/31/UML%E7%B1%BB%E5%9B%BE%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="关系汇总"><a href="#关系汇总" class="headerlink" title="关系汇总"></a>关系汇总</h2><p>uml的类图是用来描述类与类之间的基本关系一种图。常见的有以下几种关系: </p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><ul>
<li><strong>泛化(Generalization)</strong></li>
<li><strong>实现(Realization)</strong></li>
</ul>
<h3 id="拥有关系"><a href="#拥有关系" class="headerlink" title="拥有关系"></a>拥有关系</h3><ul>
<li><strong>关联(Association)</strong></li>
<li><strong>聚合(Aggregation)</strong></li>
<li><strong>组合(Composition)</strong></li>
</ul>
<h3 id="使用关系"><a href="#使用关系" class="headerlink" title="使用关系"></a>使用关系</h3><ul>
<li><strong>依赖(Dependency)</strong></li>
</ul>
<hr>
<h2 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h2><h3 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h3><p>是一种继承关系, 表示一般与特殊的关系, 它指定了子类如何特化父类的所有特征和行为。</p>
<p><img src="/img/16_05_31/01.png" alt="泛化"></p>
<h3 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h3><p>是一种类与接口的关系，表示类是接口所有特征和行为的实现。</p>
<p><img src="/img/16_05_31/02.png" alt="实现"></p>
<h2 id="拥有关系-1"><a href="#拥有关系-1" class="headerlink" title="拥有关系"></a>拥有关系</h2><h3 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联(Association)"></a>关联(Association)</h3><p>是一种拥有的关系，它使一个类知道另一个类的属性和方法；具体代码体现是：成员变量。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p>
<p><img src="/img/16_05_31/03.png" alt="实现"></p>
<h3 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h3><p>是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。具体的代码体现也是成员变量，但突出强调整体和部分的关系。</p>
<p><img src="/img/16_05_31/04.png" alt="实现"></p>
<h3 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h3><p>是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p>
<p><img src="/img/16_05_31/05.png" alt="组合"></p>
<h2 id="使用关系-1"><a href="#使用关系-1" class="headerlink" title="使用关系"></a>使用关系</h2><h3 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h3><p>是一种使用的关系，即一个类的实现需要另一个类的协助。具体代码实现为：局部变量、方法的参数或者对静态方法的调用。</p>
<p><img src="/img/16_05_31/06.png" alt="组合"></p>
]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>工具学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图片内存优化</title>
    <url>/2015/11/19/android%E5%9B%BE%E7%89%87%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>首先，关于android的内存管理机制，建议阅读这篇文章：</p>
<p><a href="http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html">android垃圾回收算法</a></p>
<p>如果在布局文件中，设置了背景图，要在界面onDestroy()的时候，将图片回收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;recycle backgroundBitmap </span><br><span class="line">View v &#x3D; findViewById(id);</span><br><span class="line">BitmapDrawable bd &#x3D; (BitmapDrawable) v.getBackground();</span><br><span class="line">if (bd !&#x3D; null)&#123;</span><br><span class="line">    bd.getBitmap().recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将资源id清空</span><br><span class="line">v.setBackgroundResource(0);</span><br></pre></td></tr></table></figure>
<p>对布局文件的背景图建议在界面销毁的时候调用上面的代码来将图片的引用置空。</p>
<p>虽然这样不能及时释放内存，但java虚拟机在执行gc的时候，会优先释放这些多余的内存空间。</p>
<p>以下是对上述代码添加前后的效果对比：</p>
<p>添加优化代码前，完全回收一张图片的内存，需要连续两次gc：<br><img src="/img/android_neicunyouhua2.gif" alt="未添加优化代码"></p>
<p>添加优化之后，完全回收一张图片的内存，只需要调用一次gc：<br><img src="/img/android_neicunyouhua1.gif" alt="添加优化代码"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-Gradle Wrapper</title>
    <url>/2016/07/10/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gradle%20Wrapper/</url>
    <content><![CDATA[<blockquote>
<p>大多数工具都需要在使用之前安装在你的电脑上，虽然简单的安装步骤会让你觉得没什么大碍，但这其实会给用户带来负担。同样重要的是，用户是否会安装正确的版本的工具呢？如果他们正在构建一个版本比较老的项目呢？</p>
</blockquote>
<h2 id="1-通过Wrapper来执行一次构建"><a href="#1-通过Wrapper来执行一次构建" class="headerlink" title="1.通过Wrapper来执行一次构建"></a>1.通过Wrapper来执行一次构建</h2><p>如果一个gradle项目已经设置了wrapper(我们建议所有的项目都这样做)，你可以从项目的根目录执行下列命令之一来进行构建：</p>
<ul>
<li><code>./gradlew &lt;task&gt;</code> (Unix-like系统上使用，如Linux和Mac OS X)</li>
<li><code>gradlew &lt;task&gt;</code> (在Windows上使用gradlew.bat批处理文件)</li>
</ul>
<p>每一个wrapper都绑定在一个指定版本的gradle上，所以当你第一次以一个指定版本的gradle来运行以上的命令，它将会去下载指定的gradle并且去使用它来执行构建。</p>
<p>这不仅意味着你不需要自己手动安装gradle，而且你也能确定当前构建的设计所需要的gradle版本。这使你的历史构建更可靠。只需要在用户指南、在Stack Overflow，在文章的任何地方看到命令行是以<code>gradle ...</code>开头的地方使用适当的语法。（这段没看懂。。）</p>
<p>为了完整起见，并确保您不删除任何重要的文件，这里是一个gradle工程构成包装的文件和目录：</p>
<ul>
<li>gradlew (Unix Shell script)</li>
<li>gradlew.bat (Windows batch file)</li>
<li>gradle/wrapper/gradle-wrapper.jar (Wrapper JAR)</li>
<li>gradle/wrapper/gradle-wrapper.properties (Wrapper properties)</li>
</ul>
<p>如果你想要知道你的gradle分配被存储在哪里，那么你可以在home目录下的<code>$USER_HOME/.gradle/wrapper/dists</code>目录下找到。</p>
<h2 id="2-添加Wrapper到项目中"><a href="#2-添加Wrapper到项目中" class="headerlink" title="2.添加Wrapper到项目中"></a>2.添加Wrapper到项目中</h2><p>wrapper是一种需要检查版本控制的东西。通过分发你的项目wrapper，任何人都可以使用它而无需事先安装gradle。更好的是，它可以保证构建使用正确的gradle版本。当然，由于不需要服务端的任何配置，这也非常有利于<a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(continuous integration)</a>服务，(服务器定期构建你的项目)。</p>
<p>通过运行wrapper任务，您将wrapper安装到您的项目中。(这个任务总是可用的，即使你不把它添加到你的构建中)。通过命令参数<code>--gradle-version</code>来指定一个gradle版本。你也可以直接通过命令<code>--gradle-distribution-url</code>来设置gradle下载链接。如果没有版本或分配URL指定的wrapper将被配置为使用gradle的版本的wrapper task执行。所以，如果你通过gradle2.4运行wrapper task，然后wrapper的配置将默认配置为版本2.4。</p>
<p>例如：</p>
<p><strong>运行Wrapper task</strong></p>
<p>执行<code>gradle wrapper --gradle-version 2.0</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle wrapper --gradle-version 2.0</span><br><span class="line">:wrapper</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1 secs</span><br></pre></td></tr></table></figure>
<p>wrapper能够通过在构建脚本中配置一些参数来被进一步定制并且执行：</p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task wrapper(type: Wrapper) &#123;</span><br><span class="line">    gradleVersion &#x3D; &#39;2.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这样的一个执行之后，你会发现在你的项目目录中的新的或更新的文件（一旦在wrapper task的默认配置被用到）。</p>
<p><strong>Wrapper 生成的文件</strong></p>
<p>Build layout</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">simple&#x2F;</span><br><span class="line">  gradlew</span><br><span class="line">  gradlew.bat</span><br><span class="line">  gradle&#x2F;wrapper&#x2F;</span><br><span class="line">    gradle-wrapper.jar</span><br><span class="line">    gradle-wrapper.properties</span><br></pre></td></tr></table></figure>
<p>所有这些文件都应该提交给您的版本控制系统。这只需要做一次。在这些文件已经添加到项目中之后，项目构建时就应该加<code>gradlew</code>命令了。<code>gradlew</code>命令可以按照和<code>gradle</code>完全一样的方式来使用。</p>
<p>如果你想切换到一个新的gradle，你不需要重新运行wrapper task。在<code>gradle-wrapper</code>中更改相应的入口就足够了。属性文件，但如果你想要体验新的版本的gradle wrapper，那么你就需要重新生成wrapper文件。</p>
<h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h2><p>如果你通过<code>gradlew</code>来运行gradle，wrapper会去检查是否有一个可用版本的gradle。如果这样的话它代表将<code>gradlew</code>命令带上所有的参数传递到当前版本的gradle命令上来。如果没有发现一个一个可用的gradle，它就会去自动下载。</p>
<p>当你配置wrapper task，你可以指定一个你想要使用的gradle版本。的gradlew命令将从gradle库下载合适的版本。或者，你也可以指定一个gradle的下载链接。的gradlew命令将使用这个URL下载gradle。如果你既没有指定版本，也没有指定下载链接，那么<code>gradlew</code>命令将下载任意一个版本的gralde来生成wrapper文件。</p>
<p>有关如何配置包装的详细信息，参见<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.wrapper.Wrapper.html">Wrapper</a>类API文档。</p>
<p>如果你在使用<code>gradlew</code>进行构建的过程中，不希望有任何下载产生，只需将gradle的zip包放在你的wrapper配置指定的位置并添加到您的版本控制工具即可。相对路径的支持-您可以指定gradle的文件到一个相对于gradle-wrapper.properties文件的位置。</p>
<p>如果你通过wrapper来构建，机器上安装的任何版本的gradle都会被忽略。</p>
<h2 id="4-验证下载的gradle"><a href="#4-验证下载的gradle" class="headerlink" title="4.验证下载的gradle"></a>4.验证下载的gradle</h2><p>gradle wrapper通过SHA-256哈希比较来校验下载的gradle。这种方式通过阻止中间人篡改下载的gradle来进行攻击，从而提高了安全性。</p>
<p>要启用这个功能，你要先计算一个已知的gradle版本的SHA-256哈希码。你可以通过<code>shasum</code>命令在Linux、OSX或者Windows(通过 Cygwin)上来生成SHA-256哈希码。</p>
<p><strong>生成一个SHA-256 hash</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; shasum -a 256 gradle-2.4-all.zip</span><br><span class="line">371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10  gradle-2.4-all.zip</span><br></pre></td></tr></table></figure>
<p>通过将<code>distributionSha256Sum</code>属性配置添加到<code>gradle-wrapper.properties</code>来返回校验的哈希码。</p>
<p><strong>配置SHA-256校验</strong></p>
<p>gradle-wrapper.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distributionSha256Sum&#x3D;371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10</span><br></pre></td></tr></table></figure>
<h2 id="5-UNIX文件的权限"><a href="#5-UNIX文件的权限" class="headerlink" title="5.UNIX文件的权限"></a>5.UNIX文件的权限</h2><p>对wrapper task添加适当的文件权限来允许*NIX上的命令行上可以执行<code>gradlew</code>命令。我们不确定其他版本控制系统如何处理这个。但<code>sh gradlew</code>这个命令总是很有效的。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-Gradle 守护进程</title>
    <url>/2016/07/10/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Gradle%20%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>来自维基百科：</p>
<blockquote>
<p>A daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user.<br>守护进程是一个作为计算机后台进程运行的，而不是直接可以与用户进行交互的程序。</p>
</blockquote>
<p>gradle运行在java虚拟机(JVM)中，并且需要使用几个支持库，这些都会花费不少的初始化时间。因此，有时开启的时候回有一点点慢。解决这个问题的方式就是<strong>gradle守护进程(Daemon)</strong>:一个长时间存活的后台进程，可以使得执行你的构建的速度比其他情况下更为迅速。我们通过避免昂贵的引导进程以及利用缓存，在内存中来保存你的项目数据，来达到提高构建速度的效果。通过使用守护进程执行gradle构建，与不使用守护进程，没有区别的。通过简单的配置，就可以设置是否使用守护进程—gradle中一切操作都是如此的透明。</p>
<h2 id="1-开启守护进程"><a href="#1-开启守护进程" class="headerlink" title="1.开启守护进程"></a>1.开启守护进程</h2><p>gradle守护进程默认是不可用的，但是我们建议每一个开发者的机器上都将守护进程设置为开启状态（除了持续集成服务器）。以下是几种开启守护进程的方式，但最通用的一种方式是添加这样一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.gradle.daemon&#x3D;true</span><br></pre></td></tr></table></figure>
<p>到文件<code>«USER_HOME»/.gradle/gradle.properties</code>，其中<code>«USER_HOME»</code>是你的home目录。以下是几个典型的路径，取决于你的系统平台：</p>
<ul>
<li>C:\Users\<username> (Windows Vista &amp; 7+)</li>
<li>/Users/<username> (Mac OS X)</li>
<li>/home/<username> (Linux)</li>
</ul>
<p>如果那个文件不存在，直接通过文本编辑器创建一个即可。你可以使用另一种方式来开启（或关闭）守护进程，具体步骤可以看下面的FAQ部分。这部分还包含关于守护进程运行的更详细的信息。</p>
<p>一旦你开启了全局守护进程，你所有的构建都会充分利用到这种速度的提升。</p>
<blockquote>
<p><strong><em>关于持续集成</em></strong></p>
<p><em>目前我们建议持续集成不要使用守护进程，取而代之更为可靠方案是为每个构建分配一个新的运行时，原因是运行时是完全与之前的构建隔离的。此外，由于守护进程主要是为了减少构建的启动时间，这一点在CI服务器上并不像是在开发者的机器上那么重要。</em></p>
</blockquote>
<h2 id="2-终止一个正在运行的守护进程"><a href="#2-终止一个正在运行的守护进程" class="headerlink" title="2.终止一个正在运行的守护进程"></a>2.终止一个正在运行的守护进程</h2><p>如前所述，守护进程是一个后台进程。你不必担心gradle在你的机器上创建进程，虽然每一个守护进程，在没有任何活动后3小时才会停止。在某些情况下，如果你希望明确的终止一个守护进程，使用<code>gradle --stop</code>即可。</p>
<p>这将终止所有的和当前gradle版本相同的后台进程。如果你安装了JDK，你可以通过<code>jps</code>命令来轻松的核实守护进程是否被停止了。你会看到所有正在运行的名字为“GradleDaemon”的守护进程列表。</p>
<h2 id="3-FAQ"><a href="#3-FAQ" class="headerlink" title="3.FAQ"></a>3.FAQ</h2><h3 id="3-1有什么方法能开启守护进程呢？"><a href="#3-1有什么方法能开启守护进程呢？" class="headerlink" title="3.1有什么方法能开启守护进程呢？"></a>3.1有什么方法能开启守护进程呢？</h3><p>这里有两种推荐的方式在一个运行环境下开启守护进程:</p>
<ul>
<li>通过环境变量:在GRADLE_OPTS的环境变量下添加标示：<code>Dorg.gradle.daemon=true</code></li>
<li>通过配置文件:添加<code>org.gradle.daemon=true</code>到<code>«GRADLE_USER_HOME»/gradle.properties</code>文件中。</li>
</ul>
<blockquote>
<p><strong>注意：</strong><code>«GRADLE_USER_HOME»</code>默认值为<code>«USER_HOME»/.gradle</code>，<code>«USER_HOME»</code>是当前用户的home目录。这个位置可以通过<code>-g</code>或<code>--gradle-user-home</code>命令来设置。同样也可以通过<code>GRADLE_USER_HOME</code>环境变量和<code>org.gradle.user.home</code>JVM系统属性来设置。</p>
</blockquote>
<p>这两种方法有相同的效果。可根据个人喜好来选择使用。大多数用户使用的是第二种方式。</p>
<p>在Windows下，这个命令会对当前用户开启守护进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(if not exist &quot;%USERPROFILE%&#x2F;.gradle&quot; mkdir &quot;%USERPROFILE%&#x2F;.gradle&quot;) &amp;&amp; (echo org.gradle.daemon&#x3D;true &gt;&gt; &quot;%USERPROFILE%&#x2F;.gradle&#x2F;gradle.properties&quot;)</span><br></pre></td></tr></table></figure>
<p>在UNIX-like的操作系统上，下面的这个bash脚本命令将会对当前用户开启守护进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch ~&#x2F;.gradle&#x2F;gradle.properties &amp;&amp; echo &quot;org.gradle.daemon&#x3D;true&quot; &gt;&gt; ~&#x2F;.gradle&#x2F;gradle.properties</span><br></pre></td></tr></table></figure>
<p>一旦守护进程通过这种方式开启了，所有的构建都将隐式的使用这个守护进程。</p>
<p>可以通过使用<code>--daemon</code>和<code>--no-daemon</code>命令，来针对个别的构建的调用，进行切换开启和关闭使用守护进程。通常情况下，更便捷的方式是对某个环境（例如某个用户账号）开启守护进程，以便于所有的构建使用守护进程，从而不再需要再记得提供<code>--daemon</code>的开关了，</p>
<h3 id="3-2-我该如何关闭守护进程呢？"><a href="#3-2-我该如何关闭守护进程呢？" class="headerlink" title="3.2 我该如何关闭守护进程呢？"></a>3.2 我该如何关闭守护进程呢？</h3><p>gradle守护进程默认情况下是不可用的。然而，一旦启用，有时会有需要对某些项目或某些构建调用禁用的场景。</p>
<p><code>--no-daemon</code>命令可以强制指定某个构建不使用守护进程。这个很少用，但在调试某次构建，或者gradle插件时，这个将是一个很有用的方法。当考虑到构建环境时，此命令行开关具有最高的优先级。</p>
<h3 id="3-3-我该如何抑制“please-consider-using-the-Gradle-Daemon”这样的消息呢？"><a href="#3-3-我该如何抑制“please-consider-using-the-Gradle-Daemon”这样的消息呢？" class="headerlink" title="3.3 我该如何抑制“please consider using the Gradle Daemon”这样的消息呢？"></a>3.3 我该如何抑制“please consider using the Gradle Daemon”这样的消息呢？</h3><p>gradle也许会在构建建议的末尾发出一个“使用守护进程”警告 。为了避开这个警告，你可以通过上面的方式来开启守护进程，或者明确的禁用守护进程。你可以通过<code>--no-daemon</code>命令来明确的关闭守护进程，或者通过上面某种方式开启守护进程，但将<code>org.gradle.daemon</code>属性设置为false。</p>
<p>由于gradle不推荐持续集成构建使用守护进程，所以如果CI环境变量是存在的，那么Gradle不会发出这条消息。</p>
<h3 id="3-4-为什么有超过一个的守护进程在我的机器上？"><a href="#3-4-为什么有超过一个的守护进程在我的机器上？" class="headerlink" title="3.4 为什么有超过一个的守护进程在我的机器上？"></a>3.4 为什么有超过一个的守护进程在我的机器上？</h3><p>有几种原因可以解释为什么gradle会创建一个新的守护进程，而不是使用一个已经运行。基本规则是，如果当前没有<strong>闲置</strong>的或<strong>兼容</strong>的守护进程，Gradle将可以启动一个新的守护进程。gradle会自动杀死已经闲置了超过3小时的守护进程，所以你不用担心需要手动的清理它们。</p>
<p><strong>闲置</strong>：一个空闲守护进程是指当前没有执行构建或其他工作的守护进程。</p>
<p><strong>兼容</strong>：一个兼容的守护进程是能够满足构建环境的要求的。java运行时环境是对构建环境兼容性依赖的一个方面的例子，另外一个例子是构建运行环境需要依赖的一套jvm系统参数。</p>
<p>对某些方面的构建环境的请求也许某个守护进程并不满足。如果守护进程在java7的运行环境下，但是被要求的运行环境是java8，然而守护进程并不兼容，那么另一个守护进程一定会被开启。而且，一旦jvm开始运行，java运行时的某些参数是不可以被改变的。对于一个正在运行的JVM，改变内存分配（例如:<code>-Xmx1024m</code>），默认文字的编码，默认位置等，都是不可能的。</p>
<p>“要求构建环境”通常是一些隐式的来自一些client端（例如：gradle命令行，IDE，等）并且明确的通过命令行来开关和设置。见<a href="https://docs.gradle.org/current/userguide/build_environment.html">Chapter 11, The Build Environment</a>，详细介绍了如何指定并控制一个构建环境。</p>
<p>下面的JVM系统配置是不可变的。如果被要求的构建环境需要这些配置中的任何一个，并且需要的值和守护进程的JVM的属性是不一样的，那么守护进程就不兼容了。</p>
<ul>
<li>file.encoding</li>
<li>user.language</li>
<li>user.country</li>
<li>user.variant</li>
<li>java.io.tmpdir</li>
<li>javax.net.ssl.keyStore</li>
<li>javax.net.ssl.keyStorePassword</li>
<li>javax.net.ssl.keyStoreType</li>
<li>javax.net.ssl.trustStore</li>
<li>javax.net.ssl.trustStorePassword</li>
<li>javax.net.ssl.trustStoreType</li>
<li>com.sun.management.jmxremote</li>
</ul>
<p>下面的JVM属性，是被启动参数控制的，同样也是不可改变的。守护进程的环境必须完全匹配这些属性，否则就是不兼容的。</p>
<ul>
<li>The maximum heap size (i.e. the -Xmx JVM argument)</li>
<li>The minimum heap size (i.e. the -Xms JVM argument)</li>
<li>The boot classpath (i.e. the -Xbootclasspath argument)</li>
<li>The “assertion” status (i.e. the -ea argument)</li>
</ul>
<p>gradle版本要求是构建环境条件的另一方面。守护进程是被连接到一个具体的gradle运行时的。多个不同版本的gradle项目并行，也是有多个守护进程出现的原因。</p>
<h3 id="3-5-守护进程到底会消耗多少内存？我怎样才能分配更多的内存给它？"><a href="#3-5-守护进程到底会消耗多少内存？我怎样才能分配更多的内存给它？" class="headerlink" title="3.5 守护进程到底会消耗多少内存？我怎样才能分配更多的内存给它？"></a>3.5 守护进程到底会消耗多少内存？我怎样才能分配更多的内存给它？</h3><p>如果请求的构建环境没有设定最大的内存大小，守护进程将使用最大1GB的内存。它将使用JVM的默认最小内存的大小。1GB对于大多数的构建来说是足够的。较大的有数以百计的子项目的构建，很多的配置，和源代码，也许才能用到1GB或许更多的内存。</p>
<p>为了增加守护进程的内存使用，可以通过设定所请求的构建环境的一些参数来达到目的。详情请见<a href="https://docs.gradle.org/current/userguide/build_environment.html"> Chapter 11, The Build Environment</a></p>
<h3 id="3-6-我该如何停止守护进程？"><a href="#3-6-我该如何停止守护进程？" class="headerlink" title="3.6 我该如何停止守护进程？"></a>3.6 我该如何停止守护进程？</h3><p>守护进程会在闲置超过3小时之后自动终止。如果你希望提前终止守护进程，你可以通过你的操作系统来杀死这个进程，或者通过输入gradle的<code>--stop</code>命令来终止。<code>--stop</code>命令会终止所有当前版本的gradle的守护进程。</p>
<h3 id="3-7-守护进程什么时候会出错呢？"><a href="#3-7-守护进程什么时候会出错呢？" class="headerlink" title="3.7 守护进程什么时候会出错呢？"></a>3.7 守护进程什么时候会出错呢？</h3><p>考虑到工程已经稳定的、透明的并且默默的进入到守护进程中运行。然而守护进程可能偶尔会被损坏或耗尽。一个gradle从多个源代码中任意选取一个执行构建。然而gradle自身的设计，以及大量的通过守护进程进行过的测试，用户构建的脚本，和第三方插件会通过一些缺陷，例如内存泄漏，全局变量泛滥等问题，打破守护进程的平衡。</p>
<p>没有正确的释放资源也有可能导致守护进程（以及正常的构建）异常。当使用Windows进行读写文件后没有正常关闭文件时，对于这种现象尤为敏感。</p>
<p>gradle主动监控堆内存的使用，并且试图检测到内存泄漏的发生点，将可用的内存排出到守护进程中。当gradle查到了一个堆内存空间的问题，gradle守护进程会结束掉当前正在运行的构建，并在下次构建中重启守护进程。这种检测是默认开启的，可用通过系统属性<code>org.gradle.daemon.performance.enable-monitoring</code>设置为false来关闭。</p>
<p>如果怀疑守护进程开始变得不稳定了，那么我们可以轻松的杀死它。再次使用<code>--no-daemon</code>这个开关，可以指定一个构建不使用守护进程。通过这种方式，我们能判断守护进程是否是造成问题的罪魁祸首。</p>
<h2 id="4-什么情况下我不该使用守护进程"><a href="#4-什么情况下我不该使用守护进程" class="headerlink" title="4.什么情况下我不该使用守护进程"></a>4.什么情况下我不该使用守护进程</h2><p>我们推荐所有的开发者的环境中都是用守护进程。但我们<strong>不建议</strong>在持续集成(Continuous Integration)和构建服务器上使用守护进程。</p>
<p>守护进程带来的快速构建，对于坐在机器前的开发人员是格外有意义的。对于持续集成构建服务来说，稳定性和可预见性，是最重要的。对每一个构建使用一个新的完全与上次构建隔离的运行时（比如进程），是一种更可靠的方案。</p>
<h2 id="5-Tools-amp-IDEs"><a href="#5-Tools-amp-IDEs" class="headerlink" title="5.Tools &amp; IDEs"></a>5.Tools &amp; IDEs</h2><p>Gradle Tooling API（见<a href="https://docs.gradle.org/current/userguide/embedding.html">Chapter 13, Embedding Gradle using the Tooling API</a>），通过其他IDE或者一些gradle整合工具来使用时，<strong>通常</strong>都会用到守护进程来执行构建。如果你通过你的IDE来使用守护进程执行构建，那么你不需要在环境中开启守护进程。</p>
<p>然而除非你已经明确指定了开启守护进程，否则你的命令行执行的构建将不使用守护进程。</p>
<h2 id="6-守护进程是如何提高gradle构建速度的？"><a href="#6-守护进程是如何提高gradle构建速度的？" class="headerlink" title="6.守护进程是如何提高gradle构建速度的？"></a>6.守护进程是如何提高gradle构建速度的？</h2><p>gradle守护进程是一个<strong>长时间存活</strong>的构建进程。在每次构建之间的间隙，它都会等在那里，直到下次构建。显而易见，多次构建中只加载一次gradle到内存中，与每次构建都加载一次相比，是有很大的好处的。这本身是一个显著的性能优化，但它本身也不会被终止掉。</p>
<p>对于现代的JVM来说，运行时代码优化是意义重大的。例如：热区（是一种作为OpenJDK的基础，由Oracle提供支持的JVM的实现技术）会在运行时对代码进行优化。优化是渐进的，而不是瞬时的。也就是说，代码是在执行过程中逐步优化的，这意味着后面的构建可以执行的更快，这纯粹由于这个优化过程导致的。通过对热区的实验表明，5到10个构建之后，优化的效果将趋于稳定。通过守护进程进行第1次构建，和进行第10次构建，感知层面是有很大的差异的。</p>
<p>守护进程也可以更有效的在内存中缓存的构建。例如：构建所需的类（比如插件，脚本），可以在每次构建之间缓存到内存中。同样，Gradle可将构建数据比如task的输入输出文件的哈希值维持在内存缓存中，用于增量构建。</p>
<h3 id="6-1-未来更强大的功能"><a href="#6-1-未来更强大的功能" class="headerlink" title="6.1 未来更强大的功能"></a>6.1 未来更强大的功能</h3><p>目前，守护进程通过内存缓存和JVM的优化使得构建执行的更快。在以后的gradle版本中，守护进程将变得更加智能，以及做到<strong>预先执行</strong>的效果。比如，他可以在构建脚本被编辑之后加入了新的改动或者添加必要的依赖时，假设当前脚本是用来运行的，并立刻开始下载依赖项。</p>
<p>在未来的gradle版本中，将有更多其他的方式来提高构建速度。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-使用gradle命令行</title>
    <url>/2016/07/07/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8gradle%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="1-执行多条tasks"><a href="#1-执行多条tasks" class="headerlink" title="1.执行多条tasks"></a>1.执行多条tasks</h2><p>gradle可以在一次构建中执行多条tasks。例如：命令<code>gradle compile test</code>将会执行<code>compile</code>和<code>test</code>这两条task。gradle将会按照命令行上输入的顺序去执行这些task。并且也会去执行这些task所依赖的(dependencies)task。并且保证每个task只被执行一次。</p>
<p>例如：</p>
<p>如下四个task</p>
<p><img src="/img/16_07_09/commandLineTutorialTasks.png" alt=""></p>
<p>build.gradle:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> <span class="keyword">compile</span> &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">&#x27;compiling source&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> compileTest(dependsOn: <span class="keyword">compile</span>) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">&#x27;compiling unit tests&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> test(dependsOn: [<span class="keyword">compile</span>, compileTest]) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">&#x27;running unit tests&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> dist(dependsOn: [<span class="keyword">compile</span>, test]) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">&#x27;building the distribution&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>命令行输入<code>gradle dist test</code>的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle dist test</span><br><span class="line">:compile</span><br><span class="line">compiling source</span><br><span class="line">:compileTest</span><br><span class="line">compiling unit tests</span><br><span class="line">:test</span><br><span class="line">running unit tests</span><br><span class="line">:dist</span><br><span class="line">building the distribution</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1 secs</span><br></pre></td></tr></table></figure>
<p>可以看到每个task只被执行一次，因此命令<code>gradle test test</code>和<code>gradle test</code>的执行效果是一样的。</p>
<h2 id="2-排除某个task-x-someTask"><a href="#2-排除某个task-x-someTask" class="headerlink" title="2.排除某个task(-x someTask)"></a>2.排除某个task(<code>-x someTask</code>)</h2><p>你也可以通过<code>-x</code>的命令参数来排除某个task的执行：</p>
<p>以下是命令<code>gradle dist -x test</code>的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle dist -x test</span><br><span class="line">:compile</span><br><span class="line">compiling source</span><br><span class="line">:dist</span><br><span class="line">building the distribution</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1 secs</span><br></pre></td></tr></table></figure>
<p>从输出结果中可以看出来，<code>test</code>的task并没有被执行，即使它是<code>dist</code>所依赖的task。</p>
<p>有一个细节也许你已经注意到了：<code>test</code>所依赖的task例如<code>compileTest</code>并没有被执行，因为这个task并没有被其他不被排除的task所依赖，为什么<code>compile</code>这个task也是被<code>test</code>所依赖，但却被执行了呢？那是因为<code>compile</code>这个task被其他不被排除的task所依赖了。</p>
<h2 id="3-当发生失败的时候依然继续执行构建-continue"><a href="#3-当发生失败的时候依然继续执行构建-continue" class="headerlink" title="3.当发生失败的时候依然继续执行构建(--continue)"></a>3.当发生失败的时候依然继续执行构建(<code>--continue</code>)</h2><p>默认情况下，gradle会在任意一个task执行失败的时候立刻中断执行。gradle可以使得构建速度更快，但需要以隐藏发生的失败为代价。为了能够在一次构建的执行中发现尽可能多的失败，你可以使用<code>--continue</code>选项。</p>
<p>当在命令中加入<code>--continue</code>,gradle将会执行每一个要被执行的task，以及所有的依赖task，并且无错误的完成task，而不是一旦遇到错误就立马停止。并且每一个发生的失败都会在构建结束后上报出来。</p>
<p>如果一个task失败了，那么任何依赖于这个产生失败的task的子task也不会被执行，这样做是不安全的。例如，如果在测试代码中有一个编译失败，测试将不会运行；因为测试任务将直接或间接的取决于编译任务。</p>
<h2 id="4-task名字的缩写"><a href="#4-task名字的缩写" class="headerlink" title="4.task名字的缩写"></a>4.task名字的缩写</h2><p>当你在命令行上指定task时，你没必要指定task的全名。你只需要提供足够长的能唯一标识task的名字即可。例如：在上面的构建例子中，你可以通过命令<code>gradle d</code>来执行<code>dist</code>这条task。</p>
<p><code>gradle di</code>的输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle di</span><br><span class="line">:compile</span><br><span class="line">compiling source</span><br><span class="line">:compileTest</span><br><span class="line">compiling unit tests</span><br><span class="line">:test</span><br><span class="line">running unit tests</span><br><span class="line">:dist</span><br><span class="line">building the distribution</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1 secs</span><br></pre></td></tr></table></figure>
<p>你也可以通过每个task名称的单词的首字母的驼峰缩写来标识一个task：你可以通过执行<code>gradle compTest</code>或者甚至是<code>gradle cT</code>来执行<code>compileTest</code>这个task。</p>
<p><code>gradle cT</code>的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle cT</span><br><span class="line">:compile</span><br><span class="line">compiling source</span><br><span class="line">:compileTest</span><br><span class="line">compiling unit tests</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1 secs</span><br></pre></td></tr></table></figure>
<p>以上规则对<code>-x</code>项(排除某个task)也是适用的。</p>
<h2 id="5-选择某一条构建去执行"><a href="#5-选择某一条构建去执行" class="headerlink" title="5.选择某一条构建去执行"></a>5.选择某一条构建去执行</h2><p>当你运行gradle命令时，它会在当前目录中查找一个build文件。你可以使用<code>-b</code>选项来选择其他的build文件。如果你使用了<code>-b</code>选项，那么<code>settings.gradle</code>这个文件将不起作用。</p>
<p>举个例子：</p>
<p>选择一个工程使用build文件：</p>
<p>subdir/myproject.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &quot;using build file &#39;$buildFile.name&#39; in &#39;$buildFile.parentFile.name&#39;.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle -q -b subdir/myproject.gradle hello</code></p>
<p><em>这里<code>-q</code>是“安静模式”，指过程中只会输出错误log</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q -b subdir&#x2F;myproject.gradle hello</span><br><span class="line">using build file &#39;myproject.gradle&#39; in &#39;subdir&#39;.</span><br></pre></td></tr></table></figure>
<p>另外一种方式，你可以使用<code>-p</code>选项来指定项目所在的路径。对于多项目构建，你应该使用<code>-p</code>选项来代替<code>-b</code>选项。</p>
<p>执行<code>gradle -q -p subdir hello</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q -p subdir hello</span><br><span class="line">using build file &#39;build.gradle&#39; in &#39;subdir&#39;.</span><br></pre></td></tr></table></figure>
<h2 id="6-强制执行task-rerun-tasks-someTask"><a href="#6-强制执行task-rerun-tasks-someTask" class="headerlink" title="6.强制执行task(--rerun-tasks someTask)"></a>6.强制执行task(<code>--rerun-tasks someTask</code>)</h2><p>许多task，尤其是gradle自身的task，都支持<strong>incremental builds(增量构建)</strong>。这种task可以决定是否需要运行，或者通过最后一次运行之后的输入输出文件是否有变动来判断是否有必要重新运行。你可以通过在执行构建时gradle列出的<code>UP-TO-DATE</code>,来很容易的认出<code>incremental tasks</code>。</p>
<p>某些场景下，你也许希望忽略<code>up-to-date</code>的检查，来强制执行gradle所有的task。这种情况下，你只需要使用<code>--rerun-tasks</code>这条命令即可。</p>
<p>以下是两个例子的输出，分别是执行task带有和不带有<code>--rerun-tasks</code>命令：</p>
<p>执行<code>gradle doIt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle doIt</span><br><span class="line">:doIt UP-TO-DATE</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle --rerun-tasks doIt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle --rerun-tasks doIt</span><br><span class="line">:doIt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这将会强制执行全部的task，不仅仅是你在命令行上指定的那些。这有点像在运行<code>clean</code>，但不同的是没有任何的输出会被删除掉。</p>
</blockquote>
<h2 id="7-获取关于你的构建的信息"><a href="#7-获取关于你的构建的信息" class="headerlink" title="7.获取关于你的构建的信息"></a>7.获取关于你的构建的信息</h2><p>gradle提供了多个用来显示构建详情的内置task。这些可以被用来理解你项目构建的结构和依赖，以及用debug调试问题。</p>
<p>除了这些内置task之外，    你也可以使用project report plugin(项目报告插件)，添加到你的项目中，就可以生成这些信息报告了。</p>
<h3 id="7-1-展示项目列表-gradle-projects"><a href="#7-1-展示项目列表-gradle-projects" class="headerlink" title="7.1.展示项目列表(gradle projects)"></a>7.1.展示项目列表(<code>gradle projects</code>)</h3><p>运行<code>gradle projects</code>，你会得到一个你所选项目的子项目清单，并且是分层显示的哦。下面就是一个例子：</p>
<p>输入<code>gradle -q projects</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q projects</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Root project &#39;projectReports&#39;</span><br><span class="line">+--- Project &#39;:api&#39; - The shared API for the application</span><br><span class="line">\--- Project &#39;:webapp&#39; - The Web application implementation</span><br><span class="line"></span><br><span class="line">To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks</span><br><span class="line">For example, try running gradle :api:tasks</span><br></pre></td></tr></table></figure>
<p>该报告展示了每个项目的描述（如果项目被设置了描述）。你也可以通过设置描述特性，来为一个项目提供一个描述。</p>
<p>例如在<code>build.gradle</code>中添加描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">description &#x3D; &#39;The shared API for the application&#39;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-展示task列表-gradle-tasks"><a href="#7-2-展示task列表-gradle-tasks" class="headerlink" title="7.2 展示task列表(gradle tasks)"></a>7.2 展示task列表(<code>gradle tasks</code>)</h3><p>运行<code>gradle tasks</code>可以得到当前项目的主task。生成的报告清单会显示所有的默认task，当然，如果有描述信息的话，也会一并显示。</p>
<p>例如：</p>
<p>运行<code>gradle -q tasks</code>会得到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q tasks</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Default tasks: dists</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">clean - Deletes the build directory (build)</span><br><span class="line">dists - Builds the distribution</span><br><span class="line">libs - Builds the JAR</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build. [incubating]</span><br><span class="line">wrapper - Generates Gradle wrapper files. [incubating]</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared in root project &#39;projectReports&#39;.</span><br><span class="line">components - Displays the components produced by root project &#39;projectReports&#39;. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project &#39;projectReports&#39;.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project &#39;projectReports&#39;.</span><br><span class="line">help - Displays a help message.</span><br><span class="line">model - Displays the configuration model of root project &#39;projectReports&#39;. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project &#39;projectReports&#39;.</span><br><span class="line">properties - Displays the properties of root project &#39;projectReports&#39;.</span><br><span class="line">tasks - Displays the tasks runnable from root project &#39;projectReports&#39; (some of the displayed tasks may belong to subprojects).</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradle tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradle help --task &lt;task&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，此报告只显示已被分配给一个task group的task。你可以设置task的所在组，也可以设置task的描述信息。这些设置都会在这份报告中展示。</p>
<p>例如：</p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dists &#123;</span><br><span class="line">    description &#x3D; &#39;Builds the distribution&#39;</span><br><span class="line">    group &#x3D; &#39;build&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过使用<code>--all</code>命令来获取更多的task列表信息。通过这个命令，task列表报告单会显示当前项目的所有的task，并且会按照主task以及每个task的依赖进行分组展示。下面是一个例子：</p>
<p>获取有关task的更多信息</p>
<p>执行<code>gradle -q tasks --all</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q tasks --all</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Default tasks: dists</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">clean - Deletes the build directory (build)</span><br><span class="line">api:clean - Deletes the build directory (build)</span><br><span class="line">webapp:clean - Deletes the build directory (build)</span><br><span class="line">dists - Builds the distribution [api:libs, webapp:libs]</span><br><span class="line">    docs - Builds the documentation</span><br><span class="line">api:libs - Builds the JAR</span><br><span class="line">    api:compile - Compiles the source files</span><br><span class="line">webapp:libs - Builds the JAR [api:libs]</span><br><span class="line">    webapp:compile - Compiles the source files</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build. [incubating]</span><br><span class="line">wrapper - Generates Gradle wrapper files. [incubating]</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared in root project &#39;projectReports&#39;.</span><br><span class="line">api:buildEnvironment - Displays all buildscript dependencies declared in project &#39;:api&#39;.</span><br><span class="line">webapp:buildEnvironment - Displays all buildscript dependencies declared in project &#39;:webapp&#39;.</span><br><span class="line">components - Displays the components produced by root project &#39;projectReports&#39;. [incubating]</span><br><span class="line">api:components - Displays the components produced by project &#39;:api&#39;. [incubating]</span><br><span class="line">webapp:components - Displays the components produced by project &#39;:webapp&#39;. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project &#39;projectReports&#39;.</span><br><span class="line">api:dependencies - Displays all dependencies declared in project &#39;:api&#39;.</span><br><span class="line">webapp:dependencies - Displays all dependencies declared in project &#39;:webapp&#39;.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project &#39;projectReports&#39;.</span><br><span class="line">api:dependencyInsight - Displays the insight into a specific dependency in project &#39;:api&#39;.</span><br><span class="line">webapp:dependencyInsight - Displays the insight into a specific dependency in project &#39;:webapp&#39;.</span><br><span class="line">help - Displays a help message.</span><br><span class="line">api:help - Displays a help message.</span><br><span class="line">webapp:help - Displays a help message.</span><br><span class="line">model - Displays the configuration model of root project &#39;projectReports&#39;. [incubating]</span><br><span class="line">api:model - Displays the configuration model of project &#39;:api&#39;. [incubating]</span><br><span class="line">webapp:model - Displays the configuration model of project &#39;:webapp&#39;. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project &#39;projectReports&#39;.</span><br><span class="line">api:projects - Displays the sub-projects of project &#39;:api&#39;.</span><br><span class="line">webapp:projects - Displays the sub-projects of project &#39;:webapp&#39;.</span><br><span class="line">properties - Displays the properties of root project &#39;projectReports&#39;.</span><br><span class="line">api:properties - Displays the properties of project &#39;:api&#39;.</span><br><span class="line">webapp:properties - Displays the properties of project &#39;:webapp&#39;.</span><br><span class="line">tasks - Displays the tasks runnable from root project &#39;projectReports&#39; (some of the displayed tasks may belong to subprojects).</span><br><span class="line">api:tasks - Displays the tasks runnable from project &#39;:api&#39;.</span><br><span class="line">webapp:tasks - Displays the tasks runnable from project &#39;:webapp&#39;.</span><br></pre></td></tr></table></figure>
<h3 id="7-3-显示task的使用细节-gradle-help-task-someTask"><a href="#7-3-显示task的使用细节-gradle-help-task-someTask" class="headerlink" title="7.3 显示task的使用细节(gradle help --task someTask)"></a>7.3 显示task的使用细节(<code>gradle help --task someTask</code>)</h3><p>运行<code>gradle help --task someTask</code>会得到一个关于你所选择的task或者与你输入名称相匹配的一系列task的详细信息。</p>
<p>下面是一个例子：</p>
<p><code>gradle -q help --task libs</code>执行的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q help --task libs</span><br><span class="line">Detailed task information for libs</span><br><span class="line"></span><br><span class="line">Paths</span><br><span class="line">     :api:libs</span><br><span class="line">     :webapp:libs</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">     Task (org.gradle.api.Task)</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">     Builds the JAR</span><br><span class="line"></span><br><span class="line">Group</span><br><span class="line">     build</span><br></pre></td></tr></table></figure>
<p>这些信息包含全部的task路径，task的类型，可能有的命令行选项和给定的task的描述。</p>
<h3 id="7-4-列出项目的依赖项-gradle-dependencies"><a href="#7-4-列出项目的依赖项-gradle-dependencies" class="headerlink" title="7.4 列出项目的依赖项(gradle dependencies)"></a>7.4 列出项目的依赖项(<code>gradle dependencies</code>)</h3><p>运行<code>gradle dependencies</code>，列出了所选项目的所有依赖，以及被配置项分解的依赖。对于每个配置，该配置的直接和传递的依赖关系都会在树中显示。下面是一个例子：</p>
<p><strong>获取依赖关系的信息</strong></p>
<p>运行<code>gradle -q dependencies api:dependencies webapp:dependencies</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q dependencies api:dependencies webapp:dependencies</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">No configurations</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Project :api - The shared API for the application</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">compile</span><br><span class="line">\--- org.codehaus.groovy:groovy-all:2.4.4</span><br><span class="line"></span><br><span class="line">testCompile</span><br><span class="line">\--- junit:junit:4.12</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Project :webapp - The Web application implementation</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">compile</span><br><span class="line">+--- project :api</span><br><span class="line">|    \--- org.codehaus.groovy:groovy-all:2.4.4</span><br><span class="line">\--- commons-io:commons-io:1.2</span><br><span class="line"></span><br><span class="line">testCompile</span><br><span class="line">No dependencies</span><br></pre></td></tr></table></figure>
<p>由于一个依赖报告可能会变得很大，所以有必要通过一些配置来过滤依赖报告的显示。通过命令参数<code>--configuration</code>来实现：</p>
<p><strong>通过配置来过滤依赖项报告</strong></p>
<p><code>gradle -q api:dependencies --configuration testCompile</code>的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q api:dependencies --configuration testCompile</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Project :api - The shared API for the application</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">testCompile</span><br><span class="line">\--- junit:junit:4.12</span><br><span class="line">     \--- org.hamcrest:hamcrest-core:1.3</span><br></pre></td></tr></table></figure>
<h3 id="7-5-列出项目构建脚本依赖-gradle-buildEnvironment"><a href="#7-5-列出项目构建脚本依赖-gradle-buildEnvironment" class="headerlink" title="7.5 列出项目构建脚本依赖(gradle buildEnvironment)"></a>7.5 列出项目构建脚本依赖(<code>gradle buildEnvironment</code>)</h3><p>运行<code>gradle buildEnvironment</code>可以看见项目的依赖的构建脚本，类似于执行<code>gradle dependencies</code>列出构建的依赖项的展示。</p>
<h3 id="7-6-观察一个特定的依赖项"><a href="#7-6-观察一个特定的依赖项" class="headerlink" title="7.6 观察一个特定的依赖项"></a>7.6 观察一个特定的依赖项</h3><p>运行<code>gradle dependencyInsight</code>你将得到一个与你输入匹配的一条或多条依赖项的内部信息。下面是一个例子：</p>
<p><strong>观察一个特定的依赖</strong></p>
<p>运行<code>gradle -q webapp:dependencyInsight --dependency groovy --configuration compile</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q webapp:dependencyInsight --dependency groovy --configuration compile</span><br><span class="line">org.codehaus.groovy:groovy-all:2.4.4</span><br><span class="line">\--- project :api</span><br><span class="line">     \--- compile</span><br></pre></td></tr></table></figure>
<p>这个task对于解决调查一个依赖，发现一定的依赖关系是从哪里来的，某些版本的选择原因是什么，是非常有用的。更多的信息，请查阅<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.DependencyInsightReportTask.html">DependencyInsightReportTask</a>类的API文档。</p>
<p>内置的dependencyInsight task在’Help’的task组内。task需要配置依赖项和设置信息。该报告查找在指定的配置中匹配指定的依赖性规范的依赖。如果应用java相关的插件，那么dependencyInsight task就被预配置了’compile’这条配置，因为通常情况下，编译依赖是我们感兴趣的。你应该指定你感兴趣的依赖，通过命令行<code>--dependency</code>选项。如果你不喜欢的默认值，你可以通过<code>--configuration</code>选项来选择配置。更多的信息，请查阅<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.diagnostics.DependencyInsightReportTask.html">DependencyInsightReportTask</a>类的API文档。</p>
<h3 id="7-7-列出项目属性gradle-properties"><a href="#7-7-列出项目属性gradle-properties" class="headerlink" title="7.7 列出项目属性gradle properties"></a>7.7 列出项目属性<code>gradle properties</code></h3><p>运行<code>gradle properties</code>列出一个项目属性的列表。下面是一小片输出：</p>
<p><strong>信息的属性</strong></p>
<p><code>gradle -q api:properties</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q api:properties</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Project :api - The shared API for the application</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">allprojects: [project &#39;:api&#39;]</span><br><span class="line">ant: org.gradle.api.internal.project.DefaultAntBuilder@12345</span><br><span class="line">antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@12345</span><br><span class="line">artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@12345</span><br><span class="line">asDynamicObject: DynamicObject for project &#39;:api&#39;</span><br><span class="line">baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@12345</span><br><span class="line">buildDir: &#x2F;home&#x2F;user&#x2F;gradle&#x2F;samples&#x2F;userguide&#x2F;tutorial&#x2F;projectReports&#x2F;api&#x2F;build</span><br><span class="line">buildFile: &#x2F;home&#x2F;user&#x2F;gradle&#x2F;samples&#x2F;userguide&#x2F;tutorial&#x2F;projectReports&#x2F;api&#x2F;build.gradle</span><br></pre></td></tr></table></figure>
<h3 id="7-8-分析构建-profile"><a href="#7-8-分析构建-profile" class="headerlink" title="7.8 分析构建(--profile)"></a>7.8 分析构建(<code>--profile</code>)</h3><p><code>--profile</code>命令选项会在你执行构建上报出有用的定时信息，并输出在<code>build/reports/profile</code>目录下。报告被命名为构建运行的时间。</p>
<p>这份报告列出了配置阶段和任务执行的汇总时间和详细信息。配置和任务执行的时间按照花费时间最高到最低进行排序。任务执行结果还表明，是否有任何任务被跳过（以及原因），或者如果没有跳过的任务没有工作。</p>
<p>利用buildsrc目录的构建，将在buildSrc/build目录下会生成第二份报告。</p>
<p><img src="/img/16_07_09/profile.png" alt=""></p>
<h2 id="8-Dry-Run"><a href="#8-Dry-Run" class="headerlink" title="8.Dry Run"></a>8.Dry Run</h2><p>有时，您是希望在命令行上指定一组给定的task的执行的顺序，但你不希望task被执行。你可以使用<code>-m</code>命令项。例如<code>gradle -m clean compile</code>，你将会看见全部作为clean和compile的task的一部分的将被执行的task。这些会展示给你所依赖的可被执行的task。</p>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h2><p>在这一节中，你看到了你可以通过gradle命令行做到的一些事情，更多命令可以查阅<a href="https://docs.gradle.org/current/userguide/gradle_command_line.html">Appendix D, Gradle Command Line</a>。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-使用gradle图形界面</title>
    <url>/2016/07/22/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8gradle%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<blockquote>
<p>除了支持传统的命令行界面，Gradle提供了一个图形用户界面。可以通过<code>--gui</code>选项来开启。</p>
</blockquote>
<p><strong>Example 10.1. Launching the GUI</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradle --gui</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意这条命令会阻塞进程直到关闭GUI，在*nix下，使用<code>gradle --gui&amp;</code>这条命令，使得它运行在一个后台任务中是一个更好的选择。</p>
</blockquote>
<p>如果你在你的gradle工作目录下运行了这个命令，你将看到一个task树。</p>
<p><strong>Figure 10.1. GUI Task Tree</strong></p>
<p><img src="/img/gradle/guiTaskTree.png" alt=""></p>
<p>最好在你的gradle项目下运行这条命令，以便于用户界面的设置将存储在您的项目目录中。你也可以运行这条命令后通过用户界面中的“设置”选项卡更改工作目录。</p>
<p>用户界面顶部有4个tab，底部有一个输出窗口。</p>
<h2 id="10-1-Task-Tree"><a href="#10-1-Task-Tree" class="headerlink" title="10.1. Task Tree"></a>10.1. Task Tree</h2><p>任务树显示了所有项目和它们的任务的分层显示。双击一个任务可以执行它</p>
<p>顶部有一个过滤器按钮，您可以通过过滤器按钮切换过滤器。编辑筛选器允许您配置任务和项目所显示的项目。隐藏的task出现在红色区域中。注意：新创建的task将默认出现（相对的默认被隐藏）。</p>
<p>任务树上下文菜单提供以下选项：</p>
<ul>
<li>执行忽略依赖关系。不需要依赖的项目被重建（类似于<code>-a</code> 选项）。</li>
<li>将task添加到favorites中（见favorites tab）</li>
<li>隐藏选择的task。</li>
<li>编辑build.gradle文件。注意：这需要你的java版本&gt;= 1.6，并且你有和系统相匹配的.gradle文件。</li>
</ul>
<h2 id="10-2-Favorites"><a href="#10-2-Favorites" class="headerlink" title="10.2. Favorites"></a>10.2. Favorites</h2><p>Favorites tab是一个很好的用来存储经常被使用命令的地方。这里可以是一些很复杂的命令（只要是符合gradle规范的），并且你可以为他们提供一个显示名称。这可以用于：创建、说、自定义一个明确跳过测试的构建命令，文档，和样品，你可以称之为“快速构建”。</p>
<p>你可以对你列出的favorites进行重新排序，并且导出到磁盘上，并且被其他人引用。</p>
<h2 id="10-3-Command-Line"><a href="#10-3-Command-Line" class="headerlink" title="10.3. Command Line"></a>10.3. Command Line</h2><p>命令行界面你可以直接输入一条gradle命令。在你将命令添加到Favorites中，这也是一个让你尝试gradle命令的好地方。</p>
<h2 id="10-4-Setup"><a href="#10-4-Setup" class="headerlink" title="10.4. Setup"></a>10.4. Setup</h2><p>设置选项卡允许一些一般设置的配置。</p>
<p><strong>Figure 10.2. GUI Setup</strong></p>
<p><img src="/img/gradle/guiSetup.png" alt=""></p>
<ul>
<li><p>当前目录</p>
<p>  设置你的gradle项目的根目录（通常是build.gradle文件的所在位置）</p>
</li>
<li><p>堆栈跟踪输出</p>
<p>  取决于当你的错误发生时，有多少信息被写入。提示：如果在命令行或“Favorites”选项卡上指定了堆栈跟踪级别，则将覆盖该堆栈跟踪级别。</p>
</li>
<li><p>只有当错误发生时才显示输出</p>
<p>  启用此选项隐藏任务执行时的任何输出，除非生成失败。</p>
</li>
<li><p>使用自定义gradle执行器 - 高级功能</p>
<p>  这为你提供了另一种方式推出Gradle的命令。如果你的项目需要一些额外的设置，这将会很有用，这是在一个批处理文件或脚本（如指定init脚本）内完成的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-依赖管理基础</title>
    <url>/2016/07/11/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>这一节将介绍一些gradle中依赖管理的基本知识。</p>
<h2 id="1-什么是依赖管理？"><a href="#1-什么是依赖管理？" class="headerlink" title="1.什么是依赖管理？"></a>1.什么是依赖管理？</h2><p>粗略的说，依赖管理是由两个部分组成的。首先，gradle需要知道你的项目需要执行的一些构建和一些运行的信息，通过这些信息可以找到它们。我们称这些传入的文件为项目的<strong>依赖（dependencies）</strong>。第二，Gradle需要构建和上传您的项目产生的东西。我们把这些传出的文件称为项目的<strong>出版物（publications）</strong>。让我们更详细地看一下这两部分：</p>
<p>大多数项目并不是完全独立的。它们需要其他项目构建的文件以便于被编译或测试，等。例如，为了在我的项目中使用Hibernate,我需要在编译我的源代码时引入一些Hibernate的jar包到classpath中。为了运行我的测试，我也许需要引入一些额外的jar包到test的classpath中，例如一个特定的JDBC驱动，或者Ehcache jar包。</p>
<p>这些传入的文件形成了项目的依赖关系。gradle允许你告诉它你的项目依赖是怎样的，这样以来它可以照顾好你的项目依赖关系，并且在你的构建中也是可以生效的。依赖可能需要从远程仓库Maven、lvy下载到本地，或者也有可能存在于本地目录，或者也许是同一个多项目构建的项目中的一个其他项目。我们称这个过程为<strong>依赖解析(dependency resolution)</strong>。</p>
<p>请注意，这里提到的这个主要功能的优势超越了Ant。用Ant时，你只能通过指定jar包加载的绝对路径或相对路径。然而在使用gradle时，你只需要简单的声明依赖的“名字”，以及指定其他层是从哪里获得这些依赖的即可。你可以通过在Ant上添加Apache lvy来简化这些操作，但gradle会处理的更好。</p>
<p>通常，一个项目的依赖，其自身也存在依赖。例如，Hibernate内核需要添加几个其他的库到classpath中，才能正常运行。因此，当gradle在你的项目中运行测试，也需要去找到它的依赖项并且确保它们是可用的。我们称这种为<strong>过渡依赖(transitive dependencies)</strong>。</p>
<p>很多项目就是为了让外部项目来使用的。例如，如果你的项目提供一个java库，你需要构建一个jar包，并且可能是源码jar以及一些文档，并将它们发布到某个地方。</p>
<p>这些发出来的文件形成了这些项目的出版物。gradle也会做好这些工作的。你声明你的项目的出版物，然后gradle会负责构建并将它们发布到某个地方。究竟“发布（publishing）”是什么意思，取决于你具体想怎么做。也许你只是想从本地目录拷贝文件，或者上传它们到一个远端的Maven或lvy仓库，或者你使用的文件是当前项目中多个子项目中的另一个子项目中的。我们称这种行为是<strong>发布(publishing)</strong>。</p>
<h2 id="2-声明你的依赖"><a href="#2-声明你的依赖" class="headerlink" title="2.声明你的依赖"></a>2.声明你的依赖</h2><p>让我们来看看一些依赖的声明。这是一个基本构建脚本：</p>
<p><strong>声明依赖</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &#39;org.hibernate&#39;, name: &#39;hibernate-core&#39;, version: &#39;3.6.7.Final&#39;</span><br><span class="line">    testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.+&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些是什么呢？这些构建脚本描述了一些项目的事情。首先，规定了编译项目源码需要用到版本为“3.6.7.Final”的Hibernate core。言外之意，Hibernate core和它自身的依赖项也将在运行时被使用到。这个构建脚本也指出编译项目的测试，需要任意版本&gt;=4.0的junit。这也是再告诉gradle去看看Maven中央仓库里是否有其他的依赖被用到。下面我们详细来介绍一下。</p>
<h2 id="3-依赖配置"><a href="#3-依赖配置" class="headerlink" title="3.依赖配置"></a>3.依赖配置</h2><p>在gradle中依赖是在设置中分组配置的。一个配置是一个被命名的一系列依赖项。我们把它们称为依赖配置。您可以使用它们来声明项目的外部依赖关系。我们稍后也会看到，他们会被用来申报你的项目的publications。</p>
<p>java插件定义了大量的标准配置。这些配置表示java插件使用到的classpath。一些已经列在下面，你可以在<a href="https://docs.gradle.org/current/userguide/java_plugin.html#tab:configurations">Table 45.5, “Java plugin - dependency configurations”</a>看到更多的详细信息。</p>
<ul>
<li><p><strong>compile</strong></p>
<p>  编译项目所需要的依赖</p>
</li>
<li><p><strong>runtime</strong></p>
<p>  项目运行所需要的依赖。默认情况下，也包含编译时的依赖。</p>
</li>
<li><p><strong>testCompile</strong></p>
<p>  项目测试是所需要的依赖。默认情况下，也包含已编译的项目的类和编译时依赖。</p>
</li>
<li><p><strong>testRuntime</strong></p>
<p>  运行测试所需的依赖关系。默认情况下，包含编译、运行时和测试编译所需要的依赖。</p>
</li>
</ul>
<p>各种插件添加更多的配置。你也可以在你的构建中使用自定义配置。关于定义和定制依赖的设置，详情请见<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sub:configurations">Section 23.3, “Dependency configurations</a></p>
<h2 id="4-外部依赖"><a href="#4-外部依赖" class="headerlink" title="4.外部依赖"></a>4.外部依赖</h2><p>你可以声明各种各样的依赖类型。一类是<strong>外部依赖(external dependency)</strong>。这是一些依赖于非当前构建的外部文件，这些文件存储在某个外部库中，如Maven中央仓库、公司级Maven、lvy库，或本地的目录。</p>
<p>如果要定义一个外部依赖关系，您需要将它添加到依赖配置中：</p>
<p><strong>外部依赖的定义</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;    compile group:&#39;org.hibernate&#39;, name:&#39;hibernate-core&#39;, version:&#39;3.6.7.Final&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>一个外部依赖是通过组名，库名，以及版本号来唯一标示的。其中组名和版本号是可选的。</p>
<p>也可以使用类似于：<code>&quot;group:name:version&quot;</code>的简写形式。</p>
<p><strong>外部依赖定义的简写形式</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;    compile&#39;org.hibernate:hibernate-core:3.6.7.Final&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于依赖的定义和使用，见<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:how_to_declare_your_dependencies">Section 23.4, “How to declare your dependencies”</a>。</p>
<h2 id="5-仓库"><a href="#5-仓库" class="headerlink" title="5.仓库"></a>5.仓库</h2><p>gradle是如何找到外部依赖的文件的呢？gradle通过在一个<strong>仓库repository</strong>中寻找这些文件。一个仓库其实就是一个通过组名，文件名和版本号标识的文件集合。gradle能理解几种不同的仓库格式，例如Maven，lvy，以及几种不同的方式访问仓库，如本地文件系统或者http。</p>
<p>默认情况下，gradle并没有定义任何仓库。在你使用外部依赖之前你需要定义至少一个仓库。一种可选的方案是使用Maven中央仓库：</p>
<p><strong>使用Maven中央仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是JCenter</p>
<p><strong>使用JCenter仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者其他任何一个远程Maven仓库：</p>
<p><strong>使用一个远程Maven仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &quot;http:&#x2F;&#x2F;repo.mycompany.com&#x2F;maven2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用一个lvy仓库：</p>
<p><strong>使用一个远程lvy地址</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url &quot;http:&#x2F;&#x2F;repo.mycompany.com&#x2F;repo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以通过本地文件系统构建仓库。这对于Maven和lvy都适用。</p>
<p><strong>使用本地lvy地址</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        &#x2F;&#x2F; URL can refer to a local directory</span><br><span class="line">        url &quot;..&#x2F;local-repo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个项目可以有多个仓库。gradle会按照仓库的声明顺序在每一个仓库中去寻找指定的依赖，当第一次找到的时，就停止搜索。</p>
<p>更多关于仓库的声明和使用，见<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:repositories">Section 23.6, “Repositories”</a>。</p>
<h2 id="6-发布工件"><a href="#6-发布工件" class="headerlink" title="6.发布工件"></a>6.发布工件</h2><p>依赖配置同样也可以被用来发布文件。我们称这些文件为<strong>发布工件publication artifacts</strong>，或者仅仅是<strong>工件artifacts</strong>。</p>
<p>插件很好的完成了定义一个项目的工件的工作，因此你不需要做任何特殊的事情来告诉gradle需要发布什么。<br>但是，你需要告诉gradle这些工件要发布到哪里。你需要通过uploadArchives task来将你的项目附加到某个库上。下面是一个发布到远端lvy仓库的例子：</p>
<p><strong>发布到一个远端lvy仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ivy &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username &quot;username&quot;</span><br><span class="line">                password &quot;pw&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            url &quot;http:&#x2F;&#x2F;repo.mycompany.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当你运行<code>gradle uploadArchives</code>时，gradle就开始构建并上传jar包了。同时gradle也会生成一个<code>ivy.xml</code>并上传到仓库中。</p>
<p>你也可以上传到Maven仓库中。语法有一些不一样。<strong>注意</strong>你需要使用Maven插件来支持上传到Maven仓库的操作。在这种情况下，gradle会生成一个<code>pom.xml</code>文件，并上传到Maven仓库中。</p>
<p><strong>发布到一个Maven仓库</strong></p>
<p>build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: &quot;file:&#x2F;&#x2F;localhost&#x2F;tmp&#x2F;myRepo&#x2F;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于发布的信息，请看<a href="https://docs.gradle.org/current/userguide/artifact_management.html">Chapter 30, Publishing artifacts</a>。</p>
<h2 id="7-下一步去哪？"><a href="#7-下一步去哪？" class="headerlink" title="7.下一步去哪？"></a>7.下一步去哪？</h2><p>关于的依赖解析的全部详情，见<a href="https://docs.gradle.org/current/userguide/dependency_management.html">Chapter 23, Dependency Management</a>，关于发布工件的详情见<a href="https://docs.gradle.org/current/userguide/artifact_management.html">Chapter 30, Publishing artifacts</a>。</p>
<p>如果你对上述的DSL元素感兴趣，请看<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure">Project.configurations{}</a>)，<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure">Project.repositories{}</a>)和<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure">Project.dependencies{}</a>)。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-多项目构建介绍</title>
    <url>/2016/07/11/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>只有小规模的项目具有单一的构建文件和源码，除非恰好是一个大规模的整体的应用。项目被分割成更小的、相互依赖的模块，往往会更容易理解和处理。“相互依赖”这个词很重要，因此，这就是为什么你通常希望通过一个单一的构建将多个模块链接起来。</p>
<p>gradle通过<strong>多项目构建(multi-project)</strong>来支持这种需求。</p>
<h2 id="1-多项目构建的结构"><a href="#1-多项目构建的结构" class="headerlink" title="1.多项目构建的结构"></a>1.多项目构建的结构</h2><p>这种构建引入了各种各样的子项目，但它们都有共同的特点：</p>
<ul>
<li>在项目的根目录都有一个<code>settings.gradle</code>文件</li>
<li>在根目录或主目录下都有一个<code>build.gradle</code>文件</li>
<li>每个字目录都有他们自己的<code>*.gradle</code>文件（有些多项目构建结构也许会胜率子项目的构建脚本）</li>
</ul>
<p><code>settings.gradle</code>告诉gradle主项目和子项目的结构是怎样的。幸运的是，你其实不必通过读这个文件来了解项目的结构是怎样，如果你想要了解项目结构的话，通过运行命令<code>gradle projects</code>就可以了。下面是一个在<strong>多项目(multiproject)</strong>下使用命令的例子：</p>
<p><strong>列出一次构建中的项目</strong></p>
<p>gradle -q projects</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gradle -q projects</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Root project &#39;multiproject&#39;</span><br><span class="line">+--- Project &#39;:api&#39;</span><br><span class="line">+--- Project &#39;:services&#39;</span><br><span class="line">|    +--- Project &#39;:services:shared&#39;</span><br><span class="line">|    \--- Project &#39;:services:webservice&#39;</span><br><span class="line">\--- Project &#39;:shared&#39;</span><br><span class="line"></span><br><span class="line">To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks</span><br><span class="line">For example, try running gradle :api:tasks</span><br></pre></td></tr></table></figure>
<p>输出结果会告诉你，这个多项目构建有三个直接的子项目：<strong>api</strong>，<strong>services</strong>和<strong>shared</strong>。其中<strong>services</strong>还有属于它的子项目:<strong>shared</strong>和<strong>webservice</strong>。通过这个目录结构图，我们可以很容易的找到任意一个其中的项目。例如：你可以通过这张图中发现<strong>webservice</strong>位于<code>&lt;root&gt;/services/webservice.</code>这个位置。</p>
<p>默认情况下，gradle使用<code>settings.gradle</code>文件的目录名来作为根项目的名称。这样做通常不会有什么问题，因为所有的开发者会在同一个项目中检出相同的目录名。在持续集成服务器上，例如Jenkins，目录名称可能会是自动生成的并且与你的版本控制工具中的名字并不匹配。因此，建议你设置一个可预测的项目名称，即使是一个单一构建的项目。你可以通过设置<code>rootProject.name</code>来配置根项目名。</p>
<p>每个项目都有属于它们自己的构建文件，但这并不是必须的。在上面的例子中，<strong>services</strong>项目仅仅是其他子项目的一个容器或者说是分组。在它相应的目录中没有构建文件。然而，多构建项目的根项目都有这个构建文件。</p>
<p>根项目的<code>build.gradle</code>通常会和子项目共享配置，例如主项目会和子项目共享自己的插件和依赖项。当所有的配置都在同一个地方，也可以通过配置这一处来达到配置所有子项目的效果。这意味着，当你发现某个子项目被配置了某个属性，你通常应该先经常检查根项目的构建文件。</p>
<p>另外一个需要被牢记的是构建配置的文件可能并不叫<code>build.gradle</code>。许多项目都会以子项目的名称来命名构建文件，例如之前例子中的<code>api.gradle</code>和<code>services.gradle</code>。在使用IDE时，这种做法有很大的好处，因为很难从几十个<code>build.gradle</code>文件中找出你要的具体是哪一个。对于<code>settings.gradle</code>文件的处理有一点小小的特殊，但对于一次构建，你不需要了解它是怎么做到这样的。只需要看一看子项目目录，去找一下以<code>.gradle</code>结尾的文件就行了。</p>
<p>一旦你知道子项目中能用到的是什么，那么关键的问题就是构建者如何在项目中执行这些task。</p>
<h2 id="2-执行一个多项目构建"><a href="#2-执行一个多项目构建" class="headerlink" title="2.执行一个多项目构建"></a>2.执行一个多项目构建</h2><p>从用户的角度去看，多项目构建任然是一系列可以用来运行的task。这不同于你想控制哪一个项目的task的执行。这里你有两条选项：</p>
<ul>
<li>改变子项目对应的目录到你想要的地方，然后正常的执行<code>gradle &lt;task&gt;</code>。</li>
<li>在任意目录下都使用一个符合标准的task的名称，尽管这通常是从根目录开始的。例如：<code>gradle :services:webservice:build</code>将执行<strong><code>webservice</code></strong>这个子项目以及它所依赖的所有子项目。</li>
</ul>
<p>第一种方法是类似于单项目的使用情况，但在多项目的gradle构建时略有不同。命令<code>gradle test</code>会执行相对于当前工作目录的所有子项目中的test task，前提是如果这些子项目中有这个名为<code>test</code>的task。因此，如果你在根项目的目录下运行命令，你也会在<strong>api</strong>, <strong>shared</strong>, <strong>services:shared</strong> 和<strong>services:webservice</strong>下运行test这个task。如果你仅仅在<strong>services</strong>这个项目下运行这个命令，那么只有<strong> services:shared</strong>和<strong>services:webservice</strong>这两个项目会执行test的task。</p>
<p>为了能更多的控制执行，可以使用符合标准的名字（上面提到的第二种方法）。这些路径类似于目录路径，但需要使用”:”而不是”/“或”\”。如果路径是以”:”开头的，那么路径会以根项目为相对路径去解析。换句话说，开头的”:”代表根项目本身。所有其他的冒号都是路径分隔符。</p>
<p>这种方法适用于任何task，所以，如果你想知道在一个特定的子项目的task是什么，只需使用类似这种方式：<code>gradle :services:webservice:tasks</code>。</p>
<p>无论你使用哪种方式来执行task，gradle都能处理好当前依赖的任何子项目的构建。你不用担心项目间依赖问题。如果你对它们是如何配置的感兴趣，你可以阅读写多项目构建的文档<a href="https://docs.gradle.org/current/userguide/multi_project_builds.html">later in the user guide</a>。</p>
<p>还有最后一件事要注意。当你使用gradle wrapper时，第一种方式不能很好的工作，因为如果你不在项目的根目录，你必须对你的wrapper脚本指定路径。举个例子：如果你在<strong>webservice</strong>这个子项目中，你必须执行<code>../../gradlew build</code></p>
<p>这就是构建者关于多项目构建需要了解的全部。现在你可以辨别一个构建是否是一个多项目构建项目，并且可以观察它的结构。最终你可以执行指定的子项目的task。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习笔记-持续构建</title>
    <url>/2016/07/13/gradle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>持续构建是一个正在发<strong>孵化中(<a href="https://docs.gradle.org/current/userguide/feature_lifecycle.html">incubating</a>)</strong>的feature。这意味着它目前还是不完整的，并且没有达到gradle产品的标准。这同样也意味着这一章节的用户指南也是在不断完善中的。</p>
</blockquote>
<p>通常，你让gradle执行一个你指定task。gradle需要制定一系列实际需要执行的满足要求的task，并将它们全部执行，然后停止工作直到下一次请求出现。持续构建不同于gradle那种通过在检查到之前的构建已经过时时执行构建，来保持满足初始化构建的条件（直到指示停止）。例如：如果你将java代码编译为class文件，一个持续构建将在源码文件改变时自动初始化一次编译。持续构建在很多场景下都很有用。</p>
<h2 id="1-我该如何开始和终止一个持续构建呢？"><a href="#1-我该如何开始和终止一个持续构建呢？" class="headerlink" title="1.我该如何开始和终止一个持续构建呢？"></a>1.我该如何开始和终止一个持续构建呢？</h2><p>一个持续构建可以通过输入<code>--continuous</code>或<code>-t</code>开关来开启，通过对任务列表中的任务切换开关和参数，来定义要执行的任务。例如：<code>gradle build --continuous</code>。这和执行<code>gradle build</code>的效果是一样的，但当gradle执行完时，它会等待发生改变的文件输入。当有改变产生时，<code>gradle build</code>将会被再次自动的执行，再次执行构建。</p>
<p>如果gradle附加在了一个交互式输入源，例如终端，持续构建会在按下<strong>CTRL-D</strong>（在Microsoft Windows上，在按下<strong>CTRL-D</strong>之后还需要按下<strong>ENTER</strong>或者<strong>RETURN</strong>）时执行。如果gradle没有附加在交互式输入源(例如以一个脚本的形式运行)，构建进程一定需要被中断（使用<code>kill</code>命令或类似的其他方式）。如果构建是通过Tooling API执行的，构建可以通过Tooling API的取消机制来终止。</p>
<h2 id="2-什么将会导致后续的构建？"><a href="#2-什么将会导致后续的构建？" class="headerlink" title="2.什么将会导致后续的构建？"></a>2.什么将会导致后续的构建？</h2><p>这时，只有对task输入的更改会被注意到。gradle会在task开始时就对改变进行监控。没有其他的改变会初始化一次构建。例如：对于构建脚本和构建逻辑的修改不会初始化构建。同样的，对于修改配置文件在构建时读入的文件，没有执行，将不会初始化一次构建。为了纳入这种变化，持续构建必须手动重启。</p>
<p>对于一个典型的使用java插件的构建，使用传统的文件系统布局。下面是<code>gradle build</code>的生词的task图。</p>
<p><strong>Java plugin task graph</strong></p>
<p><img src="/img/16_07_13/javaPluginTasks.png" alt=""></p>
<p>下面对于图中用到的task使用相对路径作为输入：</p>
<p><strong>compileJava</strong></p>
<pre><code>src/main/java
</code></pre><p><strong>processResources</strong></p>
<pre><code>src/main/resources
</code></pre><p><strong>compileTestJava</strong></p>
<pre><code>src/test/java
</code></pre><p><strong>processTestResources</strong></p>
<pre><code>src/test/resources
</code></pre><p>假设初始化构建执行成功（比如：构建task和它的依赖的编译都没有错误），对文件的更改，或者对文件的增删操作，上述的场景将会初始化一次构建。如果在<code>src/main/java</code>目录下的java代码发生了变动，构建将会启动，并且所有的task将开始执行。gradle的增量构建支持，确保只有被变动所影响的task会被执行。</p>
<p>如果主项目中的java代码编译失败，那么子变动<code>src/test/java</code>目录将不会被执行构建。由于测试代码依赖于主代码，直到主代码发生了改变，才有可能修复编译产生的错误。在每次构建之后，只有task的输入文件会被检测变化。</p>
<h2 id="3-限制和异常"><a href="#3-限制和异常" class="headerlink" title="3.限制和异常"></a>3.限制和异常</h2><p>目前有几个关于持续构建的问题。这些问题有可能会在未来的gradle版本中进行修复。</p>
<h3 id="3-1-构建循环"><a href="#3-1-构建循环" class="headerlink" title="3.1 构建循环"></a>3.1 构建循环</h3><p>gradle会在task执行之前就去监测改变。如果一个task在执行过程中改变了它自己，gradle将会查出这个变动，并且触发一次新的构建。如果每次task的执行，输入都被改变，那么构建就会再一次被触发。这不仅仅在持续构建中会出问题。当在“normally”模式并不是持续构建模式下运行，task改变了他自身的输入时也不会被视为有“up-to-date”标签。</p>
<p>如果你的构建进入了一个这样的循环，你可以通过gradle的查看报告清单中的变动追踪task。当确认有文件在每次构建期间发生了改变，你应该找到那个出问题的task。在某些情况下，这种问题会很明显（例如：java文件通过<code>compileJava</code>来执行编译）。在其他的情况下，你可以通过使用<code>--info logging</code>来找到识别为<code>out-of-date</code>的文件所在的task。</p>
<h3 id="3-2-需要Java7或更高版本"><a href="#3-2-需要Java7或更高版本" class="headerlink" title="3.2 需要Java7或更高版本"></a>3.2 需要Java7或更高版本</h3><p>gradle使用jdk的<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/WatchService.html">WatchService</a>来在每次构建之间接收文件改变的通知。这个API是在Java7中引进的。由于这个原因，gradle的持续构建暂时不支持在Java6下的构建。</p>
<h3 id="3-3-性能和稳定性"><a href="#3-3-性能和稳定性" class="headerlink" title="3.3 性能和稳定性"></a>3.3 性能和稳定性</h3><p>Jdk文件监控设备在 Mac OS X（见<a href="https://bugs.openjdk.java.net/browse/JDK-8079620">JDK-8079620</a>）上会依赖于一个无效的文件系统。这在大型项目中能感受到通知改变有显著的延迟。</p>
<p>此外，监控机制可能在 Mac OS X （见<a href="https://bugs.openjdk.java.net/browse/JDK-8079620">JDK-8079620</a>）下进行<strong>超负荷</strong>的加载时发生死锁。这表明，gradle不会通知文件改变。如果你怀疑这种情况发生了，退出持续构建，并且重新启动。</p>
<p>在Linux下，OpenJDK的文件检测服务有时会丢失一些系统事件（见：<a href="https://bugs.openjdk.java.net/browse/JDK-8145981">JDK-8145981</a>）。</p>
<h3 id="3-4-符号链接的更改"><a href="#3-4-符号链接的更改" class="headerlink" title="3.4 符号链接的更改"></a>3.4 符号链接的更改</h3><ul>
<li>创建或删除符号链接到文件将启动一次构建。</li>
<li>修改一个符号链接的目标不会导致重建。</li>
<li>创建或删除符号链接目录不会造成重建。</li>
<li>在一个符号链接的目标目录中创建新文件将不会导致重建。</li>
<li>删除目标目录将不会导致重建。</li>
</ul>
<h3 id="3-5-不考虑构建逻辑的更改"><a href="#3-5-不考虑构建逻辑的更改" class="headerlink" title="3.5 不考虑构建逻辑的更改"></a>3.5 不考虑构建逻辑的更改</h3><p>当前的实现是在不会重新计算构建模型。这意味着对task配置的更改，或者其他对构建modle的改动，都是被忽略的。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Jeklly搬家到Hexo</title>
    <url>/2015/08/28/helloWorld/</url>
    <content><![CDATA[<p>Hexo 果然比Jeklly 漂亮许多，使用了NexT的模版，以后可以愉快的写blog了～</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>java技巧－Collections.unmodifiableList获取一个只读List</title>
    <url>/2016/04/14/java%E6%8A%80%E5%B7%A7%EF%BC%8DCollections.unmodifiableList/</url>
    <content><![CDATA[<h2 id="java-util-Collections"><a href="#java-util-Collections" class="headerlink" title="java.util.Collections"></a>java.util.Collections</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns an unmodifiable view of the specified list.  This method allows</span></span><br><span class="line"><span class="comment">    * modules to provide users with &quot;read-only&quot; access to internal</span></span><br><span class="line"><span class="comment">    * lists.  Query operations on the returned list &quot;read through&quot; to the</span></span><br><span class="line"><span class="comment">    * specified list, and attempts to modify the returned list, whether</span></span><br><span class="line"><span class="comment">    * direct or via its iterator, result in an</span></span><br><span class="line"><span class="comment">    * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;.&lt;p&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * The returned list will be serializable if the specified list</span></span><br><span class="line"><span class="comment">    * is serializable. Similarly, the returned list will implement</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> RandomAccess&#125; if the specified list does.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  &lt;T&gt; the class of the objects in the list</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  list the list for which an unmodifiable view is to be returned.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an unmodifiable view of the specified list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">               <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(list) :</span><br><span class="line">               <span class="keyword">new</span> UnmodifiableList&lt;&gt;(list));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>unmodifiableList用来获取一个只可读，不可写的指定的list。如果试图去写入或者改变这个list，则会抛出一个UnsupportedOperationException异常。</p>
<p><strong>这是一个可以用来获取只可读不可写的list的方法。</strong></p>
<p>那么他具体是怎么实现的呢？可以看一下UnmodifiableList或者UnmodifiableRandomAccessList的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">                                 <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">283967356065247728L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> List&lt;? extends E&gt; list;</span><br><span class="line"></span><br><span class="line">       UnmodifiableList(List&lt;? extends E&gt; list) &#123;</span><br><span class="line">           <span class="keyword">super</span>(list);</span><br><span class="line">           <span class="keyword">this</span>.list = list;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;<span class="keyword">return</span> o == <span class="keyword">this</span> || list.equals(o);&#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>           </span>&#123;<span class="keyword">return</span> list.hashCode();&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span>            </span>&#123;<span class="keyword">return</span> list.indexOf(o);&#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span>        </span>&#123;<span class="keyword">return</span> list.lastIndexOf(o);&#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> listIterator(<span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ListIterator&lt;E&gt;() &#123;</span><br><span class="line">               <span class="keyword">private</span> <span class="keyword">final</span> ListIterator&lt;? extends E&gt; i</span><br><span class="line">                   = list.listIterator(index);</span><br><span class="line"></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>     </span>&#123;<span class="keyword">return</span> i.hasNext();&#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span>              </span>&#123;<span class="keyword">return</span> i.next();&#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i.hasPrevious();&#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span>          </span>&#123;<span class="keyword">return</span> i.previous();&#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span>       </span>&#123;<span class="keyword">return</span> i.nextIndex();&#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> i.previousIndex();&#125;</span><br><span class="line"></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">                   i.forEachRemaining(action);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * UnmodifiableRandomAccessList instances are serialized as</span></span><br><span class="line"><span class="comment">        * UnmodifiableList instances to allow them to be deserialized</span></span><br><span class="line"><span class="comment">        * in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList).</span></span><br><span class="line"><span class="comment">        * This method inverts the transformation.  As a beneficial</span></span><br><span class="line"><span class="comment">        * side-effect, it also grafts the RandomAccess marker onto</span></span><br><span class="line"><span class="comment">        * UnmodifiableList instances that were serialized in pre-1.4 JREs.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Note: Unfortunately, UnmodifiableRandomAccessList instances</span></span><br><span class="line"><span class="comment">        * serialized in 1.4.1 and deserialized in 1.4 will become</span></span><br><span class="line"><span class="comment">        * UnmodifiableList instances, as this method was missing in 1.4.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess</span><br><span class="line">                   ? <span class="keyword">new</span> UnmodifiableRandomAccessList&lt;&gt;(list)</span><br><span class="line">                   : <span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实现很简单，除了读操作相关的方法之外，例如remove,add,replaceAll,之类的操作，都抛出了UnsupportedOperationException异常。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorFlow运行android demo</title>
    <url>/2015/11/17/tensorFlow%E8%BF%90%E8%A1%8Candroid%20demo/</url>
    <content><![CDATA[<p>本月初，google开源了第二代深度机器学习系统tensorFlow。</p>
<p><a href="https://github.com/tensorflow/tensorflow">https://github.com/tensorflow/tensorflow</a></p>
<p>代码中提供了一个android的example，下面我们就来一步步把它运行起来。</p>
<hr>
<p>在代码的这层目录下，我们能看到android的example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tensorflow&#x2F;tensorflow&#x2F;examples&#x2F;android&#x2F; </span><br></pre></td></tr></table></figure>
<p>目测是ADT结构的，README中也明确指出了运行demo需要的一些环境：</p>
<blockquote>
<h2 id="To-build-install-run"><a href="#To-build-install-run" class="headerlink" title="To build/install/run"></a>To build/install/run</h2><p>As a prerequisite, Bazel, the Android NDK, and the Android SDK must all be installed on your system. The Android build tools may be obtained from: <a href="https://developer.android.com/tools/revisions/build-tools.html">https://developer.android.com/tools/revisions/build-tools.html</a></p>
</blockquote>
<p>我们需要这三个东东：Bazel、Android NDK、Android SDK</p>
<p>其中NDK和SDK的安装就不废话了，网上有一大堆的安装教程，接下来介绍一些Bazel的安装.</p>
<p>那么什么是Bazel呢？具体可以参考这篇博文<a href="http://www.cnblogs.com/Jack47/p/bazel-faq.html">Google软件构建工具Bazel FAQ</a></p>
<p>Bazel是一个软件构建工具，tensorFlow就是基于这个构建工具进行编译的。而且如果想要运行Bazel，必须要有java1.8以及支持c++11的编译器才可以。接下来介绍如何安装Bazel：</p>
<p><strong>下载代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;bazel&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>编译</strong></p>
<p>直接执行 ./compile.sh 脚本来编译Bazel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;compile.sh</span><br></pre></td></tr></table></figure>
<p>如果安装过程中，出现问题，可以参考<a href="http://www.tuicool.com/articles/rMbMRbU">这篇文章</a>(适用于mac和linux)</p>
<p>安装成功后，将bazel配置到环境变量中，然后按照README继续走：</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bazel build &#x2F;&#x2F;tensorflow&#x2F;examples&#x2F;android:tensorflow_demo -c opt --copt&#x3D;-mfpu&#x3D;neon</span><br></pre></td></tr></table></figure>
<p>不出意外的话，会出现错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;The external label &#39;&#x2F;&#x2F;external:android&#x2F;sdk&#39; is not bound to anything&quot; will be reported.</span><br></pre></td></tr></table></figure>
<p>因为在tensorflow根目录下，有一个WORKSPACE的文件，我们要更改这个文件中的sdk和ndk的路径。并且将注释打开，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android_sdk_repository(</span><br><span class="line">    name &#x3D; &quot;androidsdk&quot;,</span><br><span class="line">    api_level &#x3D; 22,</span><br><span class="line">    build_tools_version &#x3D; &quot;23.0.2&quot;,</span><br><span class="line">    # Replace with path to Android SDK on your system</span><br><span class="line">    path &#x3D; &quot;&#x2F;Users&#x2F;lijianan&#x2F;Documents&#x2F;Android&#x2F;sdk&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">android_ndk_repository(</span><br><span class="line">    name&#x3D;&quot;androidndk&quot;,</span><br><span class="line">    path&#x3D;&quot;&#x2F;Users&#x2F;lijianan&#x2F;Documents&#x2F;Android&#x2F;ndk&#x2F;android-ndk-r10d&quot;,</span><br><span class="line">    api_level&#x3D;21)</span><br></pre></td></tr></table></figure>
<p>继续重新执行构建命令，中间可能会出现api或者build_tools的版本不存在，那么建议去下载相应版本的api和build_tools。</p>
<p>继续执行，应该就会成功了。</p>
<p>生成的apk文件会放在这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bazel-bin&#x2F;tensorflow&#x2F;examples&#x2F;android&#x2F;tensorflow_demo_incremental</span><br></pre></td></tr></table></figure>
<p>安装到一个5.0以上的android机器里就可以成功运行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ adb install -r -g bazel-bin&#x2F;tensorflow&#x2F;examples&#x2F;android&#x2F;tensorflow_demo_incremental.apk</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix编程艺术 读书笔记</title>
    <url>/2015/08/29/unixArt/</url>
    <content><![CDATA[<p>Unix管道的发明人、Unix传统的奠基人之一<strong>Doug Mcllroy</strong>在［Mcllroy78］中曾经说过：</p>
<ul>
<li>（i）让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。</li>
<li>（ii）假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏式和二进制格式输入。不要坚持使用交互式输入。</li>
<li>（iii）经可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。</li>
<li>（iv）优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。</li>
</ul>
<p>后来他这样总结道（引自<strong>《Unix的四分之一世纪》</strong>）：</p>
<blockquote>
<p>Unix哲学是这样的：一个程序制作一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。</p>
</blockquote>
<p><strong>Rob Pike</strong>，最伟大的C语言大师之一，在<strong>《Notes on C Programming》</strong> 中从另一个稍微不同的角度阐述了Unix的哲学[Pike]:</p>
<ul>
<li><strong>原则1:</strong>你无法判定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。</li>
<li><strong>原则2:</strong>估量。在你没对代码进行估量，特别是没有找到最耗时的那部分之前，别去优化速度。</li>
<li><strong>原则3:</strong>花哨的算法在n很小时通常很慢，而n通畅很小。花哨算法的常熟复杂度很大。除非你确定n总是很大，否则不要用花哨算法（即使n很大，也优先考虑原则2）</li>
<li><strong>原则4:</strong>花哨的算法比简单算法更容易出bug、更难实现。尽量使用简单的算法配合简单的数据结构。</li>
<li><strong>原则5:</strong>数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也有不言自明。编程的核心是数据结构，而不是算法。</li>
<li><strong>原则6:</strong>没有原则6.</li>
</ul>
<p><strong>Ken Thompson</strong>  —Unix最初版本的设计者和实现者，禅宗偈语般地对Pike的原则4作了强调：</p>
<blockquote>
<p>拿不准就穷举。</p>
</blockquote>
<p>Unix哲学中更多的内容不是这些先哲们口头表述出来的，而是由他们所作的一切和Unix本身所作出的榜样体现出来的.从整体上来说，可以概括为以下几点：</p>
<ul>
<li>1.模块原则：使用简洁的接口拼合借口简单的部件。</li>
<li>2.清晰原则：清晰声誉机巧。</li>
<li>3.组合原则：设计时考虑拼接组合。</li>
<li>4.分离原则：策略同机制分离，接口同引擎分离。</li>
<li>5.简洁原则：设计要简洁，复杂度能低则低。</li>
<li>6.吝啬原则：除非确无它法，不要编写庞大的程序。</li>
<li>7.透明性原则：设计要可见，以便审查和调试。</li>
<li>8.健壮原则：健壮源于透明与简洁。</li>
<li>9.表示原则：把知识叠入数据以求逻辑质朴而健壮。</li>
<li>10.通俗原则：接口设计避免标新立异。</li>
<li>11.缄默原则：如果一个程序没什么好说的，就沉默。</li>
<li>12.补救原则：出现异常时，马上退出并给出足够错误信息。</li>
<li>13.经济原则：宁花机器一分钟，不花程序员一秒。</li>
<li>14.生成原则：避免手工hack，尽量编写程序去生成程序。</li>
<li>15.优化原则：雕琢前先要有原则，跑之前先学会走。</li>
<li>16.多样原则：绝不相信所谓“不二法门”的断言。</li>
<li>17.扩展原则：设计着眼未来，未来总比预想来得快。</li>
</ul>
<p>正如<strong>Brian Kernighan</strong>曾经说过的：<strong>“计算机编程的本质就是控制复杂度”</strong></p>
<blockquote>
<p>汇编语言、编译语言、流程图、过程化编程、结构化编程、所谓的人工智能、第四代编程语言、面向对象、以及软件开发的方法论，不计其数的解决之道被抛售者吹得神乎其神。但实际上这些用处都不大，原因恰恰在于它们“成功”地将程序的复杂度提升到了人脑几乎不能处理的地步。就像Fredbrooks的一句名言[Brooks]:<strong>没有万能药</strong></p>
<p>永远不要去吃力地解读一段晦涩的代码三次。第一次也许侥幸成功，但如果发现必须重新解读一遍－－离第一次太久了、具体细节无从回想－－那么你该注释代码了，这样第三次就相对不会那么痛苦了。<br>                            －－Henry Spencer</p>
<p>“错综复杂的美妙事务”听来自相矛盾。Unix程序员相互比的是谁能够做到“简洁而漂亮”并以此为荣，这一点虽然只是隐含在这些规则之中，但还是很值得公开提出来强调一下。<br>                            －－Doug Mcllroy</p>
<p>最小立异原则的另一面是避免表象相似而实际略有不同。这回极端危险，因为表象相似往往导致人们产生错误的假定。所以最好不要让不同事务有明显区别，而不要看起来几乎一模一样。<br>                            －－Henry Spencer</p>
</blockquote>
<p>由于略微不同的一些原因，<strong>Donald Knuth</strong>（程序设计领域中屈指可数的经典著作之一《计算机程序设计艺术》的作者）广为传播普及了这样的观点：<strong>“过早优化是万恶之源”</strong>。他是对的。<br>    <em>完整的句子是这样的：“97%的时间里，我们不应该考虑蝇头小利的效率提升：过早优化是万恶之源”。Knuth自称这一观点来自C.A.R.Hoare。</em></p>
<p>在Unix世界里，有一个非常明确的悠久传统（例证之一是Rob Pike以上的评论，另一个是Ken Thompson关于穷举法的格言）：<strong>先制作原型，再精雕细琢。优化之前先确保能用。</strong>或者：<strong>先能走，再学跑。</strong>“极限编程”宗师Kent Beck从另一种不同的文化将这一点有效地扩展为：<strong>先求运行，再求正确，最后求快</strong>。</p>
<blockquote>
<p>我最有成效的一天就是扔掉了1000行代码。 －－Ken Thompson</p>
</blockquote>
<p>所有的Unix哲学浓缩为一条铁律，那就是各地编程大师们奉为圭臬的<strong>“KISS”</strong>原则：</p>
<h1 id="K-I-S-S"><a href="#K-I-S-S" class="headerlink" title="K.I.S.S."></a>K.I.S.S.</h1><blockquote>
<p>Keep It Simple,Stupid!</p>
</blockquote>
<ul>
<li>只要可行，一切都应该做成与来源和目标无关的过滤器。</li>
<li>数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）。</li>
<li>数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）。</li>
<li>复杂的前端（用户界面）和后端应该泾渭分明。</li>
<li>如果可能，用C编写前，先用解释性语言搭建原型。</li>
<li>当且仅当只用一门语言编程会提高程序复杂度时，混用语言编程才比单一语言编程来得好。</li>
<li>宽收严发（对接收的东西要包容，对输出的东西要严格）。</li>
<li>过滤时，不需要丢弃的信息决不丢。</li>
<li>小就是美。在确保完成任务的基础上，程序功能尽可能少。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2016/04/14/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile</p>
<p>易变的，不稳定的</p>
<p>volatile关键字类似synchronized关键字。不同之处是volatile用来修饰的是单个进行原子操作的变量，而synchronized修饰的是一个代码块。</p>
<p>在java中，多线程访问主线程中的变量时，默认并不会直接操作主线程中的变量，而是从主线程中创建一个变量的拷贝，到对应的子线程中，在子线程操作的过程中去和主线程的变量进行同步，这也就意味着，子线程中操作的变量并不是最新的。</p>
<p>如果想要直接在子线程中访问到主线程的变量，而不是通过拷贝内存的方式，那么就需要在对应的变量之前加上<strong>volatile</strong>关键字，来标识这个变量是与主线程同步的，但这仅仅限于原子操作，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = i ++;  <span class="comment">//不是原子操作，因为i自身参与了运算</span></span><br><span class="line">i = i +<span class="number">1</span>;  <span class="comment">//不是原子操作，因为i自身参与了运算</span></span><br></pre></td></tr></table></figure>
<p>这两种操作都不是原子操作，只有没有自身参与的负值操作，才是原子操作，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = m + n;  <span class="comment">//这是原子操作，因为i自身没有参与运算</span></span><br></pre></td></tr></table></figure>
<p>对于非原子操作的形式，可以选择使用<strong>synchronized</strong>关键字，其实synchronized内部也做了内存同步，不同的是，它对所括起来的区域内的变量都做了内存同步，因此synchronized相比volatile开销会大一些。</p>
<p>所以在不确定是否是原子操作的情况下，最好使用synchronized关键字。</p>
<p>参考文章：</p>
<p><a href="http://sakyone.iteye.com/blog/668091">java中关键字volatile的作用</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】APP测试组件集成</title>
    <url>/2017/01/11/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91APP%E6%B5%8B%E8%AF%95%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p>如果您的应用使用用户不直接交互的组件（例如 Service 或 Content Provider），您应验证这些组件是否以正确的方式在您的应用程序中运行。</p>
<p>当开发这样的组件时，您应该习惯于编写集成测试，以便在应用程序在设备或仿真器上运行时验证组件的行为。</p>
<blockquote>
<p><strong>注意：</strong>Android不为<code>BroadcastReceiver</code>提供单独的测试用例类。要验证<code>BroadcastReceiver</code>响应是否正确，您可以测试向其发送<code>Intent</code>对象的组件。您可以通过调用<code>InstrumentationRegistry.getTargetContext()</code>创建一个<code>BroadcastReceiver</code>的实例，然后调用要测试的<code>BroadcastReceiver</code>方法（通常是<code>onReceive()</code>方法）。</p>
</blockquote>
<p>该类教您使用Android平台提供的测试API和工具构建自动化集成测试。</p>
<h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a href="/2017/01/13/【Android文档翻译】测试你的Service/">测试你的Service</a></p>
<pre><code>了解如何构建集成测试，以验证服务是否能与您的应用正常工作。
</code></pre><p><a href="/2017/01/13/【Android文档翻译】测试你的Content Provider/">测试你的Content Provider</a></p>
<pre><code>了解如何构建集成测试，以验证Content Provider是否能够与您的应用正常工作。
</code></pre>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】入门测试</title>
    <url>/2017/01/11/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E5%85%A5%E9%97%A8%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>Android的测试是基于<a href="http://junit.org/">JUnit</a>的，你可以以一个本地单元测试的模式在JVM上运行，也可以在Android设备上运行它们。这个页面提供了一个关于构建android测试的概念和工具的介绍。</p>
</blockquote>
<h2 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h2><p>当使用Android Studio来写测试的时候，你的测试代码必须放置在两个不同的代码目录下。对于你项目中的每个模块，Android Studio包含两个代码集合，对应以下的测试类型：</p>
<ul>
<li><strong>本地单元测试</strong></li>
</ul>
<p>放置在<code>module-name/src/test/java/</code>目录下。</p>
<p>这些测试运行在本地的JVM上，并且没有访问Android 框架的API的权限。</p>
<p>开始请看：<a href="/2017/01/11/【Android文档翻译】构建本地单元测试/">构建本地单元测试</a></p>
<ul>
<li><strong>仪表化测试</strong></li>
</ul>
<p>放置在<code>module-name/src/androidTest/java/</code>目录下。</p>
<p>这些所有的测试必须运行在Android硬件设备上，或者Android模拟器上。</p>
<p>仪表化测试是内置在APK中的依附于你的APP的运行在设备上的测试。系统运行你的测试APK，并且与你的app运行在同一进程中，因此你的测试能调用app中的方法并且改变app中的字段，并且自动化的运行你的UI界面。</p>
<p>有关如何创建仪表化测试，请参阅以下的主题：</p>
<ul>
<li><a href="/2017/01/11/【Android文档翻译】构建仪表化单元测试/">构建仪表化单元测试</a>：通过Android依赖来构建复杂的单元测试，对于mock对象来说是不安全的。</li>
<li><a href="/2017/01/11/【Android文档翻译】自动化UI测试/">自动化UI测试</a>：创建测试，在单个应用程序和多个应用程序之间的交互，来确认你的UI的交互行为是否准确。</li>
<li><a href="/2017/01/11/【Android文档翻译】APP测试组件集成/">APP测试组件集成</a>：验证那些用户不直接与之交互的组件的行为，例如一个Service或者一个Content Provider。</li>
</ul>
<p><img src="/img/17_01_11/001.png" alt=""></p>
<p>然而，<em>本地单元测试</em>和<em>仪表化测试</em>只是用于区分在本地JVM上运行的测试和在Android平台上(在硬件设备或者模拟器上)运行的测试的术语。在构建完整测试体系的时候应该理解的真正的测试类型见下表的描述：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">子类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单元测试</td>
<td style="text-align:center">本地单元测试</td>
<td style="text-align:center">运行在本地JVM的单元测试。当你的测试没有Android框架依赖或者当你能模拟Android框架依赖时，你可以使用这些测试来最小化执行时间。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">仪表化测试</td>
<td style="text-align:center">单元测试可以运行在一个Android设备或者模拟器上。这些测试可以访问仪表信息，例如你正在测试的App的Context。当你的测试有Android依赖时，摸你对象不能满足时，可以使用这些测试。</td>
</tr>
<tr>
<td style="text-align:center">集成测试</td>
<td style="text-align:center">仅仅在你App内部的原件</td>
<td style="text-align:center">这个类型的测试可以在一个用户执行一个特殊的事件或者在它的activity中传入了一个特殊的输入时，用来验证目标的app行为与期望的是否相同。例如，它允许你检查目标app返回的正确的UI输出，响应到app的Activity的交互界面。UI测试框架，像Espresso允许你程序化模拟用户操作，并测试复杂的应用内的用户交互。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">跨应用组件</td>
<td style="text-align:center">这个类型的测试用于验证不同用户应用程序之间或用户应用程序和系统应用程序之间的交互的正确行为。例如，当你在Android的菜单中执行一个事件，也许想测试你的app行为的正确性。UI测试框架支持跨应用互动，例如UIAutomator，允许你为这种情况创建测试。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="测试API"><a href="#测试API" class="headerlink" title="测试API"></a>测试API</h2><p>接下来的通用API用于在Android上测试app。</p>
<h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>你应该写你自己的单元测试或者集成测试类，正如JUnit4测试类。框架提供了一个方便的方法来在测试中执行通用的设置，拆卸以及断言操作。</p>
<p>一个基本的JUnit测试类是一个包含一个或多个测试模块的Java类。测试方法以<code>@Test</code>注解开头，包含练习和验证要测试的组件中的单个功能（即逻辑单元）的代码。</p>
<p>以下代码段显示了一个JUnit集成测试的例子，它使用Espresso API对UI元素执行单击操作，然后检查是否显示预期的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">@LargeTest</span><br><span class="line">public class MainActivityInstrumentationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Rule</span><br><span class="line">    public ActivityTestRule mActivityRule &#x3D; new ActivityTestRule&lt;&gt;(</span><br><span class="line">            MainActivity.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sayHello()&#123;</span><br><span class="line">        onView(withText(&quot;Say hello!&quot;)).perform(click());</span><br><span class="line"></span><br><span class="line">        onView(withId(R.id.textView)).check(matches(withText(&quot;Hello, World!&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你的JUnit测试类中，你可以通过使用以下注释调出测试代码中的部分进行特殊处理：</p>
<ul>
<li><code>@Before</code>:使用此注释可以指定包含测试设置操作的代码块。测试类会在每次测试之前调用这些代码块。你可以拥有多个<code>@Before</code>方法，但测试类调用这些方法的顺序不能保证。</li>
<li><code>@After</code>:这个注解指定一个包含测试拆分操作的代码块。测试类在每个测试方法之后调用这个代码块。你可以在代码中定义多个<code>@After</code>操作。可以通过使用这个注解来释放任何内存中的资源。</li>
<li><code>@Rule</code>:Rules允许你以一种可复用的方式来灵活的添加或者重定义每个测试方法的行为。在Android测试中，将此注解与某个Android测试支持库提供的测试规则一起使用，例如<a href="https://developer.android.google.cn/training/testing/start/index.html#test-apis">ActivityTestRule</a>或者<a href="https://developer.android.google.cn/reference/android/support/test/rule/ServiceTestRule.html">ServiceTestRule</a>。</li>
<li><code>@BeforeClass</code>:使用这个注解来为每个测试类指定仅调用一次的静态方法。这个测试步骤在某些昂贵的操作(例如连接数据库)非常有用。</li>
<li><code>@AfterClass</code>:使用这个注解来为每个测试类指定在所有的测试运行结束后仅调用一次的静态方法。这个测试步骤对于释放在<code>@BeforeClass</code>块之后分配的任意资源非常有用。</li>
<li><code>@Test(timeout=)</code>:一些注解支持传递可以设置值的元素。例如，你可以指定测试的timeout时长。如果测试开始，但是没有在给定的超时时间内完成，它会自动失败。例如:<code>@Test(timeout=5000)</code></li>
</ul>
<p>更多的注解，见文档<a href="http://junit.sourceforge.net/javadoc/org/junit/package-summary.html">JUnit注解</a>和<a href="https://developer.android.google.cn/reference/android/support/annotation/package-summary.html">Android注解</a>。</p>
<p>使用JUnit <a href="https://developer.android.google.cn/reference/junit/framework/Assert.html">Assert</a>类来验证对象状态的正确性。这个断言方法会比较你测试中期望的值与实际结果的值，当两者值不一致时，会抛出一个异常。<a href="https://developer.android.google.cn/training/testing/start/index.html#AssertionClasses">断言类</a>中有更多关于这些方法的描述。</p>
<h3 id="Android测试支持库"><a href="#Android测试支持库" class="headerlink" title="Android测试支持库"></a>Android测试支持库</h3><p><a href="https://developer.android.google.cn/topic/libraries/testing-support-library/index.html">Android测试支持库</a>提供一个允许你快速构建并执行关于你app的测试代码的API接口，包括JUnit4和UI功能测试。这个库包括以下基于工具的API，当你想要自动化测试时，这些API非常有用：</p>
<p><a href="https://developer.android.google.cn/topic/libraries/testing-support-library/index.html#AndroidJUnitRunner">AndroidJUnitRunner</a>:</p>
<pre><code>一个适用于Android的JUnit4兼容测试运行器。
</code></pre><p><a href="https://developer.android.google.cn/topic/libraries/testing-support-library/index.html#Espresso">Espresso</a>:</p>
<pre><code>一个UI测试框架；适合在应用程序内的功能UI测试。
</code></pre><p><a href="https://developer.android.google.cn/topic/libraries/testing-support-library/index.html#UIAutomator">UI Automator</a>:</p>
<pre><code>适用于系统和已安装应用程序之间跨应用程序功能UI测试的UI测试框架。
</code></pre><h3 id="断言类"><a href="#断言类" class="headerlink" title="断言类"></a>断言类</h3><p>由于Android测试支持库继承自JUnit，因此你可以使用断言方法来展示测试结果。断言方法将测试返回的实际值与预期值进行比较，如果比较测试失败，则抛出AssertionException。使用断言比记录更方便，并提供更好的测试性能。</p>
<p>为了简化测试开发，你应该使用<a href="https://github.com/hamcrest">Hamcrest library</a>,它可以使用Hamcrest匹配器的API创建更灵活的测试。</p>
<h3 id="Monkey和monkeyrunner"><a href="#Monkey和monkeyrunner" class="headerlink" title="Monkey和monkeyrunner"></a>Monkey和monkeyrunner</h3><p>Android SDK包含两个功能级别的测试工具:</p>
<p>Monkey</p>
<pre><code>这是一个命令行工具，用于向设备发送按键，触摸和手势的伪随机流。你使用Android Debug Bridge(adb)工具运行它，并使用它来压力测试您的应用程序，报告所遇到的错误，或通过使用相同的随机数种子多次运行该工具来重复事件流。
</code></pre><p>monkeyrunner</p>
<pre><code>这个工具是python写的测试程序的API和执行环境。API包括用于连接到设备，安装和卸载软件包，截屏，比较两个图像以及针对应用程序运行测试包的功能。使用API，你可以编写大量，强大和复杂的测试。您使用monkeyrunner命令行工具运行使用API的程序。
</code></pre><h3 id="构建Android测试的指南"><a href="#构建Android测试的指南" class="headerlink" title="构建Android测试的指南"></a>构建Android测试的指南</h3><p>以下文档提供了有关如何构建和运行各种测试类型的更多详细信息：</p>
<p><a href="/2017/01/11/【Android文档翻译】构建本地单元测试/">构建本地单元测试</a></p>
<pre><code>构建没有依赖或只有简单的依赖的单元测试，你可以mock，它运行在本地JVM上。
</code></pre><p><a href="/2017/01/11/【Android文档翻译】构建仪表化单元测试/">构建仪表化单元测试</a></p>
<pre><code>使用Android依赖项构建复杂的单元测试，这对于在硬件设备或模拟器上运行的模拟对象无法满足。
</code></pre><p><a href="/2017/01/11/【Android文档翻译】自动化UI测试/">自动化UI测试</a></p>
<pre><code>创建测试以验证用户界面在单个应用程序内的用户交互或多个应用程序之间的交互正确运行。
</code></pre><p><a href="/2017/01/11/【Android文档翻译】APP测试组件集成/">测试应用程序集成</a></p>
<pre><code>验证用户不直接与之交互的组件（例如服务或内容提供者）的行为
</code></pre><p><a href="/2017/01/14/【Android文档翻译】测试性能展示/">测试性能展示</a></p>
<pre><code>编写测试应用程序UI性能的测试，以确保持续流畅的用户体验
</code></pre>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】最佳测试实践</title>
    <url>/2017/01/11/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%9C%80%E4%BD%B3%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>测试你的app是开发过程中的重要的一部分。测试可以在你的app发布之前验证程序的正确性，方法的行为，以及可用性。</p>
</blockquote>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>学习测试app的基础知识，以及使用Android Studio的运行测试的相关知识。</p>
<ul>
<li><strong><a href="/2017/01/11/【Android文档翻译】入门测试/">入门测试</a></strong></li>
<li><strong>测试应用</strong></li>
<li><strong>Android测试(Android 2015开发者峰会)</strong></li>
</ul>
<h2 id="测试工具和API"><a href="#测试工具和API" class="headerlink" title="测试工具和API"></a>测试工具和API</h2><p>学习Android平台提供的测试工具，帮助你测试你的app的方方面面：</p>
<ul>
<li><strong>测试支持库</strong></li>
</ul>
<p>Android测试支持库提供一个可扩展的测试框架</p>
<ul>
<li><strong>UI/Application Exerciser Monkey</strong></li>
<li><strong>monkeyrunner</strong></li>
<li><strong>通过命令行测试</strong></li>
<li><strong>dumpsys</strong></li>
</ul>
<h2 id="App测试技术"><a href="#App测试技术" class="headerlink" title="App测试技术"></a>App测试技术</h2><p>了解测试App的相关技术:</p>
<ul>
<li><strong>自动化UI测试</strong></li>
<li><strong>建立有效的单元测试</strong></li>
<li><strong>测试性能展示</strong></li>
</ul>
<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>更多的APP测试资源:</p>
<ul>
<li><strong>Android测试样本</strong></li>
</ul>
<blockquote>
<p>展示不同的框架和自动化测试技术的集合</p>
</blockquote>
<ul>
<li><strong>在AndroidStudio中调试和测试</strong></li>
</ul>
<blockquote>
<p>此视频介绍了Studio中的单元测试以及Google新的Android测试Support Library的UI测试功能，以及在设备上运行测试。</p>
</blockquote>
<ul>
<li><strong>Android测试代码实验室</strong></li>
</ul>
<blockquote>
<p>这个代码实验室展示了如何通过AndroidStudio来构建一个Android App，使用MVP(Model View Presenter)架构，单元测试，以及测试仪表盘。</p>
</blockquote>
<ul>
<li><strong>Android的测试模板</strong></li>
</ul>
<blockquote>
<p>google的测试工具和框架集合，全部集成在一个单一的应用程序中。</p>
</blockquote>
<ul>
<li><strong>Android测试支持库(github)</strong></li>
</ul>
<blockquote>
<p>一个github上的android测试支持库资源页。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】构建仪表化单元测试</title>
    <url>/2017/01/11/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%9E%84%E5%BB%BA%E4%BB%AA%E8%A1%A8%E5%8C%96%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>仪表化单元测试是在物理设备和模拟器上运行的测试，它们可以利用Android框架API和support API，例如Android Testing Support Library。如果你的测试需要访问仪表信息(例如目标APP的Context信息)或者如果他们需要真正实现一个Android框架组件(例如一个Parcelable或者SharedPreferences对象)，你应该创建仪表化单元测试。</p>
<p>使用仪表化单元测试还有助于减少编写和维护模拟代码所需的工作量。如果你想，你任然可以自由使用模拟框架，模拟任何依赖关系。</p>
<h2 id="设置您的测试环境"><a href="#设置您的测试环境" class="headerlink" title="设置您的测试环境"></a>设置您的测试环境</h2><p>在你的Android Studio项目中，你必须将用于测试的源文件存储在<code>module-name/src/androidTest/java/</code>中。在创建新项目，并包含检测测试示例时，此目录已存在。</p>
<p>在你开始之前，你应该<a href="https://developer.android.google.cn/tools/testing-support-library/index.html#setup">下载Android测试支持库设置</a>，它提供的API允许您为您的应用程序快速构建和运行测试代码。这个测试库包含一个JUnit4测试运行器(<a href="https://developer.android.google.cn/tools/testing-support-library/index.html#AndroidJUnitRunner">AndroidJUnitRunner</a>)以及针对UI功能性测试的API(<a href="https://developer.android.google.cn/tools/testing-support-library/index.html#Espresso">Espresso</a>和<a href="https://developer.android.google.cn/tools/testing-support-library/index.html#UIAutomator">UI Automator</a>)。</p>
<p>您还需要为项目配置Android测试依赖关系，以使用测试支持库提供的测试运行器和规则API。为了简化测试开发，您还应该包含<a href="https://github.com/hamcrest">Hamcrest库</a>，它允许您使用Hamcrest匹配器API创建更灵活的断言。</p>
<p>在应用程序的顶级<code>build.gradle</code>文件中，您需要将这些库指定为依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    androidTestCompile &#39;com.android.support:support-annotations:24.0.0&#39;</span><br><span class="line">    androidTestCompile &#39;com.android.support.test:runner:0.5&#39;</span><br><span class="line">    androidTestCompile &#39;com.android.support.test:rules:0.5&#39;</span><br><span class="line">    &#x2F;&#x2F; Optional -- Hamcrest library</span><br><span class="line">    androidTestCompile &#39;org.hamcrest:hamcrest-library:1.3&#39;</span><br><span class="line">    &#x2F;&#x2F; Optional -- UI testing with Espresso</span><br><span class="line">    androidTestCompile &#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;</span><br><span class="line">    &#x2F;&#x2F; Optional -- UI testing with UI Automator</span><br><span class="line">    androidTestCompile &#39;com.android.support.test.uiautomator:uiautomator-v18:2.1.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告：</strong>如果您的构建配置包括<code>support-annotations</code>库的编译依赖项<strong>和</strong><code>espresso-core</code>库的<code>androidTestCompile</code>依赖项，那么您的构建可能会由于依赖冲突而失败。为了解决这个问题，请更新<code>espresso-core</code>的依赖关系，如下所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">androidTestCompile(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, &#123;</span><br><span class="line">    exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要使用JUnit4测试类，请确保在项目中将<code>AndroidJUnitRunner</code>指定为默认测试工具运行器，方法是在应用程序的模块级<code>build.gradle</code>文件中包含以下设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建测试单元测试类"><a href="#创建测试单元测试类" class="headerlink" title="创建测试单元测试类"></a>创建测试单元测试类</h2><p>您的检测单元测试类应写为JUnit4测试类。要了解有关创建JUnit 4测试类和使用JUnit 4断言和注释的更多信息，请参阅创<a href="https://developer.android.google.cn/training/testing/unit-testing/local-unit-tests.html#build">建本地单元测试类</a>。</p>
<p>要创建一个检测的JUnit4测试类，请在测试类定义的开头添加<code>@RunWith(AndroidJUnit4.class)</code>注解。您还需要指定Android测试支持库中提供的<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>类作为默认测试运行器。此步骤在“<a href="/2017/01/11/【Android文档翻译】入门测试/">测试入门</a>”中有更详细的描述。</p>
<p><a href="https://developer.android.google.cn/training/testing/start/index.html#run-instrumented-tests">以下示例显示如何编写检测单元测试</a>，以测试Parcelable接口是否已正确实现LogHistory类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import android.os.Parcel;</span><br><span class="line">import android.support.test.runner.AndroidJUnit4;</span><br><span class="line">import android.util.Pair;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import java.util.List;</span><br><span class="line">import static org.hamcrest.Matchers.is;</span><br><span class="line">import static org.junit.Assert.assertThat;</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">@SmallTest</span><br><span class="line">public class LogHistoryAndroidUnitTest &#123;</span><br><span class="line"></span><br><span class="line">    public static final String TEST_STRING &#x3D; &quot;This is a string&quot;;</span><br><span class="line">    public static final long TEST_LONG &#x3D; 12345678L;</span><br><span class="line">    private LogHistory mLogHistory;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void createLogHistory() &#123;</span><br><span class="line">        mLogHistory &#x3D; new LogHistory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void logHistory_ParcelableWriteRead() &#123;</span><br><span class="line">        &#x2F;&#x2F; Set up the Parcelable object to send and receive.</span><br><span class="line">        mLogHistory.addEntry(TEST_STRING, TEST_LONG);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Write the data.</span><br><span class="line">        Parcel parcel &#x3D; Parcel.obtain();</span><br><span class="line">        mLogHistory.writeToParcel(parcel, mLogHistory.describeContents());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; After you&#39;re done with writing, you need to reset the parcel for reading.</span><br><span class="line">        parcel.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Read the data.</span><br><span class="line">        LogHistory createdFromParcel &#x3D; LogHistory.CREATOR.createFromParcel(parcel);</span><br><span class="line">        List&lt;Pair&lt;String, Long&gt;&gt; createdFromParcelData &#x3D; createdFromParcel.getData();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Verify that the received data is correct.</span><br><span class="line">        assertThat(createdFromParcelData.size(), is(1));</span><br><span class="line">        assertThat(createdFromParcelData.get(0).first, is(TEST_STRING));</span><br><span class="line">        assertThat(createdFromParcelData.get(0).second, is(TEST_LONG));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个测试套件"><a href="#创建一个测试套件" class="headerlink" title="创建一个测试套件"></a>创建一个测试套件</h3><p>要组织仪器化单元测试的执行，可以在测试套件类中对一组测试类进行分组，并一起运行这些测试。测试套件可以嵌套;您的测试套件可以将其他测试套件分组并将所有组件测试类一起运行。</p>
<p>测试套件包含在测试包中，类似于主应用程序包。按照惯例，测试套件包名称通常以<code>.suite</code>后缀结尾（例如，<code>com.example.android.testing.mysample.suite</code>）。</p>
<p>要为单元测试创​​建测试套件，请导入JUnit RunWith和Suite类。在您的测试套件中，添加<code>@RunWith(Suite.class)</code>和<code>@Suite.SuitClasses()</code>注解，列出单个测试类或测试套件作为参数。</p>
<p>以下示例显示如何实现名为UnitTestSuite的测试套件，它将<code>CalculatorInstrumentationTest</code>和<code>CalculatorAddParameterizedTest</code>测试类组合并运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.example.android.testing.mysample.CalculatorAddParameterizedTest;</span><br><span class="line">import com.example.android.testing.mysample.CalculatorInstrumentationTest;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.junit.runners.Suite;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Runs all unit tests.</span><br><span class="line">@RunWith(Suite.class)</span><br><span class="line">@Suite.SuiteClasses(&#123;CalculatorInstrumentationTest.class,</span><br><span class="line">        CalculatorAddParameterizedTest.class&#125;)</span><br><span class="line">public class UnitTestSuite &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行仪表单元测试"><a href="#运行仪表单元测试" class="headerlink" title="运行仪表单元测试"></a>运行仪表单元测试</h2><p>要运行仪表化测试，请按照下列步骤操作：</p>
<ul>
<li>1.通过单击工具栏中的同步项目，确保您的项目与Gradle同步。</li>
<li>2.使用以下方法之一运行测试：<ul>
<li>要运行单个测试，请打开<strong>Project</strong>窗口，然后右键单击一个测试，然后单击<strong>Run</strong>。</li>
<li>要测试类中的所有方法，请右键单击测试文件中的类或方法，然后单击<strong>Run</strong>。</li>
<li>要在目录中运行所有测试，请右键单击目录并选择<strong>Run tests</strong>。</li>
</ul>
</li>
</ul>
<p><a href="https://developer.android.google.cn/tools/building/plugin-for-gradle.html">Gradle的Android插件</a>编译位于默认目录(<code>src/androidTest/java/</code>)中的测试代码，构建测试APK和生产APK，在连接的设备或模拟器上安装这两个APK，并运行测试。然后，Android Studio将在“运行”窗口中显示已检测的测试执行的结果。</p>
<blockquote>
<p><strong>注意：</strong>在运行或调试测试测试时，Android Studio不会注入“<a href="https://developer.android.google.cn/studio/run/index.html#instant-run">Instant Run</a>”所需的其他方法，并关闭此功能。</p>
</blockquote>
<h3 id="使用Firebase-Test-Lab运行测试"><a href="#使用Firebase-Test-Lab运行测试" class="headerlink" title="使用Firebase Test Lab运行测试"></a>使用Firebase Test Lab运行测试</h3><p>使用<a href="https://firebase.google.cn/docs/test-lab/">Firebase Test Lab</a>，您可以在许多流行的Android设备和设备配置(区域设置，方向，屏幕大小和平台版本)上同时测试您的应用程序。这些测试在远程Google数据中心的物理和虚拟设备上运行。您可以直接从Android Studio或从命令行将应用程序部署到测试实验室。测试结果提供测试日志，并包括任何应用程序故障的详细信息。</p>
<p>在开始使用Firebase Test Lab之前，您需要执行以下操作，除非您已经拥有Google帐户和Firebase项目：</p>
<ul>
<li>1.如果您还没有Google帐户，请<a href="https://accounts.google.com/">创建一个Google帐户</a>。</li>
<li>2.在<a href="https://console.firebase.google.com/">Firebase控制台</a>中，单击<strong>Create New Project</strong>。 <ul>
<li>使用测试实验室在Spark计划的免费每日配额内测试您的应用程序是免费的。</li>
</ul>
</li>
</ul>
<h4 id="配置测试矩阵并运行测试"><a href="#配置测试矩阵并运行测试" class="headerlink" title="配置测试矩阵并运行测试"></a>配置测试矩阵并运行测试</h4><p>Android Studio提供了集成工具，允许您配置如何将测试部署到Firebase测试实验室。使用Blaze计划计费创建Firebase项目后，您可以创建测试配置并运行测试：</p>
<ul>
<li>1.在主菜单下点击<strong>Run &gt; Edit Configurations</strong> 。</li>
<li>2.点击<strong>Add New Configuration + </strong>然后选择<strong>Android Tests</strong>。</li>
<li>3.在Android测试配置对话框中：<ul>
<li>a.输入或选择测试的详细信息，例如测试名称，模块类型，测试类型和测试类别。</li>
<li>b.从“部署目标选项”下的“目标”下拉菜单中，选择“<strong>Firebase Test Lab Device Matrix</strong>”。</li>
<li>c.如果您尚未登录，请点击连接到Google云端平台，并允许Android Studio访问您的帐户。</li>
<li>d.在Cloud Project旁边，单击设置按钮并从列表中选择您的Firebase项目。</li>
</ul>
</li>
<li>4.创建和配置测试矩阵。<ul>
<li>a.在<em>Matrix Configuration</em>下拉列表旁边，单击<strong>Open Dialog</strong>。</li>
<li>b.点击<strong>Add New Configuration (+)</strong>。</li>
<li>c.在<strong>Name</strong>字段中，输入新配置的名称。</li>
<li>d.选择您要测试应用的设备，Android版本，地区和屏幕方向。 Firebase测试实验室将在生成测试结果时根据您的选择的每个组合来测试您的应用程序。</li>
<li>e.单击<strong>OK</strong>保存配置</li>
</ul>
</li>
<li>5.单击<em>Run/Debug Configurations</em>对话框中的<strong>OK</strong>退出。</li>
<li>6.通过单击<strong>Run</strong>运行测试。</li>
</ul>
<p><img src="/img/17_01_11/002.png" alt=""></p>
<p><strong>图1.</strong>为Firebase Test Lab创建测试配置。</p>
<h4 id="分析测试结果"><a href="#分析测试结果" class="headerlink" title="分析测试结果"></a>分析测试结果</h4><p>当Firebase Test Lab完成运行测试时，运行窗口将打开以显示结果，如图2所示。您可能需要单击<strong>Show Passd</strong>以查看所有已执行的测试。</p>
<p><img src="/img/17_01_11/003.png" alt=""></p>
<p><strong>图2.</strong>使用Firebase Test Lab查看仪表化测试的结果。</p>
<p>您还可以通过在<em>Run</em>窗口中的测试执行日志开头显示的链接来分析Web上的测试。</p>
<p>要了解有关解释Web结果的详细信息，请参阅<a href="https://firebase.google.cn/docs/test-lab/analyzing-results">分析Android结果的Firebase测试实验室</a>。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】构建本地单元测试</title>
    <url>/2017/01/11/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%9E%84%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/training/testing/unit-testing/local-unit-tests.html#build">https://developer.android.google.cn/training/testing/unit-testing/local-unit-tests.html#build</a></p>
<p>如果你的单元测试没有依赖或者只有Android上的简单依赖，你应该在本地开发机器上运行测试。这种测试方法是高效的，因为它可以帮助您避免每次运行测试时将目标应用程序和单元测试代码加载到物理设备或模拟器上的开销。因此，运行单元测试的执行时间大大减少。使用这种方法，你通常使用一个模拟框架，如<a href="https://github.com/mockito/mockito">Mockito</a>，来实现任何依赖关系。</p>
<h2 id="设置您的测试环境"><a href="#设置您的测试环境" class="headerlink" title="设置您的测试环境"></a>设置您的测试环境</h2><p>在您的Android Studio项目中，必须将用于本地单元测试的源文件存储在<code>module-name/src/test/java/</code>。创建新项目时，此目录已存在。</p>
<p>您还需要为项目配置测试依赖关系，以使用JUnit 4框架提供的标准API。如果您的测试需要与Android依赖关系交互，请引入<a href="https://github.com/mockito/mockito">Mockito</a>库以简化本地单元测试。要了解有关在本地单元测试中使用模拟对象的更多信息，请参阅<a href="https://developer.android.google.cn/training/testing/unit-testing/local-unit-tests.html#mocking-dependencies">模拟Android依赖项</a>。</p>
<p>在应用程序的顶级<code>build.gradle</code>文件中，您需要将这些库指定为依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    &#x2F;&#x2F; Required -- JUnit 4 framework</span><br><span class="line">    testCompile &#39;junit:junit:4.12&#39;</span><br><span class="line">    &#x2F;&#x2F; Optional -- Mockito framework</span><br><span class="line">    testCompile &#39;org.mockito:mockito-core:1.10.19&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建本地单元测试类"><a href="#创建本地单元测试类" class="headerlink" title="创建本地单元测试类"></a>创建本地单元测试类</h2><p>你的本地单元测试类应该写成一个JUnit 4测试类。 JUnit是Java最受欢迎和广泛使用的单元测试框架。这个框架的最新版本，JUnit 4，允许你以比它的前身版本更清洁和更灵活的方式编写测试。与以前的基于JUnit 3的Android单元测试的方法不同，使用JUnit 4，您不需要扩展junit.framework.TestCase类。您也不需要在测试方法名称前加上’test’关键字，或者使用<code>junit.framework</code>或<code>junit.extensions</code>包中的任何类。</p>
<p>要创建基本的JUnit 4测试类，请创建一个包含一个或多个测试方法的Java类。测试方法以<code>@Test</code>注解开始，包含练习和验证要测试的组件中的单个功能的代码。</p>
<p>以下示例显示如何实现本地单元测试类。测试方法<code>emailValidator_CorrectEmailSimple_ReturnsTrue</code>验证被测应用程序中的<code>isValidEmail()</code>方法是否返回正确的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">import static org.junit.Assert.assertFalse;</span><br><span class="line">import static org.junit.Assert.assertTrue;</span><br><span class="line"></span><br><span class="line">public class EmailValidatorTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void emailValidator_CorrectEmailSimple_ReturnsTrue() &#123;</span><br><span class="line">        assertThat(EmailValidator.isValidEmail(&quot;name@email.com&quot;), is(true));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要测试应用程序中的组件是否返回预期结果，请使用<a href="http://junit.org/javadoc/latest/org/junit/Assert.html">junit.Assert</a>方法执行验证检查（或断言），以便将受测试组件的状态与某些预期值进行比较。为了使测试更可读，可以使用<a href="https://github.com/hamcrest">Hamcrest匹配器</a>（例如<code>is()</code>和<code>equalTo()</code>方法）将返回的结果与预期结果进行匹配。</p>
<h2 id="模拟Android依赖"><a href="#模拟Android依赖" class="headerlink" title="模拟Android依赖"></a>模拟Android依赖</h2><p>默认情况下，Gradle的Android插件针对android.jar库的修改版本执行您的本地单元测试，该版本不包含任何实际代码。相反，从单元测试中调用Android类的方法会抛出异常。这是为了确保你只测试你的代码，不依赖于Android平台的任何特定的行为（你没有明确的被模拟）。</p>
<p>您可以使用模拟框架在代码中存根外部依赖关系，以便轻松测试您的组件是否按照预期的方式与依赖关系交互。通过用模拟对象替换Android依赖项，您可以将单元测试与Android系统的其余部分隔离，同时验证这些依赖关系中的正确方法是否被调用。Java的Mockito mocking框架（1.9.5及更高版本）提供了与Android单元测试的兼容性。使用<a href="https://github.com/mockito/mockito">Mockito</a>，您可以配置模拟对象以在调用时返回一些特定值。</p>
<p>要使用此框架将mock对象添加到本地单元测试，请遵循以下编程模型：</p>
<ul>
<li>1.在<code>build.gradle</code>文件中包含Mockito库依赖关系，如<a href="#设置您的测试环境">设置您的测试环境</a>中所述的那样。</li>
<li>2.在单元测试类定义的开始，添加<code>@RunWith(MockitoJUnitRunner.class)</code>注解。这个注解告诉Mockito测试运行器验证你的框架的使用是正确的，并简化了你的模拟对象的初始化。</li>
<li>3.要为Android依赖项创建模拟对象，请在字段声明之前添加<code>@Mock</code>注解。</li>
<li>4.要存根依赖关系的行为，当条件满足使用<code>when()</code>和<code>thenReturn()</code>方法时，你可以指定一个条件和返回值。</li>
</ul>
<p>以下示例显示如何使用mock Context 对象创建单元测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import static org.hamcrest.MatcherAssert.assertThat;</span><br><span class="line">import static org.hamcrest.CoreMatchers.*;</span><br><span class="line">import static org.mockito.Mockito.*;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.mockito.Mock;</span><br><span class="line">import org.mockito.runners.MockitoJUnitRunner;</span><br><span class="line">import android.content.SharedPreferences;</span><br><span class="line"></span><br><span class="line">@RunWith(MockitoJUnitRunner.class)</span><br><span class="line">public class UnitTestSample &#123;</span><br><span class="line"></span><br><span class="line">    private static final String FAKE_STRING &#x3D; &quot;HELLO WORLD&quot;;</span><br><span class="line"></span><br><span class="line">    @Mock</span><br><span class="line">    Context mMockContext;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void readStringFromContext_LocalizedString() &#123;</span><br><span class="line">        &#x2F;&#x2F; Given a mocked Context injected into the object under test...</span><br><span class="line">        when(mMockContext.getString(R.string.hello_word))</span><br><span class="line">                .thenReturn(FAKE_STRING);</span><br><span class="line">        ClassUnderTest myObjectUnderTest &#x3D; new ClassUnderTest(mMockContext);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...when the string is returned from the object under test...</span><br><span class="line">        String result &#x3D; myObjectUnderTest.getHelloWorldString();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...then the result should be the expected one.</span><br><span class="line">        assertThat(result, is(FAKE_STRING));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要了解有关使用Mockito框架的更多信息，请参阅示<a href="http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html">Mockito API参考</a>和<a href="https://github.com/googlesamples/android-testing/tree/master/unit/BasicSample">示例代码</a>中的<code>SharedPreferencesHelperTest</code>类。</p>
<p>如果android.jar中Android API对你的测试问题抛出了异常，您可以更改行为，以使方法通过在项目的顶级<code>build.gradle</code>文件中添加以下配置来返回null或零：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  testOptions &#123;</span><br><span class="line">    unitTests.returnDefaultValues &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong>:将<code>returnDefaultValues</code>属性设置为<code>true</code>应该小心。null/零返回值可以在测试中引入回归，这难以调试，并且可能允许失败的测试通过。只能使用它作为最后的手段。</p>
</blockquote>
<h2 id="运行本地单元测试"><a href="#运行本地单元测试" class="headerlink" title="运行本地单元测试"></a>运行本地单元测试</h2><p>要运行本地单元测试，请按照下列步骤操作：</p>
<ul>
<li>1.通过单击工具栏中的<strong>Sync Project</strong>，确保您的项目与Gradle同步。</li>
<li>2.使用以下方法之一运行测试：<ul>
<li>若要运行单个测试，请打开<strong>Project</strong>窗口，然后右击测试并单击<strong>Run</strong>。</li>
<li>要在类中测试所有方法，请右击测试文件中的类或方法，然后单击<strong>Run</strong>。</li>
<li>若要在目录中运行所有测试，请右击目录并选择<strong>Run tests</strong>。</li>
</ul>
</li>
</ul>
<p>Gradle的Android插件编译位于默认目录<code>(src/test/java/)</code>中的本地单元测试代码，并使用默认的测试运行器类在本地执行它。然后，Android Studio将在<strong>Run</strong>窗口中显示结果。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】测试你的Content Provider</title>
    <url>/2017/01/13/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84Content%20Provider/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/training/testing/integration-testing/content-provider-testing.html">https://developer.android.google.cn/training/testing/integration-testing/content-provider-testing.html</a></p>
<p>如果要实施content provider来存储和检索数据或使数据可供其他应用程序访问，则应测试提供程序以确保其不会以意外的方式运行。本课程介绍如何测试公共content provider，并且也适用于您对自己的应用保持私有的content provider。</p>
<h2 id="为content-provider创建集成测试"><a href="#为content-provider创建集成测试" class="headerlink" title="为content provider创建集成测试"></a>为content provider创建集成测试</h2><p>在Android中，应用程式将content provider视为提供资料表的资料API，而内部资讯提供不可见。content provider可以具有许多公共常量，但是它通常具有很少的公共方法并且没有公共变量。因此，您应该仅根据提供程序的公共成员编写测试。这样设计的content provider在其本身与其用户之间提供合同。</p>
<p>content provider允许您访问实际的用户数据，因此确保在隔离的测试环境中测试内容提供程序很重要。这种方法允许您只运行在测试用例中明确设置的数据依赖关系。这也意味着您的测试不会修改实际的用户数据。例如，您应避免编写失败的测试，因为上一个测试中遗留了数据。同样，您的测试应避免在content provider中添加或删除实际联系人信息。</p>
<p>要单独测试content provider程序，请使用<a href="https://developer.android.google.cn/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a>类。此类允许您使用Android模拟对象类（如<a href="https://developer.android.google.cn/reference/android/test/IsolatedContext.html">IsolatedContext</a>和<a href="https://developer.android.google.cn/reference/android/test/mock/MockContentResolver.html">MockContentResolver</a>）访问文件和数据库信息，而不会影响实际的用户数据。</p>
<p>您的集成测试应写为JUnit 4测试类。要了解有关创建JUnit 4测试类和使用JUnit 4断言的更多信息，请参阅<a href="/2017/01/11/【Android文档翻译】构建本地单元测试/#创建本地单元测试类">创建本地单元测试类</a>。</p>
<p>要为内容提供商创建集成测试，您必须执行以下步骤：</p>
<ul>
<li>创建您的测试类作为<a href="https://developer.android.google.cn/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a>的子类。</li>
<li>在你的测试类的定义部分加入<code>@RunWith(AndroidJUnit4.class)</code>注解。</li>
<li>指定<a href="https://developer.android.google.cn/tools/testing-support-library/index.html">Android测试支持库</a>提供的<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>类作为默认测试运行程序。此步骤在<a href="/2017/01/11/【Android文档翻译】入门测试/">测试入门</a>中有更详细的描述。</li>
<li>从<a href="https://developer.android.google.cn/reference/android/support/test/InstrumentationRegistry.html">InstrumentationRegistry</a>类设置Context对象。有关示例，请参阅下面的代码段。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void setUp() throws Exception &#123;</span><br><span class="line">    setContext(InstrumentationRegistry.getTargetContext());</span><br><span class="line">    super.setUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ProviderTestCase2的工作原理"><a href="#ProviderTestCase2的工作原理" class="headerlink" title="ProviderTestCase2的工作原理"></a>ProviderTestCase2的工作原理</h3><p>你通过<a href="https://developer.android.google.cn/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a>测试provider。这个基类扩展了<a href="https://developer.android.google.cn/reference/android/test/AndroidTestCase.html">AndroidTestCase</a>，因此它提供了JUnit测试框架以及特定于Android的测试应用程序权限的方法。这个类的最重要的特性是它的初始化，它创建隔离的测试环境。</p>
<p>初始化在<a href="https://developer.android.google.cn/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a>的构造函数中完成，它在自己的构造函数中调用子类。<a href="https://developer.android.google.cn/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a>构造函数创建一个<a href="https://developer.android.google.cn/reference/android/test/IsolatedContext.html">IsolatedContext</a>对象，允许文件和数据库操作，但存根与Android系统的其他交互。文件和数据库操作本身发生在设备或模拟器本地的目录中，并且具有特殊的前缀。</p>
<p>然后，构造函数创建一个<a href="https://developer.android.google.cn/reference/android/test/mock/MockContentResolver.html">MockContentResolver</a>以用作测试的解析器。</p>
<p>最后，构造函数创建一个被测试提供者的实例。这是一个正常的<a href="https://developer.android.google.cn/reference/android/content/ContentProvider.html">ContentProvider</a>对象，但它从<a href="https://developer.android.google.cn/reference/android/test/IsolatedContext.html">IsolatedContext</a>获取其所有环境信息，因此它被限制在隔离的测试环境中工作。在测试用例类中执行的所有测试都针对这个孤立的对象运行。</p>
<p>您对content provider运行集成测试的方式与仪表化单元测试相同。要对content provider运行集成测试，请按照<a href="/2017/01/11/【Android文档翻译】构建仪表化单元测试/#运行仪表单元测试">运行仪表单元测试</a>中所述的步骤操作。</p>
<h2 id="测试什么"><a href="#测试什么" class="headerlink" title="测试什么"></a>测试什么</h2><p>以下是测试content provider的一些具体指南。</p>
<ul>
<li>使用解析器方法测试：即使您可以在<a href="https://developer.android.google.cn/reference/android/test/ProviderTestCase2.html">ProviderTestCase2</a>中实例化一个content provider对象，您应该始终使用适当的URI测试解析器对象。这样做可确保您通过执行常规应用程序的相同交互方式来测试content provider。</li>
<li><p>测试公共provider作为合同：如果您打算将您的provider公开并可供其他应用程序使用，那么您应该将其作为合同进行测试。下面是一些实例：</p>
<ul>
<li>使用您的provider公开的常量进行测试。例如，查找在provider的数据表之一中引用列名的常量。这些名称通常都是由provider公开定义的常量。</li>
<li>测试您的provider提供的所有URI。您的provider可能会提供多个URI，每个URI指向数据的不同方面。</li>
<li>测试无效URI：您的单元测试应故意调用具有无效URI的provider，并查找错误。一个好的provider设计是抛出一个IllegalArgumentException无效的URI。</li>
</ul>
</li>
<li>测试标准provider交互：大多数provider提供六种访问方法：<code>query(), insert()</code>,<code>delete()</code>,<code>update()</code>,<code>getType()</code>, and <code>onCreate()</code>。你的测试应该验证所有这些方法的工作情况。这些方法在topic Content Providers中有更详细的描述。</li>
<li>测试业务逻辑：如果content provider实现业务逻辑，您应该测试它。业务逻辑包括处理无效值，财务或算术计算，消除或组合重复。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】测试你的Service</title>
    <url>/2017/01/13/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84Service/</url>
    <content><![CDATA[<p>如果要将本地Service实现为应用程序的组件，则应该测试Service以确保它不会以意想不到的方式运行。您可以创建<a href="https://developer.android.google.cn/training/testing/unit-testing/instrumented-unit-tests.html">检测单元测试</a>以验证服务中的行为是否正确;例如，Service存储和返回有效数据值，并且正确地执行数据操作。</p>
<p><a href="https://developer.android.google.cn/tools/testing-support-library/index.html">Android测试支持库</a>提供了一个用于孤立地测试Service对象的API。<a href="https://developer.android.google.cn/reference/android/support/test/rule/ServiceTestRule.html">ServiceTestRule</a>类是一个JUnit 4规则，在单元测试方法运行之前启动服务，并在测试完成后关闭服务。通过使用此测试规则，可确保在运行测试方法之前始终建立与服务的连接。要了解有关JUnit 4规则的更多信息，请参阅<a href="https://github.com/junit-team/junit/wiki/Rules">JUnit文档</a>。</p>
<p><strong>注意：</strong><a href="https://developer.android.google.cn/reference/android/support/test/rule/ServiceTestRule.html">ServiceTestRule</a>类不支持<a href="https://developer.android.google.cn/reference/android/app/IntentService.html">IntentService</a>对象的测试。如果您需要测试<a href="https://developer.android.google.cn/reference/android/app/IntentService.html">IntentService</a>对象，您应该将逻辑封装在单独的类中，并创建相应的单元测试。</p>
<h2 id="设置您的测试环境"><a href="#设置您的测试环境" class="headerlink" title="设置您的测试环境"></a>设置您的测试环境</h2><p>在构建Service的集成测试之前，请确保为你用来集成测试的项目进行配置，如<a href="/2017/01/11/【Android文档翻译】入门测试/">入门测试</a>中所述。</p>
<h2 id="为Service创建集成测试"><a href="#为Service创建集成测试" class="headerlink" title="为Service创建集成测试"></a>为Service创建集成测试</h2><p>您的集成测试应写为JUnit 4测试类。要了解有关创建JUnit 4测试类和使用JUnit 4断言方法的更多信息，请参阅<a href="/2017/01/11/【Android文档翻译】构建仪表化单元测试/">构建仪表化单元测试</a>。</p>
<p>要为您的服务创建集成测试，请在测试类定义的开头添加<code>@RunWith（AndroidJUnit4.class）</code>注解。您还需要指定Android测试支持库提供的<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>类作为默认测试运行器。</p>
<p>接下来，使用<code>@Rule</code>注解在测试中创建一个<a href="https://developer.android.google.cn/reference/android/support/test/rule/ServiceTestRule.html">ServiceTestRule</a>实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public final ServiceTestRule mServiceRule &#x3D; new ServiceTestRule();</span><br></pre></td></tr></table></figure>
<p>以下示例显示如何为Service实现集成测试。测试方法<code>testWithBoundService</code>验证应用程序是否成功绑定到本地Service，并且服务接口行为正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testWithBoundService() throws TimeoutException &#123;</span><br><span class="line">    &#x2F;&#x2F; Create the service Intent.</span><br><span class="line">    Intent serviceIntent &#x3D;</span><br><span class="line">            new Intent(InstrumentationRegistry.getTargetContext(),</span><br><span class="line">                LocalService.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Data can be passed to the service via the Intent.</span><br><span class="line">    serviceIntent.putExtra(LocalService.SEED_KEY, 42L);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Bind the service and grab a reference to the binder.</span><br><span class="line">    IBinder binder &#x3D; mServiceRule.bindService(serviceIntent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get the reference to the service, or you can call</span><br><span class="line">    &#x2F;&#x2F; public methods on the binder directly.</span><br><span class="line">    LocalService service &#x3D;</span><br><span class="line">            ((LocalService.LocalBinder) binder).getService();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Verify that the service is working correctly.</span><br><span class="line">    assertThat(service.getRandomInt(), is(any(Integer.class)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行服务的集成测试"><a href="#运行服务的集成测试" class="headerlink" title="运行服务的集成测试"></a>运行服务的集成测试</h2><p>您可以从Android Studio或从命令行运行集成测试。确保指定<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>作为项目中的默认instrumentation runner。</p>
<p>要为Service运行集成测试，请按照<a href="/2017/01/11/【Android文档翻译】入门测试/">入门测试</a>中描述的运行测试测试的步骤操作。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】测试单个应用程序的UI</title>
    <url>/2017/01/13/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%B5%8B%E8%AF%95%E5%8D%95%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84UI/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/training/testing/ui-testing/espresso-testing.html">https://developer.android.google.cn/training/testing/ui-testing/espresso-testing.html</a></p>
<p>在单个应用中测试用户互动有助于确保用户在与您的应用互动时不会遇到意外的结果或体验不佳。如果您需要验证应用程序的UI是否正常工作，您应该习惯创建用户界面（UI）测试。</p>
<p>由<a href="https://developer.android.google.cn/tools/testing-support-library/index.html">Android测试支持库</a>提供的Espresso测试框架提供了用于编写UI测试的API，以在单个目标应用程序中模拟用户交互。Espresso测试可在运行Android 2.3.3（API级别10）及更高版本的设备上运行。使用Espresso的一个主要优点是它提供了测试操作与要测试的应用程序的UI的自动同步。Espresso检测主线程何时空闲，因此可以在适当的时间运行测试命令，提高测试的可靠性。此功能还可以避免您添加任何计时解决方法，例如测试代码中的<a href="https://developer.android.google.cn/reference/java/lang/Thread.html#sleep(long">Thread.sleep()</a>)。</p>
<p>Espresso测试框架是一种基于工具的API，可与<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>测试运行程序配合使用。</p>
<h2 id="设置Espresso"><a href="#设置Espresso" class="headerlink" title="设置Espresso"></a>设置Espresso</h2><p>在使用Espresso构建UI测试之前，请确保按照<a href="/2017/01/11/【Android文档翻译】入门测试/">测试入门</a>中所述配置测试源代码位置和项目依赖关系。</p>
<p>在Android应用程序模块的<code>build.gradle</code>文件中，必须为Espresso库设置依赖性引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    &#x2F;&#x2F; Other dependencies ...</span><br><span class="line">    androidTestCompile &#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭测试设备上的动画 - 在测试设备中打开系统动画可能会导致意外的结果，或可能导致测试失败。通过打开开发者选项并关闭所有以下选项，从设置中关闭动画：</p>
<ul>
<li><strong>窗口动画设置</strong></li>
<li><strong>过渡动画设置</strong></li>
<li><strong>动画持续时间设置</strong></li>
</ul>
<p>如果要将项目设置为使用除核心API提供的以外的Espresso功能，请参阅此<a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html">资源</a>。</p>
<h2 id="创建Espresso测试类"><a href="#创建Espresso测试类" class="headerlink" title="创建Espresso测试类"></a>创建Espresso测试类</h2><p>要创建Espresso测试，请创建遵循此编程模型的Java类：</p>
<ul>
<li>1.通过调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher&lt;android.view.View"><code>onView()</code></a>方法或<a href="https://developer.android.google.cn/reference/android/widget/AdapterView.html">AdapterView</a>控件的<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onData(org.hamcrest.Matcher&lt;java.lang.Object"><code>onData()</code></a>)方法，在Activity中找到要测试的UI组件（例如，应用程序中的登录按钮）</li>
<li>2.通过调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewInteraction.html#perform(android.support.test.espresso.ViewAction..."><code>ViewInteraction.perform()</code></a>或<a href="https://developer.android.google.cn/reference/android/support/test/espresso/DataInteraction.html#perform(android.support.test.espresso.ViewAction..."><code>DataInteraction.perform()</code></a>方法并传递用户操作（例如，单击登录按钮），模拟要在该UI组件上执行的特定用户交互。要在同一个UI组件上排序多个操作，请使用方法参数中的逗号分隔列表将它们链接起来。</li>
<li>3.根据需要重复上述步骤，以模拟目标应用程序中多个活动的用户流。</li>
<li>4.在执行这些用户交互之后，使用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/assertion/ViewAssertions.html"><code>ViewAssertions</code></a>方法检查UI是否反映了预期的状态或行为。</li>
</ul>
<p>这些步骤在下面的部分中有更详细地描述。</p>
<p>以下代码段显示了您的测试类如何调用此基本工作流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.my_view))            &#x2F;&#x2F; withId(R.id.my_view) is a ViewMatcher</span><br><span class="line">        .perform(click())               &#x2F;&#x2F; click() is a ViewAction</span><br><span class="line">        .check(matches(isDisplayed())); &#x2F;&#x2F; matches(isDisplayed()) is a ViewAssertion</span><br></pre></td></tr></table></figure>
<h2 id="通过ActivityTestRule来使用Espresso"><a href="#通过ActivityTestRule来使用Espresso" class="headerlink" title="通过ActivityTestRule来使用Espresso"></a>通过ActivityTestRule来使用Espresso</h2><p>以下部分描述如何在JUnit 4样式中创建新的Espresso测试，并使用<a href="https://developer.android.google.cn/reference/android/support/test/rule/ActivityTestRule.html">ActivityTestRule</a>减少需要写入的样板代码量。通过使用<a href="https://developer.android.google.cn/reference/android/support/test/rule/ActivityTestRule.html">ActivityTestRule</a>，测试框架在用<code>@Test</code>注解的每个测试方法之前和在用<code>@Before</code>注解的任何方法之前启动测试下的activity。框架处理在测试完成后关闭activity，并运行用<code>@After</code>注解的所有方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.android.testing.espresso.BasicSample;</span><br><span class="line"></span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Rule;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line">import android.support.test.rule.ActivityTestRule;</span><br><span class="line">import android.support.test.runner.AndroidJUnit4;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">@LargeTest</span><br><span class="line">public class ChangeTextBehaviorTest &#123;</span><br><span class="line"></span><br><span class="line">    private String mStringToBetyped;</span><br><span class="line"></span><br><span class="line">    @Rule</span><br><span class="line">    public ActivityTestRule&lt;MainActivity&gt; mActivityRule &#x3D; new ActivityTestRule&lt;&gt;(</span><br><span class="line">            MainActivity.class);</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void initValidString() &#123;</span><br><span class="line">        &#x2F;&#x2F; Specify a valid string.</span><br><span class="line">        mStringToBetyped &#x3D; &quot;Espresso&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void changeText_sameActivity() &#123;</span><br><span class="line">        &#x2F;&#x2F; Type text and then press the button.</span><br><span class="line">        onView(withId(R.id.editTextUserInput))</span><br><span class="line">                .perform(typeText(mStringToBetyped), closeSoftKeyboard());</span><br><span class="line">        onView(withId(R.id.changeTextBt)).perform(click());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check that the text was changed.</span><br><span class="line">        onView(withId(R.id.textToBeChanged))</span><br><span class="line">                .check(matches(withText(mStringToBetyped)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问UI组件"><a href="#访问UI组件" class="headerlink" title="访问UI组件"></a>访问UI组件</h2><p>在Espresso可以与正在测试的应用程序交互之前，您必须首先指定UI组件或视图。Espresso支持使用<a href="http://hamcrest.org/">Hamcrest匹配器</a>在应用程序中指定视图和适配器。</p>
<p>要查找视图，请调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher&lt;android.view.View"><code>onView()</code></a>方法并传递一个视图匹配器，该视图匹配器指定您要定位的视图。这在<a href="#指定视图匹配器">指定视图匹配器</a>中有更详细地描述。<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher&lt;android.view.View"><code>onView()</code></a>方法返回一个<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewInteraction.html">ViewInteraction</a>对象，允许您的测试与视图交互。但是，如果要在<a href="https://developer.android.google.cn/reference/android/support/v7/widget/RecyclerView.html">RecyclerView</a>布局中查找视图，则调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher&lt;android.view.View"><code>onView()</code></a>方法可能不起作用。在这种情况下，请按照<a href="#在AdapterView中查找视图">在AdapterView中查找视图</a>中的说明进行操作。</p>
<blockquote>
<p><strong>注意：</strong><a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher&lt;android.view.View"><code>onView()</code></a>方法不会检查您指定的视图是否有效。相反，Espresso仅使用提供的匹配器搜索当前视图层次结构。如果没有找到匹配，该方法将抛出<a href="https://developer.android.google.cn/reference/android/support/test/espresso/NoMatchingViewException.html">NoMatchingViewException</a>异常。</p>
</blockquote>
<p>以下代码段显示了如何编写访问EditText字段，输入文本字符串，关闭虚拟键盘，然后执行按钮单击的测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void testChangeText_sameActivity() &#123;</span><br><span class="line">    &#x2F;&#x2F; Type text and then press the button.</span><br><span class="line">    onView(withId(R.id.editTextUserInput))</span><br><span class="line">            .perform(typeText(STRING_TO_BE_TYPED), closeSoftKeyboard());</span><br><span class="line">    onView(withId(R.id.changeTextButton)).perform(click());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the text was changed.</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定视图匹配器"><a href="#指定视图匹配器" class="headerlink" title="指定视图匹配器"></a>指定视图匹配器</h3><p>您可以使用以下方法指定视图匹配器：</p>
<ul>
<li>在<a href="https://developer.android.google.cn/reference/android/support/test/espresso/matcher/ViewMatchers.html">ViewMatchers</a>类中调用方法。例如，要通过查找显示的文本字符串来查找视图，可以调用以下方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onView(withText(&quot;Sign-in&quot;));</span><br></pre></td></tr></table></figure>
<p>同样，您可以调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/matcher/ViewMatchers.html#withId(int"><code>withId()</code></a>并提供视图的资源ID(R.id)，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.button_signin));</span><br></pre></td></tr></table></figure>
<p>Android资源ID不能保证是唯一的。如果您的测试尝试匹配多个视图使用的资源ID，Espresso会抛出<a href="https://developer.android.google.cn/reference/android/support/test/espresso/AmbiguousViewMatcherException.html">AmbiguousViewMatcherException</a>。</p>
<ul>
<li>使用Hamcrest <a href="http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matchers.html">Matchers</a>类。您可以使用<code>allOf()</code>方法来组合多个匹配器，例如<code>containsString()</code>和<code>instanceOf()</code>。此方法允许您更窄地过滤匹配结果，如以下示例所示：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onView(allOf(withId(R.id.button_signin), withText(&quot;Sign-in&quot;)));</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>not</code>关键字过滤不与匹配器对应的视图，如以下示例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onView(allOf(withId(R.id.button_signin), not(withText(&quot;Sign-out&quot;))));</span><br></pre></td></tr></table></figure>
<p>要在测试中使用这些方法，请导入<code>org.hamcrest.Matchers</code>包。要了解有关Hamcrest匹配的更多信息，请参阅<a href="http://hamcrest.org/">Hamcrest网站</a>。</p>
<p>要提高Espresso测试的性能，请指定查找目标视图所需的最小匹配信息。例如，如果视图通过其描述性文本可以唯一标识，则不需要指定它也可以从TextView实例分配。</p>
<h3 id="在AdapterView中查找视图"><a href="#在AdapterView中查找视图" class="headerlink" title="在AdapterView中查找视图"></a>在AdapterView中查找视图</h3><p>在<a href="https://developer.android.google.cn/reference/android/widget/AdapterView.html">AdapterView</a>小部件中，视图在运行时动态填充子视图。如果要测试的目标视图位于<a href="https://developer.android.google.cn/reference/android/widget/AdapterView.html">AdapterView</a>（例如<a href="https://developer.android.google.cn/reference/android/widget/ListView.html">ListView</a>，<a href="https://developer.android.google.cn/reference/android/widget/GridView.html">GridView</a>或<a href="https://developer.android.google.cn/reference/android/widget/Spinner.html">Spinner</a>）中，则<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher&lt;android.view.View">onView()</a>方法可能无法工作，因为只有一部分视图可能会加载到当前视图层次结构中。</p>
<p>相反，调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onData(org.hamcrest.Matcher&lt;java.lang.Object"><code>onData()</code></a>方法可获取<a href="https://developer.android.google.cn/reference/android/support/test/espresso/DataInteraction.html">DataInteraction</a>对象以访问目标视图元素。Espresso处理将目标视图元素加载到当前视图层次结构中。Espresso还负责滚动到目标元素，并将元素放在焦点上。</p>
<blockquote>
<p><strong>注意：</strong><a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onData(org.hamcrest.Matcher&lt;java.lang.Object"><code>onData()</code></a>方法不会检查您指定的项目是否与视图对应。Espresso仅搜索当前视图层次结构。如果没有找到匹配，该方法将抛出<a href="https://developer.android.google.cn/reference/android/support/test/espresso/NoMatchingViewException.html">NoMatchingViewException</a>异常。 </p>
</blockquote>
<p>下面的代码片段展示了如何使用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/Espresso.html#onData(org.hamcrest.Matcher&lt;java.lang.Object"><code>onData()</code></a>方法和Hamcrest匹配来搜索包含给定字符串的列表中的特定行。在此示例中，<code>LongListActivity</code>类包含通过<a href="https://developer.android.google.cn/reference/android/widget/SimpleAdapter.html"><code>SimpleAdapter</code></a>公开的字符串列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onData(allOf(is(instanceOf(Map.class)),</span><br><span class="line">        hasEntry(equalTo(LongListActivity.ROW_TEXT), is(&quot;test input&quot;)));</span><br></pre></td></tr></table></figure>
<h2 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h2><p>调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewInteraction.html#perform(android.support.test.espresso.ViewAction...">ViewInteraction.perform()</a>或<a href="https://developer.android.google.cn/reference/android/support/test/espresso/DataInteraction.html#perform(android.support.test.espresso.ViewAction...">DataInteraction.perform()</a>方法来模拟UI组件上的用户交互。您必须传入一个或多个<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewAction.html">ViewAction</a>对象作为参数。Espresso按照给定的顺序依次触发每个动作，并在主线程中执行它们。</p>
<p><a href="https://developer.android.google.cn/reference/android/support/test/espresso/action/ViewActions.html">ViewActions</a>类提供了指定常用操作的帮助方法列表。您可以使用这些方法作为方便的快捷方式，而不是创建和配置单个<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewAction.html">ViewAction</a>对象。您可以指定此类操作:</p>
<ul>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/action/ViewActions.html#click(">ViewActions.click()</a>: 点击视图。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/action/ViewActions.html#typeText(java.lang.String">ViewActions.typeText()</a>:单击视图并输入指定的字符串。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/action/ViewActions.html#scrollTo(">ViewActions.scrollTo()</a>:滚动到视图。目标视图必须是来自<code>ScrollView</code>的子类，它的<code>android:visibility</code>属性的值必须是<code>VISIBLE</code>。对于扩展<code>AdapterView</code>（例如<code>ListView</code>）的视图，<code>onData()</code>方法为您处理滚动。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/action/ViewActions.html#pressKey(int">ViewActions.pressKey()</a>：使用指定的键码执行按键操作。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/action/ViewActions.html#clearText(">ViewActions.clearText()</a>：清除目标视图中的文本。</li>
</ul>
<p>如果目标视图位于<code>ScrollView</code>中，在其他操作之前，请先执行<code>ViewActions.scrollTo()</code>操作使视图显示在屏幕中。如果视图已显示，<code>ViewActions.scrollTo()</code>操作将不起作用。</p>
<h2 id="与Espresso-Intents隔离测试您的Activity"><a href="#与Espresso-Intents隔离测试您的Activity" class="headerlink" title="与Espresso Intents隔离测试您的Activity"></a>与Espresso Intents隔离测试您的Activity</h2><p><a href="https://google.github.io/android-testing-support-library/docs/espresso/intents/index.html">Espresso Intents</a>支持对应用程序发送的Intent进行验证和存根。使用Espresso Intents，您可以通过拦截传出意向，存根结果并将其发送回测试中的组件来单独测试应用程序，Activity或Service。</p>
<p>要开始使用Espresso Intents进行测试，需要在应用程序的<code>build.gradle</code>文件中添加以下行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  &#x2F;&#x2F; Other dependencies ...</span><br><span class="line">  androidTestCompile &#39;com.android.support.test.espresso:espresso-intents:2.2.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要测试一个intent，您需要创建一个<a href="https://developer.android.google.cn/reference/android/support/test/espresso/intent/rule/IntentsTestRule.html">IntentsTestRule</a>类的实例，这与<a href="https://developer.android.google.cn/reference/android/support/test/rule/ActivityTestRule.html">ActivityTestRule</a>类非常相似。<a href="https://developer.android.google.cn/reference/android/support/test/espresso/intent/rule/IntentsTestRule.html">IntentsTestRule</a>类在每次测试之前初始化Espresso Intents，终止host activity，并在每次测试后释放Espresso Intents。</p>
<p>以下代码片段中显示的测试类提供了对显式意图的简单测试。它测试在<a href="https://developer.android.google.cn/training/basics/firstapp/index.html">构建您的第一个应用程序教程</a>中创建的Activity和意图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Large</span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">public class SimpleIntentTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final String MESSAGE &#x3D; &quot;This is a test&quot;;</span><br><span class="line">    private static final String PACKAGE_NAME &#x3D; &quot;com.example.myfirstapp&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Instantiate an IntentsTestRule object. *&#x2F;</span><br><span class="line">    @Rule</span><br><span class="line">    public IntentsTestRule≶MainActivity&gt; mIntentsRule &#x3D;</span><br><span class="line">      new IntentsTestRule≶&gt;(MainActivity.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void verifyMessageSentToMessageActivity() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Types a message into a EditText element.</span><br><span class="line">        onView(withId(R.id.edit_message))</span><br><span class="line">                .perform(typeText(MESSAGE), closeSoftKeyboard());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Clicks a button to send the message to another</span><br><span class="line">        &#x2F;&#x2F; activity through an explicit intent.</span><br><span class="line">        onView(withId(R.id.send_message)).perform(click());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Verifies that the DisplayMessageActivity received an intent</span><br><span class="line">        &#x2F;&#x2F; with the correct package name and message.</span><br><span class="line">        intended(allOf(</span><br><span class="line">                hasComponent(hasShortClassName(&quot;.DisplayMessageActivity&quot;)),</span><br><span class="line">                toPackage(PACKAGE_NAME),</span><br><span class="line">                hasExtra(MainActivity.EXTRA_MESSAGE, MESSAGE)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关Espresso Intents的更多信息，请参阅<a href="https://google.github.io/android-testing-support-library/docs/espresso/intents/index.html">Android测试支持库网站上的Espresso Intents文档</a>。您还可以下载<a href="https://github.com/googlesamples/android-testing/tree/master/ui/espresso/IntentsBasicSample">IntentsBasicSample</a>和<a href="https://github.com/googlesamples/android-testing/tree/master/ui/espresso/IntentsAdvancedSample">I​​ntentsAdvancedSample</a>代码示例。</p>
<h2 id="使用Espresso-Web测试WebViews"><a href="#使用Espresso-Web测试WebViews" class="headerlink" title="使用Espresso Web测试WebViews"></a>使用Espresso Web测试WebViews</h2><p>Espresso Web允许您测试Activity中包含的WebView组件。它使用<a href="http://docs.seleniumhq.org/docs/03_webdriver.jsp">WebDriver API</a>来检查和控制WebView的行为。</p>
<p>要开始使用Espresso Web进行测试，您需要将以下行添加到应用程序的<code>build.gradle</code>文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  &#x2F;&#x2F; Other dependencies ...</span><br><span class="line">  androidTestCompile &#39;com.android.support.test.espresso:espresso-web:2.2.2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用Espresso Web创建测试时，您需要在实例化<a href="https://developer.android.google.cn/reference/android/support/test/rule/ActivityTestRule.html">ActivityTestRule</a>对象以测试Activity时在WebView上启用JavaScript。在测试中，您可以选择WebView中显示的HTML元素并模拟用户交互，如在文本框中输入文本，然后单击按钮。操作完成后，您可以验证Web页上的结果是否与您期望的结果匹配。</p>
<p>在下面的代码片段中，该类在被测试的Activity中测试具有id值’webview’的WebView组件。<code>verifyValidInputYieldsSuccesfulSubmission()</code>测试在Web页面上选择一个<code>&lt;input&gt;</code>元素，输入一些文本，并检查出现在另一个元素中的文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LargeTest</span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">public class WebViewActivityTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final String MACCHIATO &#x3D; &quot;Macchiato&quot;;</span><br><span class="line">    private static final String DOPPIO &#x3D; &quot;Doppio&quot;;</span><br><span class="line"></span><br><span class="line">    @Rule</span><br><span class="line">    public ActivityTestRule mActivityRule &#x3D;</span><br><span class="line">        new ActivityTestRule(WebViewActivity.class,</span><br><span class="line">            false &#x2F;* Initial touch mode *&#x2F;, false &#x2F;*  launch activity *&#x2F;) &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void afterActivityLaunched() &#123;</span><br><span class="line">            &#x2F;&#x2F; Enable JavaScript.</span><br><span class="line">            onWebView().forceJavascriptEnabled();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void typeTextInInput_clickButton_SubmitsForm() &#123;</span><br><span class="line">       &#x2F;&#x2F; Lazily launch the Activity with a custom start Intent per test</span><br><span class="line">       mActivityRule.launchActivity(withWebFormIntent());</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Selects the WebView in your layout.</span><br><span class="line">       &#x2F;&#x2F; If you have multiple WebViews you can also use a</span><br><span class="line">       &#x2F;&#x2F; matcher to select a given WebView, onWebView(withId(R.id.web_view)).</span><br><span class="line">       onWebView()</span><br><span class="line">           &#x2F;&#x2F; Find the input element by ID</span><br><span class="line">           .withElement(findElement(Locator.ID, &quot;text_input&quot;))</span><br><span class="line">           &#x2F;&#x2F; Clear previous input</span><br><span class="line">           .perform(clearElement())</span><br><span class="line">           &#x2F;&#x2F; Enter text into the input element</span><br><span class="line">           .perform(DriverAtoms.webKeys(MACCHIATO))</span><br><span class="line">           &#x2F;&#x2F; Find the submit button</span><br><span class="line">           .withElement(findElement(Locator.ID, &quot;submitBtn&quot;))</span><br><span class="line">           &#x2F;&#x2F; Simulate a click via JavaScript</span><br><span class="line">           .perform(webClick())</span><br><span class="line">           &#x2F;&#x2F; Find the response element by ID</span><br><span class="line">           .withElement(findElement(Locator.ID, &quot;response&quot;))</span><br><span class="line">           &#x2F;&#x2F; Verify that the response page contains the entered text</span><br><span class="line">           .check(webMatches(getText(), containsString(MACCHIATO)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关Espresso Web的详细信息，请参阅<a href="https://google.github.io/android-testing-support-library/docs/espresso/web/index.html">Android测试支持库站点上的Espresso Web文档</a>。您也可以将此代码段作为<a href="https://github.com/googlesamples/android-testing/tree/master/ui/espresso/WebBasicSample">Espresso Web代码示例</a>的一部分下载。</p>
<h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>调用<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewInteraction.html#check(android.support.test.espresso.ViewAssertion"><code>ViewInteraction.check()</code></a>或<a href="https://developer.android.google.cn/reference/android/support/test/espresso/DataInteraction.html#check(android.support.test.espresso.ViewAssertion"><code>DataInteraction.check()</code></a>方法来断言UI中的视图与某些预期状态匹配。您必须传递一个<a href="https://developer.android.google.cn/reference/android/support/test/espresso/ViewAssertion.html">ViewAssertion</a>对象作为参数。如果断言失败，Espresso会抛出一个<a href="https://developer.android.google.cn/reference/junit/framework/AssertionFailedError.html">AssertionFailedError</a>。</p>
<p><a href="https://developer.android.google.cn/reference/android/support/test/espresso/assertion/ViewAssertions.html">ViewAssertions</a>类提供了用于指定公共断言的帮助程序方法的列表。您可以使用的断言包括：</p>
<ul>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/assertion/ViewAssertions.html#doesNotExist(">doesNotExist</a>: 断言没有与当前视图层次结构中指定的条件匹配的视图。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/assertion/ViewAssertions.html#matches(org.hamcrest.Matcher&lt;? super android.view.View">matches</a>):断言指定视图存在于当前视图层次结构中，并且其状态与某个给定的Hamcrest匹配器匹配。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/espresso/assertion/ViewAssertions.html#selectedDescendantsMatch(org.hamcrest.Matcher&lt;android.view.View&gt;, org.hamcrest.Matcher&lt;android.view.View">selectedDescendentsMatch</a>:断言存在父视图的指定的子视图，并且他们的状态与Hamcrest匹配器给定的相匹配。</li>
</ul>
<p>以下代码段显示了如何检查UI中显示的文本的值与之前在EditText字段中输入的文本的值相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void testChangeText_sameActivity() &#123;</span><br><span class="line">    &#x2F;&#x2F; Type text and then press the button.</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check that the text was changed.</span><br><span class="line">    onView(withId(R.id.textToBeChanged))</span><br><span class="line">            .check(matches(withText(STRING_TO_BE_TYPED)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在设备或模拟器上运行Espresso测试"><a href="#在设备或模拟器上运行Espresso测试" class="headerlink" title="在设备或模拟器上运行Espresso测试"></a>在设备或模拟器上运行Espresso测试</h2><p>您可以从Android Studio或从命令行运行Espresso测试。确保指定<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>作为项目中的默认instrumentation runner。</p>
<p>要运行Espresso测试，请按照<a href="/2017/01/11/【Android文档翻译】入门测试/">测试入门</a>中所述的运行测试测试的步骤操作。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】测试多个应用程序的UI</title>
    <url>/2017/01/13/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%B5%8B%E8%AF%95%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84UI/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/training/testing/ui-testing/uiautomator-testing.html">https://developer.android.google.cn/training/testing/ui-testing/uiautomator-testing.html</a></p>
<p>涉及多个应用程序的用户交互的用户界面（UI）测试允许您在用户流跨越其他应用程序或系统UI时验证您的应用程序行为正确。这样的用户流的示例是消息应用，其允许用户输入文本消息，启动Android联系人选择器，以便用户可以选择要向其发送消息的收件人，然后将控制权返回给原始应用程序，以供用户提交邮件。</p>
<p>本课包括如何使用<a href="https://developer.android.google.cn/tools/testing-support-library/index.html">Android测试支持库</a>提供的UI Automator测试框架编写此类UI测试。UI Automator API可让您与设备上的可见元素进行交互，无论哪个<a href="https://developer.android.google.cn/reference/android/app/Activity.html">Activity</a>正在获取焦点。您的测试可以通过使用方便的描述符（例如该组件中显示的文本或其内容描述）来查找UI组件。UI Automator测试可以在运行Android 4.3（API级别18）或更高版本的设备上运行。</p>
<p>UI Automator测试框架是一种基于工具的API，可与<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>测试运行程序配合使用。</p>
<h2 id="设置UI-Automator"><a href="#设置UI-Automator" class="headerlink" title="设置UI Automator"></a>设置UI Automator</h2><p>在使用UI Automator构建UI测试之前，请确保按照<a href="/2017/01/11/【Android文档翻译】入门测试/">测试入门</a>中所述配置测试源代码位置和项目依赖关系。</p>
<p>在Android应用程序模块的<code>build.gradle</code>文件中，您必须为UI Automator库设置依赖性引用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    androidTestCompile &#39;com.android.support.test.uiautomator:uiautomator-v18:2.1.1&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要优化UI Automator测试，您应该首先检查目标应用程序的UI组件，并确保它们可访问。这些优化提示将在接下来的两部分中介绍。</p>
<h3 id="在设备上检查UI"><a href="#在设备上检查UI" class="headerlink" title="在设备上检查UI"></a>在设备上检查UI</h3><p>在设计测试之前，请检查设备上可见的UI组件。为了确保您的UI Automator测试可以访问这些组件，请检查这些组件是否有可见的文本标签，<code>android：contentDescription</code>值或两者都有。</p>
<p><code>uiautomatorviewer</code>工具提供了一个方便的可视界面来检查布局层次结构，并查看在设备前台可见的UI组件的属性。此信息允许您使用UI Automator创建更细粒度的测试。例如，您可以创建与特定可见属性匹配的UI选择器。</p>
<p>启动uiautomatorviewer工具：</p>
<ul>
<li>1.在物理设备上启动目标应用程序。</li>
<li>2.将设备连接到开发机器。</li>
<li>3.打开终端窗口并导航到<code>&lt;android-sdk&gt;/tools/</code>目录。</li>
<li>4.使用此命令运行工具：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ uiautomatorviewer</span><br></pre></td></tr></table></figure>
<p>查看应用程序的UI属性：</p>
<ul>
<li>1.在<code>uiautomatorviewer</code>界面中，单击设备截图按钮。</li>
<li>2.将鼠标悬停在左侧面板中的快照上，以查看由<code>uiautomatorviewer</code>工具标识的UI组件。属性列在右下方面板的右下方面板和右上方面板中的布局层次结构中。</li>
<li>3.或者，单击<strong>Toggle NAF Nodes</strong>按钮可查看UI Automator无法访问的UI组件。只有有限的信息可用于这些组件。</li>
</ul>
<p>要了解Android提供的常见类型的UI组件，请参阅<a href="https://developer.android.google.cn/guide/topics/ui/index.html">用户界面</a>。</p>
<h3 id="确保您的Activity可访问"><a href="#确保您的Activity可访问" class="headerlink" title="确保您的Activity可访问"></a>确保您的Activity可访问</h3><p>UI Automator测试框架对已实现Android辅助功能的应用的效果更好。当您使用View类型的UI元素或来自SDK或支持库的View子类时，您不需要实现辅助功能支持，因为这些类已经为您完成了。</p>
<p>但是，有些应用使用自定义UI元素来提供更丰富的用户体验。这些元素将不提供自动可访问性支持。如果您的应用程式包含不是来自SDK或支援库的View子类别的执行个体，请务必按照下列步骤为这些元素加入无障碍功能：</p>
<ul>
<li>1.创建一个继承自<strong><a href="https://developer.android.google.cn/reference/android/support/v4/widget/ExploreByTouchHelper.html">ExploreByTouchHelper</a></strong>的类。</li>
<li>2.通过调用<a href="https://developer.android.google.cn/reference/android/support/v4/view/ViewCompat.html#setAccessibilityDelegate(android.view.View, android.support.v4.view.AccessibilityDelegateCompat">setAccessibilityDelegate()</a>将新类的实例与特定自定义UI元素相关联。</li>
</ul>
<p>有关向自定义视图元素添加辅助功能的其他指南，请参阅<a href="https://developer.android.google.cn/guide/topics/ui/accessibility/custom-views.html">构建可访问的自定义视图</a>。要了解更多有关在Android的可访问性一般的最佳实践，请参阅<a href="https://developer.android.google.cn/guide/topics/ui/accessibility/apps.html">使应用程序更容易访问</a>。</p>
<h3 id="创建UI-Automator测试类"><a href="#创建UI-Automator测试类" class="headerlink" title="创建UI Automator测试类"></a>创建UI Automator测试类</h3><p>您的UI Automator测试类应以与JUnit 4测试类相同的方式编写。要了解有关创建JUnit 4测试类和使用JUnit 4断言和注释的更多信息，请参阅<a href="/2017/01/11/【Android文档翻译】构建仪表化单元测试/#创建测试单元测试类">构建测试单元测试类</a>。</p>
<p>在测试类定义的开头添加<code>@RunWith(AndroidJUnit4.class)</code>注解。您还需要指定Android测试支持库中提供的<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>类作为默认测试运行器。此步骤<a href="#在设备或模拟器上运行UI Automator测试">在设备或模拟器上的运行UI自动程序测试</a>中有更详细的描述。</p>
<p>在您的UI Automator测试类中实现以下编程模型：</p>
<ul>
<li>1.通过调用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html#getInstance(android.app.Instrumentation"><code>getInstance()</code></a>方法并传递一个<a href="https://developer.android.google.cn/reference/android/app/Instrumentation.html"><code>Instrumentation</code></a>对象作为参数，获取<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html"><code>UiDevice</code></a>对象以访问要测试的设备。</li>
<li>2.通过调用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html#findObject(android.support.test.uiautomator.UiSelector"><code>findObject()</code></a>方法，获取<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>对象以访问设备上显示的UI组件（例如，前台中的当前视图）</li>
<li>3.通过调用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>的方法模拟要在该UI组件上执行的特定用户交互;例如，调用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#performMultiPointerGesture(android.view.MotionEvent.PointerCoords[]..."><code>performMultiPointerGesture()</code></a>来模拟多点触摸手势，并使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#setText(java.lang.String"><code>setText()</code></a>来编辑文本字段。</li>
<li>4.在执行这些用户交互操作后，检查UI是否反映了预期的状态或行为。</li>
</ul>
<p>这些步骤在下面的部分中有更详细地描述。</p>
<h3 id="访问UI组件"><a href="#访问UI组件" class="headerlink" title="访问UI组件"></a>访问UI组件</h3><p><a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html">UiDevice</a>对象是访问和操纵设备状态的主要方式。在测试中，可以调用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html">UiDevice</a>的方法来检查各种属性的状态，例如当前方向或显示大小。您的测试可以使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html">UiDevice</a>对象执行设备级操作，例如强制设备进行特定旋转，D-pad硬件按键事件，以及Home和Menu按键的事件。</p>
<p>最好从设备的主屏幕开始测试。从主屏幕（或您在设备中选择的其他某个起始位置），您可以调用UI Automator API提供的方法来选择特定的UI元素并与其进行交互。</p>
<p>以下代码段显示您的测试如何获取<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html">UiDevice</a>的实例，并模拟Home按钮：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.junit.Before;</span><br><span class="line">import android.support.test.runner.AndroidJUnit4;</span><br><span class="line">import android.support.test.uiautomator.UiDevice;</span><br><span class="line">import android.support.test.uiautomator.By;</span><br><span class="line">import android.support.test.uiautomator.Until;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">@SdkSuppress(minSdkVersion &#x3D; 18)</span><br><span class="line">public class ChangeTextBehaviorTest &#123;</span><br><span class="line"></span><br><span class="line">    private static final String BASIC_SAMPLE_PACKAGE</span><br><span class="line">            &#x3D; &quot;com.example.android.testing.uiautomator.BasicSample&quot;;</span><br><span class="line">    private static final int LAUNCH_TIMEOUT &#x3D; 5000;</span><br><span class="line">    private static final String STRING_TO_BE_TYPED &#x3D; &quot;UiAutomator&quot;;</span><br><span class="line">    private UiDevice mDevice;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void startMainActivityFromHomeScreen() &#123;</span><br><span class="line">        &#x2F;&#x2F; Initialize UiDevice instance</span><br><span class="line">        mDevice &#x3D; UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start from the home screen</span><br><span class="line">        mDevice.pressHome();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Wait for launcher</span><br><span class="line">        final String launcherPackage &#x3D; mDevice.getLauncherPackageName();</span><br><span class="line">        assertThat(launcherPackage, notNullValue());</span><br><span class="line">        mDevice.wait(Until.hasObject(By.pkg(launcherPackage).depth(0)),</span><br><span class="line">                LAUNCH_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Launch the app</span><br><span class="line">        Context context &#x3D; InstrumentationRegistry.getContext();</span><br><span class="line">        final Intent intent &#x3D; context.getPackageManager()</span><br><span class="line">                .getLaunchIntentForPackage(BASIC_SAMPLE_PACKAGE);</span><br><span class="line">        &#x2F;&#x2F; Clear out any previous instances</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Wait for the app to appear</span><br><span class="line">        mDevice.wait(Until.hasObject(By.pkg(BASIC_SAMPLE_PACKAGE).depth(0)),</span><br><span class="line">                LAUNCH_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中，<code>@SdkSuppress(minSdkVersion = 18)</code>语句有助于确保测试仅在UI自动化框架要求的Android 4.3（API级别18）或更高版本的设备上运行。</p>
<p>使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiDevice.html#findObject(android.support.test.uiautomator.UiSelector"><code>findObject()</code></a>方法来检索一个代表与给定选择器标准匹配的视图的<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>。请注意，每当您的测试使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html">UiObject</a>实例来单击UI元素或查询属性时，UI Automator测试框架会在当前显示中搜索匹配项。</p>
<p>以下代码段显示了您的测试如何构建表示应用程序中的“取消”按钮和“确定”按钮的<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html">UiObject</a>实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UiObject cancelButton &#x3D; mDevice.findObject(new UiSelector()</span><br><span class="line">        .text(&quot;Cancel&quot;))</span><br><span class="line">        .className(&quot;android.widget.Button&quot;));</span><br><span class="line">UiObject okButton &#x3D; mDevice.findObject(new UiSelector()</span><br><span class="line">        .text(&quot;OK&quot;))</span><br><span class="line">        .className(&quot;android.widget.Button&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simulate a user-click on the OK button, if found.</span><br><span class="line">if(okButton.exists() &amp;&amp; okButton.isEnabled()) &#123;</span><br><span class="line">    okButton.click();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定选择器"><a href="#指定选择器" class="headerlink" title="指定选择器"></a>指定选择器</h4><p>如果要在应用程序中访问特定的UI组件，请使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiSelector.html"><code>UiSelector</code></a>类。此类表示对当前显示的UI中的特定元素的查询。</p>
<p>如果找到多个匹配元素，则布局层次结构中的第一个匹配元素将作为目标<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>返回。构建<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiSelector.html"><code>UiSelector</code></a>时，可以将多个属性链接在一起以优化搜索。如果没有找到匹配的UI元素，则抛出<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObjectNotFoundException.html"><code>UiAutomatorObjectNotFoundException</code></a>。</p>
<p>您可以使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiSelector.html#childSelector(android.support.test.uiautomator.UiSelector"><code>childSelector()</code></a>方法嵌套多个<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiSelector.html"><code>UiSelector</code></a>实例。例如，以下代码示例显示您的测试如何指定搜索以在当前显示的UI中查找第一个ListView，然后在该ListView中搜索以查找具有文本属性Apps的UI元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UiObject appItem &#x3D; new UiObject(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.ListView&quot;)</span><br><span class="line">        .instance(1)</span><br><span class="line">        .childSelector(new UiSelector()</span><br><span class="line">        .text(&quot;Apps&quot;)));</span><br></pre></td></tr></table></figure>
<p>作为最佳实践，在指定选择器时，应该使用资源ID（如果已分配给UI元素）而不是文本元素或内容描述符。并非所有元素都具有文本元素（例如，工具栏中的图标）。文本选择器很脆弱，如果UI有轻微更改，则可能导致测试失败。它们也可能不跨越不同的语言扩展;您的文本选择器可能不匹配已被翻译的字符串。</p>
<p>在选择器标准中指定对象状态可能很有用。例如，如果要选择所有已选元素的列表，以便可以取消选中它们，请调用参数设置为true的<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/By.html#checked(boolean"><code>checked()</code></a>方法。</p>
<h3 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h3><p>一旦你的测试获得了一个<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>对象，你可以调用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>类中的方法在该对象所表示的UI组件上执行用户交互。您可以指定以下操作：</p>
<ul>
<li><a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#click("><code>click()</code></a>:单击UI元素的可见边界的中心。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#dragTo(int, int, int"><code>dragTo()</code></a>:将此对象拖放到任意坐标。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#setText(java.lang.String"><code>setText()</code></a>:在清除字段的内容后，在可编辑字段中设置文本。相反，<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#clearTextField("><code>clearTextField()</code></a>方法清除可编辑字段中的现有文本。</li>
<li><a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html#swipeUp(int"><code>swipeUp()</code></a>):对<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiObject.html"><code>UiObject</code></a>执行向上滑动操作。类似地，<code>swipeDown()</code>，<code>swipeLeft()</code>和<code>swipeRight()</code>方法执行相应的操作。</li>
</ul>
<p>UI Automator测试框架允许您通过<code>getContext()</code>获取<code>Context</code>对象来发送<code>Intent</code>或启动<code>Activity</code>，而不使用shell命令。</p>
<p>以下代码段显示了您的测试如何使用<code>Intent</code>启动正在测试的应用程序。当您只想测试计算器应用程序，而不关心启动器时，此方法很有用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setUp() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Launch a simple calculator app</span><br><span class="line">    Context context &#x3D; getInstrumentation().getContext();</span><br><span class="line">    Intent intent &#x3D; context.getPackageManager()</span><br><span class="line">            .getLaunchIntentForPackage(CALC_PACKAGE);</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">            &#x2F;&#x2F; Clear out any previous instances</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">    mDevice.wait(Until.hasObject(By.pkg(CALC_PACKAGE).depth(0)), TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对集合执行操作"><a href="#对集合执行操作" class="headerlink" title="对集合执行操作"></a>对集合执行操作</h4><p>如果您要模拟项目集合（例如，音乐专辑中的歌曲或收件箱中的电子邮件列表）中的用户互动，请使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiCollection.html"><code>UiCollection</code></a>类。要创建<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiCollection.html"><code>UiCollection</code></a>对象，请指定用于搜索UI容器或其他子UI用户界面元素（例如包含子UI用户界面元素的布局视图）的包装器的<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiSelector.html"><code>UiSelector</code></a>。</p>
<p>以下代码段显示了您的测试可能如何构造一个<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiCollection.html"><code>UiCollection</code></a>来表示在<code>FrameLayout</code>中显示的视频专辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UiCollection videos &#x3D; new UiCollection(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.FrameLayout&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Retrieve the number of videos in this collection:</span><br><span class="line">int count &#x3D; videos.getChildCount(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.LinearLayout&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Find a specific video and simulate a user-click on it</span><br><span class="line">UiObject video &#x3D; videos.getChildByText(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.LinearLayout&quot;), &quot;Cute Baby Laughing&quot;);</span><br><span class="line">video.click();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Simulate selecting a checkbox that is associated with the video</span><br><span class="line">UiObject checkBox &#x3D; video.getChild(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.Checkbox&quot;));</span><br><span class="line">if(!checkBox.isSelected()) checkbox.click();</span><br></pre></td></tr></table></figure>
<h4 id="对可滚动视图执行操作"><a href="#对可滚动视图执行操作" class="headerlink" title="对可滚动视图执行操作"></a>对可滚动视图执行操作</h4><p>使用<a href="https://developer.android.google.cn/reference/android/support/test/uiautomator/UiScrollable.html"><code>UiScrollable</code></a>类来模拟跨显示的垂直或水平滚动。当UI元素位于屏幕外并且您需要滚动以将其置于视图中时，此技术非常有用。</p>
<p>以下代码段显示了如何模拟向下滚动设置菜单并点击关于平板电脑选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UiScrollable settingsItem &#x3D; new UiScrollable(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.ListView&quot;));</span><br><span class="line">UiObject about &#x3D; settingsItem.getChildByText(new UiSelector()</span><br><span class="line">        .className(&quot;android.widget.LinearLayout&quot;), &quot;About tablet&quot;);</span><br><span class="line">about.click();</span><br></pre></td></tr></table></figure>
<h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><p><a href="https://developer.android.google.cn/reference/android/test/InstrumentationTestCase.html"><code>InstrumentationTestCase</code></a>扩展了<a href="https://developer.android.google.cn/reference/junit/framework/TestCase.html"><code>TestCase</code></a>，因此您可以使用标准的JUnit Assert方法来测试应用程序中的UI组件是否返回预期结果。</p>
<p>以下代码段显示您的测试如何在计算器应用程序中找到多个按钮，按顺序点击它们，然后验证是否显示正确的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String CALC_PACKAGE &#x3D; &quot;com.myexample.calc&quot;;</span><br><span class="line"></span><br><span class="line">public void testTwoPlusThreeEqualsFive() &#123;</span><br><span class="line">    &#x2F;&#x2F; Enter an equation: 2 + 3 &#x3D; ?</span><br><span class="line">    mDevice.findObject(new UiSelector()</span><br><span class="line">            .packageName(CALC_PACKAGE).resourceId(&quot;two&quot;)).click();</span><br><span class="line">    mDevice.findObject(new UiSelector()</span><br><span class="line">            .packageName(CALC_PACKAGE).resourceId(&quot;plus&quot;)).click();</span><br><span class="line">    mDevice.findObject(new UiSelector()</span><br><span class="line">            .packageName(CALC_PACKAGE).resourceId(&quot;three&quot;)).click();</span><br><span class="line">    mDevice.findObject(new UiSelector()</span><br><span class="line">            .packageName(CALC_PACKAGE).resourceId(&quot;equals&quot;)).click();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Verify the result &#x3D; 5</span><br><span class="line">    UiObject result &#x3D; mDevice.findObject(By.res(CALC_PACKAGE, &quot;result&quot;));</span><br><span class="line">    assertEquals(&quot;5&quot;, result.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在设备或模拟器上运行UI-Automator测试"><a href="#在设备或模拟器上运行UI-Automator测试" class="headerlink" title="在设备或模拟器上运行UI Automator测试"></a>在设备或模拟器上运行UI Automator测试</h2><p>您可以从Android Studio或从命令行运行UI Automator测试。确保指定<a href="https://developer.android.google.cn/reference/android/support/test/runner/AndroidJUnitRunner.html">AndroidJUnitRunner</a>作为项目中的默认instrumentation runner。</p>
<p>要运行UI Automator测试，请按照<a href="/2017/01/11/【Android文档翻译】入门测试/">测试入门</a>中所述的运行测试测试的步骤操作。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】测试性能展示</title>
    <url>/2017/01/14/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%B5%8B%E8%AF%95%E6%80%A7%E8%83%BD%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/training/testing/performance.html">https://developer.android.google.cn/training/testing/performance.html</a></p>
<p>用户界面（UI）性能测试确保您的应用程序不仅满足其功能要求，而且能确保用户与您的应用程序的交互平滑，运行在每秒一致的60帧（<a href="https://www.youtube.com/watch?v=CaMTIgxCSqU&amp;index=25&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">为什么要60fps？</a>），没有任何丢弃或延迟的帧，或者我们喜欢称之为jank。本文档介绍了可用于衡量UI性能的工具，并介绍了将UI性能测量结果集成到测试实践中的方法。</p>
<h2 id="测量UI性能"><a href="#测量UI性能" class="headerlink" title="测量UI性能"></a>测量UI性能</h2><p>为了提高性能，您首先需要能够测量系统的性能，然后诊断和识别可能从您的管道的各个部分到达的问题。</p>
<p><a href="https://source.android.com/devices/tech/debug/dumpsys.html">dumpsys</a>是一个Android工具，可在设备上运行，并转储有关系统服务状态的有趣信息。将<em>gfxinfo</em>命令传递给dumpsys在logcat中提供了一个输出，其中包含与在记录阶段发生的动画帧有关的性能信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt;</span><br></pre></td></tr></table></figure>
<p>该命令可以产生帧定时数据的多个不同变体。</p>
<h2 id="聚合框架统计"><a href="#聚合框架统计" class="headerlink" title="聚合框架统计"></a>聚合框架统计</h2><p>使用Android 6.0（API级别23），此命令会将框架数据的聚合分析打印到logcat，并在进程的整个生命周期中收集。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stats since: 752958278148ns</span><br><span class="line">Total frames rendered: 82189</span><br><span class="line">Janky frames: 35335 (42.99%)</span><br><span class="line">90th percentile: 34ms</span><br><span class="line">95th percentile: 42ms</span><br><span class="line">99th percentile: 69ms</span><br><span class="line">Number Missed Vsync: 4706</span><br><span class="line">Number High input latency: 142</span><br><span class="line">Number Slow UI thread: 17270</span><br><span class="line">Number Slow bitmap uploads: 1542</span><br><span class="line">Number Slow draw: 23342</span><br></pre></td></tr></table></figure>
<p>这些高级统计信息在高级别上传达了应用程序的呈现性能，以及其在许多帧中的稳定性。</p>
<h2 id="精确帧定时信息"><a href="#精确帧定时信息" class="headerlink" title="精确帧定时信息"></a>精确帧定时信息</h2><p>使用Android 6.0为gfxinfo新命令，这是<em>framestats</em>从最近的帧中提供的非常详细的帧定时信息，以便您可以跟踪和更准确地调试问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; framestats</span><br></pre></td></tr></table></figure>
<p>此命令打印从应用程序产生的最后120帧的帧时序信息，纳秒级时间戳。下面是来自<code>adb dumpsysg fxinfo &lt;PACKAGE_NAME&gt; framestats</code>的原始输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,27965466202353,27965466202353,27965449758000,27965461202353,27965467153286,27965471442505,27965471925682,27965474025318,27965474588547,27965474860786,27965475078599,27965479796151,27965480589068,</span><br><span class="line">0,27965482993342,27965482993342,27965465835000,27965477993342,27965483807401,27965486875630,27965487288443,27965489520682,27965490184380,27965490568703,27965491408078,27965496119641,27965496619641,</span><br><span class="line">0,27965499784331,27965499784331,27965481404000,27965494784331,27965500785318,27965503736099,27965504201151,27965506776568,27965507298443,27965507515005,27965508405474,27965513495318,27965514061984,</span><br><span class="line">0,27965516575320,27965516575320,27965497155000,27965511575320,27965517697349,27965521276151,27965521734797,27965524350474,27965524884536,27965525160578,27965526020891,27965531371203,27965532114484,</span><br></pre></td></tr></table></figure>
<p>此输出的每一行代表由应用程序生成的一帧。每行具有固定数量的列，描述在帧生产管道的每个阶段中花费的时间。下一节详细描述此格式，包括每列代表的内容。</p>
<h3 id="Framestats数据格式"><a href="#Framestats数据格式" class="headerlink" title="Framestats数据格式"></a>Framestats数据格式</h3><p>由于数据块以CSV格式输出，因此可以将其粘贴到您选择的电子表格工具中，或者使用脚本进行收集和解析。下表介绍了输出数据列的格式。所有时间戳都以纳秒为单位。</p>
<ul>
<li><p>FLAGS</p>
<ul>
<li>FLAGS列的值为0的行可以通过从FRAME_COMPLETED列减去INTENDED_VSYNC列来计算其总帧时间。</li>
<li><p>如果这不为零，则应该忽略行，因为帧已被确定为正常性能的异常值，其中期望布局和绘制花费的时间长于16ms。以下是可能发生的几个原因：</p>
<ul>
<li>窗口布局已更改（如应用程序的第一帧或旋转后的一帧）</li>
<li>也可能是跳帧，在这种情况下，一些值将具有垃圾时间戳。一个帧可以跳过，如果例如它运行超出60fps或者如果以脏模式结束时屏幕上没有任何东西，这不一定是应用程序中的问题的迹象。</li>
</ul>
</li>
</ul>
</li>
<li><p>INTENDED_VSYNC</p>
<ul>
<li>帧的预期起始点。如果此值与VSYNC不同，则UI线程上会发生工作，导致其无法及时响应vsync信号。</li>
</ul>
</li>
<li><p>VSYNC</p>
<ul>
<li>在所有vsync侦听器和帧绘图中使用的时间值（Choreographer帧回调，动画，View.getDrawingTime()等）</li>
<li>要了解更多关于VSYNC及其如何影响您的应用程序，请查看<a href="https://www.youtube.com/watch?v=1iaHxmfZGGc&amp;list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&amp;index=23">了解VSYNC</a>视频。</li>
</ul>
</li>
<li><p>OLDEST_INPUT_EVENT</p>
<ul>
<li>输入队列中最旧的输入事件的时间戳，如果没有帧的输入事件，则为Long.MAX_VALUE。</li>
<li>此值主要用于平台工作，并且对应用开发人员的用处有限。</li>
</ul>
</li>
<li>NEWEST_INPUT_EVENT<ul>
<li>输入队列中最新输入事件的时间戳，如果帧没有输入事件，则为0。</li>
<li>此值主要用于平台工作，并且对应用开发人员的用处有限。</li>
<li>但是，通过查看（FRAME_COMPLETED - NEWEST_INPUT_EVENT），可以大致了解应用增加了多少延迟。 </li>
</ul>
</li>
<li>HANDLE_INPUT_START<ul>
<li>将输入事件分派到应用程序的时间戳。</li>
<li>通过查看此时间和ANIMATION_START之间的时间，可以衡量应用程序花费在处理输入事件上的时间。</li>
<li>如果这个数字很高（&gt; 2ms），这表明应用程序花费了异常长的时间处理输入事件，如<code>View.onTouchEvent()</code>，这可能表明这项工作需要优化，或卸载到不同的线程。请注意，有一些情况，例如启动新Activity或类似Activity的点击事件，预期和可接受的数字很大。</li>
</ul>
</li>
<li>ANIMATION_START<ul>
<li>运行以Choreographer注册的动画的时间戳。</li>
<li>通过查看与PERFORM_TRANVERSALS_START之间的时间，可以确定评估所有正在运行的animators（ObjectAnimator，ViewPropertyAnimator和Transitions是常见的animators）需要多长时间。</li>
<li>如果这个数字很高（&gt; 2ms），检查你的应用程序是否已经写了任何自定义animators或ObjectAnimators的哪些字段正在做动画，并确保它们适合于动画。</li>
<li>要了解更多关于Choreographer的信息，请查看<a href="https://www.youtube.com/watch?v=Q8m9sHdyXnE">For Butter or Worse</a>视频。</li>
</ul>
</li>
<li>PERFORM_TRAVERSALS_START<ul>
<li>如果从此值中减去DRAW_START，您可以提取布局和度量阶段完成所需的时间。（注意，在滚动或动画期间，你希望这应该接近零..）</li>
<li>要了解有关渲染管道的度量和布局阶段的详细信息，请查看<a href="https://www.youtube.com/watch?v=we6poP0kw6E&amp;list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&amp;index=27">Invalidations, Layouts and Performance</a>视频。</li>
</ul>
</li>
<li>DRAW_START<ul>
<li>performTraversals的绘制阶段开始的时间。这是记录已失效的任何视图的显示列表的起始点。</li>
<li>介于这一点到SYNC_START之间的时间是在树中所有invalidated视图上调用<code>View.draw()</code>所需的时间。</li>
<li>有关绘图模型的详细信息，请参阅<a href="https://developer.android.google.cn/guide/topics/graphics/hardware-accel.html#hardware-model">Hardware Acceleration</a>，<a href="https://www.youtube.com/watch?v=we6poP0kw6E&amp;list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu&amp;index=27">Invalidations, Layouts and Performance</a>视频。</li>
</ul>
</li>
<li>SYNC_QUEUED<ul>
<li>同步请求发送到RenderThread的时间。</li>
<li>这标志着开始同步阶段的消息被发送到RenderThread的点。如果这一点到SYNC_START之间的时间差是比较大的（&gt; 0.1ms左右），这意味着RenderThread正忙于一个不同的帧。在内部，这用于区分帧做太多的工作，和超过16ms预算，并且由于前一帧超过16ms预算而被停止。</li>
</ul>
</li>
<li>SYNC_START<ul>
<li>绘图的同步阶段开始的时间。</li>
<li>如果这和ISSUE_DRAW_COMMANDS_START之间的时间是比较大的（&gt; 0.4ms左右），它通常表示绘制了很多新的Bitmaps，必须上传到GPU。</li>
<li>要了解有关同步阶段的更多信息，请查看<a href="https://www.youtube.com/watch?v=VzYkVL1n4M8&amp;index=24&amp;list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Profile GPU Rendering</a>视频</li>
</ul>
</li>
<li>ISSUE_DRAW_COMMANDS_START<ul>
<li>硬件渲染器开始向GPU发出绘图命令的时间。</li>
<li>这一点到FRAME_COMPLETED之间的时间给出了应用程序生成多少GPU的工作。这里显示过多的过度绘制或低效的渲染效果等问题。</li>
</ul>
</li>
<li>SWAP_BUFFERS<ul>
<li>调用eglSwapBuffers的时间，在平台工作之外相对不感兴趣。</li>
</ul>
</li>
<li>FRAME_COMPLETED<ul>
<li>全做完了！在此帧上工作的总时间可以通过执行FRAME_COMPLETED - INTENDED_VSYNC来计算。</li>
</ul>
</li>
</ul>
<p>您可以以不同的方式使用此数据。一个简单但有用的可视化是显示不同延迟桶中的帧时间（FRAME_COMPLETED - INTENDED_VSYNC）的分布的直方图，如下图所示。这个图表一目了然地显示，大多数帧都非常好 - 远低于16ms的截止时间（以红色描绘），但是有几帧显示超过了截止时间。我们可以看看这个直方图随时间的变化，以查看正在创建的批发班次(wholesale shifts)或新离群值(new outliers)。您还可以根据数据中的许多时间戳，绘制输入延迟，布局花费的时间或其他类似的有趣指标。</p>
<p><img src="/img/17_01_14/001.png" alt=""></p>
<h3 id="简单帧定时转储"><a href="#简单帧定时转储" class="headerlink" title="简单帧定时转储"></a>简单帧定时转储</h3><p>如果在开发人员选项中将<strong>Profile GPU rendering</strong>设置为<strong>In adb shell dumpsys gfxinfo</strong>，adb shell dumpsys gfxinfo命令打印最近120帧的定时信息，分成具有制表符分隔值的几个不同类别。该数据可用于指示绘图管线的哪些部分可能在高水平下执行较慢。</p>
<p>与上面的<a href="#Framestats数据格式">framestats</a>类似，将它粘贴到您选择的电子表格工具，或者使用脚本收集和解析是非常简单的。下图显示了应用程序生成的许多帧花费时间的细目。</p>
<p><img src="/img/17_01_14/002.png" alt=""></p>
<p>运行gfxinfo的结果，复制输出，将其粘贴到电子表格应用程序中，并将数据绘制为堆叠条形图。</p>
<p>每个垂直条表示一帧动画;它的高度表示计算该帧动画花费的毫秒数。条形的每个彩色段代表渲染管道的不同阶段，以便您可以看到应用程序的哪些部分可能会创建瓶颈。有关了解渲染管道以及如何优化渲染管道的更多信息，请参阅<a href="https://www.youtube.com/watch?v=we6poP0kw6E&amp;index=27&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">无效布局和性能</a>视频。</p>
<h3 id="控制stat收集窗口"><a href="#控制stat收集窗口" class="headerlink" title="控制stat收集窗口"></a>控制stat收集窗口</h3><p>framestats和简单的帧定时都在非常短的窗口上收集数据 - 大约两秒钟的渲染。为了精确地控制此时间窗口 - 例如，将数据约束到特定动画 - 您可以重置所有计数器，并聚合收集的统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; reset</span><br></pre></td></tr></table></figure>
<p>这也可以与转储命令本身结合使用，以常规节奏收集和重置，连续捕获帧的少于两秒的窗口。</p>
<h3 id="诊断性能回归"><a href="#诊断性能回归" class="headerlink" title="诊断性能回归"></a>诊断性能回归</h3><p>识别回归是跟踪问题和维持应用程序高健康状况的良好第一步。然而，dumpsys只是识别问题的存在和相对严重性。您仍然需要诊断性能问题的特定原因，并找到适当的方法来解决它们。为此，强烈建议使用<a href="https://developer.android.google.cn/tools/help/systrace.html">systrace</a>工具。</p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p>有关Android的渲染管道工作原理的更多信息，您可以找到的常见问题以及如何解决这些问题，以下一些资源可能对您有所帮助：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=HXQhu6qfTVU">Rendering Performance 101</a></li>
<li><a href="https://www.youtube.com/watch?v=CaMTIgxCSqU">Why 60fps?</a></li>
<li><a href="https://www.youtube.com/watch?v=WH9AFhgwmDw">Android, UI, and the GPU</a></li>
<li><a href="https://www.youtube.com/watch?v=we6poP0kw6E">Invalidations, Layouts, and Performance</a></li>
<li><a href="https://developer.android.google.cn/studio/profile/systrace.html">Analyzing UI Performance with Systrace</a></li>
</ul>
<h2 id="自动化UI性能测试"><a href="#自动化UI性能测试" class="headerlink" title="自动化UI性能测试"></a>自动化UI性能测试</h2><p>UI性能测试的一种方法是简单地让一个人类测试者在目标应用程序上执行一组用户操作，或者直观地查找jank，或者使用工具驱动的方法花费大量的时间来查找它。但是这种手动方法充满了危险 - 人类感知帧速率变化的能力变化巨大，这也是耗时，乏味和容易出错的。</p>
<p>一种更有效的方法是记录和分析来自自动UI测试的关键性能指标。Android 6.0包含新的日志记录功能，使您可以轻松确定应用程序动画中jank的数量和严重程度，并可用于构建严格的流程以确定您当前的表现并跟踪未来的表现目标。</p>
<p>要了解有关Android性能测试的更多信息，请参阅<a href="/2017/01/15/【Codelab】自动性能测试/">自动性能测试Codelab</a>。在本代码中，您将学习如何编写和执行自动化测试，并查看结果以了解如何提高应用的效果。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Android文档翻译】自动化UI测试</title>
    <url>/2017/01/11/%E3%80%90Android%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E8%87%AA%E5%8A%A8%E5%8C%96UI%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>用户界面（UI）测试可以确保您的应用程序满足其功能要求，并达到高标准的质量，使其更有可能被用户成功采纳。</p>
<p>UI测试的一种方法是简单地让人类测试者对目标应用程序执行一组用户操作，并验证它的行为是否正确。然而，该手动方法可能是耗时，冗长且易出错的。一个更有效的方法是编写用户界面测试，使得用户操作以自动化的方式执行。自动化方法允许您以可重复的方式快速可靠地运行测试。</p>
<blockquote>
<p><strong>注意：</strong>强烈建议您使用Android Studio构建测试应用程序，因为它提供了项目设置，库包含和便捷的打包功能。这里假设你使用的是Android Studio。</p>
</blockquote>
<p>要使用Android Studio自动执行UI测试，请在单独的Android测试文件夹(<code>src/androidTest/java</code>)中实现测试代码。<a href="https://developer.android.google.cn/tools/building/plugin-for-gradle.html">Android Plug-in for Gradle</a>基于您的测试代码构建测试应用程序，然后将测试应用程序加载到与目标应用程序相同的设备上。在测试代​​码中，您可以使用UI测试框架来模拟目标应用程序上的用户交互，以便执行涵盖特定使用情况的测试任务。</p>
<p>对于测试Android应用，您通常会创建以下类型的自动UI测试：</p>
<ul>
<li><p><em>跨越单个应用程序的UI测试:</em>当用户执行特定操作或在Activity中输入特定输入时，此类型的测试验证目标应用程序的行为是否与预期相符。它允许您检查目标应用程序返回正确的UI输出，以响应用户在应用程序Activity中的互动。诸如Espresso的UI测试框架允许您以编程方式模拟用户操作并测试复杂的应用内用户交互。</p>
</li>
<li><p><em>跨越多个应用程序的UI测试:</em>此类型的测试验证不同用户应用程序之间或用户应用程序和系统应用程序之间的交互的正确行为。例如，您可能想测试您的相机应用是否与第三方社交媒体应用或默认的Android Photos应用正确分享了图片。支持跨应用程序交互的UI测试框架（如UI Automator）允许您为这些场景创建测试。</p>
</li>
</ul>
<p>本课的课程将教你如何使用Android测试支持库中的工具和API来构建这些类型的自动化测试。在使用这些API开始构建测试之前，您必须安装<a href="https://developer.android.google.cn/tools/testing-support-library/index.html">Android Testing Support Library</a>，如在<a href="https://developer.android.google.cn/tools/testing-support-library/index.html#setup">下载Android Testing Support Library</a>中所描述的那样。</p>
<h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a href="/2017/01/13/【Android文档翻译】测试单个应用程序的UI/">测试单个应用程序的UI</a><br>    了解如何使用Espresso测试框架在单个应用中测试UI。</p>
<p><a href="/2017/01/13/【Android文档翻译】测试多个应用程序的UI/">测试多个应用程序的UI</a><br>    了解如何使用UI Automator测试框架在多个应用中测试UI。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Codelab】自动性能测试</title>
    <url>/2017/01/15/%E3%80%90Codelab%E3%80%91%E8%87%AA%E5%8A%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p><a href="https://codelabs.developers.google.com/codelabs/android-perf-testing/index.html?index=..%2F..%2Findex#0">https://codelabs.developers.google.com/codelabs/android-perf-testing/index.html?index=..%2F..%2Findex#0</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在这个codelab中，您将创建一个稳定和可重用的测试工具，在非常简单的现有应用程序上运行性能测试。线束将自动收集信息，如系统日志，位置请求，电池电压，图形配置等。测试失败也将记录到文件中，我们将向您展示如何编写基于性能的测试的示例。哇，这很多，对吧？Good luck!! :)</p>
<h3 id="你会学到什么"><a href="#你会学到什么" class="headerlink" title="你会学到什么"></a>你会学到什么</h3><ul>
<li>如何快速导航某些Android性能工具</li>
<li>如何使用Espresso测试框架编写单元和性能测试</li>
<li>如何使用MonkeyRunner和Gradle来自动化测试工作流</li>
<li>如何查看systrace输出以了解应用程序的性能问题</li>
</ul>
<p>由于此Codelab中的移动部件和组件的数量相当大，因此您可以通过取消注释现有代码来启用每个部件。这将使得您熟悉线束，同时还使得您对自己的项目执行类似的步骤。我们将最终得到一个测试工具，逻辑上看起来像这样。</p>
<p><img src="/img/17_01_14/003.png" alt=""></p>
<p>让我们开始吧！</p>
<h2 id="2-设置"><a href="#2-设置" class="headerlink" title="2.设置"></a>2.设置</h2><p>首先，您需要设置您的开发环境。</p>
<h3 id="你需要什么"><a href="#你需要什么" class="headerlink" title="你需要什么"></a>你需要什么</h3><p>安装以下软件包的计算机：</p>
<ul>
<li>最新版本的Android Studio</li>
<li>最新版本的Android SDK</li>
<li>JAVA JDK(1.7)</li>
<li>Python 2.7(不是 Python 3.x)</li>
</ul>
<p>还应满足以下环境条件：</p>
<ul>
<li>Python应该可以通过PATH环境变量使用。输入命令<code>python --version</code>应该输出类似于<code>Python 2.7.10</code>。</li>
<li>JAVA JDK应包含在PATH环境变量中，并可通过<code>JAVA_HOME</code>环境变量访问。输入命令<code>javac -version</code>应该输出类似于<code>javac 1.7.0_79</code>的内容。</li>
<li>Android SDK路径应设置为<code>ANDROID_HOME</code>环境变量。输入命令<code>echo $JAVA_HOME</code>或<code>echo％ANDROID_HOME％</code>应输出正在运行的Android SDK的目录。</li>
</ul>
<p>最后，您应该有一个Android设备通过USB电缆连接到您的计算机，可用于运行测试。</p>
<ul>
<li>Android Marshmallow或更高的版本是首选，因为它将最大化线束的功能。</li>
<li>需要启用Android“开发者模式”（通过点击“关于手机”下的Build Number七次）并且通过Android设置应用程序的“USB调试”。</li>
<li>对于典型的应用程序开发，Android模拟器将是足够的，因为这个codelab是关于性能测试，最好是使用物理设备。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>线束将适用于较旧版本的Android，但某些数据将无法收集。</p>
</blockquote>
<p>在下一步中，我们将下载并构建测试应用程序。</p>
<h2 id="3-运行并理解测试应用程序"><a href="#3-运行并理解测试应用程序" class="headerlink" title="3.运行并理解测试应用程序"></a>3.运行并理解测试应用程序</h2><p>在此步骤中，我们在您的Android设备上构建并运行提供的测试应用程序。</p>
<h3 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h3><p>运行以下命令从GitHub下载示例代码。或者从<a href="https://github.com/googlecodelabs/android-perf-testing/archive/master.zip">这里</a>直接作为zip文件下载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;googlecodelabs&#x2F;android-perf-testing.git</span><br></pre></td></tr></table></figure>
<p>当这样做之后，你的计算机上会有一个<code>android-perf-testing</code>文件夹。</p>
<p>打开Android Studio。在快速启动屏幕上，点击“打开现有的Android Studio项目”（或选择<strong>File &gt; Open</strong>）。</p>
<p><img src="/img/17_01_14/004.png" alt=""></p>
<p>在导入选择器窗口中打开在上一步中克隆的<code>android-perf-testing</code>文件夹。选择<code>settings.gradle</code>文件，然后单击<strong>Choose</strong>。</p>
<p>通过单击Android Studio窗口左上角的项目文本按钮打开项目导航器。在项目导航器顶部，您可以选择不同的视图透视图，通常，导入后默认为Android透视图。将此更改为<strong>Project</strong>，以确保您可以看到我们将使用的所有文件。这个过程见下面的屏幕截图。</p>
<p><img src="/img/17_01_14/005.png" alt=""></p>
<p>等待完成导入过程，通过查看Android Studio屏幕的最底部，以便在状态栏中显示“Gradle build finished”消息。</p>
<p><img src="/img/17_01_14/006.png" alt=""></p>
<p>您可能会看到构建错误，但我们会尽快解决。 Gradle构建完成后，点击Android Studio菜单顶部的绿色<strong>Run</strong>图标即可安装并运行应用程序。</p>
<p><img src="/img/17_01_14/007.png" alt=""></p>
<p>如果您还没有，请插入Android设备并解锁设备的屏幕。从出现的窗口中，从可用于运行应用程序的设备列表中选择设备。</p>
<p><img src="/img/17_01_14/008.png" alt=""></p>
<p>应用在您的设备上运行后，应该看起来像这样。应用程序可能需要一两分钟才能部署和第一次打开。</p>
<p><img src="/img/17_01_14/009.png" alt=""></p>
<p>你会注意到测试应用程序的功能非常有限。使用应用程序熟悉它：</p>
<ul>
<li>如上所述，您可以使用“Update Text”更新<code>TextView</code>。</li>
<li>触摸“Open List View”显示一个大的<code>ListView</code>。 <code>ListView</code>后面的实现有各种性能问题。</li>
<li>触摸“Open Recycler View”，显示一个大型<code>RecyclerView</code>，消除了以前的一些性能问题。</li>
</ul>
<p>现在我们有示例应用程序的源代码导入和应用程序构建和运行。在我们自动执行某些测试之前，让我们快速了解应用的效果以及我们通常用于诊断性能问题的工具，然后我们将更好地准备自动执行这些步骤。</p>
<blockquote>
<p><strong>重要提示，在下一步之前，确定你：</strong></p>
<pre><code>- 使用Android Studio窗口顶部的“**Run**”图标部署示例应用程序。
</code></pre></blockquote>
<h2 id="4-练习包含的应用程序的性能问题"><a href="#4-练习包含的应用程序的性能问题" class="headerlink" title="4.练习包含的应用程序的性能问题"></a>4.练习包含的应用程序的性能问题</h2><p>我们将手动检查应用程序中的性能问题。如果我们不了解我们正在寻找什么，我们不能自动进行性能测试，所以让我们手动寻找一些jank。</p>
<p>再次启动应用程式，然后轻触<strong>Open List View</strong>按钮。您将看到一个如下所示的屏幕：</p>
<p><img src="/img/17_01_14/010.png" alt=""></p>
<p>滚动到列表的底部;该应用程序随着你的滚动的距离变得更加jankier。这是因为应用程序无法为每16毫秒（大多数与UI相关的性能问题的主要原因）提供渲染子系统一帧;因此，Android正在跳过这一帧并导致视觉上的jank。当您向下滚动页面时，应用程序会跳过更多帧。如果你足够持久，你甚至会注意到它可能崩溃，直到到达列表的底部。</p>
<blockquote>
<p><strong>注意：</strong>如果您使用更高端的设备测试，您可能看不到jank，尽管代码是次优的。请考虑使用中低端设备。</p>
</blockquote>
<p>幸运的是，我们不必依靠仔细的视力来观看我们设备上的jank。在大多数Android设备的<strong>开发人员选项</strong>中有一个GPU渲染配置文件选项（靠近列表底部）。启用此选项，将屏幕上显示为条选项，然后打开应用程序，并再次使用<strong>Open List View</strong>选项。你的屏幕看起来会是类似这样：</p>
<p><img src="/img/17_01_14/011.png" alt=""></p>
<p>在Android设备上靠近屏幕中下部的绿色线，表示您的应用程序应该尝试从不交叉的重要的16毫秒屏障，同时向渲染子系统提供帧。帧作为时间序列水平地画在屏幕上，每个垂直条表示一个帧。条的高度指示框架花费多长时间绘制，并且当线的任何彩色部分超过绿色条时，其指示框架错过16毫秒超时并引起jank。条形的颜色表示在帧渲染的每个主要阶段中花费的时间量。栏的橙色部分表示应用程序进程代码;这个程序是浪费大量的时间。</p>
<blockquote>
<p><strong>注意：</strong>有关GPU渲染配置文件的更多详细信息，请参阅<a href="http://developer.android.com/tools/performance/profile-gpu-rendering/index.html">文档</a>。</p>
</blockquote>
<p>当你看到像<code>ListView</code>这样的jank，你通常转向一个名为<strong>Systrace</strong>的工具，以深入了解发生了什么。</p>
<blockquote>
<p><strong>重要，在进一步之前，请务必确认：</strong></p>
<ul>
<li>使用与启用GPU渲染配置文件相同的过程停用GPU渲染配置文件。</li>
</ul>
</blockquote>
<h2 id="5-使用Systrace"><a href="#5-使用Systrace" class="headerlink" title="5.使用Systrace"></a>5.使用Systrace</h2><p>我们不会深入到Systrace，但我们将调试该应用程序与systrace快速诊断jank问题。此步骤还将确保Systrace在您的系统上正确配置，但如果您精通Systrace，则可以跳过此步骤。</p>
<h3 id="什么是Systrace？"><a href="#什么是Systrace？" class="headerlink" title="什么是Systrace？"></a>什么是Systrace？</h3><p>见<a href="http://developer.android.com/tools/help/systrace.html">Android文档</a>:</p>
<p><em>Systrace是一个工具，它将帮助您通过捕获和显示应用程序进程和其他Android系统进程的执行时间来分析应用程序的性能。</em></p>
<h3 id="我们用它做什么？"><a href="#我们用它做什么？" class="headerlink" title="我们用它做什么？"></a>我们用它做什么？</h3><p>我们正在使用Systrace在我们的应用程序中查找性能问题。当我们使用我们的应用程序运行Systrace时，它会从Android中收集数据，然后将其格式化为一个html文件，我们可以在网络浏览器中查看。当我们打开Systrace结果时，我们希望它能够帮助我们解决与我们的应用程序相关的一些基本问题。到目前为止，我们所知道的是，我们的应用程序是janky;如果工具帮助我们找出原因，这将是很好的。</p>
<h3 id="如何运行Systrace"><a href="#如何运行Systrace" class="headerlink" title="如何运行Systrace"></a>如何运行Systrace</h3><p>点击Android Studio窗口左下角的“<strong>Terminal</strong>”文本按钮。</p>
<p><img src="/img/17_01_14/012.png" alt=""></p>
<p>运行以下命令：</p>
<p>Mac / Linux:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python $ANDROID_HOME&#x2F;platform-tools&#x2F;systrace&#x2F;systrace.py --time&#x3D;10 -o ~&#x2F;trace.html gfx view res</span><br></pre></td></tr></table></figure>
<p>Windows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python %ANDROID_HOME%&#x2F;platform-tools&#x2F;systrace&#x2F;systrace.py --time&#x3D;10 -o %userprofile%&#x2F;trace.html gfx view res</span><br></pre></td></tr></table></figure>
<p>这将运行Systrace 10秒，给你足够的时间来重现你在之前的步骤中看到的janky行为。运行以上命令，当systrace正在运行时，打开应用程序并再次滚动简单列表视图。Systrace将在您使用应用程序时收集数据。它将结果输出到文件：<code>trace.html</code>。</p>
<p>打开浏览器并查看<code>trace.html</code>文件。您应该看到类似以下的显示：</p>
<p><img src="/img/17_01_14/013.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：如果您在浏览器中打开该工具时遇到问题，可以按照屏幕截图。 codelab的点是自动化一些你可以在systrace中找到的东西。</p>
</blockquote>
<p>这是一个可视化的性能数据是由您的应用程序和系统在10秒的时间段内提供的线性时间表。</p>
<p>同样，这不是一个Systrace教程，但请注意此窗口右上角的浮动导航栏，将光标置于与跟踪交互的不同模式。在以下屏幕截图中，从上到下，图片图标允许指针以以下方式影响屏幕：</p>
<ul>
<li>选择项目以查看更多详细信息</li>
<li>在时间轴内滚动（在使用缩放之前不需要）</li>
<li>在时间轴上放大或缩小</li>
<li>突出显示某些时间段</li>
</ul>
<p><img src="/img/17_01_14/014.png" alt=""></p>
<p>Systrace工具用于缩放和平移。</p>
<p>您也可以使用键盘上的W，A，S，D键缩放和平移，如果这更容易。</p>
<p>首先将您的注意力集中在警报的最上面的水平部分。</p>
<p><img src="/img/17_01_14/015.png" alt=""></p>
<p>此处的警报行突出显示在跟踪期间可能出现的问题;如果您单击一个，详细信息面板将在浏览器底部打开，您可以阅读警报详细信息。例如：</p>
<p><img src="/img/17_01_14/016.png" alt=""></p>
<p>你会注意到，应用程序的<code>ListView</code>实现有多个问题。警报提供有关性能改进的详细信息，以及可帮助解决问题的文档链接。</p>
<p>下一个水平部分，通常有一个包含您的包名称的头。如果没有，请使用其他软件包名称右侧的箭头折叠各个部分，直到您的软件包名称可见。</p>
<p>如果这是您第一次使用该工具，您将需要专注于Frames行（见下面的预览）。</p>
<p><img src="/img/17_01_14/017.png" alt=""></p>
<p>您可以在浏览器窗口底部再次找到非绿色警报的说明。特别是，查找警报，指示您的应用程序缺少可怕的16ms时间窗口以产生一帧。警报还标记其他问题，如不回收视图或不正确的时间布局充气。点击此行中的一些红色提醒，直到您也找到一个<strong>Inflation during ListView recycling</strong>的描述。应该有很多。</p>
<p>想想为什么它可能告诉你。你将如何解决它？</p>
<p>每当你有性能问题，Systrace是你应该开始寻找问题的主要地方之一。在这里我们验证帧被丢弃，我们发现我们的应用程序的问题。但是我们真的不应该通过手动协调我们的测试运行与Systrace来找到这个问题。在下一步中，我们将自动执行我们执行的测试，然后我们将跟踪自动化Systrace。</p>
<h2 id="Espresso自动化UI测试"><a href="#Espresso自动化UI测试" class="headerlink" title="Espresso自动化UI测试"></a>Espresso自动化UI测试</h2><p>现在，让我们开始自动化我们之前执行的手动测试：打开<code>ListView</code>并滚动整个列表。</p>
<p>作为一个快速的Android测试引擎：通常有两种类型的测试为Android应用程序编写。单元测试通常执行离散的代码位。Android仪表化测试练习应用程序组件，以及通常模拟Android用户输入和/或模拟零件，没有专门测试。<a href="http://developer.android.com/tools/testing-support-library/index.html#Espresso">Espressolibrary</a>用于协助Android仪表化测试。</p>
<h3 id="Espresso-Test-Library"><a href="#Espresso-Test-Library" class="headerlink" title="Espresso Test Library"></a>Espresso Test Library</h3><p>Espresso是一个测试库，提供用于编写​​UI测试的API，以模拟单个应用程序中的用户交互。大多数用户交互可以在使用Espresso和<a href="http://developer.android.com/tools/testing-support-library/index.html">Android测试支持库</a>的其他部分的测试中快速简洁地编写脚本。</p>
<blockquote>
<p>注意：有时Android测试需要特定的架构设计，以允许模拟Android框架的部分。这是一个复杂的主题，在这个特定的代码库的范围之外。</p>
</blockquote>
<h3 id="Espresso-Library依赖"><a href="#Espresso-Library依赖" class="headerlink" title="Espresso Library依赖"></a>Espresso Library依赖</h3><p>使用Espresso的第一步是向项目添加库依赖项。通过在依赖关系部分中的<code>app/build.gradle</code>文件中取消注释以下行来添加库。这个片段包括一对其他经常被用到的与Espresso关联的库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">androidTestCompile &quot;com.android.support:support-annotations:$&#123;supportLibVersion&#125;&quot;</span><br><span class="line">androidTestCompile &#39;com.android.support.test:runner:0.5&#39;</span><br><span class="line">androidTestCompile &#39;com.android.support.test:rules:0.5&#39;</span><br><span class="line">androidTestCompile &#39;com.android.support.test.espresso:espresso-core:2.2.1&#39;</span><br></pre></td></tr></table></figure>
<p>每次编辑Gradle脚本时，Android Studio都会询问您是否要在文件查看器顶部的黄色栏中与Gradle进行同步。单击<strong>Sync Now</strong>，然后等待项目的构建和重新配置。</p>
<h3 id="编写Espresso测试"><a href="#编写Espresso测试" class="headerlink" title="编写Espresso测试"></a>编写Espresso测试</h3><p>现在我们将编写一个测试来滚动应用程序<code>ListView</code>，就像我们之前手动操作一样。</p>
<p>在<code>app/src/androidTest/java/</code>中导航到<code>androidTest</code>源目录。一些测试类已在<code>com.google.android.perftesting</code>包中定义。打开<code>SimpleListActivityTest</code>类。这个类保存你将为<code>SimpleListActivity</code>类逻辑编写的测试。</p>
<p><img src="/img/17_01_14/018.png" alt=""></p>
<p>取消注释在文件中定义的<code>ActivityTestRule</code>（见下文）。此JUnit规则确保在运行类中定义的任何测试之前创建指定的activity。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public ActivityTestRule&lt;SimpleListActivity&gt; mActivityRule &#x3D; new ActivityTestRule&lt;&gt;(SimpleListActivity.class);</span><br></pre></td></tr></table></figure>
<p>接下来，取消注释测试方法<code>scrollFullList</code>并检查测试方法代码。测试获取被测Activity中的<code>ListView</code>，并滚动整个列表。测试等待滚动完成。查看代码后，您需要通过右键单击文件中的每个错误来解决缺少的导入错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">@PerfTest</span><br><span class="line">public void scrollFullList() throws InterruptedException &#123;</span><br><span class="line">ListView listView &#x3D; (ListView) mActivityRule.getActivity().findViewById(android.R.id.list);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后，取消注释<code>SimpleListActivityTest</code>类声明顶部的<code>@PerfTest</code>。这对于确保测试类稍后被仪器拾取很重要。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PerfTest</span><br><span class="line">public class SimpleListActivityTest &#123;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> <code>@PerfTest</code>注解用于隔离应包括在性能测试中的测试和类。</p>
</blockquote>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>要运行所有应用程序的配置，您应当运行<code>connectedCheck</code> Gradle任务。在Android Studio中有几种方法可以运行此任务。记住确保您的测试设备的屏幕在设备上运行测试之前已解锁。</p>
<ul>
<li>在屏幕的最右侧有一个Gradle文本按钮，可用于打开Gradle任务导航器。在<strong>android-perf-testing &gt; android-perf-testing &gt; Tasks &gt; verification</strong>路径结构下，您可以双击<code>connectedCheck</code>任务。</li>
</ul>
<p><img src="/img/17_01_14/019.png" alt=""></p>
<ul>
<li>等待任务完成，如Android Studio窗口底部状态栏所示。此屏幕截图指示测试仍在运行，因为最右边的微调器仍在移动。如果您在运行测试之前忘记解锁设备，则任务可能会卡住。如果测试耗时超过3分钟，请停止并重新启动<code>connectedCheck</code>gradle任务。</li>
</ul>
<p><img src="/img/17_01_14/020.png" alt=""></p>
<ul>
<li>任务运行完成后，可以在Android Studio的“消息”面板中看到此生成的输出。测试运行通常会失败，您将看到类似于下图所示的故障。在更高性能的设备上，您可能不会看到此失败;考虑在中端或低端设备上进行性能测试。</li>
</ul>
<p><img src="/img/17_01_14/021.png" alt=""></p>
<ul>
<li>现在让我们在命令行上运行测试。在Android Studio屏幕的最底部，使用终端文本按钮打开终端窗口并键入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;gradlew :app:connectedCheck</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：如果Android Studio在<strong>Run -&gt; Edit Configurations</strong>菜单中创建新的Android测试运行配置，则拒绝该选项。你稍后会以一种不同的方式来处理。</li>
</ul>
<p>再次，当你运行任务，你可能看到运行测试的异常。在大多数设备上，编写不良的<code>ListView</code>会导致<code>OutOfMemoryException</code>。这可以通过导航到Android Studio窗口右下角的Gradle Console文本按钮来看到。</p>
<p><img src="/img/17_01_14/022.png" alt=""></p>
<blockquote>
<p><strong>重要：</strong>如果你的测试套件没有出现失败，在确认运行测试之后继续使用Codelab是很好的。通过查看Gradle输出中指定的<code>index.html</code>文件（请参阅上一屏幕截图）来执行此操作。寻找<code>scrollFullList()</code>测试并确保它被执行。如果未执行，请确保您在上述所有代码段（包括注释）中进行了注释。</p>
<p>恭喜，到目前为止你已经：</p>
<ul>
<li>编译一个有较差的实现的<code>ListView</code>的应用程序。</li>
<li>使用性能工具来确认<code>ListView</code>的性能不佳</li>
<li>写一个性能测试，滚动<code>ListView</code>，并在大多数设备上抛出<code>OutOfMemory</code>异常，失败的测试套件。</li>
</ul>
</blockquote>
<p>让我们继续自动化Systrace，在测试中检测jank。</p>
<h2 id="7-使用MonkeyRunner自动化Systrace"><a href="#7-使用MonkeyRunner自动化Systrace" class="headerlink" title="7.使用MonkeyRunner自动化Systrace"></a>7.使用MonkeyRunner自动化Systrace</h2><p>自动化systrace是有点棘手，因为它需要与测试套件并行运行。Android开发套件附带一个名为<a href="http://developer.android.com/tools/help/monkeyrunner_concepts.html">MonkeyRunner</a>的工具，我们可以使用它。 MonkeyRunner允许您使用Python 2.7语法创建脚本，允许使用连接的Android设备进行编排。这允许我们启动Systrace，然后在并行线程（以及其他）中启动测试套件。</p>
<h3 id="MonkeyRunner脚本"><a href="#MonkeyRunner脚本" class="headerlink" title="MonkeyRunner脚本"></a>MonkeyRunner脚本</h3><p>自动化systrace和测试套件的脚本相当长，所以它被包含在repo中作为一个名为<a href="https://github.com/googlecodelabs/android-perf-testing/blob/master/run_perf_tests.py">run_perf_tests.py</a>的文件。在脚本末尾查看函数调用调用，作为自动化所需逻辑的摘要。你会注意到脚本遵循这个一般结构：</p>
<ul>
<li>1.检查环境变量</li>
<li>2.定义函数</li>
<li>3.清除先前运行的本地数据</li>
<li>4.查找Android设备</li>
<li>5.启用和清除图形信息dumpsys</li>
<li>6.并行启动systrace线程和测试套件线程</li>
<li>7.等待两个线程完成</li>
<li>8.从设备下载文件</li>
<li>9.对下载的文件运行分析</li>
</ul>
<p>你会注意到脚本有两个参数，（1）一个目录来记录数据（2）Android设备ID。由于您手动运行此脚本，您必须通过在Android Studio终端窗口中运行此命令手动检索设备ID。</p>
<p>Mac / Linux:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;ANDROID_HOME&#125;&#x2F;platform-tools&#x2F;adb devices -l</span><br></pre></td></tr></table></figure>
<p>Windows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%ANDROID_HOME%\platform-tools\adb devices -l</span><br></pre></td></tr></table></figure>
<p>它会输出类似的东西;选择屏幕左侧的设备ID以运行测试（如果您有多个设备）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">84B0456625000123       device usb:337123368X product:angler model:Nexus_6P device:angler</span><br></pre></td></tr></table></figure>
<p>现在，使用设备ID替换<code>&lt;INSERT ID&gt;</code>后，在Android Studio终端窗口中输入这两个命令，运行脚本。如果已连接的Android设备在运行第二个命令之前已进入睡眠状态，请记住解锁它。</p>
<p>Mac / Linux:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;gradlew :app:assembleDebug :app:assembleDebugAndroidTest :app:installDebug :app:installDebugAndroidTest</span><br><span class="line">$&#123;ANDROID_HOME&#125;&#x2F;tools&#x2F;monkeyrunner .&#x2F;run_perf_tests.py .&#x2F; &lt;INSERT_ID&gt; </span><br></pre></td></tr></table></figure>
<p>Windows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradlew :app:assembleDebug :app:assembleDebugAndroidTest :app:installDebug :app:installDebugAndroidTest</span><br><span class="line">%ANDROID_HOME%\tools\monkeyrunner run_perf_tests.py .\ &lt;INSERT_ID&gt;</span><br></pre></td></tr></table></figure>
<p>第一个命令的输出应该看起来类似于下面的文本。请确保它确认APK已安装到您的测试设备上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">:app:preDexDebugAndroidTest UP-TO-DATE</span><br><span class="line">:app:dexDebugAndroidTest UP-TO-DATE</span><br><span class="line">:app:packageDebugAndroidTest UP-TO-DATE</span><br><span class="line">:app:assembleDebugAndroidTest UP-TO-DATE</span><br><span class="line">:app:installDebug</span><br><span class="line">Installing APK &#39;app-debug.apk&#39; on &#39;Nexus 6P - 6.0&#39;</span><br><span class="line">Installed on 1 device.</span><br><span class="line">:app:installDebugAndroidTest</span><br><span class="line">Installing APK &#39;app-debug-androidTest-unaligned.apk&#39; on &#39;Nexus 6P - 6.0&#39;</span><br><span class="line">Installed on 1 device.</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 21.073 secs</span><br></pre></td></tr></table></figure>
<p>第二个命令应该完成一个与此类似的日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Writing logs to: .&#x2F;</span><br><span class="line">Using device_id: 84B0115625000732</span><br><span class="line">Your ANDROID_HOME is set to: &#x2F;Users&#x2F;paulrashidi&#x2F;android_sdk2</span><br><span class="line">Cleaning data files</span><br><span class="line">Waiting for a device to be connected.</span><br><span class="line">Device connected.</span><br><span class="line">Starting dump permission grant</span><br><span class="line">Starting storage permission grant</span><br><span class="line">Clearing gfxinfo on device</span><br><span class="line">Starting test</span><br><span class="line">Executing systrace</span><br><span class="line">Exception in thread TestThread:Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;paulrashidi&#x2F;android_sdk2&#x2F;tools&#x2F;lib&#x2F;jython-standalone-2.5.3.jar&#x2F;Lib&#x2F;threading.py&quot;, line 179, in _Thread__bootstrap</span><br><span class="line">    self.run()</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;paulrashidi&#x2F;android_sdk2&#x2F;tools&#x2F;lib&#x2F;jython-standalone-2.5.3.jar&#x2F;Lib&#x2F;threading.py&quot;, line 170, in run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;paulrashidi&#x2F;verytmp&#x2F;android-perf-testing&#x2F;.&#x2F;run_perf_tests.py&quot;, line 51, in perform_test</span><br><span class="line">    print device.instrument(test_runner, params)[&#39;stream&#39;]</span><br><span class="line">KeyError: &#39;stream&#39;</span><br><span class="line">Done running tests</span><br><span class="line">Done systrace logging</span><br><span class="line">Systrace Thread Done</span><br><span class="line">Test Thread Done</span><br><span class="line">Time between test and trace thread completion: 0</span><br><span class="line">Starting adb pull for test files</span><br><span class="line"></span><br><span class="line">FAIL: Could not find file indicating the test run completed.</span><br><span class="line"></span><br><span class="line">OVERALL: FAILED. See above for more information.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>重要：</strong>在测试失败的时候，流错误是预期的。如果测试通过，那是因为您使用的是更高端的设备，那么您将看到那个测试完成的报告。如果日志报告没有测试完成，请仔细检查以确保您没有跳过对<code>SimpleListActivityTest</code>类的<code>@PerfTest</code>注解的注释。</p>
<p>我们使用注解将特定测试标记为性能测试，以显示如何仅将一部分测试声明为性能测试，而不是全部运行。</p>
</blockquote>
<p>你应该有一个<code>perftesting</code>目录，有一个有限的文件集，类似于下面的屏幕截图。</p>
<p><img src="/img/17_01_14/023.png" alt=""></p>
<blockquote>
<p><strong>重要：</strong>该脚本将在编码表的这个阶段报告“OVERALL”故障，因为并不是所有的测试配件都已就位。您可能还会收到关于“流”故障的错误或测试套件可能失败。这些错误在这一点上也是正常的。</p>
<p>重要的是确保您在项目中的<code>perftesting/&lt;DeviceID&gt;/testdata/</code>目录中有一个<code>trace.html</code>文件。还要仔细观察<code>perftesting/&lt;DeviceID&gt;/logs/files</code>，以确保<code>run_perf_tests.py</code>脚本中的命令没有失败。您的<code>perftesting/&lt;DeviceID&gt;/testdata/</code>目录中目前应该没有文件。</p>
</blockquote>
<h3 id="为MonkeyRunner添加Gradle任务"><a href="#为MonkeyRunner添加Gradle任务" class="headerlink" title="为MonkeyRunner添加Gradle任务"></a>为MonkeyRunner添加Gradle任务</h3><p>现在，我们让脚本对开发环境更加原生，所以我们可以从Gradle和/或Android Studio运行它。最简单的方法是创建一个将运行monkeyrunner脚本的Gradle任务。在Gradle中，我们可以通过在<code>buildSrc</code>目录中定义一个新任务来为一个典型的项目做到这一点;让我们这样做。</p>
<p>导航到<code>buildSrc/src/main/groovy/com/google/android/perftesting/RunLocalPerfTestsTask</code>并取消注释那里的代码来实现任务。Android Studio可能会在与重复类定义相关的文件编辑窗口中报告这些Gradle任务上的构建错误，因此可以忽略这些错误。</p>
<p><img src="/img/17_01_14/024.png" alt=""></p>
<p>你也应该仔细阅读<code>buildSrc/src/main/groovy/com/google/android/perftesting/PerfTestTaskGeneratorPlugin</code>。这是一个自定义Gradle插件，它查询连接的Android设备，然后为每个连接的设备设置一个<code>RunLocalPerfTestsTask</code>Gradle任务。自定义Gradle插件还创建一个额外的通用<code>RunLocalPerfTests</code>任务，在运行时执行每个特定于设备的gradle任务。</p>
<p>现在让我们将自定义Gradle插件安装到我们的项目中，以便所有自定义Gradle任务都可用。</p>
<p>导航到<code>app/build.gradle</code>并在以下代码行中注释。重要的是，在配置Android Gradle插件之后应用此插件，因此，它被放置在<code>build.gradle</code>文件的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Create performance testing tasks for all connected Android devices using a Gradle plugin defined</span><br><span class="line">&#x2F;&#x2F; in the buildSrc directory.</span><br><span class="line">apply plugin: PerfTestTaskGeneratorPlugin</span><br></pre></td></tr></table></figure>
<p>然后将此代码段添加为<code>app/build.gradle</code>文件的第一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.google.android.perftesting.PerfTestTaskGeneratorPlugin</span><br></pre></td></tr></table></figure>
<p>Android Studio屏幕顶部会显示一条消息，询问您是否要再次同步Gradle文件。执行Gradle文件同步，然后导航到Gradle任务列表。您应该看到Gradle插件添加的新任务。如果您连接了多个设备，您将有比下面的屏幕截图更多的任务。</p>
<p><img src="/img/17_01_14/025.png" alt=""></p>
<p>Gradle任务<code>runLocalPerfTests</code>是运行性能测试的任务。从Gradle运行monkeyrunner脚本的一个主要优点是我们使新的性能测试任务取决于App和Test APKs的安装。每当我们对代码库进行更改时，只要我们使用Gradle任务来执行测试，Gradle就会分析所有的项目文件，并在运行测试之前根据需要重新生成相关的APK。</p>
<p>让我们确保新任务工作。双击<code>runLocalPerfTests</code>任务运行它。耐心等待，可能需要一点时间来构建，安装，运行你的应用程序和启动monkeyrunner仪器。确保设备的屏幕显示性能测试正在运行。</p>
<p>为了使事情更容易，让我们继续，使用保存配置选项将<code>runLocalPerfTests</code> gradle任务添加到运行配置菜单，如图所示。</p>
<p><img src="/img/17_01_14/026.png" alt=""></p>
<p>你现在应该有一个运行配置<code>runLocalPerfTests</code>在你的gradle边栏，如下图所示：</p>
<p><img src="/img/17_01_14/027.png" alt=""></p>
<p>赞！！现在，您可以在Android Studio中连接到计算机的设备上运行性能测试，并且在对源代码进行更改时，应用和测试APK都会根据需要重新构建。您还在<code>testdata</code>目录中有Systrace <code>trace.html</code>文件以进行调试，但是目前您没有关于正在运行的测试的大量数据。让我们解决这个问题。</p>
<h2 id="8-收集更多数据并添加性能约束"><a href="#8-收集更多数据并添加性能约束" class="headerlink" title="8.收集更多数据并添加性能约束"></a>8.收集更多数据并添加性能约束</h2><p>我们已经启用了Systrace和测试执行，但我们需要更多的信息。此外，由于我们现在通过MonkeyRunner运行测试，我们失去了测试成功/失败信息。让我们解决这个问题。</p>
<h3 id="收集更多数据"><a href="#收集更多数据" class="headerlink" title="收集更多数据"></a>收集更多数据</h3><p>团队开发了一些我们可以使用的JUnit规则示例。这些规则在<code>com.google.android.perftesting.testrules</code>包中的<code>app/src/androidTest/java/</code>目录中可用。让我们将这些规则添加到现有测试中。</p>
<p>导航到<code>app/src/androidTests</code>目录。打开<code>SimpleListActivityTest</code>类并取消注解<code>@Rule</code>注释的成员变量，其中类名以<code>Enable</code>开头，例如下面的行。同时解决导入错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public EnableTestTracing mEnableTestTracing &#x3D; new EnableTestTracing();</span><br><span class="line">    </span><br><span class="line">@Rule</span><br><span class="line">public EnablePostTestDumpsys mEnablePostTestDumpsys &#x3D; new EnablePostTestDumpsys();</span><br><span class="line"></span><br><span class="line">@Rule</span><br><span class="line">public EnableLogcatDump mEnableLogcatDump &#x3D; new EnableLogcatDump();</span><br><span class="line"></span><br><span class="line">@Rule</span><br><span class="line">public EnableNetStatsDump mEnableNetStatsDump &#x3D; new EnableNetStatsDump();</span><br></pre></td></tr></table></figure>
<p>这些规则中的每一个导致记录不同的数据集。</p>
<ul>
<li><code>EnableTestTracing</code>在每个测试之前和之后调用Trace＃<a href="https://developer.android.com/reference/android/os/Trace.html#beginSection(java.lang.String">beginSection</a>和<code>Trace＃endSection</code>方法。这允许您查看Systrace并查看每个测试运行时在调试期间为您提供更多上下文。</li>
<li><code>EnablePostTestDumpsys</code>在每次测试后收集图形信息dumpsys输出。在Android Marshmallow和更大的设备上，这包括“Janky”百分比摘要。这个Jank百分比由现有的设置的<code>run_perf_test.py</code>脚本监控。当百分比高于配置的阈值时，脚本将发出警报。</li>
<li><code>EnableLogcatDump</code>在运行测试之前重置设备上的Logcat缓冲区，然后在测试后提取缓冲区。这在研究回归失败或只是希望看到Logcat输出的测试时很有用。</li>
<li><code>EnableNetStatsDump</code>转储历史网络信息。这在调试网络相关问题时尤其有用。例如，如果文件下载测试超时，您可能需要仔细检查网络是否不可用，然后再深入分析问题。</li>
</ul>
<p>现在取消注释<code>GlobalTimeout</code>规则以添加性能约束。此规则确保此类中的任何测试在超过指定的时间量时都会抛出错误。你会注意到<code>scrollFullList</code>测试方法在它的末尾有一个while循环。如果<code>ListView</code>代码的性能不足以允许某人在合理的时间内滚动整个列表，while循环和<code>GlobalTimeout</code>规则会导致失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public Timeout globalTimeout&#x3D; new Timeout(</span><br><span class="line">SCROLL_TIME_IN_MILLIS + MAX_ADAPTER_VIEW_PROCESSING_TIME_IN_MILLIS, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<p>现在导航到同一目录中的<code>TestListener</code>类。取消注释<code>testRunStarted</code>和<code>testRunFinished</code>方法的代码，解决导入构建错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void testRunStarted(Description description) throws Exception &#123;</span><br><span class="line">    Log.w(LOG_TAG, &quot;Test run started.&quot;);</span><br><span class="line">    &#x2F;&#x2F; Cleanup data from past test runs.</span><br><span class="line">    deleteExistingTestFilesInAppData();</span><br><span class="line">   deleteExistingTestFilesInExternalData();</span><br><span class="line">....</span><br><span class="line">@Override</span><br><span class="line">public void testRunFinished(Result result) throws Exception &#123;</span><br><span class="line">    Log.w(LOG_TAG, &quot;Test run finished.&quot;);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>这将启用电池统计信息收集，测试失败日志记录，并且在测试完成后，此代码还将所有正在收集的日志文件移动到可访问的位置，在那里可以通过简单的adb命令从主机计算机拉出。</p>
<h3 id="再次运行测试"><a href="#再次运行测试" class="headerlink" title="再次运行测试"></a>再次运行测试</h3><p>接下来，使用Android Studio窗口顶部的<code>runLocalPerfTests</code><strong>Run Configuration</strong>再次运行性能测试。</p>
<p>您可能会注意到，monkeyrunner脚本已经标记更多的问题，因为更多的文件现在被拉到，因此，可以执行检查。导航到项目根目录中的<code>testdata</code>目录。你会发现相当多的信息现在被记录到目录结构类似于测试类包结构的目录。浏览这些文件以查看正在记录的信息。</p>
<blockquote>
<p><strong>重要：</strong>如果此时没有看到新文件，请转到下一步，解决性能问题，然后再次查找文件。</p>
</blockquote>
<p>在下一步中，我们将查看当前脚本的输出，并从线束的信息开始修复性能问题。</p>
<h2 id="9-修复性能问题"><a href="#9-修复性能问题" class="headerlink" title="9.修复性能问题"></a>9.修复性能问题</h2><p>在上次性能测试运行中，您遇到了性能问题。让我们现在利用线束收集的信息来解决这些问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1) scrollFullList(com.google.android.perftesting.SimpleListActivityTest)</span><br><span class="line">Script: org.junit.runners.model.TestTimedOutException: test timed out after 2500 milliseconds</span><br><span class="line">Script:         at java.lang.Thread.sleep(Native Method)</span><br><span class="line">Script:         at java.lang.Thread.sleep(Thread.java:1031)</span><br><span class="line">Script:         at java.lang.Thread.sleep(Thread.java:985)</span><br><span class="line">Script:         at com.google.android.perftesting.SimpleListActivityTest.scrollFullList(SimpleListActivityTest.java:101)</span><br><span class="line">Script:         at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">Script:         at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">Script:         at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">Script:         at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">Script:         at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">Script:         at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298)</span><br><span class="line">Script:         at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292)</span><br><span class="line">Script:         at java.util.concurrent.FutureTask.run(FutureTask.java:237)</span><br><span class="line">Script:         at java.lang.Thread.run(Thread.java:818)</span><br></pre></td></tr></table></figure>
<p>此错误也记录在<code>testdata</code>目录的子目录中名为<code>test.failure.log</code>的文件中，该文件对应于测试类和方法名称。</p>
<p>如果你打开<code>gfxinfo.dumpsys.log</code>文件，你会看到一行注明了JANK过量的存在（样本中下方约92％）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** Graphics info for pid 31367 [com.google.android.perftesting] **</span><br><span class="line"></span><br><span class="line">Stats since: 19840518836088ns</span><br><span class="line">Total frames rendered: 323</span><br><span class="line">Janky frames: 296 (91.64%)</span><br><span class="line">90th percentile: 117ms</span><br><span class="line">95th percentile: 125ms</span><br><span class="line">99th percentile: 133ms</span><br><span class="line">Number Missed Vsync: 290</span><br><span class="line">Number High input latency: 0</span><br><span class="line">Number Slow UI thread: 295</span><br><span class="line">Number Slow bitmap uploads: 286</span><br><span class="line">Number Slow issue draw commands: 15</span><br></pre></td></tr></table></figure>
<p>打开systrace并观察指示性能问题的警报数量。</p>
<blockquote>
<p><strong>重要提示：</strong> 在Android Studio终端窗口中键入<code>open testdata/trace.html</code>，以便在所选的Web浏览器中快速打开跟踪。</p>
</blockquote>
<p>Systrace警报清楚地指向<code>ListView</code>回收视图问题以及调用<code>getView()</code>的时间过长。要解决此问题，请打开<code>com.google.android.perftesting.contacts.ContactsArrayAdapter</code>类，并解决显示的lint错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LayoutInflater inflater &#x3D; LayoutInflater.from(getContext());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This line is wrong, we&#39;re inflating a new view always instead of only if it&#39;s null.</span><br><span class="line">&#x2F;&#x2F; For demonstration purposes, we will leave this here to show the resulting jank.</span><br><span class="line">convertView &#x3D; inflater.inflate(R.layout.item_contact, parent, false);</span><br></pre></td></tr></table></figure>
<p>应该改为这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (convertView &#x3D;&#x3D; null) &#123;</span><br><span class="line">   LayoutInflater inflater &#x3D; LayoutInflater.from(getContext());</span><br><span class="line">   convertView &#x3D; inflater.inflate(R.layout.item_contact, parent, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行perf测试，并在web浏览器中刷新<code>trace.html</code>文件。嗯…看起来像<code>getView()</code>仍然导致性能问题。看看位图代码在getView一点点你意识到它应该实际上使用的东西，有一个缓存加载位图。一个常见的选择是滑翔(Glide)。所以改变这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Let&#39;s just create another bitmap when we need one. This makes no attempts to re-use</span><br><span class="line">&#x2F;&#x2F; bitmaps that were previously used in rendering past list view elements, causing a large</span><br><span class="line">&#x2F;&#x2F; amount of memory to be consumed as you scroll farther down the list.</span><br><span class="line">Bitmap bm &#x3D; BitmapFactory.decodeResource(convertView.getResources(), R.drawable.bbq);</span><br><span class="line">contactImage.setImageBitmap(bm);</span><br></pre></td></tr></table></figure>
<p>变成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Glide.with(contactImage.getContext())</span><br><span class="line">       .load(R.drawable.bbq)</span><br><span class="line">       .fitCenter()</span><br><span class="line">       .into(contactImage);</span><br></pre></td></tr></table></figure>
<p>再次运行perf测试，并在web浏览器中刷新<code>trace.html</code>文件。你可以继续优化，但你得到了一种方法。现在，您有一个可重复的方式标记问题，然后运行测试，以查看具体的更改是否有所作为。</p>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>恭喜！你已经完成了codelab。让我们再花几分钟来总结你学到的东西和一些关键的事情要记住。</p>
<h3 id="我们所涵盖的"><a href="#我们所涵盖的" class="headerlink" title="我们所涵盖的"></a>我们所涵盖的</h3><ul>
<li>如何构建一个可重复使用的测试工具，用于检测Android应用程序中的jank和性能问题，并且可以从Android Studio中进行管理</li>
<li>如何使用MonkeyRunner自动化测试框架的大多数功能</li>
<li>如何使用性能约束和JUnit规则注解测试</li>
<li>如何在测试周期中以各种粒度从测试收集各种数据</li>
</ul>
<h3 id="需要记住的事情"><a href="#需要记住的事情" class="headerlink" title="需要记住的事情"></a>需要记住的事情</h3><ul>
<li>必需是 Debuggable apk</li>
<li>对于大多数数据的统计，需要Android Marshmallow设备</li>
<li>使用项目定义的PerfTest注释来限制测试的范围</li>
<li>Systrace当前设置为在示例中运行10秒，您可能需要延长此时间。</li>
</ul>
<h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><p>如果您想详细了解效果测试，请参阅Android开发者文档网站上的<a href="https://developer.android.com/preview/testing/performance.html">测试展示效果</a>。</p>
<p>如果您想了解更多关于Systrace的信息，请参阅<a href="http://developer.android.com/tools/help/systrace.html">官方文档</a>。</p>
<p>如果你对Espresso和UI测试更好奇，请查看这些<a href="http://developer.android.com/training/testing/ui-testing/espresso-testing.html">官方文档</a>。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python3教程 第1章】基本概念</title>
    <url>/2017/01/16/%E3%80%90Python3%E6%95%99%E7%A8%8B%20%E7%AC%AC1%E7%AB%A0%E3%80%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="什么是Python？"><a href="#什么是Python？" class="headerlink" title="什么是Python？"></a>什么是Python？</h2><h3 id="欢迎来到Python"><a href="#欢迎来到Python" class="headerlink" title="欢迎来到Python!"></a>欢迎来到Python!</h3><p><strong>Python</strong>是一个应用于很多领域（包括web编程，脚本，科学计算，以及人工智能）的高级编程语言。</p>
<p>同时它也非常流行，在Google、NASA、CIA以及Disney等这些机构都在使用。</p>
<blockquote>
<p>Python在运行时被解释器(interpreter)处理。在你的程序执行之前，不需要被编译。</p>
</blockquote>
<p>Python有三个主要的版本，分别是1.x,2.x和3.x。进一步细分为一些主要的版本，例如2.7和3.3。</p>
<p>由Python3.x版本写的代码保证能够在未来的所有版本中运行。</p>
<p>有两个版本的Python分别是2.x和3.x版本现在还在被使用到。这套课程主要涵盖的是Python 3.x版本的内容，但切换到另一个版本其实并不困难。</p>
<p>Python有一些由其他语言写成的不同的实现。这套课程中用到的，<strong>CPython</strong>是目前最流行的。</p>
<blockquote>
<p><strong>解释器</strong>是运行以解释性语言（例如Python）编写的脚本的程序。</p>
</blockquote>
<h2 id="Python控制台"><a href="#Python控制台" class="headerlink" title="Python控制台"></a>Python控制台</h2><h3 id="你的第一个程序"><a href="#你的第一个程序" class="headerlink" title="你的第一个程序"></a>你的第一个程序</h3><p>这节课，我们将通过Python控制台来开始使用Python。第一步是从<strong><a href="www.python.org">www.python.org</a></strong>下载Python。</p>
<p>你应该下载与你系统兼容的Python 3.x的版本。一旦安装完毕，Python控制台就可以使用以下的几种方式之一来访问了：</p>
<ul>
<li>使用命令行</li>
<li>直接运行Python解释器</li>
<li>运行一个图形化的Python IDLE(集成化的Python开发环境)程序</li>
</ul>
<p>运行IDLE之后，你将看到一个三个箭头的提示。输入<code>print(&#39;Hello world!&#39;)</code>然后按下回车。你会看到以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(&#39;Hello world!&#39;)</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<p>恭喜！你已经写完了你的第一个程序。</p>
<blockquote>
<p>这个展示”Hello world!”的小程序在其他任何语言中像是一个传统一样，都是作为第一个程序存在的。</p>
</blockquote>
<h3 id="Python控制台-1"><a href="#Python控制台-1" class="headerlink" title="Python控制台"></a>Python控制台</h3><p>Python控制台是一个允许你输入一行Python代码，重复执行那一行代码，并输出结果的程序。这被称为<strong>REPL</strong> — 一个“读取-计算-打印输出”的循环。</p>
<p>在<code>print(&#39;Hello world!&#39;)</code>行的输出已经显示之后，您可以重新输入代码，并且您将再次获得相同的输出。尝试输入相同的代码，但使用不同的文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;Hello world!&#39;)</span><br><span class="line">Hello world!</span><br><span class="line">&gt;&gt;&gt; print(&#39;Hello world!&#39;)</span><br><span class="line">Hello world!</span><br><span class="line">&gt;&gt;&gt; print(&#39;Spam and eggs...&#39;)</span><br><span class="line">Spam and eggs...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python代码通常包含对喜剧组<strong>Monty Python</strong>的引用。这就是为什么“垃圾邮件”和“鸡蛋”这些词经常在Python中用作占位符变量，其中“foo”和“bar”将用于其他编程语言。</p>
</blockquote>
<p>结束Python控制台的使用后，您需要关闭它。您可以以关闭操作系统上其他程序的相同方式关闭IDLE，但其他类型的控制台必须通过不同的方法关闭。要关闭控制台，请键入“<strong>quit()</strong>”或“<strong>exit()</strong>”，然后按Enter键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; quit()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些Python控制台也可以通过按<strong>Ctrl-Z</strong>关闭，这是一个控制代码，发送退出信号到控制台程序。另一个控制代码，<strong>Ctrl-C</strong>，停止正在运行的程序，如果你不小心创建了一个死循环的程序时，可以用这个指令来终止它。</p>
</blockquote>
<h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><h3 id="加减法操作"><a href="#加减法操作" class="headerlink" title="加减法操作"></a>加减法操作</h3><p>Python有计算能力。直接在Python控制台中输入计算，它将输出答案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 2</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 5 + 4 - 3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里的加号和减号周围的空格是<strong>可选的</strong>（代码的执行对它们是无效的），但这些空格使代码更容易阅读。</p>
</blockquote>
<h3 id="乘除法操作"><a href="#乘除法操作" class="headerlink" title="乘除法操作"></a>乘除法操作</h3><p>Python还可以执行乘法和除法，使用星号(*)表示乘法和正斜杠(/)表示除法。</p>
<p>使用括号确定优先执行的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 * (3 + 4)</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; 10 &#x2F; 2</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用单斜杠来分割数字会产生一个小数（或<strong>浮点数</strong>）。我们将在后面的课程中更多地了解<strong>浮点数</strong>。</p>
</blockquote>
<h3 id="负数运算"><a href="#负数运算" class="headerlink" title="负数运算"></a>负数运算</h3><p>减号与数字组合会得到一个<strong>负数</strong>。在负数上的操作运算和在正数上的操作运算是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; -7</span><br><span class="line">-7</span><br><span class="line">&gt;&gt;&gt; (-7 + 2) * (-4)</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<blockquote>
<p>加号也可以跟在数字的前面，但它其实没有什么效果。其实它通常是用来强调数字是正数，目的是为了增强代码的可读性。</p>
</blockquote>
<h3 id="除以0"><a href="#除以0" class="headerlink" title="除以0"></a>除以0</h3><p>在Python中被0除会产生一个<strong>错误(error)</strong>，因为没有答案能被算出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 11 &#x2F; 0</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Python中，最后一行的错误信息展示了错误类型。仔细读错误信息，因为它通常会告诉你如何修改程序！</p>
</blockquote>
<h2 id="浮点数-Float"><a href="#浮点数-Float" class="headerlink" title="浮点数(Float)"></a>浮点数(Float)</h2><p><strong>Float</strong>在Python中用于表示不是整数的数字。以浮点数表示的实例如：<code>0.5</code>和<code>-7.8237591</code>。它们可以通过输入带小数点的数字直接创建，也可以使用整数除法等操作来得到。在数字末尾的多余的0会被忽略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 3&#x2F;4 </span><br><span class="line">0.75 </span><br><span class="line">&gt;&gt;&gt; 9.8765000 </span><br><span class="line">9.8765 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，电脑无法精确的计算浮点数，同样，我们无法写出浮点数<code>1/3</code>的完整的十进制形式(<code>0.3333333333333333...</code>)。记住这一条，因为这里总是会导致一些令人生气的bug！</p>
</blockquote>
<p>正如你上面看到的，两个整数相除可以得到一个<strong>float</strong>。</p>
<p>一个浮点数也可以由两个浮点数之间的运算得出，或者一个整数一个浮点数的运算也可以得出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 &#x2F; 2</span><br><span class="line">4.0</span><br><span class="line">&gt;&gt;&gt; 6 * 7.0</span><br><span class="line">42.0</span><br><span class="line">&gt;&gt;&gt; 4 + 1.65</span><br><span class="line">5.65</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个浮点数可以和一个整数相加，因为Python会自动将整数转变为浮点数。然而，这种隐式转型在Python中是一种例外情况，通常情况下，在Python中，如果你想要进行类型转换，都需要手动处理。</p>
</blockquote>
<h2 id="其他数值运算"><a href="#其他数值运算" class="headerlink" title="其他数值运算"></a>其他数值运算</h2><h3 id="乘方运算"><a href="#乘方运算" class="headerlink" title="乘方运算"></a>乘方运算</h3><p>除了加，减，乘，除，Python也支持乘方操作。乘方操作是使用两个星号执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 ** 5 </span><br><span class="line">32 </span><br><span class="line">&gt;&gt;&gt; 9 **（1&#x2F;2）</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure>
<h3 id="商和余"><a href="#商和余" class="headerlink" title="商和余"></a>商和余</h3><p>要确定一个除法运算的商和余数，可以分别使用<strong>floor division</strong>和<strong>取模</strong>运算。</p>
<p>Floor division使用两个下划线构成。取模运算由百分号(%)组成。</p>
<p>这些操作都可以用在浮点数和整数上。</p>
<p>下面的代码展示了20可以被6除三次，以及1.25除以0.5之后余0.25：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 20 &#x2F;&#x2F; 6</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 1.25 % 0.5</span><br><span class="line">0.25</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>如果你想在Python中使用一个text，你必须用到字符串。</p>
<p>一个字符串是由<strong>单引号</strong>或<strong>双引号</strong>以及之间的文本构成的。</p>
<p>当Python控制台显示一个字符串时，它通常是由单引号括起来的。用于字符串上的分隔符不会影响到字符串的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Python is fun!&quot;</span><br><span class="line">&#39;Python is fun!&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;Always look on the bright side of life&#39;</span><br><span class="line">&#39;Always look on the bright side of life&#39;</span><br></pre></td></tr></table></figure>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>某些字符串无法直接包含在一个字符串内。例如，双引号不能直接包含双引号的字符串，这将导致字符串提前结束。</p>
<p>想这些字符必须通过一个用于转义的反斜杠()在他们前面，才能满足我们的要求。</p>
<p>必须转义的其他常见字符还有<strong>换行符</strong>和<strong>反斜杠</strong>。</p>
<p>双引号只需要在双引号字符串中转义，对于单引号字符串也是如此。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Brian\&#39;s mother: He\&#39;s not the Messiah. He\&#39;s a very naughty boy!&#39;</span><br><span class="line">&#39;Brian&#39;s mother: He&#39;s not the Messiah. He&#39;s a very naughty boy!&#39;</span><br></pre></td></tr></table></figure>
<p><strong>\n</strong>代表新的一行。</p>
<blockquote>
<p>反斜杠也可用于转义标签、任意Unicode字符 以及许多其他并不能被打印的东西。这些字符称为转义字符。</p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>Python提供了一种简单的方式来避免手工编写”\n”来进行字符串的换行转义。创建一个<strong>三引号</strong>包裹的字符串，回车键将自动处理为转义换行符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&quot;&quot;Customer: Good morning.</span><br><span class="line">Owner: Good morning, Sir. Welcome to the National Cheese Emporium.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&#39;Customer: Good morning.\nOwner: Good morning, Sir. Welcome to the National Cheese Emporium.&#39;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正如你看到的那样，当我们按下回车键时，<strong>\n</strong>会自动地添加到输出中去。</p>
</blockquote>
<h2 id="简单的输入与输出"><a href="#简单的输入与输出" class="headerlink" title="简单的输入与输出"></a>简单的输入与输出</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>通常情况下，程序接受<strong>输入</strong>然后处理之后产生<strong>输出</strong>。</p>
<p>在Python中，你可以使用<strong>print</strong>方法来生成输出。它将在屏幕上输出某些东西的文本表示形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(1 + 1)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(&quot;Hello\nWorld!&quot;)</span><br><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个字符串被打印时，两边的括号是不被展示的。</p>
</blockquote>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>在Python中，你可以使用<strong>input</strong>方法来获取用户的输入。这个方法会提示用户输入，并且返回用户按下回车时输入的字符串（内容自动转义）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; input(&quot;Enter something please: &quot;)</span><br><span class="line">Enter something please: This is what\nthe user enters!</span><br><span class="line"></span><br><span class="line">&#39;This is what\\nthe user enters!&#39;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>能够自动的执行输入和输出的<strong>输入</strong>和<strong>输出</strong>方法在Python的控制台中并不是很有用。然而，在实际的程序中，它很有用。</p>
</blockquote>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>与整数浮点数相同，字符串在Python中也可以使用加法运算，这种可以在任意两个字符串之间完成的操作被称为<strong>级联</strong>。</p>
<p>执行级联操作时，不管字符串是由单引号创建的还是双引号创建的，都可以正常执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Spam&quot; + &#39;eggs&#39;</span><br><span class="line">&#39;Spameggs&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(&quot;First string&quot; + &quot;, &quot; + &quot;second string&quot;)</span><br><span class="line">First string, second string</span><br></pre></td></tr></table></figure>
<p>即使你的字符串中包含数字，它们在进行相加操作时，依然是以字符串的形式进行运算，而不是整数。将一个字符串与一个数字相加会产生错误，即使它们看起来很相似，但它们任然是两种不同的实体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;2&quot; + &quot;2&quot;</span><br><span class="line">&#39;22&#39;</span><br><span class="line">&gt;&gt;&gt; 1 + &#39;2&#39; + 3 + &#39;4&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在后面的课程中，错误信息只显示最后一行，因为它是唯一提供当前发生的错误的详细信息的消息。</p>
</blockquote>
<h3 id="字符串操作-1"><a href="#字符串操作-1" class="headerlink" title="字符串操作"></a>字符串操作</h3><p>字符串也可以和整数<strong>相乘</strong>。这种操作会生成由原始字符串重复出现组成的字符串。字符串和整数的顺序并不重要，但通常情况下，字符串是放在最前面的。</p>
<p>字符串不能被其他字符串相乘。字符串也不能被浮点数相乘，即使浮点数是整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;spam&quot; * 3)</span><br><span class="line">spamspamspam</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 4 * &#39;2&#39;</span><br><span class="line">&#39;2222&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#39;17&#39; * &#39;87&#39;</span><br><span class="line">TypeError: can&#39;t multiply sequence by non-int of type &#39;str&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#39;pythonisfun&#39; * 7.0</span><br><span class="line">TypeError: can&#39;t multiply sequence by non-int of type &#39;float&#39;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在Python中，由于类型所以有些操作不能完成。例如，你不能把字符串“2”和字符串“3”相加得到字符串“5”，由于这种加法操作是在字符串上进行的，得到的结果是“23”。</p>
<p>解决这个问题的方式是<strong>类型转换</strong>。</p>
<p>在这个例子中，你可以使用<strong>int</strong>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;2&quot; + &quot;3&quot;</span><br><span class="line">&#39;23&#39;</span><br><span class="line">&gt;&gt;&gt; int(&quot;2&quot;) + int(&quot;3&quot;)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Python中，我们使用的类型是<strong>整数</strong>，<strong>浮点数</strong>和<strong>字符串</strong>。用于转换为这些的函数分别是<strong>int</strong>，<strong>float</strong>和<strong>str</strong>。</p>
</blockquote>
<p>另一个类型转换的例子是转换用户的输入(是一个<strong>string</strong>)成为一个数字(<strong>integers</strong>或者<strong>floats</strong>)，以至于可以进行计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; float(input(&quot;Enter a number: &quot;)) + float(input(&quot;Enter another number: &quot;))</span><br><span class="line">Enter a number: 40</span><br><span class="line">Enter another number: 2</span><br><span class="line">42.0</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量在大多数编程语言中都起到了重要的作用，Python也不例外。一个变量通过赋予一个名字，然后可以存储一个值，在其后面的程序中进行调用。</p>
<p>通过<strong>一个等号</strong>来定义一个变量。不同于到目前我们看到的大部分代码，它不会在控制台产生任何输出信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; 7</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; print(x + 3)</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您可以使用变量执行相应的操作，就像使用数字和字符串一样。正如你所看到的，这个变量在整个程序中都保存着它的值。</p>
</blockquote>
<p>变量可以多次的重新赋值。在Python中，变量没有被指定类型，因此你可以赋值一个string到一个变量上，然后你也可以赋值一个integer型的数据到同一个变量上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; 123.456</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">123.456</span><br><span class="line">&gt;&gt;&gt; x &#x3D; &quot;This is a string&quot;</span><br><span class="line">&gt;&gt;&gt; print(x + &quot;!&quot;)</span><br><span class="line">This is a string!</span><br></pre></td></tr></table></figure>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>在Python中，对于变量名有一些限制，在变量名中只可以使用字母、数字和下划线。另外，不能以数字开头。</p>
<p>如果不遵循这些规则，则会产生错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; this_is_a_normal_name &#x3D; 7</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 123abc &#x3D; 7</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; spaces are not allowed</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python是一种大小写敏感的编程语言。因此，<strong>Lastname</strong>和<strong>lastname</strong>在Python中是两个不同的变量名。</p>
</blockquote>
<p>如果使用了一个没有被赋值的变量，将产生一个<strong>错误</strong>。</p>
<p>你可以使用<strong>del</strong>语句来删除一个变量，这意味着这个变量从名称到值的引用都会被删除，并且尝试使用被删除的变量会导致错误。被删除的变量可以正常的重新被赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; foo &#x3D; &quot;a string&quot;</span><br><span class="line">&gt;&gt;&gt; foo</span><br><span class="line">&#39;a string&#39;</span><br><span class="line">&gt;&gt;&gt; bar</span><br><span class="line">NameError: name &#39;bar&#39; is not defined</span><br><span class="line">&gt;&gt;&gt; del foo</span><br><span class="line">&gt;&gt;&gt; foo</span><br><span class="line">NameError: name &#39;foo&#39; is not defined</span><br></pre></td></tr></table></figure>
<p>你也可以接受用户的输入作为变量的值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; foo &#x3D; input(&quot;Enter a number: &quot;)</span><br><span class="line">Enter a number: 7</span><br><span class="line">&gt;&gt;&gt; print(foo)</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符允许你将像<code>x = x + 3</code>这样的代码写的更简洁，像这样<code>x += 3</code>。</p>
<p>同样的操作也适用于其他操作例如<code>-</code>,<code>*</code>,<code>/</code>和<code>%</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; x +&#x3D; 3</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>这些运算符也可以用于数字以外的类型，例如<strong>字符串</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; &quot;spam&quot;</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">spam</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x +&#x3D; &quot;eggs&quot;</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">spameggs</span><br></pre></td></tr></table></figure>
<blockquote>
<p>许多其他的语言有像<code>++</code>这样的对于<code>x += 1</code>的简写的写法。Python中<strong>不支持</strong>这样做。</p>
</blockquote>
<h2 id="使用编辑器"><a href="#使用编辑器" class="headerlink" title="使用编辑器"></a>使用编辑器</h2><p>到目前为止，我们仅仅通过Python控制台来写Python。这样我们每次仅能同时输入并允许一行代码。</p>
<p>在实际的开发中其实并不是这样的，我们会将多行代码写入一个文件中，并通过Python解释器来运行它。</p>
<p>在<strong>IDLE</strong>中，这种操作是通过创建一个文件，输入一些代码，保存文件，然后运行它来执行。这些操作可以通过点击菜单来完成或者通过键盘快捷键’Ctrl-N’,’Ctrl-S’和‘F5’来完成。</p>
<p>文件中的每行代码都被解释为在控制台中一次输入的一行代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 7</span><br><span class="line">x &#x3D; x + 2</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="/img/17_01_16/001.png" alt=""></p>
<blockquote>
<p>Python源代码有一个<strong>.py</strong>的扩展名。</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python3教程 第2章】控制结构</title>
    <url>/2017/01/17/%E3%80%90Python3%E6%95%99%E7%A8%8B%20%E7%AC%AC2%E7%AB%A0%E3%80%91%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="布尔与比较"><a href="#布尔与比较" class="headerlink" title="布尔与比较"></a>布尔与比较</h2><h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>Python中的另一种类型是布尔类型(Boolean)。布尔类型有两种值：<strong>True</strong>和<strong>False</strong>。它们可以通过比较值来创建，例如通过等号操作符<code>==</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_boolean = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_boolean</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> == <span class="number">3</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;hello&quot;</span> == <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意不要混淆<strong>赋值</strong>（一个等号）和<strong>比较</strong>（两个等号）操作符。</p>
</blockquote>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>另外一个比较操作符是不等于(<strong>!=</strong>)，如果两者相比不相等，则结果为<strong>False</strong>否则为<strong>True</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> != <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;eleven&quot;</span> != <span class="string">&quot;seven&quot;</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> != <span class="number">10</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>Python也有比较两个数值（浮点数或整数）是否大于或小于另一个数值的运算。操作符分别是<code>&gt;</code>和<code>&lt;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> &gt; <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> &lt; <span class="number">10</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>大于或等于的运算符是<code>&gt;=</code>，小于或等于的运算符是<code>&lt;=</code>。</p>
<p>与大于小于操作符类似，除了当两者相等的时候也返回<strong>True</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span> &lt;= <span class="number">8</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span> &gt;= <span class="number">9.0</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>大于等于和小于等于操作符也可以用于按字典排序模式比较字符串操作（字的字母顺序是基于它们的组成字母的字母顺序排序的）。</p>
</blockquote>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>你可以使用<strong>if</strong>语句来运行满足某个条件的语句。</p>
<p>如果表达式的结果是<strong>True</strong>，某些语句会执行。否则，它们不会被执行。</p>
<p>一个if语句看起来像是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">   statements</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python使用缩进(在行首的空白)的方式来限制代码块。其他语言，例如C语言，使用花括号来表示代码块，但在Python中缩进是强制性的，程序没有缩进就不会正常工作。正如你看到的<strong>if</strong>里的语句应该被缩进。</p>
</blockquote>
<p>下面是一个<strong>if</strong>语句的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">10</span> &gt; <span class="number">5</span>:</span><br><span class="line">   print(<span class="string">&quot;10 greater than 5&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Program ended&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>判断表达式10是否大于5，如果是，则执行缩进的语句，输出<code>10 greater than 5</code>，然后执行后面没有缩进的语句。</p>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">10</span> greater than <span class="number">5</span></span><br><span class="line">Program ended</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>注意<strong>冒号</strong>在<strong>if</strong>语句的末尾处。</p>
<blockquote>
<p>由于程序包含多行代码，因此应将其创建为单独的代码文件来运行。</p>
</blockquote>
<h3 id="if的嵌套"><a href="#if的嵌套" class="headerlink" title="if的嵌套"></a>if的嵌套</h3><p>为了执行更严格的条件检查，<strong>if</strong>语句可以嵌套使用，嵌套在另一个if语句中。这意味着内部的<strong>if</strong>语句是外部的<strong>if</strong>语句的一部分，这是一种查看是否满足多个条件的方法。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">5</span>:</span><br><span class="line">   print(<span class="string">&quot;Bigger than 5&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> num &lt;=<span class="number">47</span>:</span><br><span class="line">      print(<span class="string">&quot;Between 5 and 47&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">Bigger than <span class="number">5</span></span><br><span class="line">Between <span class="number">5</span> <span class="keyword">and</span> <span class="number">47</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="else语句"><a href="#else语句" class="headerlink" title="else语句"></a>else语句</h2><p>一个<strong>else</strong>语句跟在一个<strong>if</strong>语句后面，并且包含当<strong>if</strong>条件语句执行结果为<strong>False</strong>时执行的代码。</p>
<p>与<strong>if</strong>语句一样，内部的代码块也应该缩进。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">4</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">5</span>:</span><br><span class="line">   print(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; </span><br><span class="line">No</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="if和else嵌套使用"><a href="#if和else嵌套使用" class="headerlink" title="if和else嵌套使用"></a>if和else嵌套使用</h3><p>你可以将<strong>if</strong>和<strong>else</strong>连接起来，来判断一系列的对错情况，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">5</span>:</span><br><span class="line">  print(<span class="string">&quot;Number is 5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">  <span class="keyword">if</span> num == <span class="number">11</span>:</span><br><span class="line">    print(<span class="string">&quot;Number is 11&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">7</span>:</span><br><span class="line">      print(<span class="string">&quot;Number is 7&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">      print(<span class="string">&quot;Number isn&#x27;t 5, 11 or 7&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">Number <span class="keyword">is</span> <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<h3 id="elif语句"><a href="#elif语句" class="headerlink" title="elif语句"></a>elif语句</h3><p><strong>elif</strong>(<code>else if</code>的缩写)语句是<code>if</code>和<code>else</code>连起来使用的一个缩写形式。一系列的<strong>elif</strong>判断需要用一个<strong>else</strong>来收尾，用于判断<strong>if</strong>或<strong>elif</strong>以外的情况。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">5</span>:</span><br><span class="line">   print(<span class="string">&quot;Number is 5&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">11</span>:</span><br><span class="line">   print(<span class="string">&quot;Number is 11&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">7</span>:</span><br><span class="line">   print(<span class="string">&quot;Number is 7&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">&quot;Number isn&#x27;t 5, 11 or 7&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">Number <span class="keyword">is</span> <span class="number">7</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在其他的编程语言中，<strong>elif</strong>语句有多种名称，包括<strong>else if</strong>,<strong>elseif</strong>或者<strong>elsif</strong>。</p>
</blockquote>
<h2 id="布尔逻辑"><a href="#布尔逻辑" class="headerlink" title="布尔逻辑"></a>布尔逻辑</h2><p>当<strong>if</strong>语句依赖多个条件时，使用<strong>布尔(Boolean)逻辑</strong>可以用来生成更复杂的条件。</p>
<p>Python的布尔操作符是<strong>and</strong>，<strong>or</strong>和<strong>not</strong>。</p>
<h3 id="布尔逻辑-and"><a href="#布尔逻辑-and" class="headerlink" title="布尔逻辑 and"></a>布尔逻辑 and</h3><p><strong>and</strong>操作符接受两个参数，并且当且仅当两个参数都为<strong>True</strong>时，计算结果才为<strong>True</strong>。否则，计算结果是<strong>False</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> == <span class="number">3</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> != <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span> &gt;  <span class="number">6</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python用直白的单词来表示布尔逻辑，而其他大多数编程语言使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>这些符号来表示。</p>
</blockquote>
<h3 id="布尔逻辑-or"><a href="#布尔逻辑-or" class="headerlink" title="布尔逻辑 or"></a>布尔逻辑 or</h3><p><strong>or</strong>操作符也接受两个参数，当两个参数至少有一个为<strong>True</strong>时，计算结果就为<strong>True</strong>；否则，当两个参数都为<strong>False</strong>时，计算结果为<strong>False</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> == <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> == <span class="number">3</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> != <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> &lt; <span class="number">1</span> <span class="keyword">or</span> <span class="number">3</span> &gt;  <span class="number">6</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔逻辑-not"><a href="#布尔逻辑-not" class="headerlink" title="布尔逻辑 not"></a>布尔逻辑 not</h3><p>不像其他我们已经看到的操作符那样，<strong>not</strong>操作符只接受一个参数，并且计算结果是取反。<strong>True</strong>的<strong>not</strong>结果是<strong>False</strong>，而且<strong>not False</strong>的计算结果是<strong>True</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="number">1</span> &gt; <span class="number">7</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过布尔逻辑，你可以在if的条件语句中连接多个条件。</p>
</blockquote>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><strong>运算符优先级</strong>是编程中非常重要的概念。这个概念是数学中运算顺序的一种延伸（例如前面提到的乘法操作），用于包含多个其他的操作符，例如布尔逻辑。</p>
<p>下面的代码展示了<code>==</code>运算符拥有比<code>or</code>更高的优先级：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> == <span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span> == (<span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="literal">False</span> == <span class="literal">False</span>) <span class="keyword">or</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python的运算符顺序与数学中的运算顺序是一致的：括号优先，然后是幂运算，然后是乘/除法运算，然后是加/减法运算。</p>
</blockquote>
<p>下面的表按照优先级从高到低展示了Python中所有的运算符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>**</code></td>
<td style="text-align:left">指数 (最高优先级)</td>
</tr>
<tr>
<td style="text-align:left"><code>~</code> <code>+</code> <code>-</code></td>
<td style="text-align:left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td style="text-align:left">乘，除，取模和取整除</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code> <code>-</code></td>
<td style="text-align:left">加法减法</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td style="text-align:left">右移，左移运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">位 ‘AND’</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code> &#124;</td>
<td style="text-align:left">位运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td style="text-align:left">比较运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&gt;</code> <code>==</code> <code>!=</code></td>
<td style="text-align:left">等于运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>=</code> <code>%=</code> <code>/=</code> <code>//=</code> <code>-=</code> <code>+=</code> <code>*=</code> <code>**=</code></td>
<td style="text-align:left">赋值运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>is</code> <code>is not</code></td>
<td style="text-align:left">身份运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>in</code> <code>not in</code></td>
<td style="text-align:left">成员运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>not</code> <code>or</code> <code>and</code></td>
<td style="text-align:left">逻辑运算符</td>
</tr>
</tbody>
</table>
</div>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>一个<strong>if</strong>语句在条件为<strong>True</strong>时会执行一次，如果为<strong>False</strong>则不执行。<strong>while</strong>语句会在条件满足时执行多次。只要条件为<strong>True</strong>，while内部的语句就会重复的执行下去。一旦条件为<strong>False</strong>，就会跳出循环，继续执行后面的代码。</p>
<p>下面是一个<strong>while</strong>循环，包含一个从1到5自增长用来计数的变量，直到i的值达到了循环的终点就会跳出循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;=<span class="number">5</span>:</span><br><span class="line">   print(i)</span><br><span class="line">   i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Finished!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Finished!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>while</strong>内部循环执行的的代码被称为<strong>迭代(iteration)</strong>。</p>
</blockquote>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p><strong>无限循环</strong>是一种特殊的while循环；它永远都不会停止运行。它的判断条件一直是<strong>True</strong>    。</p>
<p>下面是一个无限循环的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>==<span class="number">1</span>:</span><br><span class="line">  print(<span class="string">&quot;In the loop&quot;</span>) </span><br></pre></td></tr></table></figure>
<p>这个程序会无限的打印<code>In the loop</code>。</p>
<blockquote>
<p>你可以通过按下快捷键<strong>Ctrl-C</strong>来终止程序的执行，从而中断这个无限循环。</p>
</blockquote>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>通过使用<strong>break</strong>语句，可以提前跳出<strong>while</strong>循环的执行。<strong>break</strong>可以立刻中断<strong>while</strong>内部的循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>==<span class="number">1</span>:</span><br><span class="line">  print(i)</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> i &gt;= <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">&quot;Breaking&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Finished&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Breaking</span><br><span class="line">Finished</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在循环外使用<strong>break</strong>会产生错误。</p>
</blockquote>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>另一个可以用在循环内的语句是<strong>continue</strong>。</p>
<p>不同于<strong>break</strong>，<strong>continue</strong>会跳回到循环的顶部而不是停止循环的执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   i = i +<span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">      print(<span class="string">&quot;Skipping 2&quot;</span>)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">      print(<span class="string">&quot;Breaking&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   print(i)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Finished&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Skipping <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Breaking</span><br><span class="line">Finished</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>continue</strong>语句会停止当前这一次的迭代项，并且继续执行下一次项。</p>
<blockquote>
<p>在循环外使用<strong>continue</strong>会产生错误。</p>
</blockquote>
<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h2><p><strong>列表(List)</strong>是另一个Python对象，它可以用于存储条目的索引列表。<br>列表可以通过一个<strong>方括号(<code>[]</code>)</strong>来构建，内部的条目用<strong>逗号(<code>,</code>)</strong>隔开。</p>
<p>可以通过使用其在方括号中的索引来访问列表中的特定项。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>]</span><br><span class="line">print(words[<span class="number">0</span>])</span><br><span class="line">print(words[<span class="number">1</span>])</span><br><span class="line">print(words[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;python</span><br><span class="line">Hello</span><br><span class="line">world</span><br><span class="line">!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个列表项的索引值是<strong>0</strong>，而不是<strong>1</strong>。</p>
</blockquote>
<p>一个空的列表可以通过一对方括号来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">empty_list = []</span><br><span class="line">print(empty_list)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大多数情况下，列表的最后一个条目后是不用添加逗号的。但是如果你添加了逗号，那就表明在最后占了一个位置，在某些情况下这种做法也是被推荐的。</p>
</blockquote>
<p>列表通常包含着同一种类型的数据，但你也完全可以添加不同类型的数据到列表中。列表本身也可以嵌套在其他列表中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number = <span class="number">3</span></span><br><span class="line">things = [<span class="string">&quot;string&quot;</span>, <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, number], <span class="number">4.56</span>]</span><br><span class="line">print(things[<span class="number">1</span>])</span><br><span class="line">print(things[<span class="number">2</span>])</span><br><span class="line">print(things[<span class="number">2</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表嵌套列表是通常用于表示二维网格，Python缺少像其他语言中的<strong>多维数组</strong>的结构，可以通过嵌套列表来实现。</p>
</blockquote>
<p>索引超出列表长度的边界会导致<strong>IndexError</strong>。</p>
<p>有些类型，如<strong>字符串(strings)</strong>，可以像<strong>列表(List)</strong>一样被索引。索引字符串的行为就好像你在索引一个包含了每个字符的列表所组成的字符串。</p>
<p>对于其他类型，例如<strong>整数(integers)</strong>，它们是不可以被索引的，如果对它使用索引会导致TypeError。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">print(<span class="built_in">str</span>[<span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">w</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="列表操作-List-Operations"><a href="#列表操作-List-Operations" class="headerlink" title="列表操作(List Operations)"></a>列表操作(List Operations)</h2><p>列表中的某个位置的条目可以重新赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>列表可以像字符串一样执行<strong>加法</strong>和<strong>乘法</strong>操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(nums + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(nums * <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表和字符串在很多情况下是相似的，字符串可以想象成是字符组成的不可变列表。</p>
</blockquote>
<hr>
<p>可以通过<strong>in</strong>操作符来检测某个条目是否存在于某个列表中。如果当前条目在列表中存在一份或多份时，返回<strong>True</strong>，否则返回<strong>False</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;egg&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;sausage&quot;</span>]</span><br><span class="line">print(<span class="string">&quot;spam&quot;</span> <span class="keyword">in</span> words)</span><br><span class="line">print(<span class="string">&quot;egg&quot;</span> <span class="keyword">in</span> words)</span><br><span class="line">print(<span class="string">&quot;tomato&quot;</span> <span class="keyword">in</span> words)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>in</strong>操作符也可以用来判断某个字符串是否是另一个字符串的子字符串。</p>
</blockquote>
<hr>
<p>可以通过<strong>not</strong>操作符来判断某个条目是否不在列表中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(<span class="keyword">not</span> <span class="number">4</span> <span class="keyword">in</span> nums)</span><br><span class="line">print(<span class="number">4</span> <span class="keyword">not</span> <span class="keyword">in</span> nums)</span><br><span class="line">print(<span class="keyword">not</span> <span class="number">3</span> <span class="keyword">in</span> nums)</span><br><span class="line">print(<span class="number">3</span> <span class="keyword">not</span> <span class="keyword">in</span> nums)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><h2 id="列表方法-List-Functions"><a href="#列表方法-List-Functions" class="headerlink" title="列表方法(List Functions)"></a>列表方法(List Functions)</h2><p>另外一种改变列表的方式是通过<strong>append</strong>函数。这个函数会添加一个元素到列表的末尾。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">nums.append(<span class="number">4</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><p>可以通过<strong>len</strong>函数来获取列表中元素的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">print(<span class="built_in">len</span>(nums))</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><p><strong>insert</strong>方法和<strong>append</strong>类似，不同的是，它可以在列表的任何位置插入指定的元素，而不是仅仅跟在列表最后。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;fun&quot;</span>]</span><br><span class="line">index = <span class="number">1</span></span><br><span class="line">words.insert(index, <span class="string">&quot;is&quot;</span>)</span><br><span class="line">print(words)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><p><strong>index</strong>方法会找到元素第一次出现的所在位置索引值，如果元素不在列表中，会抛出一个ValueError。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">letters = [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]</span><br><span class="line">print(letters.index(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">print(letters.index(<span class="string">&#x27;p&#x27;</span>))</span><br><span class="line">print(letters.index(<span class="string">&#x27;z&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">ValueError: <span class="string">&#x27;z&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下面有几个列表的更有用的方法：</p>
<ul>
<li><strong>max</strong>(list): 返回列表中最大的元素。</li>
<li><strong>min</strong>(list): 返回列表中最小的元素。</li>
<li>list.<strong>count</strong>(obj): 返回列表中指定元素的出现次数。</li>
<li>list.<strong>remove</strong>(obj): 移除列表中的一个指定元素。</li>
<li>list.<strong>reverse</strong>(): 将列表中的元素顺序翻转。</li>
</ul>
</blockquote>
<hr>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><strong>range</strong>方法会创建一个包含数字序列的列表。下面的代码会生成一组0到10之间(包含0不包含10)的整数的序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><p>如果<strong>range</strong>方法传入一个参数，那么它将产生一组包含0到那个参数的数字序列。</p>
<p>如果包含两个参数，那么它将产生第一个参数到第二个参数之间的数字序列。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">range</span>(<span class="number">20</span>) == <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-5"><a href="#-5" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><p><strong>range</strong>可以拥有第三个用来决定步数的参数。这个参数必须是一个<strong>整形(integer)</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">20</span>, <span class="number">2</span>))</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>有时，你需要对列表中的元素依次执行运算，这种操作叫做<strong>迭代(iteration)</strong>。迭代可以通过<strong>while</strong>循环以及一个条件变量来实现。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>]</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">max_index = <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counter &lt;= max_index:</span><br><span class="line">   word = words[counter]</span><br><span class="line">   print(word + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">   counter = counter + <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">hello!</span><br><span class="line">world!</span><br><span class="line">spam!</span><br><span class="line">eggs!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><h3 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h3><p>使用<strong>while</strong>来对列表进行迭代操作需要写的代码有点多，所以Python提供了一种<strong>for</strong>循环的方式来更简便的实现这一操作。</p>
<p>同样的代码用<strong>for</strong>循环来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">  print(word + <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">hello!</span><br><span class="line">world!</span><br><span class="line">spam!</span><br><span class="line">eggs!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python中的<strong>for</strong>循环，就像其他语言中的<strong>foreach</strong>循环一样。</p>
</blockquote>
<hr>
<p><strong>for</strong>循环通常用于重复某一代码执行一定次数。这种操作可以通过与<strong>range</strong>对象结合使用来完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">  print(<span class="string">&quot;hello!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<h2 id="-8"><a href="#-8" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">hello!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></h2><h2 id="一个简单的计算器"><a href="#一个简单的计算器" class="headerlink" title="一个简单的计算器"></a>一个简单的计算器</h2><h3 id="创建一个计算器"><a href="#创建一个计算器" class="headerlink" title="创建一个计算器"></a>创建一个计算器</h3><p>这节课介绍一个Python程序的示例：一个简单的计算器。</p>
<p>第一部分是整体菜单部分。它将持续接受用户的输入，直到用户输入了“quit”为止，因此用到了一个<strong>while</strong>循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   print(<span class="string">&quot;Options:&quot;</span>)</span><br><span class="line">   print(<span class="string">&quot;Enter &#x27;add&#x27; to add two numbers&quot;</span>)</span><br><span class="line">   print(<span class="string">&quot;Enter &#x27;subtract&#x27; to subtract two numbers&quot;</span>)</span><br><span class="line">   print(<span class="string">&quot;Enter &#x27;multiply&#x27; to multiply two numbers&quot;</span>)</span><br><span class="line">   print(<span class="string">&quot;Enter &#x27;divide&#x27; to divide two numbers&quot;</span>)</span><br><span class="line">   print(<span class="string">&quot;Enter &#x27;quit&#x27; to end the program&quot;</span>)</span><br><span class="line">   user_input = <span class="built_in">input</span>(<span class="string">&quot;: &quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> user_input == <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">elif</span> user_input == <span class="string">&quot;add&quot;</span>:</span><br><span class="line">      ...</span><br><span class="line">   <span class="keyword">elif</span> user_input == <span class="string">&quot;subtract&quot;</span>:</span><br><span class="line">      ...</span><br><span class="line">   <span class="keyword">elif</span> user_input == <span class="string">&quot;multiply&quot;</span>:</span><br><span class="line">      ...</span><br><span class="line">   <span class="keyword">elif</span> user_input == <span class="string">&quot;divide&quot;</span>:</span><br><span class="line">      ...</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">      print(<span class="string">&quot;Unknown input&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这部分代码是程序的开始部分。它将接受用户的输入，并且比较<strong>if/elif</strong>的条件语句。</p>
<p>当用户输入了“quit”时，<strong>break</strong>语句用来终止while循环的执行。</p>
</blockquote>
<hr>
<p>接下来一部分的代码是获取用户输入的数字。下面的代码展示了加法部分的逻辑。其他操作的代码也与此类似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> user_input == <span class="string">&quot;add&quot;</span>:</span><br><span class="line">  num1 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a number: &quot;</span>))</span><br><span class="line">  num2 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter another number: &quot;</span>))</span><br></pre></td></tr></table></figure>
<p>现在，当用户输入了“add”时，程序提示输入两个数字，并且存储到相应的变量中。</p>
<blockquote>
<p>当提示输入数字时，如果用户输入了一个非数字的字符，那么会产生一个崩溃。我们会在后面的章节来修复这个类似的问题。</p>
</blockquote>
<hr>
<p>最后一部分是处理用户输入，并且展示结果。</p>
<p>加法部分的逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> user_input == <span class="string">&quot;add&quot;</span>:</span><br><span class="line">  num1 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a number: &quot;</span>))</span><br><span class="line">  num2 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter another number: &quot;</span>))</span><br><span class="line">  result = <span class="built_in">str</span>(num1 + num2)</span><br><span class="line">  print(<span class="string">&quot;The answer is &quot;</span> + result)</span><br></pre></td></tr></table></figure>
<p>我们现在有了一个可以正常工作程序：提示用户输入，然后计算和打印输入的和。</p>
<blockquote>
<p>其他分支(减法，乘法，除法)的代码结构类似，可以自行补全。</p>
<p>输出行可以放在<strong>if</strong>语句之外，以省略重复的代码。</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python3教程 第3章】方法和模块</title>
    <url>/2017/02/04/%E3%80%90Python3%E6%95%99%E7%A8%8B%20%E7%AC%AC3%E7%AB%A0%E3%80%91%E6%96%B9%E6%B3%95%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】TensorBoard:可视化学习</title>
    <url>/2017/03/07/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91TensorBoard-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>你使用TensorFlow来进行的某些大规模深度神经网络，可能是很复杂，并且令人困惑的。为了使它更容易被理解、调试、并且优化TensorFlow程序，我们引入了一套可视化工具，它就是TensorBoard。你可以使用TensorBoard来可视化你的TensorFlow计算图，绘制关于图形执行的定量指标，以及显示其他数据的图像。</p>
<p>当TensorBoard完全配置好时，它看起来是这样的：</p>
<p><img src="/img/17_03_07/001.png" alt=""></p>
<p>本教程旨在帮助您学习TensorBoard的基本使用方式。当然，还有其他介绍资源！<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tensorboard/README.md">TensorBoard README</a>有大量关于TensorBoard的信息，包括提示和技巧和调试信息。</p>
<h2 id="序列化数据"><a href="#序列化数据" class="headerlink" title="序列化数据"></a>序列化数据</h2><p>TensorBoard通过读取TensorFlow事件文件进行操作，这些文件包含运行TensorFlow时可以生成的摘要数据。下面是TensorBoard中摘要数据的一般生命周期。</p>
<p>首先，创建要从其中收集摘要数据的TensorFlow图，并决定要使用<a href="https://www.tensorflow.org/api_guides/python/summary">summary operations</a>注释哪些节点。</p>
<p>例如，假设你正在训练一个卷积神经网络来识别MNIST数字。你想记录学习速率随时间的变化，以及目标函数如何变化。通过将<a href="https://www.tensorflow.org/api_docs/python/tf/summary/scalar"><code>tf.summary.scalar</code></a>操作分别附加到输出学习速率和损失的节点来收集这些信息。然后，给每个<code>scalar_summary</code>赋予有意义的<code>tag</code>，如<code>learning rate</code>或<code>loss function</code>。</p>
<p>也许你也想要可视化来自特定层的激活的分布，或梯度或权重的分布。通过将<a href="https://www.tensorflow.org/api_docs/python/tf/summary/histogram"><code>tf.summary.histogram</code></a>操作附加到梯度输出和分别保存您的权重的变量来收集此数据。</p>
<p>有关所有可用摘要操作的详细信息，请查看<a href="https://www.tensorflow.org/api_guides/python/summary">摘要操作的文档</a>。</p>
<p>在您运行TensorFlow中的操作之前，它们都不会被运行，依赖于它们的输出的操作也不会被执行。我们刚刚创建的汇总节点是图形的外设：您当前运行的任何操作都不依赖于它们。因此，要生成摘要，我们需要运行所有这些摘要节点。手动管理它们将是一项乏味的工作，因此我们使用<a href="https://www.tensorflow.org/api_docs/python/tf/summary/merge_all"><code>tf.summary.merge_all</code></a>将它们组合到一个单独的操作中，生成所有的摘要数据。</p>
<p>然后，您可以运行合并的摘要操作，这将生成一个包含有所有给定步骤的摘要数据的序列化的<code>Summary</code>（摘要）protobuf对象。最后，要将此摘要数据写入磁盘，将摘要protobuf传递给<a href="https://www.tensorflow.org/api_docs/python/tf/summary/FileWriter"><code>tf.summary.FileWriter</code></a>。</p>
<p><code>FileWriter</code>在它的构造函数中接受一个logdir - 这个logdir是非常重要的，它是所有事件将被写出的目标目录。此外，<code>FileWriter</code>可以选择在其构造函数中接受一个<code>Graph</code>。如果它接收到一个<code>Graph</code>对象，那么TensorBoard将与Tensor形状信息一起显示到界面上。这将使您更好地了解通过图形流动的信息：请参阅<a href="https://www.tensorflow.org/get_started/graph_viz#tensor_shape_information">Tensor shape信息</a>。</p>
<p>现在，你已经修改好了你的图，并且有了一个<code>FileWriter</code>，并且做好了开始运行网络的准备!如果需要，您可以每一步运行一次摘要合并，并记录大量的训练数据。这可能会产生很多你不需要的数据。所以换一种方式，请考虑每n个步骤运行一次摘要合并操作。</p>
<p>下面的代码示例是一个<a href="https://www.tensorflow.org/get_started/mnist/beginners">简单的MNIST教程</a>的修改，其中我们添加了一些摘要操作，并且每十步运行它们一次。如果你运行这个代码，然后启动<code>tensorboard --logdir=/tmp/mnist_logs</code>，你将能够可视化统计，例如权重或精度在训练期间如何变化。下面是部分代码，全部源码在<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/mnist_with_summaries.py">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def variable_summaries(var):</span><br><span class="line">  &quot;&quot;&quot;Attach a lot of summaries to a Tensor (for TensorBoard visualization).&quot;&quot;&quot;</span><br><span class="line">  with tf.name_scope(&#39;summaries&#39;):</span><br><span class="line">    mean &#x3D; tf.reduce_mean(var)</span><br><span class="line">    tf.summary.scalar(&#39;mean&#39;, mean)</span><br><span class="line">    with tf.name_scope(&#39;stddev&#39;):</span><br><span class="line">      stddev &#x3D; tf.sqrt(tf.reduce_mean(tf.square(var - mean)))</span><br><span class="line">    tf.summary.scalar(&#39;stddev&#39;, stddev)</span><br><span class="line">    tf.summary.scalar(&#39;max&#39;, tf.reduce_max(var))</span><br><span class="line">    tf.summary.scalar(&#39;min&#39;, tf.reduce_min(var))</span><br><span class="line">    tf.summary.histogram(&#39;histogram&#39;, var)</span><br><span class="line"></span><br><span class="line">def nn_layer(input_tensor, input_dim, output_dim, layer_name, act&#x3D;tf.nn.relu):</span><br><span class="line">  &quot;&quot;&quot;Reusable code for making a simple neural net layer.</span><br><span class="line"></span><br><span class="line">  It does a matrix multiply, bias add, and then uses relu to nonlinearize.</span><br><span class="line">  It also sets up name scoping so that the resultant graph is easy to read,</span><br><span class="line">  and adds a number of summary ops.</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  # Adding a name scope ensures logical grouping of the layers in the graph.</span><br><span class="line">  with tf.name_scope(layer_name):</span><br><span class="line">    # This Variable will hold the state of the weights for the layer</span><br><span class="line">    with tf.name_scope(&#39;weights&#39;):</span><br><span class="line">      weights &#x3D; weight_variable([input_dim, output_dim])</span><br><span class="line">      variable_summaries(weights)</span><br><span class="line">    with tf.name_scope(&#39;biases&#39;):</span><br><span class="line">      biases &#x3D; bias_variable([output_dim])</span><br><span class="line">      variable_summaries(biases)</span><br><span class="line">    with tf.name_scope(&#39;Wx_plus_b&#39;):</span><br><span class="line">      preactivate &#x3D; tf.matmul(input_tensor, weights) + biases</span><br><span class="line">      tf.summary.histogram(&#39;pre_activations&#39;, preactivate)</span><br><span class="line">    activations &#x3D; act(preactivate, name&#x3D;&#39;activation&#39;)</span><br><span class="line">    tf.summary.histogram(&#39;activations&#39;, activations)</span><br><span class="line">    return activations</span><br><span class="line"></span><br><span class="line">hidden1 &#x3D; nn_layer(x, 784, 500, &#39;layer1&#39;)</span><br><span class="line"></span><br><span class="line">with tf.name_scope(&#39;dropout&#39;):</span><br><span class="line">  keep_prob &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">  tf.summary.scalar(&#39;dropout_keep_probability&#39;, keep_prob)</span><br><span class="line">  dropped &#x3D; tf.nn.dropout(hidden1, keep_prob)</span><br><span class="line"></span><br><span class="line"># Do not apply softmax activation yet, see below.</span><br><span class="line">y &#x3D; nn_layer(dropped, 500, 10, &#39;layer2&#39;, act&#x3D;tf.identity)</span><br><span class="line"></span><br><span class="line">with tf.name_scope(&#39;cross_entropy&#39;):</span><br><span class="line">  # The raw formulation of cross-entropy,</span><br><span class="line">  #</span><br><span class="line">  # tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(tf.softmax(y)),</span><br><span class="line">  #                               reduction_indices&#x3D;[1]))</span><br><span class="line">  #</span><br><span class="line">  # can be numerically unstable.</span><br><span class="line">  #</span><br><span class="line">  # So here we use tf.nn.softmax_cross_entropy_with_logits on the</span><br><span class="line">  # raw outputs of the nn_layer above, and then average across</span><br><span class="line">  # the batch.</span><br><span class="line">  diff &#x3D; tf.nn.softmax_cross_entropy_with_logits(targets&#x3D;y_, logits&#x3D;y)</span><br><span class="line">  with tf.name_scope(&#39;total&#39;):</span><br><span class="line">    cross_entropy &#x3D; tf.reduce_mean(diff)</span><br><span class="line">tf.summary.scalar(&#39;cross_entropy&#39;, cross_entropy)</span><br><span class="line"></span><br><span class="line">with tf.name_scope(&#39;train&#39;):</span><br><span class="line">  train_step &#x3D; tf.train.AdamOptimizer(FLAGS.learning_rate).minimize(</span><br><span class="line">      cross_entropy)</span><br><span class="line"></span><br><span class="line">with tf.name_scope(&#39;accuracy&#39;):</span><br><span class="line">  with tf.name_scope(&#39;correct_prediction&#39;):</span><br><span class="line">    correct_prediction &#x3D; tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))</span><br><span class="line">  with tf.name_scope(&#39;accuracy&#39;):</span><br><span class="line">    accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">tf.summary.scalar(&#39;accuracy&#39;, accuracy)</span><br><span class="line"></span><br><span class="line"># Merge all the summaries and write them out to &#x2F;tmp&#x2F;mnist_logs (by default)</span><br><span class="line">merged &#x3D; tf.summary.merge_all()</span><br><span class="line">train_writer &#x3D; tf.summary.FileWriter(FLAGS.summaries_dir + &#39;&#x2F;train&#39;,</span><br><span class="line">                                      sess.graph)</span><br><span class="line">test_writer &#x3D; tf.summary.FileWriter(FLAGS.summaries_dir + &#39;&#x2F;test&#39;)</span><br><span class="line">tf.global_variables_initializer().run()</span><br></pre></td></tr></table></figure>
<p>在我们初始化<code>FileWriter</code>之后，我们在训练和测试模型时，必须向<code>FileWriter</code>添加摘要。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Train the model, and also write summaries.</span><br><span class="line"># Every 10th step, measure test-set accuracy, and write test summaries</span><br><span class="line"># All other steps, run train_step on training data, &amp; add training summaries</span><br><span class="line"></span><br><span class="line">def feed_dict(train):</span><br><span class="line">  &quot;&quot;&quot;Make a TensorFlow feed_dict: maps data onto Tensor placeholders.&quot;&quot;&quot;</span><br><span class="line">  if train or FLAGS.fake_data:</span><br><span class="line">    xs, ys &#x3D; mnist.train.next_batch(100, fake_data&#x3D;FLAGS.fake_data)</span><br><span class="line">    k &#x3D; FLAGS.dropout</span><br><span class="line">  else:</span><br><span class="line">    xs, ys &#x3D; mnist.test.images, mnist.test.labels</span><br><span class="line">    k &#x3D; 1.0</span><br><span class="line">  return &#123;x: xs, y_: ys, keep_prob: k&#125;</span><br><span class="line"></span><br><span class="line">for i in range(FLAGS.max_steps):</span><br><span class="line">  if i % 10 &#x3D;&#x3D; 0:  # Record summaries and test-set accuracy</span><br><span class="line">    summary, acc &#x3D; sess.run([merged, accuracy], feed_dict&#x3D;feed_dict(False))</span><br><span class="line">    test_writer.add_summary(summary, i)</span><br><span class="line">    print(&#39;Accuracy at step %s: %s&#39; % (i, acc))</span><br><span class="line">  else:  # Record train set summaries, and train</span><br><span class="line">    summary, _ &#x3D; sess.run([merged, train_step], feed_dict&#x3D;feed_dict(True))</span><br><span class="line">    train_writer.add_summary(summary, i)</span><br></pre></td></tr></table></figure>
<p>现在，你就可以通过TensorBoard来可视化数据了。</p>
<h2 id="启动TensorBoard"><a href="#启动TensorBoard" class="headerlink" title="启动TensorBoard"></a>启动TensorBoard</h2><p>要运行TensorBoard，请使用以下命令（或者<code>python -m tensorflow.tensorboard</code>）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir&#x3D;path&#x2F;to&#x2F;log-directory</span><br></pre></td></tr></table></figure>
<p>其中<code>logdir</code>指向<code>FileWriter</code>将其数据序列化的目录。如果此logdir目录包含包含单独运行的序列化数据的子目录，则TensorBoard将可视化所有这些运行的数据。TensorBoard开始运行之后，就可以打开您的Web浏览器到<code>localhost:6006</code>来查看TensorBoard了。</p>
<p>当你看着TensorBoard，你会看到在右上角的导航选项卡。每个选项卡表示可以可视化的一组序列化数据。</p>
<p>有关如何使用图形选项卡可视化图形的详细信息，请参阅<a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-图的可视化/">TensorBoard：图形可视化</a>。</p>
<p>有关TensorBoard的更多使用信息，请参阅<a href="https://www.tensorflow.org/code/tensorflow/tensorboard/README.md">TensorBoard README</a>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】TensorBoard:图的可视化</title>
    <url>/2017/03/07/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91TensorBoard-%E5%9B%BE%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>TensorFlow计算图是强大而复杂的。图形可视化可以帮助您理解和调试它们。这里有一个可视化工作的例子。</p>
<p><img src="/img/17_03_07/007.gif" alt=""></p>
<p><em>TensorFlow图的可视化。</em></p>
<p>如有想查看你的图，你需要运行TensorBoard并将其指向你的作业的日志目录，单击顶部窗格上的图形选项卡，然后使用左上角的菜单选择适当的运行。有关如何运行TensorBoard并确保您记录所有必要信息的深入信息，请参阅<a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-可视化学习/">TensorBoard：可视化学习</a>。</p>
<h2 id="名称作用域和节点"><a href="#名称作用域和节点" class="headerlink" title="名称作用域和节点"></a>名称作用域和节点</h2><p>典型的TensorFlow图可以有成千上万的节点 - 这个展示量太大了，以至于即使使用标准图工具来布局也太大了。为了简化显示，我们通过变量名指定其对应的作用域，通过使用这些信息来定义图中节点图层的可视化。默认情况下，只显示此层次结构的顶部部分。下面是一个使用<a href="https://www.tensorflow.org/api_docs/python/tf/name_scope"><code>tf.name_scope</code></a>在隐藏名称范围下定义三个操作的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">with tf.name_scope(&#39;hidden&#39;) as scope:</span><br><span class="line">  a &#x3D; tf.constant(5, name&#x3D;&#39;alpha&#39;)</span><br><span class="line">  W &#x3D; tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0), name&#x3D;&#39;weights&#39;)</span><br><span class="line">  b &#x3D; tf.Variable(tf.zeros([1]), name&#x3D;&#39;biases&#39;)</span><br></pre></td></tr></table></figure>
<p>这将产生以下三个操作名称：</p>
<ul>
<li><code>hidden/alpha</code></li>
<li><code>hidden/weights</code></li>
<li><code>hidden/biases</code></li>
</ul>
<p>默认情况下，可视化将这三个操作压缩到标记为<code>hidden</code>的节点中。额外的细节不会丢失。您可以双击或单击右上角的橙色<code>+</code>号来展开节点，然后您将看到三个子节点的<code>alpha</code>，<code>weights</code>和<code>biases</code>。</p>
<p>这是一个在初始化和展开状态更复杂的真实例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/008.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/009.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">顶层名称作用域<strong>pool_1</strong>的初始化视图。单击右上角的橙色<code>+</code>按钮或双击节点本身将会展开它。</td>
<td style="text-align:left"><strong>pool_1</strong>名称作用域的展开视图。单击右上角的橙色按钮或双击节点本身将折叠名称作用域。</td>
</tr>
</tbody>
</table>
</div>
<p>按名称范围对节点分组对于创建清晰的图表至关重要。如果您正在构建模型，名称作用域可以控制生成的可视化。<strong>你的名字的作用域越好，可视化效果越好。</strong></p>
<p>上图说明了可视化的第二个方面。TensorFlow图有两种连接：数据依赖和控制依赖。数据依赖显示了两个操作之间的tensor流，并且示为实箭头，而控制依赖使用虚线。在扩展视图（上图右侧）中，所有连接都是数据依赖关系，但连接<code>CheckNumerics</code>和<code>control_dependency</code>的虚线除外。</p>
<p>还有第二种简化布局的小技巧。大多数TensorFlow图都存在几个与其他节点有很多连接的节点。例如，许多节点可能对初始化步骤具有控制依赖性。绘制<code>init</code>节点以及其依赖项之间的所有边将创建一个非常混乱的视图。</p>
<p>为了减少杂乱程度，可视化将所有高度节点分离到右侧的辅助区域，并且不绘制代表它们边缘的线。相对于用线来表示边缘来讲，这里我们绘制小节点图标以指示连接关系。分离出辅助节点通常不会移除关键信息，因为这些节点通常与记录方法相关。有关如何在主图和辅助区域之间移动节点，请参阅<a href="#交互">交互</a>部分。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/010.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/011.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">节点<strong>conv_1</strong>已被连接到<strong>save</strong>。注意它右边的小<strong>save</strong>节点图标。</td>
<td style="text-align:left"><strong>save</strong>有高度，并且将作为辅助节点出现。与<strong>conv_1</strong>的连接在其左侧显示为节点图标。为了进一步减少杂乱程度，由于<strong>save</strong>有很多连接，我们显示到第5个，其他缩写为<strong>… 12 more</strong>。</td>
</tr>
</tbody>
</table>
</div>
<p>最后一个结构简化是series collapsing(系列折叠)。有顺序的图案 - 也就是说，其名称与末尾的数字不同并且具有相同构结构的节点被折叠为单个节点堆叠，如下所示。对于具有长序列的网络，这极大地简化了视图的显示。与分层节点一样，双击也可以展开。有关如何为特定节点集禁用/启用系列折叠，请参阅<a href="#交互">交互</a>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/012.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/013.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">节点序列的折叠视图。</td>
<td style="text-align:left">双击后的一个小块的展开视图。</td>
</tr>
</tbody>
</table>
</div>
<p>最后，作为可读性的最后一个辅助部分，可视化对常量和摘要节点使用一些特定的图标来。下面是一个节点符号对照表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/014.png" alt=""></td>
<td style="text-align:left">高级节点，代表名称作用域。双击展开高级节点。</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/015.png" alt=""></td>
<td style="text-align:left">编号节点序列，它们彼此没有连接</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/016.png" alt=""></td>
<td style="text-align:left">编号节点序列，它们是彼此连接的</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/017.png" alt=""></td>
<td style="text-align:left">单个操作节点。</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/018.png" alt=""></td>
<td style="text-align:left">常数</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/019.png" alt=""></td>
<td style="text-align:left">摘要节点。</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/020.png" alt=""></td>
<td style="text-align:left">边缘显示操作之间的数据流。</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/021.png" alt=""></td>
<td style="text-align:left">边缘显示操作之间的控制依赖性。</td>
</tr>
<tr>
<td style="text-align:left"><img src="/img/17_03_07/022.png" alt=""></td>
<td style="text-align:left">表示输出操作节点可以变为输入张量的参考边。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>通过平移和缩放导航图。点击并拖动即可平移，并使用滚动手势进行缩放。双击一个节点，或单击其<code>+</code>按钮，可以展开一个表示一组操作的名称作用域。为了在缩放和平移时轻松跟踪当前视点，右下角有一个小地图。</p>
<p>要关闭打开的节点，请再次双击它，或单击它的 <code>-</code> 按钮。您也可以单击来选择某个节点。它将变成更暗的颜色，并且它的详细信息和它连接的节点将出现在可视化界面的右上角的信息卡中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/023.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/024.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">显示<strong>conv2</strong>名称作用域的详细信息的信息卡。输入和输出从名称作用域内的操作节点的输入和输出组合。对于名称作用域，不显示属性。</td>
<td style="text-align:left">显示<code>DecodeRaw</code>操作节点的详细信息的信息卡。除了输入和输出之外，它还显示了设备和与当前操作相关的属性。</td>
</tr>
</tbody>
</table>
</div>
<p>TensorBoard提供了几种方法来更改图形的视觉布局。这些方法不改变图的计算语义，但它可以为网络的结构带来一些清晰度。通过右键单击节点或按下该节点信息卡底部的按钮，可以对其布局进行以下更改：</p>
<ul>
<li>节点可以在主图和辅助区域之间移动。</li>
<li>一系列节点可以取消分组，以便系列中的节点不会显示在一起。未分组的系列同样可以重新分组。</li>
</ul>
<p>选择也有助于理解高度节点。选择任何高级节点，并选择其他连接的相应节点图标。这使得某些操作变得很容易，例如，看到哪些节点被保存，哪些没有被保存。</p>
<p>单击信息卡中的节点名称将选择它。如果需要，视点将自动平移，以便节点可见。</p>
<p>最后，您可以使用图例上方的颜色菜单为图形选择两种颜色方案。默认结构视图显示结构：当两个高级节点具有相同的结构时，它们以彩虹的相同颜色显示。唯一结构化的节点是灰色的。还有一个显示了运行不同操作的设备第二个视图。名称作用域的颜色与其内部操作的设备分数成比例。</p>
<p>下面的图片给出了一幅实际场景中的插图。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/025.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/026.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">结构视图：灰色节点具有独特的结构。橙色<strong>conv1</strong>和<strong>conv2</strong>节点具有相同的结构，并且类似地用于具有其它颜色的节点。</td>
<td style="text-align:left">设备视图：名称范围与其中的操作节点的设备分数成比例地着色。这里，紫色表示GPU，绿色表示CPU。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Tensor形状信息"><a href="#Tensor形状信息" class="headerlink" title="Tensor形状信息"></a>Tensor形状信息</h2><p>当序列化<code>GraphDef</code>引入tensor形状时，图形可视化器标记具有tensor维度的边缘，并且边缘厚度反映总张量大小。在<code>GraphDef</code>中引入tensor形状，将序列化图形时的实际图形对象（如<code>sess.graph</code>中所示）传递给<code>SummaryWriter</code>。下图显示了带有张量形状信息的CIFAR-10模型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/027.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CIFAR-10模型与张量形状信息。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="运行时统计"><a href="#运行时统计" class="headerlink" title="运行时统计"></a>运行时统计</h2><p>通常，收集运行的运行时元数据是有用的，例如节点的总内存使用，总计算时间和tensor形状。下面的代码示例是来自<a href="/2017/02/22/【Tensorflow%20r1.0%20文档翻译】机器学习的HelloWorld%20--%20MNIST手写数字识别/">简单MNIST教程</a>中的经过修改的训练和测试部分的代码片段，其中我们记录了摘要和运行时统计信息。有关如何记录摘要的详细信息，请参阅<a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-可视化学习/">摘要教程</a>。全部源代码在<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/mnist_with_summaries.py">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Train the model, and also write summaries.</span><br><span class="line"># Every 10th step, measure test-set accuracy, and write test summaries</span><br><span class="line"># All other steps, run train_step on training data, &amp; add training summaries</span><br><span class="line"></span><br><span class="line">def feed_dict(train):</span><br><span class="line">  &quot;&quot;&quot;Make a TensorFlow feed_dict: maps data onto Tensor placeholders.&quot;&quot;&quot;</span><br><span class="line">  if train or FLAGS.fake_data:</span><br><span class="line">    xs, ys &#x3D; mnist.train.next_batch(100, fake_data&#x3D;FLAGS.fake_data)</span><br><span class="line">    k &#x3D; FLAGS.dropout</span><br><span class="line">  else:</span><br><span class="line">    xs, ys &#x3D; mnist.test.images, mnist.test.labels</span><br><span class="line">    k &#x3D; 1.0</span><br><span class="line">  return &#123;x: xs, y_: ys, keep_prob: k&#125;</span><br><span class="line"></span><br><span class="line">for i in range(FLAGS.max_steps):</span><br><span class="line">  if i % 10 &#x3D;&#x3D; 0:  # Record summaries and test-set accuracy</span><br><span class="line">    summary, acc &#x3D; sess.run([merged, accuracy], feed_dict&#x3D;feed_dict(False))</span><br><span class="line">    test_writer.add_summary(summary, i)</span><br><span class="line">    print(&#39;Accuracy at step %s: %s&#39; % (i, acc))</span><br><span class="line">  else:  # Record train set summaries, and train</span><br><span class="line">    if i % 100 &#x3D;&#x3D; 99:  # Record execution stats</span><br><span class="line">      run_options &#x3D; tf.RunOptions(trace_level&#x3D;tf.RunOptions.FULL_TRACE)</span><br><span class="line">      run_metadata &#x3D; tf.RunMetadata()</span><br><span class="line">      summary, _ &#x3D; sess.run([merged, train_step],</span><br><span class="line">                            feed_dict&#x3D;feed_dict(True),</span><br><span class="line">                            options&#x3D;run_options,</span><br><span class="line">                            run_metadata&#x3D;run_metadata)</span><br><span class="line">      train_writer.add_run_metadata(run_metadata, &#39;step%d&#39; % i)</span><br><span class="line">      train_writer.add_summary(summary, i)</span><br><span class="line">      print(&#39;Adding run metadata for&#39;, i)</span><br><span class="line">    else:  # Record a summary</span><br><span class="line">      summary, _ &#x3D; sess.run([merged, train_step], feed_dict&#x3D;feed_dict(True))</span><br><span class="line">      train_writer.add_summary(summary, i)</span><br></pre></td></tr></table></figure>
<p>此代码将从步骤99开始每隔100步发出运行时统计信息。</p>
<p>当您启动tensorboard并转到图表选项卡，您现在将看到“Session runs”下的选项对应于添加运行元数据的步骤。选择其中一个运行将显示该步骤的网络快照，淡出未使用的节点。在左侧的控件中，您可以按总内存或总计算时间对节点进行着色。此外，单击节点将显示确切的总内存，计算时间和张量输出大小。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/028.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/029.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/030.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】TensorBoard:嵌入可视化</title>
    <url>/2017/03/07/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91TensorBoard-%E5%B5%8C%E5%85%A5%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>嵌入在机器学习中无处不在，出现在推荐系统，NLP和许多其他应用程序中。事实上，在TensorFlow的上下文中，将tensor（或tensor切片）视为空间中的点是自然的，因此几乎任何TensorFlow系统将自然地产生各种嵌入。</p>
<p>要了解有关嵌入和如何训练它们的更多信息，请参阅<a href="https://www.tensorflow.org/tutorials/word2vec">单词向量表示教程</a>。如果你对图像的嵌入感兴趣，请查看<a href="http://colah.github.io/posts/2014-10-Visualizing-MNIST/">这篇文章</a>，了解MNIST图像的有趣的可视化。另一方面，如果你对单词嵌入感兴趣，那么<a href="http://colah.github.io/posts/2014-10-Visualizing-MNIST/">这篇文章</a>会给你一个很好的介绍。</p>
<p>TensorBoard有一个内置的可视化工具，称为嵌入投影仪，用于交互式可视化和分析高维数据，例如嵌入。这意味着对开发人员和研究人员同样有用。它从保存tensorflow变量的检查点文件读取。虽然它对嵌入最有用，它将加载任何2D tensor，可能包括您的训练权重。</p>
<video height=363 width=710 id="video" controls="" preload="none" poster="/img/17_03_07/002.png">
    <source id="mp4" src="/img/17_03_07/001.mp4" type="video/mp4">
    <p>Your user agent does not support the HTML5 Video element.</p>
</video>

<p>默认情况下，嵌入投影仪执行三维<a href="https://en.wikipedia.org/wiki/Principal_component_analysis">主成分分析</a>，这意味着它接受你的高维数据，并试图找到一个结构保留投影到三维空间。基本上，它通过旋转你的数据，使前三个维度显示尽可能多的数据方差。<a href="http://setosa.io/ev/principal-component-analysis/">这里</a>有一个很好的视觉解释。另一个非常有用的投影是<a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding">t-SNE</a>。我们稍后在教程中讨论更多的t-SNE。</p>
<p>如果您使用嵌入，您可能需要将标签/图像附加到数据点，以告诉可视化器每个数据点对应的标签/图像。您可以通过生成元数据文件，使用我们的Python API将其附加到tensor，或将其上传到已经运行的TensorBoard来完成。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>有关如何运行TensorBoard并确保您记录所有必要的信息，请参阅<a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-可视化学习/">TensorBoard-可视化学习/</a>。</p>
<p>要可视化您的嵌入，您需要做3件事：</p>
<p>1）设置一个二维tensor变量来保存你的嵌入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">embedding_var &#x3D; tf.Variable(....)</span><br></pre></td></tr></table></figure>
<p>2）定期将您的嵌入保存在<code>LOG_DIR</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">saver &#x3D; tf.train.Saver()</span><br><span class="line">saver.save(session, os.path.join(LOG_DIR, &quot;model.ckpt&quot;), step)</span><br></pre></td></tr></table></figure>
<p>以下步骤不是必要的，但是如果您有与嵌入相关联的任何元数据（标签，图像），则需要将它们链接到tensor上，以便TensorBoard知道它。</p>
<p>3）将元数据与嵌入关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tensorflow.contrib.tensorboard.plugins import projector</span><br><span class="line"># Use the same LOG_DIR where you stored your checkpoint.</span><br><span class="line">summary_writer &#x3D; tf.train.SummaryWriter(LOG_DIR)</span><br><span class="line"></span><br><span class="line"># Format: tensorflow&#x2F;contrib&#x2F;tensorboard&#x2F;plugins&#x2F;projector&#x2F;projector_config.proto</span><br><span class="line">config &#x3D; projector.ProjectorConfig()</span><br><span class="line"></span><br><span class="line"># You can add multiple embeddings. Here we add only one.</span><br><span class="line">embedding &#x3D; config.embeddings.add()</span><br><span class="line">embedding.tensor_name &#x3D; embedding_var.name</span><br><span class="line"># Link this tensor to its metadata file (e.g. labels).</span><br><span class="line">embedding.metadata_path &#x3D; os.path.join(LOG_DIR, &#39;metadata.tsv&#39;)</span><br><span class="line"></span><br><span class="line"># Saves a configuration file that TensorBoard will read during startup.</span><br><span class="line">projector.visualize_embeddings(summary_writer, config)</span><br></pre></td></tr></table></figure>
<p>运行模型并训练嵌入后，运行TensorBoard并将其指向job的<code>LOG_DIR</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir&#x3D;LOG_DIR</span><br></pre></td></tr></table></figure>
<p>然后单击顶部窗格上的<em>Embeddings</em>选项卡，并选择适当的运行（如果有多个运行）。</p>
<h2 id="元数据（可选）"><a href="#元数据（可选）" class="headerlink" title="元数据（可选）"></a>元数据（可选）</h2><p>通常嵌入具有与其相关联的元数据（例如，标签，图像）。元数据应存储在模型检查点之外的单独文件中，因为元数据不是模型的可训练参数。格式应为TSV文件，第一行包含列标题，后续行包含元数据值。这里有一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name\tType\n</span><br><span class="line">Caterpie\tBug\n</span><br><span class="line">Charmeleon\tFire\n</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>没有与主数据文件共享的显式键;相反，假设元数据文件中的顺序与嵌入tensor中的顺序匹配。换句话说，第一行是头信息，元数据文件中的第(i+1)行对应于存储在检查点中的嵌入tensor的第i行。</p>
<blockquote>
<p><strong>注意：</strong>如果TSV元数据文件只有一个列，那么我们不需要一个标题行，并且假设每一行都是嵌入的标签。我们包含此异常，因为它匹配常用的“词汇文件”格式。</p>
</blockquote>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>如果您有与嵌入关联的图像，则需要生成包含每个数据点的小缩略图的单个图像。这被称为<a href="https://www.google.com/webhp#q=what+is+a+sprite+image">精灵图像（sprite image）</a>。精灵应具有相同数目的行和列，缩略图按行首先顺序存储：第一个数据点放置在左上角，最后一个数据点在右下角：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
</div>
<p>请注意，在上面的示例中，最后一行不必填写。对于精灵的一个具体示例，请看这个<a href="https://www.tensorflow.org/images/mnist_10k_sprite.png">精灵图像</a>的10,000 MNIST数字（100x100）。</p>
<blockquote>
<p><strong>注意：</strong>我们目前支持高达8192px X 8192px.的精灵。</p>
</blockquote>
<p>构造精灵后，您需要告诉嵌入投影机在哪里可以找到它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">embedding.sprite.image_path &#x3D; PATH_TO_SPRITE_IMAGE</span><br><span class="line"># Specify the width and height of a single thumbnail.</span><br><span class="line">embedding.sprite.single_image_dim.extend([w, h])</span><br></pre></td></tr></table></figure>
<h2 id="相互作用"><a href="#相互作用" class="headerlink" title="相互作用"></a>相互作用</h2><p>嵌入式投影机有三个面板</p>
<ul>
<li>1.位于左上方的数据面板，你可以选择你指定的运行、嵌入tensor和数据列来着色和标记点。</li>
<li>2.位于左下方的预测面板，用于选择投影类型（例如PCA，t-SNE）。</li>
<li>3.位于右侧的监视面板，在那里你可以搜索特定的点，并查看最近的邻居列表。</li>
</ul>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>嵌入投影仪具有减少数据集的维度的三种方法：两个线性的和一个非线性的。每个方法可用于创建二维或三维视图。</p>
<p><strong>主成分分析（Principal Component Analysis）</strong>减少维度的主要技术是主成分分析（PCA）。嵌入投影仪计算前10个主要元素。该菜单允许您将这些元素投影到两个或三个任意组合。PCA是一个线性投影，通常用于检查全局几何。</p>
<p><strong>t-SNE</strong>一种流行的非线性降维技术是T-SNE。嵌入投影机提供二维和三维t-SNE视图。布局是在客户端对算法的每一步执行动画。因为t-SNE经常保留一些局部结构，所以它对于探索局部邻域和找到簇是有用的。虽然对于可视化高维数据非常有用，但t-SNE图有时可能会产生迷惑或者误导的作用。想要了解如何有效地使用t-SNE，可以看看这篇<a href="http://distill.pub/2016/misread-tsne/">很棒的文章</a>。</p>
<p><strong>自定义（Custom）</strong>您还可以基于文本搜索来构造专门的线性投影，以在空间中找到有意义的方向。要定义投影轴，请输入两个搜索字符串或正则表达式。程序计算出其标签与这些搜索匹配的点集合的质心，并使用质心之间的差向量作为投影轴。</p>
<h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>要探索数据集，您可以在2D或3D模式中浏览视图，使用自然的点击和拖动手势进行缩放，旋转和平移。单击一个点会使右窗格显示最近邻居的显式文本列表，以及到当前点的距离。最近邻点本身在投影上突出显示。</p>
<p>放大集群会提供一些信息，但有时更有帮助的是将视图限制为点的子集，并仅对这些点执行投影。为此，您可以通过多种方式选择点：</p>
<ul>
<li>1.点击一个点后，也选择其最近的邻居。</li>
<li>2.搜索后，选择与查询匹配的点。</li>
<li>3.启用选择，单击点并拖动定义选择球体。</li>
</ul>
<p>选择一组点后，您可以使用右侧“检查器”窗格中的“隔离点”按钮单独隔离这些点以进行进一步分析。</p>
<p><img src="/img/17_03_07/003.png" alt=""></p>
<p><em>在词嵌入数据集中选择“重要”的最近邻。</em></p>
<p>过滤与自定义投影的组合的功能是非常强大的。下面，我们过滤了“politics”的100个最接近的邻居，并将它们投影到“best” - “worst”向量作为x轴。 y轴是随机的。</p>
<p>你可以看到，在右边我们有“ideas”，“science”，“perspective”，“journalism”，而在左边我们有“crisis”，“violence”和“conflict”。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><img src="/img/17_03_07/006.png" alt=""></th>
<th style="text-align:left"><img src="/img/17_03_07/004.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">自定义投影控件。</td>
<td style="text-align:left">将“politics”的邻居定义为“best” - “worst”向量。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="共同特征"><a href="#共同特征" class="headerlink" title="共同特征"></a>共同特征</h3><p>如果你想要分享您的发现，您可以使用右下角的书签面板，并将当前状态（包括任何投影的计算坐标）保存为小文件。投影仪可以同时打开并展示一个或多个这些小文件。这样一来，其他用户就可以浏览这些书签了。</p>
<p><img src="/img/17_03_07/005.png" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】TensorFlow入门</title>
    <url>/2017/02/20/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91TensorFlow%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="TensorFlow入门"><a href="#TensorFlow入门" class="headerlink" title="TensorFlow入门"></a>TensorFlow入门</h2><p>这是一个TensorFlow的入门指南。在你使用这份指南之前，请先<a href="https://www.tensorflow.org/install/">安装TensorFlow</a>。在充分的使用本指南之前，您应该了解以下内容：</p>
<ul>
<li>如何使用Python进行编程。</li>
<li>至少对矩阵有一些了解</li>
<li>最好是对<strong>机器学习</strong>有一点了解。但即使你对<strong>机器学习</strong>有一点了解、或者甚至完全不了解，那么你很有必要读一读这一篇指南了。</li>
</ul>
<p>TensorFlow提供了多种API。即使是最低版本的TensorFlow 核心 API，也为您提供了完整的编程控制。如果您是机器学习研究人员，或需要对模型进行精细控制的人，那么我们建议你使用TensorFlow 核心代码，否则我们建议您使用TensorFlow Core API。这些更高级的API通常比TensorFlow 核心代码更容易学习和使用。此外，较高级别的API使重复性任务更容易上手，并且在不同用户之间更一致。高级API（如<strong>tf.contrib.learn</strong>）可帮助您管理数据集、估计量、训练和推断。注意，在一些高级TensorFlow API 中，方法名称包含<code>contrib</code>的API表示仍在开发中。一些<code>contrib</code>方法可能会在随后的TensorFlow版本中发生改变或过时。</p>
<p>本指南从TensorFlow 核心教程开始。稍后，我们将演示如何在<code>tf.contrib.learn</code>中实现相同的模型。了解TensorFlow核心原则将会给你提供一个很棒的心理模型，这个模型是用于说明当您使用更紧凑的更高级别的API时，内部是如何工作的。</p>
<h2 id="Tensors（张量）"><a href="#Tensors（张量）" class="headerlink" title="Tensors（张量）"></a>Tensors（张量）</h2><p>TensorFlow中的数据的中心单元是<strong>Tensors(张量)</strong>。tensor是由一组原始数据组成，这些原始数据是由一组任意数量维度的数组形成。一个tensor的<strong>rank</strong>是表示它尺寸的一个数值。下面是几个tensor的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 # a rank 0 tensor; this is a scalar with shape []</span><br><span class="line">[1. ,2., 3.] # a rank 1 tensor; this is a vector with shape [3]</span><br><span class="line">[[1., 2., 3.], [4., 5., 6.]] # a rank 2 tensor; a matrix with shape [2, 3]</span><br><span class="line">[[[1., 2., 3.]], [[7., 8., 9.]]] # a rank 3 tensor with shape [2, 1, 3]</span><br></pre></td></tr></table></figure>
<h2 id="TensorFlow核心教程"><a href="#TensorFlow核心教程" class="headerlink" title="TensorFlow核心教程"></a>TensorFlow核心教程</h2><h3 id="导入TensorFlow"><a href="#导入TensorFlow" class="headerlink" title="导入TensorFlow"></a>导入TensorFlow</h3><p>TensorFlow程序的标准导入语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br></pre></td></tr></table></figure>
<p>这样做可以使得Python能够正常访问TensorFlow的所有类、方法和符号。我们的大多数文档都假设你已经这样做了。</p>
<h3 id="用于计算的Graph（图）"><a href="#用于计算的Graph（图）" class="headerlink" title="用于计算的Graph（图）"></a>用于计算的Graph（图）</h3><p>也许你会认为TensorFlow Core的程序包含下面两部分组成：</p>
<ul>
<li>1.构建<strong>computational graph（用于计算的图）</strong></li>
<li>2.运行<strong>computational graph（用于计算的图）</strong></li>
</ul>
<p>一个<strong>computational graph（用于计算的图）</strong>是一系列排列在graph的节点上的TensorFlow操作单元。让我们来构建一个简单的<strong>computational graph</strong>。每个节点接受0个或多个tensor作为输入，并且产生一个tensor作为输出。<strong>常量类型</strong>是节点的一种类型。正如所有的TensorFlow常量一样，它是不接收输入的，并且输出一个它内部存储的值。我们可以按照下面的方式来创建两个浮点Tensor节点<code>node1</code>和<code>node2</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node1 &#x3D; tf.constant(3.0, tf.float32)</span><br><span class="line">node2 &#x3D; tf.constant(4.0) # also tf.float32 implicitly</span><br><span class="line">print(node1, node2)</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tensor(&quot;Const:0&quot;, shape&#x3D;(), dtype&#x3D;float32) Tensor(&quot;Const_1:0&quot;, shape&#x3D;(), dtype&#x3D;float32)</span><br></pre></td></tr></table></figure>
<p>你会注意到，打印节点并不会如你所想的输出<code>3.0</code>和<code>4.0</code>。相反，这些节点会在计算时分别产生<code>3.0</code>和<code>4.0</code>。为了实际评估这些节点，我们必须以一个 <strong>session（会话）</strong> 来运行 <strong>computational graph</strong>。<strong>session（会话）</strong> 封装了TensorFlow运行时的控件和状态。</p>
<p>下面的代码创建了一个<code>Session</code>对象，并且执行了它的<code>run</code>方法来运行包含了<code>node1</code>和<code>node2</code>的<strong>computational graph</strong>的计算结果。通过在<strong>session</strong>中运行<strong>computational graph</strong>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess &#x3D; tf.Session()</span><br><span class="line">print(sess.run([node1, node2]))</span><br></pre></td></tr></table></figure>
<p>我们看到了我们期望看到的<code>3.0</code>和<code>4.0</code>的输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3.0, 4.0]</span><br></pre></td></tr></table></figure>
<p>我们可以通过将<code>Tensor</code>节点与操作节点（操作也是一种节点）组合起来的方式来构建更复杂的计算。例如，我们可以将两个常量节点执行加法操作，并且产生一个新的graph，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node3 &#x3D; tf.add(node1, node2)</span><br><span class="line">print(&quot;node3: &quot;, node3)</span><br><span class="line">print(&quot;sess.run(node3): &quot;,sess.run(node3))</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node3:  Tensor(&quot;Add_2:0&quot;, shape&#x3D;(), dtype&#x3D;float32)</span><br><span class="line">sess.run(node3):  7.0</span><br></pre></td></tr></table></figure>
<p>TensorFlow提供了一个叫做<strong>TensorBoard</strong>的很实用的程序，它可以将computational graph可视化的展示出来。下面是通过TensorBoard来可视化一个graph的效果：</p>
<p><img src="/img/17_02_20/001.png" alt=""></p>
<p>由于我们用到的是常量，因此这个图看起来并不是特别有趣，因为它总是产生一个恒定的结果。graph可以被参数化，并且通过<strong>placeholders（占位符）</strong>来接受外部的输入。<strong>placeholders（占位符）</strong>表示对稍后所提供的值的一个承诺。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">b &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">adder_node &#x3D; a + b  # + 是tf.add(a, b)的缩写形式</span><br></pre></td></tr></table></figure>
<p>上面三行的表达形式看起来有点像一个方法，或lambda表达式：其中我们定义两个输入参数（<code>a</code>和<code>b</code>），然后对它们执行一个操作。我们可以通过多个输入来计算这个graph的执行结果，其中我们的输入是通过<code>feed_dict</code>参数来指定对这些<strong>placeholders（占位符）</strong>提供具体值的<code>Tensors</code>的输入的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(sess.run(adder_node, &#123;a: 3, b:4.5&#125;))</span><br><span class="line">print(sess.run(adder_node, &#123;a: [1,3], b: [2, 4]&#125;))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7.5</span><br><span class="line">[ 3.  7.]</span><br></pre></td></tr></table></figure>
<p>在TensorBoard中，graph看起来是这个样子：</p>
<p><img src="/img/17_02_20/002.png" alt=""></p>
<p>我们可以通过添加其他操作，来让我们的<strong>computational graph</strong>看起来更复杂。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_and_triple &#x3D; adder_node * 3.</span><br><span class="line">print(sess.run(add_and_triple, &#123;a: 3, b:4.5&#125;))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22.5</span><br></pre></td></tr></table></figure>
<p>上面的computational graph在TensorBoard中看起来是这样的：</p>
<p><img src="/img/17_02_20/003.png" alt=""></p>
<p>在机器学习中，我们通常需要一个可以接受任意输入的模型，例如上面的模型。为了使模型可训练，我们需要能够修改<code>graph</code>以获得具有相同输入的新输出。<strong>Variables（变量）</strong>允许我们向graph中添加可训练的参数。它们由一个类型和初始值组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W &#x3D; tf.Variable([.3], tf.float32)</span><br><span class="line">b &#x3D; tf.Variable([-.3], tf.float32)</span><br><span class="line">x &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">linear_model &#x3D; W * x + b</span><br></pre></td></tr></table></figure>
<p>当调用<code>tf.constant</code>时，常量被初始化，它们的值永远不会改变。相比之下，变量<code>tf.Variable</code>在调用时不会被初始化。要初始化TensorFlow程序中的所有变量，必须显式调用特殊的初始化操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init &#x3D; tf.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br></pre></td></tr></table></figure>
<p><code>init</code>是TensorFlow的sub-graph的一个重要的操作，它用于初始化所有的全局变量。在这里直到我们调用<code>sess.run</code>之前，变量是未初始化的。</p>
<p>由于<code>x</code>是一个占位符，因此我们可以同时计算<code>linear_model</code>几个值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(sess.run(linear_model, &#123;x:[1,2,3,4]&#125;))</span><br></pre></td></tr></table></figure>
<p>产生如下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 0.          0.30000001  0.60000002  0.90000004]</span><br></pre></td></tr></table></figure>
<p>我们创建了一个模型，但目前我们还不知道它是好是坏。为了评估训练数据的模型，我们需要一个<strong>loss function（损失函数）</strong>，我们可以用一个<code>y</code>占位符来提供所需的值。</p>
<p>损失函数会计算出当前训练出的模型和所提供的数据之间的距离。我们将使用用于线性回归的标准损失模型，其原理是将当前模型和提供的数据之间的增量的平方求和。<code>linear_model - y</code>创建一个向量，其中每个元素是相应的样本的误差增量。我们称之为<code>tf.square</code>平方误差。然后，我们使用<code>tf.reduce_sum</code>将所有平方误差求和，以创建一个单一的标量，用于提取出表示所有样本的总误差值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">squared_deltas &#x3D; tf.square(linear_model - y)</span><br><span class="line">loss &#x3D; tf.reduce_sum(squared_deltas)</span><br><span class="line">print(sess.run(loss, &#123;x:[1,2,3,4], y:[0,-1,-2,-3]&#125;))</span><br></pre></td></tr></table></figure>
<p>输出损失值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23.66</span><br></pre></td></tr></table></figure>
<p>我们可以通过手动的将<code>W</code>和<code>b</code>的值重新赋值为<code>-1</code>和<code>1</code>的方式来提高我们的算法的效果。变量可以初始化后将数据提供给<code>tf.Variable</code>对象，也可以使用像<code>tf.assign</code>这样的操作来更改。例如，<code>W=-1</code>和<code>b=1</code>是我们的模型中的最佳参数。因此我们可以更改<code>W</code>和<code>b</code>的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fixW &#x3D; tf.assign(W, [-1.])</span><br><span class="line">fixb &#x3D; tf.assign(b, [1.])</span><br><span class="line">sess.run([fixW, fixb])</span><br><span class="line">print(sess.run(loss, &#123;x:[1,2,3,4], y:[0,-1,-2,-3]&#125;))</span><br></pre></td></tr></table></figure>
<p>最终输出结果的损失是0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.0</span><br></pre></td></tr></table></figure>
<p>我们猜到了“最完美”的参数<code>W</code>和<code>b</code>的值，但机器学习的目标是<strong>自动</strong>找到正确的模型参数。我们将在下一节中说明如何完成这一任务。</p>
<h2 id="tf-train-API"><a href="#tf-train-API" class="headerlink" title="tf.train API"></a>tf.train API</h2><p>机器学习的完整讨论超出了本教程的范围。然而，TensorFlow提供了缓慢地改变每个变量以便<strong>最小化损失函数</strong>的<strong>optimizers（优化器）</strong>。其中最简单的优化器是<strong>gradient descent（梯度下降）</strong>。其原理是根据相对于该变量的损失导数的大小修改每个变量的值。一般来说，人工计算导数是繁琐的并且容易出错。因此，TensorFlow可以使用<code>tf.gradients</code>函数，来自动的产生当前所给模型描述的导数。为了简化操作，优化器通常会自动地为您执行此操作。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimizer &#x3D; tf.train.GradientDescentOptimizer(0.01)</span><br><span class="line">train &#x3D; optimizer.minimize(loss)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess.run(init) # 将值重置为不正确的默认值</span><br><span class="line">for i in range(1000):</span><br><span class="line">  sess.run(train, &#123;x:[1,2,3,4], y:[0,-1,-2,-3]&#125;)</span><br><span class="line"></span><br><span class="line">print(sess.run([W, b]))</span><br></pre></td></tr></table></figure>
<p>最终训练得出的模型参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[array([-0.9999969], dtype&#x3D;float32), array([ 0.99999082],</span><br><span class="line"> dtype&#x3D;float32)]</span><br></pre></td></tr></table></figure>
<p>现在我们已经完成了实际的机器学习！完成这个简单的线性回归不需要太多的TensorFlow核心代码，但是更复杂的学习模型和方法通常需要更多的代码。因此，TensorFlow为通用模式、结构和功能提供了一套更高级别的抽象实现。我们将在下一节中学习如何使用这些抽象实现。</p>
<h3 id="完整的程序"><a href="#完整的程序" class="headerlink" title="完整的程序"></a>完整的程序</h3><p>完成的可训练线性回归模型程序如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># Model parameters</span><br><span class="line">W &#x3D; tf.Variable([.3], tf.float32)</span><br><span class="line">b &#x3D; tf.Variable([-.3], tf.float32)</span><br><span class="line"># Model input and output</span><br><span class="line">x &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">linear_model &#x3D; W * x + b</span><br><span class="line">y &#x3D; tf.placeholder(tf.float32)</span><br><span class="line"># loss</span><br><span class="line">loss &#x3D; tf.reduce_sum(tf.square(linear_model - y)) # sum of the squares</span><br><span class="line"># optimizer</span><br><span class="line">optimizer &#x3D; tf.train.GradientDescentOptimizer(0.01)</span><br><span class="line">train &#x3D; optimizer.minimize(loss)</span><br><span class="line"># training data</span><br><span class="line">x_train &#x3D; [1,2,3,4]</span><br><span class="line">y_train &#x3D; [0,-1,-2,-3]</span><br><span class="line"># training loop</span><br><span class="line">init &#x3D; tf.global_variables_initializer()</span><br><span class="line">sess &#x3D; tf.Session()</span><br><span class="line">sess.run(init) # reset values to wrong</span><br><span class="line">for i in range(1000):</span><br><span class="line">  sess.run(train, &#123;x:x_train, y:y_train&#125;)</span><br><span class="line"></span><br><span class="line"># evaluate training accuracy</span><br><span class="line">curr_W, curr_b, curr_loss  &#x3D; sess.run([W, b, loss], &#123;x:x_train, y:y_train&#125;)</span><br><span class="line">print(&quot;W: %s b: %s loss: %s&quot;%(curr_W, curr_b, curr_loss))</span><br></pre></td></tr></table></figure>
<p>当执行它时，会产生如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W: [-0.9999969] b: [ 0.99999082] loss: 5.69997e-11</span><br></pre></td></tr></table></figure>
<p>这个更复杂的程序也可以在TensorBoard中可视化：</p>
<p><img src="/img/17_02_20/004.png" alt=""></p>
<h2 id="tf-contrib-learn"><a href="#tf-contrib-learn" class="headerlink" title="tf.contrib.learn"></a>tf.contrib.learn</h2><p><code>tf.contrib.learn</code>是一个高级别的TensorFlow库，它简化了机器学习的机制，包括：</p>
<ul>
<li>运行训练循环</li>
<li>运行评估循环</li>
<li>管理数据集</li>
<li>管理数据导入</li>
</ul>
<p><code>tf.contrib.learn</code>定义了许多常见的模型。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>请注意，线性回归在使用<code>tf.contrib.learn</code>的情况下变得更简单了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"># NumPy is often used to load, manipulate and preprocess data.</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># Declare list of features. We only have one real-valued feature. There are many</span><br><span class="line"># other types of columns that are more complicated and useful.</span><br><span class="line">features &#x3D; [tf.contrib.layers.real_valued_column(&quot;x&quot;, dimension&#x3D;1)]</span><br><span class="line"></span><br><span class="line"># An estimator is the front end to invoke training (fitting) and evaluation</span><br><span class="line"># (inference). There are many predefined types like linear regression,</span><br><span class="line"># logistic regression, linear classification, logistic classification, and</span><br><span class="line"># many neural network classifiers and regressors. The following code</span><br><span class="line"># provides an estimator that does linear regression.</span><br><span class="line">estimator &#x3D; tf.contrib.learn.LinearRegressor(feature_columns&#x3D;features)</span><br><span class="line"></span><br><span class="line"># TensorFlow provides many helper methods to read and set up data sets.</span><br><span class="line"># Here we use &#96;numpy_input_fn&#96;. We have to tell the function how many batches</span><br><span class="line"># of data (num_epochs) we want and how big each batch should be.</span><br><span class="line">x &#x3D; np.array([1., 2., 3., 4.])</span><br><span class="line">y &#x3D; np.array([0., -1., -2., -3.])</span><br><span class="line">input_fn &#x3D; tf.contrib.learn.io.numpy_input_fn(&#123;&quot;x&quot;:x&#125;, y, batch_size&#x3D;4,</span><br><span class="line">                                              num_epochs&#x3D;1000)</span><br><span class="line"></span><br><span class="line"># We can invoke 1000 training steps by invoking the &#96;fit&#96; method and passing the</span><br><span class="line"># training data set.</span><br><span class="line">estimator.fit(input_fn&#x3D;input_fn, steps&#x3D;1000)</span><br><span class="line"></span><br><span class="line"># Here we evaluate how well our model did. In a real example, we would want</span><br><span class="line"># to use a separate validation and testing data set to avoid overfitting.</span><br><span class="line">estimator.evaluate(input_fn&#x3D;input_fn)</span><br></pre></td></tr></table></figure>
<p>当执行它时，会产生如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;global_step&#39;: 1000, &#39;loss&#39;: 1.9650059e-11&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定制模型"><a href="#定制模型" class="headerlink" title="定制模型"></a>定制模型</h3><p><code>tf.contrib.learn</code>不会将你锁定在预定义模型中。假设我们想创建一个未内置到TensorFlow中的自定义模型。我们仍然可以保留<code>tf.contrib.learn</code>的数据集、馈送、训练等的高级抽象。为了说明，我们将演示如何使用我们的较低级别TensorFlow API的知识来实现​​我们自己的等效模型到<code>LinearRegressor</code>。</p>
<p>要定义与<code>tf.contrib.learn</code>一起使用的自定义模型，我们需要使用<code>tf.contrib.learn.Estimator</code>。 <code>tf.contrib.learn.LinearRegressor</code>实际上是<code>tf.contrib.learn.Estimator</code>的子类。替代子类<code>Estimator</code>，我们只是提供<code>Estimator</code>一个<code>model_fn</code>函数，用于告诉<code>tf.contrib.learn</code>如何评估预测、训练步骤和损失。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"># Declare list of features, we only have one real-valued feature</span><br><span class="line">def model(features, labels, mode):</span><br><span class="line">  # Build a linear model and predict values</span><br><span class="line">  W &#x3D; tf.get_variable(&quot;W&quot;, [1], dtype&#x3D;tf.float64)</span><br><span class="line">  b &#x3D; tf.get_variable(&quot;b&quot;, [1], dtype&#x3D;tf.float64)</span><br><span class="line">  y &#x3D; W*features[&#39;x&#39;] + b</span><br><span class="line">  # Loss sub-graph</span><br><span class="line">  loss &#x3D; tf.reduce_sum(tf.square(y - labels))</span><br><span class="line">  # Training sub-graph</span><br><span class="line">  global_step &#x3D; tf.train.get_global_step()</span><br><span class="line">  optimizer &#x3D; tf.train.GradientDescentOptimizer(0.01)</span><br><span class="line">  train &#x3D; tf.group(optimizer.minimize(loss),</span><br><span class="line">                   tf.assign_add(global_step, 1))</span><br><span class="line">  # ModelFnOps connects subgraphs we built to the</span><br><span class="line">  # appropriate functionality.</span><br><span class="line">  return tf.contrib.learn.ModelFnOps(</span><br><span class="line">      mode&#x3D;mode, predictions&#x3D;y,</span><br><span class="line">      loss&#x3D; loss,</span><br><span class="line">      train_op&#x3D;train)</span><br><span class="line"></span><br><span class="line">estimator &#x3D; tf.contrib.learn.Estimator(model_fn&#x3D;model)</span><br><span class="line"># define our data set</span><br><span class="line">x&#x3D;np.array([1., 2., 3., 4.])</span><br><span class="line">y&#x3D;np.array([0., -1., -2., -3.])</span><br><span class="line">input_fn &#x3D; tf.contrib.learn.io.numpy_input_fn(&#123;&quot;x&quot;: x&#125;, y, 4, num_epochs&#x3D;1000)</span><br><span class="line"></span><br><span class="line"># train</span><br><span class="line">estimator.fit(input_fn&#x3D;input_fn, steps&#x3D;1000)</span><br><span class="line"># evaluate our model</span><br><span class="line">print(estimator.evaluate(input_fn&#x3D;input_fn, steps&#x3D;10))</span><br></pre></td></tr></table></figure>
<p>当执行它时，会产生如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;loss&#39;: 5.9819476e-11, &#39;global_step&#39;: 1000&#125;</span><br></pre></td></tr></table></figure>
<p>注意，自定义<code>model()</code>函数的内容与低版本API的手册中的模型训练循环非常相似。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>现在你了解到了TensorFlow的基本运作的知识。我们还有几个教程，您可以查看以了解更多。如果你是机器学习的初学者，请参阅<a href="/2017/02/22/【Tensorflow%20r1.0%20文档翻译】机器学习的HelloWorld%20--%20MNIST手写数字识别/">【深度学习的HelloWorld — MNIST手写数字识别】</a>，否则请参阅<a href="/2017/02/26/【Tensorflow%20r1.0%20文档翻译】深入MNIST--专家级/">【深入MNIST — 专家级】</a>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】Tensorflow原理导论</title>
    <url>/2017/03/03/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91Tensorflow%E5%8E%9F%E7%90%86%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p>代码：<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/">tensorflow/examples/tutorials/mnist/</a></p>
<p>这篇教程的目的是为了展示如何使用TensorFlow来训练并评估一个简单的<strong>前馈神经网络(feed-forward neural network)</strong>用来识别MNIST手写数字数据集。本教程的目标读者是有兴趣使用TensorFlow的有经验的机器学习用户。</p>
<p>这部分教程不是为了教授普通的机器学习。</p>
<p>请确保您已按照说明<a href="https://www.tensorflow.org/install/index">安装了TensorFlow</a>。</p>
<h2 id="教程文件"><a href="#教程文件" class="headerlink" title="教程文件"></a>教程文件</h2><p>本教程引用以下文件：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">文件</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/mnist.py"><code>mnist.py</code></a></td>
<td style="text-align:left">构建一个完全连接的MNIST模型的代码。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/fully_connected_feed.py"><code>fully_connected_feed.py</code></a></td>
<td style="text-align:left">利用下载的数据集训练构建好的MNIST模型的主要代码，以数据反馈字典（feed dictionary）的形式作为输入模型。</td>
</tr>
</tbody>
</table>
</div>
<p>只需要运行<code>fully_connected_feed.py</code>文件，就可以开启训练：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python fully_connected_feed.py</span><br></pre></td></tr></table></figure>
<h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>MNIST是机器学习中的经典问题。这个问题是查看28x28像素的手写数字灰度图像，并确定图像表示的数字，数字范围是0到9。</p>
<p><img src="/img/17_03_03/001.png" alt=""></p>
<p>更多的信息，参加<a href="http://yann.lecun.com/exdb/mnist/">Yann LeCun’s MNIST page</a>或者<a href="http://colah.github.io/posts/2014-10-Visualizing-MNIST/">Chris Olah’s visualizations of MNIST</a>。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在<code>run_training()</code>方法的开始部分，<code>input_data.read_data_sets()</code>方法会确保你的本地训练文件夹中，已经下载了正确的数据，然后将这些数据解压并返回一个含有<code>DataSet</code>实例的字典。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_sets &#x3D; input_data.read_data_sets(FLAGS.train_dir, FLAGS.fake_data)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>fake_data</code>标记是用于单元测试的，读者可以不必理会。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据集</th>
<th style="text-align:left">目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>data_sets.train</code></td>
<td style="text-align:left">55000图像和标签，用于初级训练。</td>
</tr>
<tr>
<td style="text-align:left"><code>data_sets.validation</code></td>
<td style="text-align:left">5000图像和标签，用于迭代验证训练准确性。</td>
</tr>
<tr>
<td style="text-align:left"><code>data_sets.test</code></td>
<td style="text-align:left">10000图像和标签，用于最终测试训练的准确性。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="输入和占位符"><a href="#输入和占位符" class="headerlink" title="输入和占位符"></a>输入和占位符</h3><p><code>placeholder_inputs()</code>方法创建了两个<code>tf.placeholder</code>操作，用于定义输入的形状。形状参数中包含<code>batch_size</code>值，后续还会将实际的训练样本传入图中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">images_placeholder &#x3D; tf.placeholder(tf.float32, shape&#x3D;(batch_size,</span><br><span class="line">                                                       mnist.IMAGE_PIXELS))</span><br><span class="line">labels_placeholder &#x3D; tf.placeholder(tf.int32, shape&#x3D;(batch_size))</span><br></pre></td></tr></table></figure>
<p>在训练的循环代码的下方，传入的整个图像和标签数据集会被切片，以符合每一个操作所设置的<code>batch_size</code>值，占位符操作将会填补以符合这个<code>batch_size</code>值。然后使用<code>feed_dict</code>参数，将数据传入<code>sess.run()</code>函数。</p>
<h2 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h2><p>在为数据创建占位符之后，就可以运行<code>mnist.py</code>文件，经过三阶段的模式函数操作：<code>inference()</code>， <code>loss()</code>，和<code>training()</code>。图表就构建完成了。</p>
<ul>
<li>1.<code>inference()</code>-尽可能地构建好图表，满足促使神经网络向前反馈并做出预测的要求。</li>
<li>2.<code>loss()</code>-往inference图表中添加生成损失（loss）所需要的操作（ops）。</li>
<li>3.<code>training()</code>-往损失图表中添加计算并应用梯度（gradients）所需的操作。</li>
</ul>
<p><img src="/img/17_03_03/002.png" alt=""></p>
<h3 id="推理-Inference"><a href="#推理-Inference" class="headerlink" title="推理(Inference)"></a>推理(Inference)</h3><p><code>inference()</code>函数会尽可能地构建图表，做到返回包含了预测结果（output prediction）的Tensor。</p>
<p>它采用图像占位符作为输入，并在其上借助<a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks">ReLU</a>)激活函数构建一对完全连接层，以及一个有着十个节点、指明了输出logtis模型的线性层。</p>
<p>每个图层都在唯一的<a href="https://www.tensorflow.org/api_docs/python/tf/name_scope"><code>tf.name_scope</code></a>下创建，创建于该作用域之下的所有元素都将带有其前缀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.name_scope(&#39;hidden1&#39;):</span><br></pre></td></tr></table></figure>
<p>在定义的范围内，由这些层中的每一个使用的权重和偏差被生成为<a href="https://www.tensorflow.org/api_docs/python/tf/Variable"><code>tf.Variable</code></a>实例，具有它们期望的形状：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weights &#x3D; tf.Variable(</span><br><span class="line">    tf.truncated_normal([IMAGE_PIXELS, hidden1_units],</span><br><span class="line">                        stddev&#x3D;1.0 &#x2F; math.sqrt(float(IMAGE_PIXELS))),</span><br><span class="line">    name&#x3D;&#39;weights&#39;)</span><br><span class="line">biases &#x3D; tf.Variable(tf.zeros([hidden1_units]),</span><br><span class="line">                     name&#x3D;&#39;biases&#39;)</span><br></pre></td></tr></table></figure>
<p>例如，当在<code>hidden1</code>范围下创建这些时，赋予权重变量的唯一名称将是“<code>hidden1 / weights</code>”。</p>
<p>每个变量在构建时，都会执行初始化操作。</p>
<p>在大多数情况下，通过<a href="https://www.tensorflow.org/api_docs/python/tf/truncated_normal"><code>tf.truncated_normal</code></a>函数初始化权重变量，给赋予的shape则是一个二维tensor，其中第一个维度代表该层中权重变量所连接（connect from）的单元数量，第二个维度代表该层中权重变量所连接到的（connect to）单元数量。第一层，名字为<code>hidden1</code>，它的尺寸是<code>[IMAGE_PIXELS, hidden1_units]</code>，因为权重变量将图像输入连接到了<code>hidden1</code>层。<code>tf.truncated_normal</code>初始函数将根据所得到的均值和标准差，生成一个随机分布。</p>
<p>然后，通过<a href="https://www.tensorflow.org/api_docs/python/tf/zeros"><code>tf.zeros</code></a>函数初始化偏差变量（biases），确保所有偏差的起始值都是0，而它们的形状则是其在该层中所接到的（connect to）单元数量。</p>
<p>图表的三个主要操作，分别是两个<code>tf.nn.relu</code>操作，它们中嵌入了隐藏层所需的<a href="https://www.tensorflow.org/api_docs/python/tf/matmul"><code>tf.matmul</code></a>；以及logits模型所需的另外一个<code>tf.matmul</code>。三者依次生成，各自的<code>tf.Variable</code>实例则与输入占位符或下一层的输出tensor所连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hidden1 &#x3D; tf.nn.relu(tf.matmul(images, weights) + biases)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hidden2 &#x3D; tf.nn.relu(tf.matmul(hidden1, weights) + biases)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logits &#x3D; tf.matmul(hidden2, weights) + biases</span><br></pre></td></tr></table></figure>
<p>最终，程序会返回包含了输出结果的<code>logits</code>Tensor。</p>
<h3 id="损失"><a href="#损失" class="headerlink" title="损失"></a>损失</h3><p><code>loss()</code>函数通过添加所需的损失操作，进一步构建图表。</p>
<p>首先，来自<code>labels_placeholder</code>的值将转换为64位整数。然后，添加一个<a href="https://www.tensorflow.org/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits">tf.nn.sparse_softmax_cross_entropy_with_logits</a>操作，以从<code>labels_placeholder</code>自动生成1-hot标签，并且与<code>inference()</code>函数的输出logits与那些1-hot标签进行比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">labels &#x3D; tf.to_int64(labels)</span><br><span class="line">cross_entropy &#x3D; tf.nn.sparse_softmax_cross_entropy_with_logits(</span><br><span class="line">    labels&#x3D;labels, logits&#x3D;logits, name&#x3D;&#39;xentropy&#39;)</span><br></pre></td></tr></table></figure>
<p>然后使用<a href="https://www.tensorflow.org/api_docs/python/tf/reduce_mean"><code>tf.reduce_mean</code></a>来求在批量维度（第一维度）上的交叉熵的平均值，作为总损失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loss &#x3D; tf.reduce_mean(cross_entropy, name&#x3D;&#39;xentropy_mean&#39;)</span><br></pre></td></tr></table></figure>
<p>然后将包含损失值的张量返回。</p>
<blockquote>
<p><strong>注意：</strong>交叉熵是信息论中的一种理论，它用于描述神经网络的预测结果相对于实际所给定的真实结果的偏差程度。更多的信息，请参阅博文<a href="http://colah.github.io/posts/2015-09-Visual-Information/">《可视化信息理论》</a>。</p>
</blockquote>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p><code>training()</code>方法通过添加<a href="https://en.wikipedia.org/wiki/Gradient_descent">梯度下降</a>的操作来最小化损失。</p>
<p>首先，它通过<code>loss()</code>方法接受损失tensor，然后传递到<a href="https://www.tensorflow.org/api_docs/python/tf/summary/scalar"><code>tf.summary.scalar</code></a>，用于在与<code>SummaryWriter</code>（见下文）一起使用时生成事件文件中的摘要值的操作。在这里，它将在每次写出摘要时发出损失的快照值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.summary.scalar(&#39;loss&#39;, loss)</span><br></pre></td></tr></table></figure>
<p>接下来，我们实例化一个<a href="https://www.tensorflow.org/api_docs/python/tf/train/GradientDescentOptimizer"><code>tf.train.GradientDescentOptimizer</code></a>，负责按照所要求的学习效率（learning rate）应用梯度下降法（gradients）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optimizer &#x3D; tf.train.GradientDescentOptimizer(learning_rate)</span><br></pre></td></tr></table></figure>
<p>之后，我们生成一个单个的变量用于统计全局训练的次数，<a href="https://www.tensorflow.org/api_docs/python/tf/train/Optimizer#minimize"><code>tf.train.Optimizer.minimize</code></a>操作被同时用作在系统中更新可训练的权值，以及增加全局步长（global step）。按照惯例，这个操作被称为<code>train_op</code>，TensorFlow会话必须运行的，以便引入一个完整的训练步骤（见下文）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global_step &#x3D; tf.Variable(0, name&#x3D;&#39;global_step&#39;, trainable&#x3D;False)</span><br><span class="line">train_op &#x3D; optimizer.minimize(loss, global_step&#x3D;global_step)</span><br></pre></td></tr></table></figure>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>一旦图被构建，它就可以在由<code>fully_connected_feed.py</code>中的用户代码控制的循环中迭代地训练和求值。</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>在<code>run_training()</code>方法的一开始的部分，是一个python的<code>with</code>命令，这表示所有构建的操作将与默认全局<a href="https://www.tensorflow.org/api_docs/python/tf/Graph"><code>tf.Graph</code></a>实例相关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Graph().as_default():</span><br></pre></td></tr></table></figure>
<p><code>tf.Graph</code>实例是一系列可以作为整体执行的操作。TensorFlow的大部分场景只需要依赖默认图表一个实例即可。</p>
<p>利用多个图表的更加复杂的使用场景也是可能的，但是超出了本教程的范围。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>完成全部的构建准备、生成全部所需的操作之后，我们就可以创建一个<a href="https://www.tensorflow.org/api_docs/python/tf/Session">tf.Session</a>，用于运行图表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess &#x3D; tf.Session()</span><br></pre></td></tr></table></figure>
<p>另外，也可以利用<code>with</code>代码块生成<code>Session</code>，限制作用域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tf.Session() as sess:</span><br></pre></td></tr></table></figure>
<p><code>Session</code>函数中没有传入参数，表明该代码将会依附于（如果还没有创建会话，则会创建新的会话）默认的本地会话。</p>
<p>生成会话之后，所有<code>tf.Variable</code>实例都会立即通过调用各自初始化操作中的<a href="https://www.tensorflow.org/api_docs/python/tf/Session#run"><code>tf.Session.run</code></a>函数进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init &#x3D; tf.global_variables_initializer()</span><br><span class="line">sess.run(init)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/Session#run"><code>tf.Session.run</code></a>方法将会运行图表中与作为参数传入的操作相对应的完整子集。在初次调用时，<code>init</code>操作只包含了变量初始化程序<a href="https://www.tensorflow.org/api_docs/python/tf/group"><code>tf.group</code></a>。图表的其他部分不会在这里，而是在下面的训练循环运行。</p>
<h3 id="训练循环"><a href="#训练循环" class="headerlink" title="训练循环"></a>训练循环</h3><p>在通过会话来初始化变量后，就可以开始训练了。</p>
<p>训练的每一步都是通过用户代码控制，而能实现有效训练的最简单循环就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for step in xrange(FLAGS.max_steps):</span><br><span class="line">    sess.run(train_op)</span><br></pre></td></tr></table></figure>
<p>但是，本教程中的例子要更为复杂一点，原因是我们必须把输入的数据根据每一步的情况进行切分，以匹配之前生成的占位符。</p>
<h3 id="向图表提供反馈"><a href="#向图表提供反馈" class="headerlink" title="向图表提供反馈"></a>向图表提供反馈</h3><p>执行每一步时，我们的代码会生成一个反馈字典（feed dictionary），其中包含对应步骤中训练所要使用的样本，这些样本的key就是其所代表的占位符操作。</p>
<p><code>fill_feed_dict</code>函数会查询给定的<code>DataSet</code>，索要下一批次`batch_size的图像和标签，与占位符相匹配的Tensor则会包含下一批次的图像和标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">images_feed, labels_feed &#x3D; data_set.next_batch(FLAGS.batch_size,</span><br><span class="line">                                               FLAGS.fake_data)</span><br></pre></td></tr></table></figure>
<p>然后，以占位符作为键，创建一个Python字典对象，值则是其代表的反馈Tensor。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed_dict &#x3D; &#123;</span><br><span class="line">    images_placeholder: images_feed,</span><br><span class="line">    labels_placeholder: labels_feed,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个字典随后作为<code>feed_dict</code>参数，传入<code>sess.run()</code>函数中，为这一步的训练提供输入样本。</p>
<h3 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h3><p>在运行<code>sess.run</code>时，要在代码中明确其需要获取的两个值：<code>[train_op, loss]</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for step in xrange(FLAGS.max_steps):</span><br><span class="line">    feed_dict &#x3D; fill_feed_dict(data_sets.train,</span><br><span class="line">                               images_placeholder,</span><br><span class="line">                               labels_placeholder)</span><br><span class="line">    _, loss_value &#x3D; sess.run([train_op, loss],</span><br><span class="line">                             feed_dict&#x3D;feed_dict)</span><br></pre></td></tr></table></figure>
<p>因为要获取这两个值，<code>sess.run()</code>会返回一个有两个元素的元组。其中每一个<code>Tensor</code>对象，对应了返回的元组中的numpy数组，而这些数组中包含了当前这步训练中对应Tensor的值。由于<code>train_op</code>并不会产生输出，其在返回的元祖中的对应元素就是<code>None</code>，所以会被抛弃。但是，如果模型在训练中出现偏差，<code>loss</code> Tensor的值可能会变成NaN，所以我们要获取它的值，并记录下来。</p>
<p>假设训练一切正常，没有出现NaN，训练循环会每隔100个训练步骤，就打印一行简单的状态文本，告知用户当前的训练状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if step % 100 &#x3D;&#x3D; 0:</span><br><span class="line">    print &#39;Step %d: loss &#x3D; %.2f (%.3f sec)&#39; % (step, loss_value, duration)</span><br></pre></td></tr></table></figure>
<h3 id="状态可视化"><a href="#状态可视化" class="headerlink" title="状态可视化"></a>状态可视化</h3><p>为了发出<a href="https://www.tensorflow.org/get_started/summaries_and_tensorboard">TensorBoard</a>所使用的事件文件（events file），所有的摘要（在这里只有一个）都要在图构建阶段合并至一个Tensor中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">summary &#x3D; tf.summary.merge_all()</span><br></pre></td></tr></table></figure>
<p>在创建好会话（session）之后，可以实例化一个<a href="https://www.tensorflow.org/api_docs/python/tf/summary/FileWriter"><code>tf.summary.FileWriter</code></a>，用于写入包含了图表本身和即时数据具体值的事件文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">summary_writer &#x3D; tf.summary.FileWriter(FLAGS.train_dir, sess.graph)</span><br></pre></td></tr></table></figure>
<p>最后，每次评估<code>summary</code>(摘要)并将输出传递给<code>add_summary()</code>函数时，事件文件将被新的摘要值更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">summary_str &#x3D; sess.run(summary, feed_dict&#x3D;feed_dict)</span><br><span class="line">summary_writer.add_summary(summary_str, step)</span><br></pre></td></tr></table></figure>
<p>事件文件写入完毕之后，可以就训练文件夹打开一个TensorBoard，查看即时数据的情况。</p>
<p><img src="/img/17_03_03/003.png" alt=""></p>
<blockquote>
<p><strong>注意：</strong>了解更多如何构建并运行TensorBoard的信息，请查看相关教程<a href="https://www.tensorflow.org/get_started/summaries_and_tensorboard">Tensorboard：训练过程可视化</a>。</p>
</blockquote>
<h3 id="保存检查点"><a href="#保存检查点" class="headerlink" title="保存检查点"></a>保存检查点</h3><p>为了得到可以用来后续恢复模型以进一步训练或评估的检查点文件（checkpoint file），我们实例化一个<a href="https://www.tensorflow.org/api_docs/python/tf/train/Saver"><code>tf.train.Saver</code></a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">saver &#x3D; tf.train.Saver()</span><br></pre></td></tr></table></figure>
<p>在训练循环中，将定期调用<a href="https://www.tensorflow.org/api_docs/python/tf/train/Saver#save"><code>tf.train.Saver.save</code></a>方法，使用所有可训练变量的当前值将检查点文件写入训练目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">saver.save(sess, FLAGS.train_dir, global_step&#x3D;step)</span><br></pre></td></tr></table></figure>
<p>在将来的某个时间点，可以通过使用<a href="https://www.tensorflow.org/api_docs/python/tf/train/Saver#restore"><code>tf.train.Saver.restore</code></a>方法重新加载模型参数来恢复训练。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">saver.restore(sess, FLAGS.train_dir)</span><br></pre></td></tr></table></figure>
<h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>每隔一千个训练步骤，我们的代码会尝试使用训练数据集与测试数据集，对模型进行评估。<code>do_eval</code>函数会被调用三次，分别使用训练数据集、验证数据集合测试数据集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print &#39;Training Data Eval:&#39;</span><br><span class="line">do_eval(sess,</span><br><span class="line">        eval_correct,</span><br><span class="line">        images_placeholder,</span><br><span class="line">        labels_placeholder,</span><br><span class="line">        data_sets.train)</span><br><span class="line">print &#39;Validation Data Eval:&#39;</span><br><span class="line">do_eval(sess,</span><br><span class="line">        eval_correct,</span><br><span class="line">        images_placeholder,</span><br><span class="line">        labels_placeholder,</span><br><span class="line">        data_sets.validation)</span><br><span class="line">print &#39;Test Data Eval:&#39;</span><br><span class="line">do_eval(sess,</span><br><span class="line">        eval_correct,</span><br><span class="line">        images_placeholder,</span><br><span class="line">        labels_placeholder,</span><br><span class="line">        data_sets.test)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，更复杂的使用场景通常是，先隔绝<code>data_sets.test</code>测试数据集，只有在大量的超参数优化调整（hyperparameter tuning）之后才进行检查。但是，由于MNIST问题比较简单，我们在这里一次性评估所有的数据。</p>
</blockquote>
<h3 id="构建评估图-Eval-Graph"><a href="#构建评估图-Eval-Graph" class="headerlink" title="构建评估图(Eval Graph)"></a>构建评估图(Eval Graph)</h3><p>在打开默认图表（Graph）之前，我们应该先调用get_data(train=False)函数，抓取测试数据集。</p>
<p>在进入训练循环之前，评估操作应该通过<code>mnist.py</code>中的<code>evaluate()</code>函数来构建。<code>evaluate()</code>传入的<code>logist</code>和标签参数与<code>loss()</code>函数相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval_correct &#x3D; mnist.evaluation(logits, labels_placeholder)</span><br></pre></td></tr></table></figure>
<p><code>evaluation()</code>函数会生成<a href="https://www.tensorflow.org/api_docs/python/tf/nn/in_top_k"><code>tf.nn.in_top_k</code></a>操作，如果在K个最有可能的预测中可以发现真的标签，那么这个操作就会将模型输出标记为正确。在本文中，我们把K的值设置为1，也就是只有在预测是真的标签时，才判定它是正确的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval_correct &#x3D; tf.nn.in_top_k(logits, labels, 1)</span><br></pre></td></tr></table></figure>
<h3 id="评估输出"><a href="#评估输出" class="headerlink" title="评估输出"></a>评估输出</h3><p>之后，我们可以创建一个循环，往其中添加<code>feed_dict</code>，并在调用<code>sess.run()</code>函数时传入<code>eval_correct</code>操作，目的就是用给定的数据集评估模型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for step in xrange(steps_per_epoch):</span><br><span class="line">    feed_dict &#x3D; fill_feed_dict(data_set,</span><br><span class="line">                               images_placeholder,</span><br><span class="line">                               labels_placeholder)</span><br><span class="line">    true_count +&#x3D; sess.run(eval_correct, feed_dict&#x3D;feed_dict)</span><br></pre></td></tr></table></figure>
<p><code>true_count</code>变量会累加所有<code>in_top_k</code>操作判定为正确的预测之和。接下来，只需要将正确测试的总数，除以例子总数，就可以得出准确率了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">precision &#x3D; true_count &#x2F; num_examples</span><br><span class="line">print(&#39;  Num examples: %d  Num correct: %d  Precision @ 1: %0.04f&#39; %</span><br><span class="line">      (num_examples, true_count, precision))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】【tf.contrib.learn快速入门】</title>
    <url>/2017/03/05/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E3%80%90tf.contrib.learn%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E3%80%91/</url>
    <content><![CDATA[<p>TensorFlow的高级机器学习API(tf.contrib.learn)使得各种机器学习模型的配置、训练和评估都变得简单。在本教程中，你将使用tf.contrib.learn来构建一个<a href="https://en.wikipedia.org/wiki/Artificial_neural_network">神经网络</a>分类器，并且在<a href="https://en.wikipedia.org/wiki/Iris_flower_data_set">Iris数据集</a>上进行训练，以达到通过萼片/花瓣几何来预测花的种类。您将编写代码以执行以下五个步骤：</p>
<ul>
<li>1.加载格包含Iris的训练和测试数据的CSV到TensorFlow数据集中。</li>
<li>2.构建一个<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/DNNClassifier">神经网络分类器</a>。</li>
<li>3.使用训练数据拟合模型</li>
<li>4.评估模型的准确性</li>
<li>5.分类新样品</li>
</ul>
<blockquote>
<p><strong>注意：</strong>在开始本教程之前，请确认在你的机器上已经<a href="https://www.tensorflow.org/install/index">安装了TensorFlow</a>。</p>
</blockquote>
<h2 id="完整的神经网络源代码"><a href="#完整的神经网络源代码" class="headerlink" title="完整的神经网络源代码"></a>完整的神经网络源代码</h2><p>这里是神经网络分类器的完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data sets</span></span><br><span class="line">IRIS_TRAINING = <span class="string">&quot;iris_training.csv&quot;</span></span><br><span class="line">IRIS_TEST = <span class="string">&quot;iris_test.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load datasets.</span></span><br><span class="line">training_set = tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">    filename=IRIS_TRAINING,</span><br><span class="line">    target_dtype=np.<span class="built_in">int</span>,</span><br><span class="line">    features_dtype=np.float32)</span><br><span class="line">test_set = tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">    filename=IRIS_TEST,</span><br><span class="line">    target_dtype=np.<span class="built_in">int</span>,</span><br><span class="line">    features_dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify that all features have real-value data</span></span><br><span class="line">feature_columns = [tf.contrib.layers.real_valued_column(<span class="string">&quot;&quot;</span>, dimension=<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build 3 layer DNN with 10, 20, 10 units respectively.</span></span><br><span class="line">classifier = tf.contrib.learn.DNNClassifier(feature_columns=feature_columns,</span><br><span class="line">                                            hidden_units=[<span class="number">10</span>, <span class="number">20</span>, <span class="number">10</span>],</span><br><span class="line">                                            n_classes=<span class="number">3</span>,</span><br><span class="line">                                            model_dir=<span class="string">&quot;/tmp/iris_model&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fit model.</span></span><br><span class="line">classifier.fit(x=training_set.data,</span><br><span class="line">               y=training_set.target,</span><br><span class="line">               steps=<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Evaluate accuracy.</span></span><br><span class="line">accuracy_score = classifier.evaluate(x=test_set.data,</span><br><span class="line">                                     y=test_set.target)[<span class="string">&quot;accuracy&quot;</span>]</span><br><span class="line">print(<span class="string">&#x27;Accuracy: &#123;0:f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Classify two new flower samples.</span></span><br><span class="line">new_samples = np.array(</span><br><span class="line">    [[<span class="number">6.4</span>, <span class="number">3.2</span>, <span class="number">4.5</span>, <span class="number">1.5</span>], [<span class="number">5.8</span>, <span class="number">3.1</span>, <span class="number">5.0</span>, <span class="number">1.7</span>]], dtype=<span class="built_in">float</span>)</span><br><span class="line">y = <span class="built_in">list</span>(classifier.predict(new_samples, as_iterable=<span class="literal">True</span>))</span><br><span class="line">print(<span class="string">&#x27;Predictions: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(y)))</span><br></pre></td></tr></table></figure>
<p>接下来，我们将详细介绍这部分代码的细节。</p>
<h2 id="将Iris-CSV数据加载到TensorFlow"><a href="#将Iris-CSV数据加载到TensorFlow" class="headerlink" title="将Iris CSV数据加载到TensorFlow"></a>将Iris CSV数据加载到TensorFlow</h2><p><a href="https://en.wikipedia.org/wiki/Iris_flower_data_set">Iris数据集</a>包含150行数据，包括来自三个相关鸢尾花物种，其中每个物种包含50个样本：山鸢尾，杂色鸢尾和维吉尼亚鸢尾。</p>
<p><img src="/img/17_03_05/001.jpg" alt=""></p>
<p><strong>从左到右依次是：<a href="https://commons.wikimedia.org/w/index.php?curid=170298">山鸢尾</a>(by <a href="https://commons.wikimedia.org/wiki/User:Radomil">Radomil</a>, CC BY-SA 3.0),<a href="https://commons.wikimedia.org/w/index.php?curid=248095">杂色鸢尾</a>(by <a href="https://commons.wikimedia.org/wiki/User:Dlanglois">Dlanglois</a>, CC BY-SA 3.0)和<a href="https://www.flickr.com/photos/33397993@N05/3352169862">维吉尼亚鸢尾</a>(by <a href="https://www.flickr.com/photos/33397993@N05">Frank Mayfield</a>, CC BY-SA 2.0)</strong></p>
<p>每行包含每个花样品的以下数据：<a href="https://en.wikipedia.org/wiki/Sepal">萼片</a>长度，萼片宽度，<a href="https://en.wikipedia.org/wiki/Petal">花瓣</a>长度，花瓣宽度以及花的品种。花的品种用整数表示，0表示山鸢尾，1表示杂色鸢尾，2表示维吉尼亚鸢尾。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">萼片长度(Sepal Length)</th>
<th style="text-align:left">萼片宽度(Sepal Width)</th>
<th style="text-align:left">花瓣长度(Petal Length)</th>
<th style="text-align:left">花瓣宽度(Petal Width)</th>
<th style="text-align:left">品种(Species)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5.1</td>
<td style="text-align:left">3.5</td>
<td style="text-align:left">1.4</td>
<td style="text-align:left">0.2</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">4.9</td>
<td style="text-align:left">3.0</td>
<td style="text-align:left">1.4</td>
<td style="text-align:left">0.2</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">4.7</td>
<td style="text-align:left">3.2</td>
<td style="text-align:left">1.3</td>
<td style="text-align:left">0.2</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">7.0</td>
<td style="text-align:left">3.2</td>
<td style="text-align:left">4.7</td>
<td style="text-align:left">1.4</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">6.4</td>
<td style="text-align:left">3.2</td>
<td style="text-align:left">4.5</td>
<td style="text-align:left">1.5</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">6.9</td>
<td style="text-align:left">3.1</td>
<td style="text-align:left">4.9</td>
<td style="text-align:left">1.5</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">6.5</td>
<td style="text-align:left">3.0</td>
<td style="text-align:left">5.2</td>
<td style="text-align:left">2.0</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">6.2</td>
<td style="text-align:left">3.4</td>
<td style="text-align:left">5.4</td>
<td style="text-align:left">2.3</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">5.9</td>
<td style="text-align:left">3.0</td>
<td style="text-align:left">5.1</td>
<td style="text-align:left">1.8</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
</div>
<p>在本教程中，Iris数据已随机分到两个单独的CSV中：</p>
<ul>
<li>一个包含了120个样本的训练集(<a href="http://download.tensorflow.org/data/iris_training.csv">iris_training.csv</a>)</li>
<li>一个包含了30个样本的测试集(<a href="http://download.tensorflow.org/data/iris_test.csv">iris_test.csv</a>)</li>
</ul>
<p>将这些文件放在与Python代码相同的目录中。</p>
<p>首先导入TensorFlow和numpy：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br><span class="line">from __future__ import division</span><br><span class="line">from __future__ import print_function</span><br><span class="line"></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br></pre></td></tr></table></figure>
<p>接下来，使用<code>learn.datasets.base</code>中的<a href="https://www.tensorflow.org/code/tensorflow/contrib/learn/python/learn/datasets/base.py"><code>load_csv_with_header()</code></a>方法将训练和测试集装入数据集。<code>load_csv_with_header()</code>方法需要三个必需的参数：</p>
<ul>
<li><code>filename</code>，CSV文件的路径</li>
<li><code>target_dtype</code>，接受数据集的目标值的<a href="http://docs.scipy.org/doc/numpy/user/basics.types.html"><code>numpy</code>数据类型</a>。</li>
<li><code>features_dtype</code>，接受数据集的特征值的<a href="http://docs.scipy.org/doc/numpy/user/basics.types.html"><code>numpy</code>数据类型</a>。</li>
</ul>
<p>在这里，target（你训练模型预测的值）是花种，它是一个从0-2的整数，所以对应的适当的<code>numpy</code>数据类型是<code>np.int</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Data sets</span><br><span class="line">IRIS_TRAINING &#x3D; &quot;iris_training.csv&quot;</span><br><span class="line">IRIS_TEST &#x3D; &quot;iris_test.csv&quot;</span><br><span class="line"></span><br><span class="line"># Load datasets.</span><br><span class="line">training_set &#x3D; tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">    filename&#x3D;IRIS_TRAINING,</span><br><span class="line">    target_dtype&#x3D;np.int,</span><br><span class="line">    features_dtype&#x3D;np.float32)</span><br><span class="line">test_set &#x3D; tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">    filename&#x3D;IRIS_TEST,</span><br><span class="line">    target_dtype&#x3D;np.int,</span><br><span class="line">    features_dtype&#x3D;np.float32)</span><br></pre></td></tr></table></figure>
<p>tf.contrib.learn中的<code>Dataset</code>是<a href="https://docs.python.org/2/library/collections.html#collections.namedtuple">命名元组</a>；您可以通过<code>data</code>和<code>target</code>字段访问特征数据和目标值。这里<code>training_set.data</code>和<code>training_set.target</code>分别包含训练集的特征数据和目标值；<code>test_set.data</code>和<code>test_set.target</code>分别包含测试集的特征数据和目标值。</p>
<p>在后面的<a href="#将DNN分类器用于Iris训练数据">“将DNN分类器用于Iris训练数据”</a>中，你将使用到<code>training_set.data</code>和<code>training_set.target</code>来训练你的模型，在<a href="#评估模型精度">“评估模型精度”</a>中，你将使用<code>test_set.data</code>和<code>test_set.target</code>。但首先，你需要在下一节中构建你的模型。</p>
<h2 id="构建一个深度神经网络分类器"><a href="#构建一个深度神经网络分类器" class="headerlink" title="构建一个深度神经网络分类器"></a>构建一个深度神经网络分类器</h2><p>tf.contrib.learn提供了一系列预定义的模型，叫做<a href="https://www.tensorflow.org/api_guides/python/contrib.learn#estimators">Estimator</a>s。通过Estimator，您可以对您的数据很方便的进行训练和评估操作，达到“开箱即用”的效果。在这里，您将配置一个深层神经网络分类器模型以适应Iris数据。通过使用tf.contrib.learn，你可以仅仅使用一行代码就实例化一个<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/DNNClassifier"><code>tf.contrib.learn.DNNClassifier</code></a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Specify that all features have real-value data</span><br><span class="line">feature_columns &#x3D; [tf.contrib.layers.real_valued_column(&quot;&quot;, dimension&#x3D;4)]</span><br><span class="line"></span><br><span class="line"># Build 3 layer DNN with 10, 20, 10 units respectively.</span><br><span class="line">classifier &#x3D; tf.contrib.learn.DNNClassifier(feature_columns&#x3D;feature_columns,</span><br><span class="line">                                            hidden_units&#x3D;[10, 20, 10],</span><br><span class="line">                                            n_classes&#x3D;3,</span><br><span class="line">                                            model_dir&#x3D;&quot;&#x2F;tmp&#x2F;iris_model&quot;)</span><br></pre></td></tr></table></figure>
<p>上面的代码首先定义了模型的特征列，它指定了数据集中特征的数据类型。所有的特征数据都是连续的，因此<code>tf.contrib.layers.real_valued_column</code>是用于构造特征列的适当函数。数据集中有四个特征（萼片宽度，萼片高度，花瓣宽度和花瓣高度），因此相应的尺寸必须设置为4以保存所有数据。</p>
<p>然后，代码使用以下参数创建<code>DNNClassifier</code>模型：</p>
<ul>
<li><code>feature_columns=feature_columns</code>。上面定义的一组特征</li>
<li><code>hidden_units=[10, 20, 10]</code>。三个<a href="http://stats.stackexchange.com/questions/181/how-to-choose-the-number-of-hidden-layers-and-nodes-in-a-feedforward-neural-netw">隐藏层</a>分别包含10，20，10个神经元。</li>
<li><code>n_classes=3</code>。三个目标类，代表三个鸢尾物种。</li>
<li><code>model_dir=/tmp/iris_model</code>。TensorFlow在模型训练期间将保存检查点数据的目录。有关使用TensorFlow进行日志记录和监视的更多信息，请见<a href="">使用tf.contrib.learn记录和监视的基本知识</a>。</li>
</ul>
<h2 id="将DNN分类器用于Iris训练数据"><a href="#将DNN分类器用于Iris训练数据" class="headerlink" title="将DNN分类器用于Iris训练数据"></a>将DNN分类器用于Iris训练数据</h2><p>现在，你已经配置好了你的DNN<code>classifier</code>模型，你可以使用<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/BaseEstimator#fit"><code>fit</code></a>方法来将Iris训练数据应用到分类器上。将特征数据（<code>training_set.data</code>），目标值（<code>training_set.target</code>）和要训练的步数（这里是<code>2000</code>）作为参数传递：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Fit model</span><br><span class="line">classifier.fit(x&#x3D;training_set.data, y&#x3D;training_set.target, steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>模型的状态保存在<code>classifier</code>(分类器)中，这意味着如果你喜欢，你可以迭代地训练。上面的代码执行效果等同于下面这两行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.fit(x&#x3D;training_set.data, y&#x3D;training_set.target, steps&#x3D;1000)</span><br><span class="line">classifier.fit(x&#x3D;training_set.data, y&#x3D;training_set.target, steps&#x3D;1000)</span><br></pre></td></tr></table></figure>
<p>但是，如果您希望在训练时跟踪模型，则可能需要使用TensorFlow<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/monitors">monitor</a>(监视器)来执行日志操作。关于这个主题更多的内容，请见教程<a href="">使用tf.contrib.learn记录和监视的基本知识</a>。</p>
<h2 id="评估模型精度"><a href="#评估模型精度" class="headerlink" title="评估模型精度"></a>评估模型精度</h2><p>你已经将Iris的训练数据适配到了<code>DNNClassifier</code>模型上；现在，您可以使用<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/BaseEstimator#evaluate"><code>evaluate</code></a>方法在Iris测试数据上检查其准确性。像<code>fit</code>（拟合）一样，<code>evaluate</code>（评估操作）将特征数据和目标值作为参数，并返回带有评估结果的<code>dict</code>（字典）。以下代码通过了Iris测试数据-<code>test_set.data</code>和<code>test_set.target</code>来评估和打印结果的准确性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accuracy_score &#x3D; classifier.evaluate(x&#x3D;test_set.data, y&#x3D;test_set.target)[&quot;accuracy&quot;]</span><br><span class="line">print(&#39;Accuracy: &#123;0:f&#125;&#39;.format(accuracy_score))</span><br></pre></td></tr></table></figure>
<p>运行全部的脚本，并检查结果的准确度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy: 0.966667</span><br></pre></td></tr></table></figure>
<p>您的准确度结果可能有所不同，但应该是高于90％的。这对于相对较小的数据集是一个不错的结果了！</p>
<h2 id="分类新样品"><a href="#分类新样品" class="headerlink" title="分类新样品"></a>分类新样品</h2><p>使用评估器的<code>predict()</code>方法来分类一个新的样本。例如，说你有这两个新的花样本：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">萼片长度(Sepal Length)</th>
<th style="text-align:left">萼片宽度(Sepal Width)</th>
<th style="text-align:left">花瓣长度(Petal Length)</th>
<th style="text-align:left">花瓣宽度(Petal Width)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">6.4</td>
<td style="text-align:left">3.2</td>
<td style="text-align:left">4.5</td>
<td style="text-align:left">1.5</td>
</tr>
<tr>
<td style="text-align:left">5.8</td>
<td style="text-align:left">3.1</td>
<td style="text-align:left">5.0</td>
<td style="text-align:left">1.7</td>
</tr>
</tbody>
</table>
</div>
<p>你可以用以下代码预测他们的物种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Classify two new flower samples.</span><br><span class="line">new_samples &#x3D; np.array(</span><br><span class="line">    [[6.4, 3.2, 4.5, 1.5], [5.8, 3.1, 5.0, 1.7]], dtype&#x3D;float)</span><br><span class="line">y &#x3D; list(classifier.predict(new_samples, as_iterable&#x3D;True))</span><br><span class="line">print(&#39;Predictions: &#123;&#125;&#39;.format(str(y)))</span><br></pre></td></tr></table></figure>
<p><code>predict()</code>方法返回了一个预测数组，每个样本对应其中的一个结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prediction: [1 2]</span><br></pre></td></tr></table></figure>
<p>该模型预测的结果为：第一个样本是杂色鸢尾，第二个样本是维吉尼亚鸢尾。</p>
<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><ul>
<li>有关tf.contrib.learn的更多参考资料，请参阅<a href="https://www.tensorflow.org/api_guides/python/contrib.learn">官方API文档</a>。</li>
<li>要了解有关使用tf.contrib.learn创建线性模型的更多信息，请参阅<a href="https://www.tensorflow.org/tutorials/linear">使用TensorFlow的大型线性模型</a>。</li>
<li>要使用tf.contrib.learn API构建自己的评估器，请查看<a href="http://terrytangyuan.github.io/2016/07/08/understand-and-build-tensorflow-estimator/">TensorFlow中的Building Machine Learning Estimator</a>。</li>
<li>要在浏览器中尝试神经网络建模和可视化，请查看<a href="http://playground.tensorflow.org/">Deep Playground</a>。</li>
<li>有关神经网络的更高级教程，请参阅<a href="https://www.tensorflow.org/tutorials/deep_cnn">卷积神经网络</a>和<a href="https://www.tensorflow.org/tutorials/recurrent">循环神经网络</a>。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】使用tf.contrib.learn记录和监视的基本知识</title>
    <url>/2017/03/09/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E4%BD%BF%E7%94%A8tf.contrib.learn%E8%AE%B0%E5%BD%95%E5%92%8C%E7%9B%91%E8%A7%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>在训练模型时，实时跟踪和评估进度通常很有价值。在本教程中，您将学习如何使用TensorFlow的日志记录功能和<code>Monitor</code> API来审计用于分类鸢尾花的神经网络分类器的正在进行中的训练。本教程基于在<a href="/2017/03/05/【Tensorflow%20r1.0%20文档翻译】【tf.contrib.learn快速入门】/">tf.contrib.learn快速入门</a>中开发的代码，所以如果你还没有完成该教程，你可能想先探索它， 特别是如果你正在寻找一个tf.contrib.learn基础介绍/复习文章时。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>在本教程中，你将在从<a href="/2017/03/05/【Tensorflow%20r1.0%20文档翻译】【tf.contrib.learn快速入门】/">tf.contrib.learn快速入门</a>中的下面的代码来进行构建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br><span class="line">from __future__ import division</span><br><span class="line">from __future__ import print_function</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># Data sets</span><br><span class="line">IRIS_TRAINING &#x3D; os.path.join(os.path.dirname(__file__), &quot;iris_training.csv&quot;)</span><br><span class="line">IRIS_TEST &#x3D; os.path.join(os.path.dirname(__file__), &quot;iris_test.csv&quot;)</span><br><span class="line"></span><br><span class="line">def main(unused_argv):</span><br><span class="line">    # Load datasets.</span><br><span class="line">    training_set &#x3D; tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">        filename&#x3D;IRIS_TRAINING, target_dtype&#x3D;np.int, features_dtype&#x3D;np.float32)</span><br><span class="line">    test_set &#x3D; tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">        filename&#x3D;IRIS_TEST, target_dtype&#x3D;np.int, features_dtype&#x3D;np.float32)</span><br><span class="line"></span><br><span class="line">    # Specify that all features have real-value data</span><br><span class="line">    feature_columns &#x3D; [tf.contrib.layers.real_valued_column(&quot;&quot;, dimension&#x3D;4)]</span><br><span class="line"></span><br><span class="line">    # Build 3 layer DNN with 10, 20, 10 units respectively.</span><br><span class="line">    classifier &#x3D; tf.contrib.learn.DNNClassifier(feature_columns&#x3D;feature_columns,</span><br><span class="line">                                                hidden_units&#x3D;[10, 20, 10],</span><br><span class="line">                                                n_classes&#x3D;3,</span><br><span class="line">                                                model_dir&#x3D;&quot;&#x2F;tmp&#x2F;iris_model&quot;)</span><br><span class="line"></span><br><span class="line">    # Fit model.</span><br><span class="line">    classifier.fit(x&#x3D;training_set.data,</span><br><span class="line">                   y&#x3D;training_set.target,</span><br><span class="line">                   steps&#x3D;2000)</span><br><span class="line"></span><br><span class="line">    # Evaluate accuracy.</span><br><span class="line">    accuracy_score &#x3D; classifier.evaluate(x&#x3D;test_set.data,</span><br><span class="line">                                         y&#x3D;test_set.target)[&quot;accuracy&quot;]</span><br><span class="line">    print(&#39;Accuracy: &#123;0:f&#125;&#39;.format(accuracy_score))</span><br><span class="line"></span><br><span class="line">    # Classify two new flower samples.</span><br><span class="line">    new_samples &#x3D; np.array(</span><br><span class="line">        [[6.4, 3.2, 4.5, 1.5], [5.8, 3.1, 5.0, 1.7]], dtype&#x3D;float)</span><br><span class="line">    y &#x3D; list(classifier.predict(new_samples, as_iterable&#x3D;True))</span><br><span class="line">    print(&#39;Predictions: &#123;&#125;&#39;.format(str(y)))</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">  tf.app.run()</span><br></pre></td></tr></table></figure>
<p>将上述代码复制到一个文件中，并将相应的<a href="http://download.tensorflow.org/data/iris_training.csv">训练</a>和<a href="https://www.tensorflow.org/api_docs/python/tf/test">tf.test</a>数据集下载到同一目录。</p>
<p>在以下部分中，您将逐步更新上述代码以添加日志记录和监视功能。包含所有更新的最终代码可在<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/monitors/iris_monitors.py">此处</a>下载。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="/2017/03/05/【Tensorflow%20r1.0%20文档翻译】【tf.contrib.learn快速入门】/">tf.contrib.learn快速入门</a>教程中通过如何实现一个神经网络分类器实现了将鸢尾花的样本分为三种类型之一。</p>
<p>但是，当运行本教程的<a href="https://www.tensorflow.org/get_started/monitors#setup">代码</a>时，输​​出并不包含日志记录跟踪模型训练如何进行 - 仅包含打印语句的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accuracy: 0.933333</span><br><span class="line">Predictions: [1 2]</span><br></pre></td></tr></table></figure>
<p>没有任何日志记录，模型训练感觉就像一个黑盒子;你不能看到发生了什么，因此TensorFlow通过逐步的梯度下降，了解模型是否适当的收敛、或者确定是否可以提前停止训练是有必要的。</p>
<p>解决这个问题的一种方法是将模型训练分成具有较少步骤的多个<code>fit</code>(拟合)调用，以便逐步评估准确性。然而，这不是推荐的做法，因为它大大减慢了模型的训练过程。幸运的是，tf.contrib.learn提供了另一个解决方案：一个<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/monitors">Monitor API</a>，旨在帮助您在训练正在进行时记录指标并评估模型。在以下部分中，您将学习如何在TensorFlow中启用日志记录，设置ValidationMonitor进行流评估，以及使用TensorBoard可视化您的度量。</p>
<h2 id="启用TensorFlow的日志记录"><a href="#启用TensorFlow的日志记录" class="headerlink" title="启用TensorFlow的日志记录"></a>启用TensorFlow的日志记录</h2><p>TensorFlow对日志消息使用五个不同的级别。按照严重性递增的顺序，它们是<code>DEBUG</code>，<code>INFO</code>，<code>WARN</code>，<code>ERROR</code>和<code>FATAL</code>。当您在配置任何这些级别的日志记录时，TensorFlow将输出与该级别以及所有严重性级别高于该级别的相对应的所有日志消息。例如，如果您设置为<code>ERROR</code>的日志级别，您将获得包含<code>ERROR</code>和<code>FATAL</code>消息的日志输出，如果设置为<code>DEBUG</code>级别，则将获取所有五个级别的日志消息。</p>
<p>默认情况下，TensorFlow的日志级别为<code>WARN</code>，但是在跟踪模型训练时，您需要将级别调整为<code>INFO</code>，这将在适配操作正在进行时提供其他反馈。</p>
<p>将以下行添加到代码的开头（在<code>import</code>之后）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br></pre></td></tr></table></figure>
<p>现在当你运行代码，你会看到额外的日志输出，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:loss &#x3D; 1.18812, step &#x3D; 1</span><br><span class="line">INFO:tensorflow:loss &#x3D; 0.210323, step &#x3D; 101</span><br><span class="line">INFO:tensorflow:loss &#x3D; 0.109025, step &#x3D; 201</span><br></pre></td></tr></table></figure>
<p>使用<code>INFO</code>级别日志记录，tf.contrib.learn每100步后自动向标准错误（stderr）输出<a href="https://en.wikipedia.org/wiki/Loss_function">训练损失指标</a>。</p>
<h2 id="为流式处理评估配置验证监视器"><a href="#为流式处理评估配置验证监视器" class="headerlink" title="为流式处理评估配置验证监视器"></a>为流式处理评估配置验证监视器</h2><p>记录训练损失有助于了解您的模型是否收敛，但如果您想进一步了解训练期间发生的情况怎么办？tf.contrib.learn提供了几个高级监视器，您可以附加到您的合适的操作中，以进一步在模型训练期间跟踪指标和/或调试较低级别的TensorFlow操作，包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Monitor</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>CaptureVariable</code></td>
<td style="text-align:left">在训练的每n个步骤中将指定变量的值保存到集合中</td>
</tr>
<tr>
<td style="text-align:left"><code>PrintTensor</code></td>
<td style="text-align:left">在训练的每n个步骤记录指定的tensor的值</td>
</tr>
<tr>
<td style="text-align:left"><code>SummarySaver</code></td>
<td style="text-align:left">在每n个训练步骤使用<a href="https://www.tensorflow.org/api_docs/python/tf/summary/FileWriter"><code>tf.summary.FileWriter</code></a>保存给定tensor的<a href="https://www.tensorflow.org/api_docs/python/tf/Summary"><code>tf.Summary</code></a><a href="https://developers.google.com/protocol-buffers/">protocol buffers</a></td>
</tr>
<tr>
<td style="text-align:left"><code>ValidationMonitor</code></td>
<td style="text-align:left">在训练的每n个步骤记录指定的一组评估度量，并且如果需要，可以在某些条件下实现提前停止训练</td>
</tr>
</tbody>
</table>
</div>
<h3 id="评估每N个步骤"><a href="#评估每N个步骤" class="headerlink" title="评估每N个步骤"></a>评估每N个步骤</h3><p>对于鸢尾花神经网络分类器，在记录训练损失时，您可能还需要同时评估测试数据，以了解模型的泛化程度。您可以通过使用测试数据（<code>test_set.data</code>和<code>test_set.target</code>）配置一个<code>ValidationMonitor</code>并设置使用<code>every_n_steps</code>进行求值的频率来实现此目的。<code>every_n_steps</code>的默认值为<code>100</code>;这里，设置<code>every_n_steps</code>为<code>50</code>，以评估后每50步的模型训练：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validation_monitor &#x3D; tf.contrib.learn.monitors.ValidationMonitor(</span><br><span class="line">    test_set.data,</span><br><span class="line">    test_set.target,</span><br><span class="line">    every_n_steps&#x3D;50)</span><br></pre></td></tr></table></figure>
<p>将此代码放置在实例化<code>classifier</code>的行之前。</p>
<p><code>ValidationMonitor</code>依赖于保存的检查点来执行评估操作，因此您需要通过修改分类器的实例化，来添加包含<code>save_checkpoints_secs</code>的来指定在训练运行期间每个checkpoint之间消耗了多少秒的<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/RunConfig"><code>tf.contrib.learn.RunConfig</code></a>。由于鸢尾花数据集非常小，因此可以快速进行训练，将<code>save_checkpoints_secs</code>设置为1（每秒保存一个检查点）以确保有足够数量的检查点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier &#x3D; tf.contrib.learn.DNNClassifier(</span><br><span class="line">    feature_columns&#x3D;feature_columns,</span><br><span class="line">    hidden_units&#x3D;[10, 20, 10],</span><br><span class="line">    n_classes&#x3D;3,</span><br><span class="line">    model_dir&#x3D;&quot;&#x2F;tmp&#x2F;iris_model&quot;,</span><br><span class="line">    config&#x3D;tf.contrib.learn.RunConfig(save_checkpoints_secs&#x3D;1))</span><br></pre></td></tr></table></figure>
<p>注意：<code>model_dir</code>参数为要存储的模型数据指定显式目录（<code>/tmp/iris_model</code>）;此目录路径将比后面自动生成的路径更容易引用。每次运行代码时，在<code>/tmp/iris_model</code>目录下的任何的数据都会被加载，并且模型训练将会在上次停止的位置继续进行（例如，连续运行两次2000步<code>fit</code>操作的脚本将在训练期间执行4000步操作）。如果想要从头开始模型训练，那么需要在执行训练前删除<code>/tmp/iris_model</code>目录。</p>
<p>最后，为了附加您的<code>validation_monitor</code>，更新<code>fit</code>调用，来包含一个包含在模型训练期间运行的所有监视器的列表的监视器参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.fit(x&#x3D;training_set.data,</span><br><span class="line">               y&#x3D;training_set.target,</span><br><span class="line">               steps&#x3D;2000,</span><br><span class="line">               monitors&#x3D;[validation_monitor])</span><br></pre></td></tr></table></figure>
<p>现在，当您重新运行代码时，您应该会在日志输出中看到验证指标，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Validation (step 50): loss &#x3D; 1.71139, global_step &#x3D; 0, accuracy &#x3D; 0.266667</span><br><span class="line">...</span><br><span class="line">INFO:tensorflow:Validation (step 300): loss &#x3D; 0.0714158, global_step &#x3D; 268, accuracy &#x3D; 0.966667</span><br><span class="line">...</span><br><span class="line">INFO:tensorflow:Validation (step 1750): loss &#x3D; 0.0574449, global_step &#x3D; 1729, accuracy &#x3D; 0.966667</span><br></pre></td></tr></table></figure>
<h3 id="使用MetricSpec自定义评估指标"><a href="#使用MetricSpec自定义评估指标" class="headerlink" title="使用MetricSpec自定义评估指标"></a>使用MetricSpec自定义评估指标</h3><p>默认情况下，如果未指定评估指标，<code>ValidationMonitor</code>将同时记录loss和accuracy精确度，但您可以自定义将每隔50个步骤运行的指标列表。要指定要在每个评估传递中运行的确切指标，您可以向<code>ValidationMonitor</code>构造函数添加一个<code>metrics</code>参数。<code>metrics</code>接受一个key/value的字典，其中字典的每个键是您要为该指标记录的名称，对应的值是<a href="https://www.tensorflow.org/code/tensorflow/contrib/learn/python/learn/metric_spec.py"><code>MetricSpec</code></a>对象。</p>
<p><code>MetricSpec</code>构造函数接受四个参数：</p>
<ul>
<li><p><code>metric_fn</code> 计算和返回指标值的函数。这可以是<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/metrics">tf.contrib.metrics</a>模块中可用的预定义函数，例如<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/metrics/streaming_precision">tf.contrib.metrics.streaming_precision</a>或<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/metrics/streaming_recall">tf.contrib.metrics.streaming_recall</a>。或者，您可以定义自己的自定义指标函数，必须将<code>predictions</code>和<code>labels</code>tensor作为参数(还可以可选地提供<code>weights</code>参数)。函数必须以以下两种格式之一返回度量的值：</p>
<ul>
<li>单个的tensor </li>
<li>一对操作(<code>value_op</code>, <code>update_op</code>)，其中<code>value_op</code>返回度量值，<code>update_op</code>执行相应的操作以更新内部模型状态。</li>
</ul>
</li>
<li><p><code>prediction_key</code> 包含模型返回的预测的tensor的key。如果模型返回单个tensor或带有单个条目的字典，则可以省略此参数。对于<code>DNNClassifier</code>模型，类别预测将在带有关键字<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/learn/PredictionKey#CLASSES"><code>tf.contrib.learn.PredictionKey.CLASSES</code></a>的tensor中返回。</p>
</li>
<li><code>label_key</code> tensor的键包含模型返回的标签，由模型的<a href="https://www.tensorflow.org/get_started/input_fn"><code>input_fn</code></a>指定。与<code>prediction_key</code>一样，如果<code>input_fn</code>返回单个tensor或具有单个条目的字典，则可以省略此参数。在本教程的鸢尾花样本中，<code>DNNClassifier</code>没有<code>input_fn</code>（<code>x</code>，<code>y</code>数据直接传递给<code>fit</code>），因此没有必要提供<code>label_key</code>。</li>
<li><code>weights_key</code> 可选参数。tensor的键（由<a href="https://www.tensorflow.org/get_started/input_fn"><code>input_fn</code></a>返回），包含<code>metric_fn</code>的权重输入。</li>
</ul>
<p>以下代码创建了一个<code>validation_metrics</code>字典，它定义了在模型评估期间要记录的三个指标：</p>
<ul>
<li><code>&quot;accuracy&quot;(准确性)</code>,使用<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/metrics/streaming_accuracy"><code>tf.contrib.metrics.streaming_accuracy</code></a>作为<code>metric_fn</code>。</li>
<li><code>&quot;precision&quot;(精确)</code>,使用<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/metrics/streaming_precision"><code>tf.contrib.metrics.streaming_precision</code></a>作为<code>metric_fn</code>。</li>
<li><code>&quot;recall&quot;(召回)</code>,使用<a href="https://www.tensorflow.org/api_docs/python/tf/contrib/metrics/streaming_recall"><code>tf.contrib.metrics.streaming_recall</code></a>作为<code>metric_fn</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validation_metrics &#x3D; &#123;</span><br><span class="line">    &quot;accuracy&quot;:</span><br><span class="line">        tf.contrib.learn.metric_spec.MetricSpec(</span><br><span class="line">            metric_fn&#x3D;tf.contrib.metrics.streaming_accuracy,</span><br><span class="line">            prediction_key&#x3D;tf.contrib.learn.prediction_key.PredictionKey.</span><br><span class="line">            CLASSES),</span><br><span class="line">    &quot;precision&quot;:</span><br><span class="line">        tf.contrib.learn.metric_spec.MetricSpec(</span><br><span class="line">            metric_fn&#x3D;tf.contrib.metrics.streaming_precision,</span><br><span class="line">            prediction_key&#x3D;tf.contrib.learn.prediction_key.PredictionKey.</span><br><span class="line">            CLASSES),</span><br><span class="line">    &quot;recall&quot;:</span><br><span class="line">        tf.contrib.learn.metric_spec.MetricSpec(</span><br><span class="line">            metric_fn&#x3D;tf.contrib.metrics.streaming_recall,</span><br><span class="line">            prediction_key&#x3D;tf.contrib.learn.prediction_key.PredictionKey.</span><br><span class="line">            CLASSES)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ValidationMonitor</code>构造函数之前添加上面的代码。然后按如下所示修改<code>ValidationMonitor</code>构造函数，以添加度量参数以记录<code>validation_metrics</code>中指定的accuracy，precision和recall指标（loss是始终被记录的，不需要显示的设定）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validation_monitor &#x3D; tf.contrib.learn.monitors.ValidationMonitor(</span><br><span class="line">    test_set.data,</span><br><span class="line">    test_set.target,</span><br><span class="line">    every_n_steps&#x3D;50,</span><br><span class="line">    metrics&#x3D;validation_metrics)</span><br></pre></td></tr></table></figure>
<p>重新运行代码，您应该会在日志输出中看到precision和recall，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Validation (step 50): recall &#x3D; 0.0, loss &#x3D; 1.20626, global_step &#x3D; 1, precision &#x3D; 0.0, accuracy &#x3D; 0.266667</span><br><span class="line">...</span><br><span class="line">INFO:tensorflow:Validation (step 600): recall &#x3D; 1.0, loss &#x3D; 0.0530696, global_step &#x3D; 571, precision &#x3D; 1.0, accuracy &#x3D; 0.966667</span><br><span class="line">...</span><br><span class="line">INFO:tensorflow:Validation (step 1500): recall &#x3D; 1.0, loss &#x3D; 0.0617403, global_step &#x3D; 1452, precision &#x3D; 1.0, accuracy &#x3D; 0.966667</span><br></pre></td></tr></table></figure>
<h3 id="通过ValidationMonitor来提前停止"><a href="#通过ValidationMonitor来提前停止" class="headerlink" title="通过ValidationMonitor来提前停止"></a>通过ValidationMonitor来提前停止</h3><p>注意，在上述日志输出中，通过600步训练，模型已经实现了1.0的精确度和召回率。这体现出了一个问题，即模型训练是否可以从<a href="https://en.wikipedia.org/wiki/Early_stopping">提前停止</a>中受益。</p>
<p>除了记录eval指标外，<code>ValidationMonitor</code>还可以通过三个参数轻松实现提前停止：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>early_stopping_metric</code></td>
<td style="text-align:left">在<code>early_stopping_rounds</code>和<code>early_stopping_metric_minimize</code>中指定的条件下触发提前停止的指标（例如，loss或accuracy）。默认为“loss”。</td>
</tr>
<tr>
<td style="text-align:left"><code>early_stopping_metric_minimize</code></td>
<td style="text-align:left">如果期望的模型行为是最小化<code>early_stopping_metric</code>的值，则为<code>True</code>;如果期望的模型行为是最大化<code>early_stopping_metric</code>的值，则为<code>False</code>。默认值是<code>True</code></td>
</tr>
<tr>
<td style="text-align:left"><code>early_stopping_rounds</code></td>
<td style="text-align:left">设置如果<code>early_stopping_metric</code>不减小（如果<code>early_stopping_metric_minimize</code>为<code>True</code>）或增加（如果<code>early_stopping_metric_minimize</code>为<code>False</code>）的步骤数，训练将会停止。默认值为<code>None</code>，这意味着永远不会发生提前停止。</td>
</tr>
</tbody>
</table>
</div>
<p>对<code>ValidationMonitor</code>的构造函数进行以下修改，其指定如果在200个步骤（<code>early_stopping_rounds = 200</code>）的时段内loss（<code>early_stopping_metric =“loss”</code>）不减小（<code>early_stopping_metric_minimize = True</code>），模型训练将在该点立即停止，并且不会完成<code>fit</code>中指定的2000步训练：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">validation_monitor &#x3D; tf.contrib.learn.monitors.ValidationMonitor(</span><br><span class="line">    test_set.data,</span><br><span class="line">    test_set.target,</span><br><span class="line">    every_n_steps&#x3D;50,</span><br><span class="line">    metrics&#x3D;validation_metrics,</span><br><span class="line">    early_stopping_metric&#x3D;&quot;loss&quot;,</span><br><span class="line">    early_stopping_metric_minimize&#x3D;True,</span><br><span class="line">    early_stopping_rounds&#x3D;200)</span><br></pre></td></tr></table></figure>
<p>重新运行代码以查看模型训练是否提前停止：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">INFO:tensorflow:Validation (step 1150): recall &#x3D; 1.0, loss &#x3D; 0.056436, global_step &#x3D; 1119, precision &#x3D; 1.0, accuracy &#x3D; 0.966667</span><br><span class="line">INFO:tensorflow:Stopping. Best step: 800 with loss &#x3D; 0.048313818872.</span><br></pre></td></tr></table></figure>
<p>实际上，这里的训练在第1150步时停止，这说明对于过去的200步，损失没有减少，并且总体上，第800步针对测试数据集产生最小损失值。这表明通过减少步数来额外校准超参数可以进一步改善模型。</p>
<h2 id="使用TensorBoard可视化日志数据"><a href="#使用TensorBoard可视化日志数据" class="headerlink" title="使用TensorBoard可视化日志数据"></a>使用TensorBoard可视化日志数据</h2><p>通过<code>ValidationMonitor</code>生成的日志读取提供了大量关于模型在训练期间的性能的原始数据，这也对数据可视化以进一步了解趋势是有帮助的 - 例如，精确度是如何随着步数变化而变化的。您可以使用TensorBoard（与TensorFlow一起打包的单独程序）通过将<code>logdir</code>命令行参数设置为保存模型训练数据的目录（此处为<code>/tmp/iris_model</code>）来绘制这样的图。在命令行上运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tensorboard --logdir&#x3D;&#x2F;tmp&#x2F;iris_model&#x2F;</span><br><span class="line">Starting TensorBoard 39 on port 6006</span><br></pre></td></tr></table></figure>
<p>然后在你的浏览器中打开<code>http://0.0.0.0:&lt;port_number&gt;</code>，<code>&lt;port_number&gt;</code>是在命令行输出中指定的端口（此处为<code>6006</code>）。</p>
<p>如果单击accuracy(准确度)字段，您将看到类似以下的图像，其中显示了针对步数的精确度：</p>
<p><img src="/img/17_03_07/031.png" alt=""></p>
<p>有关使用TensorBoard的更多信息，请参阅<a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-可视化学习/">TensorBoard:可视化学习</a>和<a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-图的可视化/">TensorBoard:图的可视化</a>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】入门教程</title>
    <url>/2017/02/20/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li><a href="/2017/02/20/【Tensorflow%20r1.0%20文档翻译】TensorFlow入门/">【TensorFlow入门】</a></li>
<li><a href="/2017/02/22/【Tensorflow%20r1.0%20文档翻译】机器学习的HelloWorld%20--%20MNIST手写数字识别/">【机器学习的HelloWorld — MNIST手写数字识别】</a></li>
<li><a href="/2017/02/26/【Tensorflow%20r1.0%20文档翻译】深入MNIST--专家级/">【深入MNIST — 专家级】</a></li>
<li><a href="/2017/03/03/【Tensorflow%20r1.0%20文档翻译】Tensorflow原理导论/">【TensorFlow原理导论】</a></li>
<li><a href="/2017/03/05/【Tensorflow%20r1.0%20文档翻译】【tf.contrib.learn快速入门】/">【tf.contrib.learn快速入门】</a></li>
<li><a href="/2017/03/06/【Tensorflow%20r1.0%20文档翻译】通过tf.contrib.learn来构建输入函数/">【通过tf.contrib.learn来构建输入函数】</a></li>
<li><a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-可视化学习/">【TensorBoard:可视化学习】</a></li>
<li><a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-嵌入可视化/">【TensorBoard:嵌入可视化】</a></li>
<li><a href="/2017/03/07/【Tensorflow%20r1.0%20文档翻译】TensorBoard-图的可视化/">【TensorBoard:图的可视化】</a></li>
<li><a href="/2017/03/09/【Tensorflow%20r1.0%20文档翻译】使用tf.contrib.learn记录和监视的基本知识/">【使用tf.contrib.learn记录和监视的基本知识】</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】机器学习的HelloWorld -- MNIST手写数字识别</title>
    <url>/2017/02/22/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84HelloWorld%20--%20MNIST%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>本教程面向那些不熟悉<strong>机器学习</strong>和<strong>TensorFlow</strong>的读者。如果你已经知道MNIST是什么，softmax（多项Logistic）回归是什么，你可能更喜欢这个<a href="/2017/02/26/【Tensorflow%20r1.0%20文档翻译】深入MNIST--专家级/">更快节奏的教程</a>。在开始教程之前，请确认<a href="https://www.tensorflow.org/install/index">安装TensorFlow</a>。</p>
<p>当一个人开始学习如何编程时，有一个传统，就是编写的第一个程序是能够打印”Hello World.”的程序。正如编程中的”Hello World”一样，机器学习中有MNIST。</p>
<p>MNIST是一个简单的计算机视觉数据集。它由像以下这样的手写数字的图像组成：</p>
<p><img src="/img/17_02_22/001.png" alt=""></p>
<p>它还包括每个图像的标签，用于标识是哪个数字。例如，上述图像的标签是<code>5</code>,<code>0</code>,<code>4</code>和<code>1</code>。</p>
<p>在本教程中，我们将训练一个模型，用来查看图像并预测它们是什么数字。我们的目标不是训练一个真正精准的，拥有高性能的模型，而是浅尝辄止的来体验一下TensorFlow的使用。 - 尽管我们稍后会给出实现这种效果的代码。因此，我们将从一个非常简单的，称为<strong>Softmax回归</strong>的模型开始。</p>
<p>这个教程的实际代码非常短，其中真正有趣的东西只有三行代码。然而，了解背后的想法是非常重要的：TensorFlow如何工作和核心机器学习概念。因此，我们将非常仔细地完成这部分代码。</p>
<h2 id="关于本教程"><a href="#关于本教程" class="headerlink" title="关于本教程"></a>关于本教程</h2><p>本教程是对<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/mnist_softmax.py">mnist_softmax.py</a>中的代码进行逐行解释。</p>
<p>您可以通过以下几种不同的方式使用本教程：</p>
<ul>
<li>在阅读每行的解释时，将每个代码段逐行复制并粘贴到Python环境中。</li>
<li>在阅读教程期间，运行整个mnist_softmax.py，并使用本教程来了解您不清楚的代码行。</li>
</ul>
<p>我们将在本教程中完成：</p>
<ul>
<li>了解MNIST数据和softmax回归。</li>
<li>创建一个函数，它是一个用于识别数字的模型，其识别原理是基于查看图像中的每个像素的值来实现的。</li>
<li>使用TensorFlow来训练模型以识别数字，其训练方式是“查看”数千个示例（运行我们的第一个TensorFlow会话来执行此逻辑）。</li>
<li>使用我们的测试数据检查模型的精度。</li>
</ul>
<h2 id="MNIST数据集"><a href="#MNIST数据集" class="headerlink" title="MNIST数据集"></a>MNIST数据集</h2><p>MNIST数据集托管在<a href="http://yann.lecun.com/exdb/mnist/">Yann LeCun的站点</a>。如果您要复制粘贴本教程中的代码，请从这两行代码开始，这两行代码将自动下载并读入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&quot;MNIST_data&#x2F;&quot;, one_hot&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>MNIST数据被分为三部分：55,000个训练数据（<code>mnist.train</code>），10,000个测试数据（<code>mnist.test</code>）和5,000个验证数据（<code>mnist.validation</code>）。这种切分是非常重要的：它能通过一部分我们并没有实际用来训练学习的数据，来确保我们的算法有很好的通用性。</p>
<p>如前所述，每个MNIST数据点有两个部分：手写数字的图像和相应的标签。我们称为图像”x”和标签”y”。训练集和测试集都包含图像及其相应的标签;例如训练图像是<code>mnist.train.images</code>，训练标签是<code>mnist.train.labels</code>。</p>
<p>每张图像的尺寸是28×28像素。我们可以把它解释为一个大的数组：</p>
<p><img src="/img/17_02_22/002.png" alt=""></p>
<p>我们可以将这个数组变成一个长度为28x28 = 784的向量。如何平铺数组其实并不重要，重要的是要保证图像和数组之间的一致性。从这个角度来看，MNIST图像只是784维向量空间中的一堆点，具有<a href="http://colah.github.io/posts/2014-10-Visualizing-MNIST/">非常丰富的结构</a>（警告：计算密集的可视化）。</p>
<p>展平数据丢弃了关于图像的2D结构的信息。这样做是不是并不够好？没错，最好的计算机视觉方法确实可以利用这种2D结构信息，我们将在后面的教程进行介绍。但是我们在这里所使用的一种简单方法：<strong>softmax回归</strong>（下面会给出定义），不会利用到这种信息。</p>
<p><code>mnist.train.images</code>是形状为<code>[55000,784]</code>的张量（n维数组）。第一个维度是在列表中图像的索引，第二个维度是每个图像中的每个像素点的索引。对于特定图像中的特定像素，张量中的每个条目是介于0和1之间的像素强度。</p>
<p><img src="/img/17_02_22/003.png" alt=""></p>
<p>MNIST中的每个图像都有相应的标签，标签用介于0到9之间的数字表示图像中绘制的数字。</p>
<p>为了达到本教程的目的，我们需要要将我们的标签作为“one-hot 向量”。one-hot向量是指在大多数维度上数值为0，仅在其中一个维度上数值为1的向量。在这种情况下，第n个数字将被表示为在第n维中为1的向量。例如，3将表示为$[0,0,0,1,0,0,0,0,0,0]$。因此，<code>mnist.train.labels</code>是一个形状为<code>[55000, 10]</code>的数字矩阵。</p>
<p><img src="/img/17_02_22/004.png" alt=""></p>
<p>现在，我们可以开始构建我们的模型啦！</p>
<h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h2><p>我们知道MNIST中的每个图像都是一个在0和9之间的手写数字。因此，对于给定的图像，只有10种可能的结果。我们想要能够看到一个图像，并给出它的每个数字的概率。例如，用我们的模型来查看一个9的图片，80％的可能性确认是9，但有5％的可能是8（因为8和9顶部都有一个圈），剩余的可能性分布在其他数值上。</p>
<p>这是一个<strong>softmax回归</strong>的典型案例。如果你想给一个对象赋予其表示不同数字的概率，可以使用softmax，因为softmax可以得出一组介于0到1之间的值，并且这组值加起来结果为1。即使在以后，当我们训练其他更复杂的模型时，最后一步也是一层softmax。</p>
<p>softmax回归有两个步骤：首先我们将图片中属于某个特定数字的证据（evidence）相加，然后将该证据转换为概率。</p>
<p>为了计算给定图像在特定类中的证据，我们对像素强度进行加权求和。如果像素点有很高的强度表示和对应的标签数字不匹配，那么这一点的权值是负数，相反，权值是正数。</p>
<p>下面的图片显示了一个模型学习到的图片上每个像素对于特定数字类的权值。红色表示负权重，蓝色表示正权重。</p>
<p><img src="/img/17_02_22/005.png" alt=""></p>
<p>我们还需要增加一个偏置量（bias），因为输入往往会带有一些无关的干扰量。因此对于给定的输入图片<strong>x</strong>它代表的是数字<strong>i</strong>的证据可以表示为：</p>
<script type="math/tex; mode=display">
\text{evidence}\_i = \sum\_j W_\{i,~ j} x\_j + b\_i</script><p>其中，$W_i$表示权值，$b_i$代表$i$类别的偏置量，$j$代表给定图片$x$的像素索引，用于像素求和。然后用softmax函数可以把这些证据转换成概率<strong>y</strong>：</p>
<script type="math/tex; mode=display">
y = \text{softmax}(\text{evidence})</script><p>这里softmax用作“激活”或“链接”函数，将我们的线性函数的输出变形为我们想要的形式 - 在这里，也就是10种数字的概率分布。你可以把它看作是将证据转换为每种分类的概率。它的定义是：</p>
<script type="math/tex; mode=display">
\text{softmax}(x) = \text{normalize}(\exp(x))</script><p>如果你把这个方程展开，你将得到：</p>
<script type="math/tex; mode=display">
\text{softmax}(x)\_i = \frac{\exp(x\_i)}{\sum\_j \exp(x\_j)}</script><p>但通常我们把softmax定义为第一种形式：对其输入求幂，然后将其归一化处理。这里幂运算表示，更大的证据对应更大的假设模型（hypothesis）里面的乘数权重值。反之，拥有更少的证据意味着在假设模型里面拥有更小的乘数系数。假设模型里的权值不可以是0值或者负值。Softmax然后会正则化这些权重值，使它们的总和等于1，以此构造一个有效的概率分布。（更多的关于Softmax函数的信息，可以参考Michael Nieslen的书里面的这个<a href="http://neuralnetworksanddeeplearning.com/chap3.html#softmax">部分</a>，其中有关于softmax的可交互式的可视化解释。）</p>
<p>softmax回归可以表示为下面这张图，不过真实情况下会有更多的$x$值。我们通过计算出$x$的权值之和加上一个偏置量，然后代入到一个softmax中，来计算出每个输出值。</p>
<p><img src="/img/17_02_22/006.png" alt=""></p>
<p>如果我们把它写成方程的形式，我们将得到：</p>
<p><img src="/img/17_02_22/007.png" alt=""></p>
<p>我们可以“向量化”这个过程，把它变成矩阵乘法和向量加法。这有助于提升计算效率。 （这也是一个有用的思考方式。）</p>
<p><img src="/img/17_02_22/008.png" alt=""></p>
<p>更紧凑的表达形式如下：</p>
<script type="math/tex; mode=display">
y = \text{softmax}(Wx + b)</script><p>现在让我们把它变成TensorFlow可以使用的形式。</p>
<h2 id="回归的实现"><a href="#回归的实现" class="headerlink" title="回归的实现"></a>回归的实现</h2><p>为了在Python中进行高效的数值计算，我们通常使用像<strong><a href="http://www.numpy.org/">NumPy</a></strong>这样的库，它们会把类似矩阵乘法这样的复杂运算使用其他外部语言实现。不幸的是，从外部计算切换回Python的每一个操作，仍然是一个很大的开销。如果要在GPU上以分布式方式运行计算，那么这种开销尤其糟糕，其中传输数据的成本很高。</p>
<p>TensorFlow也在Python之外做了很大量的计算工作，但它做了进一步的完善以改善前面说的那种切换。TensorFlow不是独立于Python运行一个昂贵的操作，而是让我们可以先用图描述一系列可交互的计算操作，然后全部一起在Python之外运行。（这样类似的运行方式，可以在不少的机器学习库中看到。）</p>
<p>要使用TensorFlow，首先我们需要导入它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br></pre></td></tr></table></figure>
<p>我们通过操作符号变量来描述这些交互的操作单元。让我们用下面的方式创建一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; tf.placeholder(tf.float32, [None, 784])</span><br></pre></td></tr></table></figure>
<p><code>x</code>不是一个特定的值。它是一个占位符(<code>placeholder</code>)，当我们要求TensorFlow运行一个计算时，我们将输入一个值。我们希望能够输入任意数量的MNIST图像，其中每个图像都被展开为784维向量。我们将其表示为float类型的2-D张量，形状为<code>[None, 784]</code>。（这里的<code>None</code>表示维度可以是任何长度。）</p>
<p>我们的模型还需要权重和偏差。当然我们可以把它们当做是另外的输入（使用占位符），但TensorFlow有一个更好的方法来表示它们：<code>Variable</code>。<code>Variable</code>代表一个可修改的张量，它存在于TensorFlow中用于描述交互性操作的图中。在计算过程中，它们可以被拿来使用甚至可以修改。对于机器学习应用，一般都会有模型参数，可以用Variable表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W &#x3D; tf.Variable(tf.zeros([784, 10]))</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros([10]))</span><br></pre></td></tr></table></figure>
<p>我们通过给与<code>tf.Variable</code>初始值来创建<code>Variable</code>:在这种情况下，我们将<code>W</code>和<code>b</code>初始化为全部为0的张量。因为我们要通过学习得到<code>W</code>和<code>b</code>，因此它们的初始值具体是什么并不重要。</p>
<p>注意，<code>W</code>的形状为<code>[784,10]</code>，因为我们想要用784维的图片向量乘以它以得到一个10维的证据值向量，其中每一位对应着不同数字类别。<code>b</code>的形状是<code>[10]</code>，所以我们可以直接把它加到输出上面。</p>
<p>现在，我们可以实现我们的模型啦。只需要一行代码！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; tf.nn.softmax(tf.matmul(x, W) + b)</span><br></pre></td></tr></table></figure>
<p>首先，我们通过表达式<code>tf.matmul(x, W)</code>将<code>x</code>和<code>W</code>相乘。这对应于前面方程中的$Wx$，<code>x</code>是一个拥有多个输入的2D张量。紧接着，我们加上<code>b</code>，最后，代入到<code>tf.nn.softmax</code>中。</p>
<p>就是这样，在几行用来设置变量的代码之后，我们只需要一行代码就可以定义好我们的模型。这不仅仅是因为TensorFlow被设计为使<strong>softmax回归</strong>变得特别简单，它也用这种非常灵活的方式来描述其他各种数值计算，从机器学习模型对物理学模拟仿真模型。一旦被定义好之后，我们的模型就可以在不同的设备上运行：计算机的CPU，GPU，甚至是手机！</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>为了训练我们的模型，我们首先需要定义一个指标来评估这个模型是好的。实际上，在机器学习中，我们通常定义指标来表示一个模型是坏的，这个指标称为成本（cost）或损失（loss），然后尽量最小化这个指标。</p>
<p>一个非常常见的，非常好的用来衡量模型损失的函数称为“<strong>交叉熵(cross-entropy)</strong>”。交叉熵产生于信息论里面的信息压缩编码技术，但是它后来演变成为从博弈论到机器学习等其他领域里的重要技术手段。它的定义如下：</p>
<script type="math/tex; mode=display">
H\_{y'}(y) = -\sum\_i y'\_i \log(y\_i)</script><p><strong>y</strong>是我们预测的概率分布,<strong>y’</strong>是实际的分布（我们输入的one-hot vector)。比较粗糙的理解是，交叉熵是用来衡量相对于真实值我们所给出的预测的低效性。有关交叉熵的更详细的讨论超出了本教程的范畴，但<a href="http://colah.github.io/posts/2015-09-Visual-Information/">理解它的原理</a>很有必要。</p>
<p>为了计算交叉熵，我们首先需要添加一个新的占位符用于输入正确值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y_ &#x3D; tf.placeholder(tf.float32, [None, 10])</span><br></pre></td></tr></table></figure>
<p>然后，我们可以实现交叉熵方法:$-\sum y’\log(y)$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cross_entropy &#x3D; tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices&#x3D;[1]))</span><br></pre></td></tr></table></figure>
<p>首先，<code>tf.log</code>计算了每个<code>y</code>的对数。接下来，我们将<code>y_</code>与相应的<code>tf.log(y)</code>的元素做乘法运算。然后，由于参数<code>reduction_indices=[1]</code>，<code>tf.reduce_sum</code>将<code>y</code>中的第二维中的元素相加求和。最后，通过<code>tf.reduce_mean</code>计算批次中所有示例的平均值。</p>
<p>注意，在源码中，我们不使用这些信息，因为它在数值上并不稳定。取而代之的是，我们将<code>tf.nn.softmax_cross_entropy_with_logits</code>用于非规范化的逻辑上（例如，我们对<code>tf.matmul(x, W) + b</code>使用<code>softmax_cross_entropy_with_logits</code>），因为这样在数值上更稳定方法，它在内部执行了softmax的计算。在你的代码中考虑使用<code>tf.nn.softmax_cross_entropy_with_logits</code>来代替之前的逻辑。</p>
<p>现在，我们知道了我们想要我们的模型做什么，使用TensorFlow来训练它也非常简单。因为TensorFlow知道用于计算的整个图（graph），它会自动地使用<strong><a href="http://colah.github.io/posts/2015-08-Backprop/">反向传播算法</a></strong>来有效地确定你的变量是如何影响你想要最小化的那个成本值的。然后它可以应用您选择的优化算法修改变量和减少损失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)</span><br></pre></td></tr></table></figure>
<p>在这里，我们通过使用学习率为0.5的<a href="https://en.wikipedia.org/wiki/Gradient_descent">梯度下降算法</a>令TensorFlow最小化<code>cross_entropy</code>（交叉熵）。梯度下降是一个简单的程序，它的原理是每次向着减少损失的方向移动一小步，来最小化代价函数。但TensorFlow也提供了<a href="https://www.tensorflow.org/api_guides/python/train#optimizers">很多其他的优化算法</a>，只需要简单的调整一行代码就可以随意切换。</p>
<p>TensorFlow在这里实际上所做的是，它会在后台给描述你的计算的那张图里面增加一系列新的计算操作单元，用于实现反向传播算法和梯度下降算法。然后，它返回给你的只是一个单一的操作，当运行这个操作时，它用梯度下降算法训练你的模型，微调你的变量，不断减少成本。</p>
<p>我们现在可以在<code>InteractiveSession</code>中启动我们的模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess &#x3D; tf.InteractiveSession()</span><br></pre></td></tr></table></figure>
<p>我们首先要创建一个操作来初始化我们创建的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tf.global_variables_initializer().run()</span><br></pre></td></tr></table></figure>
<p>让我们开始执行训练 - 我们将运行1000次训练步骤！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for _ in range(1000):</span><br><span class="line">  batch_xs, batch_ys &#x3D; mnist.train.next_batch(100)</span><br><span class="line">  sess.run(train_step, feed_dict&#x3D;&#123;x: batch_xs, y_: batch_ys&#125;)</span><br></pre></td></tr></table></figure>
<p>每循环一次，我们将从我们的训练集中得到一批100个随机数据点。然后我们用这些数据点作为参数替换之前的占位符来运行<code>train_step</code>。</p>
<p>使用小批随机数据称为<strong>随机训练(stochastic training)</strong> - 在这里更确切的说是随机梯度下降训练。理想情况下，我们希望将所有数据用于训练的每个步骤，因为这能给我们更好的训练结果，但很明显这需要很大的计算开销。所以，每一次训练我们可以使用不同的数据子集，这样做既可以减少计算开销，又可以最大化地学习到数据集的总体特性。</p>
<h2 id="评估我们的模型"><a href="#评估我们的模型" class="headerlink" title="评估我们的模型"></a>评估我们的模型</h2><p>那么我们的模型表现如何呢？</p>
<p>首先，来让我们找出那些预测正确的标签。<code>tf.argmax</code>是一个很有用的方法，它能给出某个tensor对象在某一维上的其数据最大值所在的索引值。例如，<code>tf.argmax(y，1)</code>是我们的模型认为每个输入最可能的标签，而<code>tf.argmax(y_，1)</code>是正确的标签。我们可以用<code>tf.equal</code>来检查我们我预测值与真实值是否相符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y,1), tf.argmax(y_,1))</span><br></pre></td></tr></table></figure>
<p>这行代码会给我们一组布尔值。为了确定正确预测项的比例，我们可以把布尔值转换成浮点数，然后取平均值。例如，<code>[True, False, True, True]</code>会变成<code>[1,0,1,1]</code>，取平均值后得到<code>0.75</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br></pre></td></tr></table></figure>
<p>最后，我们计算所学习到的模型在测试数据集上面的正确率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(sess.run(accuracy, feed_dict&#x3D;&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))</span><br></pre></td></tr></table></figure>
<p>结果大概维持在92%左右。</p>
<p>这种结果很好吗？其实并不是很好。其实，它相当差。这是因为我们使用的是一个非常简单的模型。我们可以通过做一些简单的修改，可以将正确率提高到97%。事实上，最优秀的模型可以达到超过99.7%的准确率！（想了解更多信息，可以看看这个关于各种模型的<a href="http://rodrigob.github.io/are_we_there_yet/build/classification_datasets_results.html">性能对比列表</a>。)</p>
<p>比结果更重要的是，我们从这个模型中学习到的设计思想。不过，如果你仍然对这里的结果有点失望，可以查看<a href="/2017/02/26/【Tensorflow%20r1.0%20文档翻译】深入MNIST--专家级/">下一个教程</a>，在那里你可以学习如何用FensorFlow构建更加复杂的模型以获得更好的性能！</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】深入MNIST--专家级</title>
    <url>/2017/02/26/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E6%B7%B1%E5%85%A5MNIST--%E4%B8%93%E5%AE%B6%E7%BA%A7/</url>
    <content><![CDATA[<p>TensorFlow是一个用于进行大规模数值计算的强大库。其擅长的任务之一是实施和训练深层神经网络。在本教程中，我们将学到构建一个TensorFlow模型的基本步骤，并将通过这些步骤为MNIST构建一个深度卷积神经网络。</p>
<p>这个教程假设你已经熟悉神经网络和MNIST数据集。如果你尚未了解，请查看<a href="/2017/02/22/【Tensorflow%20r1.0%20文档翻译】机器学习的HelloWorld%20--%20MNIST手写数字识别/">新手指南</a>。在开始之前，请确认<a href="https://www.tensorflow.org/install/index">安装</a>了TensorFlow。</p>
<h2 id="关于本教程"><a href="#关于本教程" class="headerlink" title="关于本教程"></a>关于本教程</h2><p>本教程的第一部分解释了<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/mnist/mnist_softmax.py">mnist_softmax.py</a>代码中发生了什么，这是Tensorflow模型的基本实现。第二部分显示了一些提高精度的方法。</p>
<p>您可以将本教程中的每个代码段复制并粘贴到Python环境中，当然你也可以选择只是读一下这部分代码。</p>
<p>我们将在本教程中完成：</p>
<ul>
<li>创建一个softmax回归函数，这是一个用于识别MNIST数字的模型，其原理是基于查看图像中的每个像素。</li>
<li>使用Tensorflow来训练模型以识别数字，方法是“查看”数千个示例（并运行我们的第一个Tensorflow会话）。</li>
<li>使用我们的测试数据检查模型的精度。</li>
<li>构建，训练和测试多层卷积神经网络以提高结果。</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在我们创建模型之前，我们首先加载MNIST数据集，并启动TensorFlow会话。</p>
<h3 id="加载MNIST数据"><a href="#加载MNIST数据" class="headerlink" title="加载MNIST数据"></a>加载MNIST数据</h3><p>如果您要复制粘贴本教程中的代码，请从这两行代码开始，这两行代码将自动下载并读入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tensorflow.examples.tutorials.mnist import input_data</span><br><span class="line">mnist &#x3D; input_data.read_data_sets(&#39;MNIST_data&#39;, one_hot&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>这里的<code>mnist</code>是一个轻量级类，将训练集，验证集和测试集存储为NumPy数组。同时提供了一个函数，用于在迭代中获得minibatch，后面我们将会用到。</p>
<h3 id="启动TensorFlow-InteractiveSession"><a href="#启动TensorFlow-InteractiveSession" class="headerlink" title="启动TensorFlow InteractiveSession"></a>启动TensorFlow InteractiveSession</h3><p>Tensorflow依赖于一个高效的C++后端来进行计算。与后端的这个连接叫做session。一般而言，使用TensorFlow程序的流程是先创建一个图，然后在session中启动它。</p>
<p>这里，我们使用更加方便的<code>InteractiveSession</code>类。通过它，你可以更加灵活地构建你的代码。它能让你在运行图的时候，插入一些<a href="https://www.tensorflow.org/get_started/get_started#the_computational_graph">计算图</a>，这些计算图是由某些操作(operations)构成的。这对于工作在交互式环境中的人们来说非常便利，比如使用IPython。如果你没有使用<code>InteractiveSession</code>，那么你需要在启动session之前构建整个计算图，然后启<a href="https://www.tensorflow.org/get_started/get_started#the_computational_graph">动该计算图</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">sess &#x3D; tf.InteractiveSession()</span><br></pre></td></tr></table></figure>
<h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>为了在Python中执行高效的数值计算，我们通常引入类似<strong><a href="http://www.numpy.org/">NumPy</a></strong>这种库来执行开销昂贵的操作。例如在Python之外其他高效的语言来执行矩阵乘法这类操作。不幸的是，每次操作之后切换回Python的动作依然是一个巨大的开销。这种开销特别的差，如果你想要以一种分布式的方式运行在GPU上的话，这里传输数据将会是一个巨大的开销。</p>
<p>TensorFlow也会在Python外部执行大量的运算，但它做了进一步的处理来规避了这种开销。取代独立于Python运行单一的代价昂贵的操作的模式，TensorFlow的方式是通过在Python中描述一个可交互的操作图，然后完全在Python之外进行运行。<strong>Theano</strong>或者<strong>Torch</strong>也有与此类似的实现。</p>
<p>在这里Python代码的作用是用来在外部定义一个操作图，然后决定具体哪一部分的运算图要被运行。详细内容，见<a href="/2017/02/20/【Tensorflow%20r1.0%20文档翻译】TensorFlow入门/">TensorFlow入门</a>中的<a href="/2017/02/20/【Tensorflow%20r1.0%20文档翻译】TensorFlow入门#用于计算的Graph（图）">用于计算的Graph（图）</a>部分。</p>
<h2 id="构建一个Softmax回归模型"><a href="#构建一个Softmax回归模型" class="headerlink" title="构建一个Softmax回归模型"></a>构建一个Softmax回归模型</h2><p>这一节，我们通过一个单一的线性层来构建一个softmax回归模型。在下一节中，我们将把这个softmax回归扩展为一个多层卷积网络。</p>
<h3 id="占位符（Placeholders）"><a href="#占位符（Placeholders）" class="headerlink" title="占位符（Placeholders）"></a>占位符（Placeholders）</h3><p>我们通过创建输入的图像创建的节点和输出的类别创建的分类来构建一个计算图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, 784])</span><br><span class="line">y_ &#x3D; tf.placeholder(tf.float32, shape&#x3D;[None, 10])</span><br></pre></td></tr></table></figure>
<p>这里<code>x</code>和<code>y_</code>不是具体的值。相反，他们都是一个<code>placeholder</code>（占位符）—当我们让TensorFlow开始执行计算时才被输入具体值。</p>
<p>输入图像的<code>x</code>包含一个2维的浮点数张量。这里我们赋予它一个<code>shape</code>（形状）为<code>[None, 784]</code>，其中<code>784</code>是由28乘28像素的图片单行展开后的维度数，<code>None</code>表示第一个维度大小不定，可以是任意尺寸，用以指代batch的大小。目标输出类别<code>y_</code>也包含一个2维的tensor，它每行都是一个10维的one-hot向量，用于表示相应的MNIST图像属于哪个数字类（0到9）。</p>
<p>虽然<code>placeholder</code>的<code>shape</code>参数是可选的，但有了它，TensorFlow能够自动捕捉因数据维度不一致导致的错误。</p>
<h3 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h3><p>我们现在为我们的模型定义了权值<code>W</code>和偏置量<code>b</code>。可以将它们当作额外的输入量，但是TensorFlow有一个更好的处理方式：<code>Variable</code>。一个<code>Variable</code>代表TensorFlow计算图中的一个值，能够在计算过程中使用，甚至进行修改。在机器学习的应用过程中，模型参数一般用<code>Variable</code>来表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W &#x3D; tf.Variable(tf.zeros([784,10]))</span><br><span class="line">b &#x3D; tf.Variable(tf.zeros([10]))</span><br></pre></td></tr></table></figure>
<p>我们在调用<code>tf.Variable</code>的时候传入初始值。在这个例子中，我们把<code>W</code>和<code>b</code>初始化全为0的tensor。<code>W</code>是一个$784×10$的矩阵（因为我们有784个输入特征以及10个输出值），<code>b</code>是一个10维向量（因为我们有10种分类）。</p>
<p>在<code>Variable</code>可以在session中被使用之前，他们必须被session初始化。此步骤使用已经指定的初始值（在这里tensor全部以0填充），并将它们分配给每个$Variable$。下面的代码可以一次初始化全部的<code>Variables</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sess.run(tf.global_variables_initializer())</span><br></pre></td></tr></table></figure>
<h3 id="类别预测与损失函数"><a href="#类别预测与损失函数" class="headerlink" title="类别预测与损失函数"></a>类别预测与损失函数</h3><p>现在我们可以实现我们自己的回归模型了。只需要一行代码！我们把向量化后的图片输入<code>x</code>和权重矩阵<code>W</code>相乘，加上偏置<code>b</code>，然后计算每个分类的softmax概率值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; tf.matmul(x,W) + b</span><br></pre></td></tr></table></figure>
<p>我们可以很容易地指定一个损失函数。损失表示模型的预测效果在单个示例的糟糕程度；在我们的训练过程中，我们会尽量去最小化这个值。在这里，我们的损失函数就是介于目标值和应用于模型预测的softmax激励函数之间的交叉熵。正如我们在新手教学中用到的稳定的方程一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cross_entropy &#x3D; tf.reduce_mean(</span><br><span class="line">    tf.nn.softmax_cross_entropy_with_logits(labels&#x3D;y_, logits&#x3D;y))</span><br></pre></td></tr></table></figure>
<p>请注意，<code>tf.nn.softmax_cross_entropy_with_logits</code>内部将softmax应用到非规范化的模型预测中，并且将所有的结果求和，通过<code>tf.reduce_mean</code>来取这些和的平均值。</p>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>现在我们已经定义好了我们的模型和用于训练的损失函数，那么用TensorFlow进行训练就很简单了。由于TensorFlow知道整个计算图，所以它可以使用自动微分来找出关于每个变量的损失梯度。TensorFlow有多种<a href="https://www.tensorflow.org/api_guides/python/train#optimizers">内置的优化算法</a>。对于这个例子，我们将使用最大梯度下降，步长为0.5，来下降交叉熵。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">train_step &#x3D; tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)</span><br></pre></td></tr></table></figure>
<p>TensorFlow在这一行中实际上是在计算图中添加新的操作。这些操作包括计算梯度，计算每个参数的步长变化，并且计算出新的参数值。</p>
<p>返回的<code>train_step</code>操作对象，在运行时会使用梯度下降来更新参数。因此，整个模型的训练可以通过反复地运行<code>train_step</code>来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for _ in range(1000):</span><br><span class="line">  batch &#x3D; mnist.train.next_batch(100)</span><br><span class="line">  train_step.run(feed_dict&#x3D;&#123;x: batch[0], y_: batch[1]&#125;)</span><br></pre></td></tr></table></figure>
<p>每次训练迭代我们都会加入100个训练样本。然后，然后执行一次<code>train_step</code>操作，并通过<code>feed_dict</code>将<code>placeholder</code>tensor<code>x</code>和<code>y_</code>，用训练训练数据替代。请注意，您可以使用<code>feed_dict</code>替换计算图形中的任何tensor。—它不仅仅局限于<code>placeholder</code>。</p>
<h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><p>那么我们的模型表现如何呢？</p>
<p>首先，来让我们找出那些预测正确的标签。<code>tf.argmax</code>是一个很有用的方法，它能给出某个tensor对象在某一维上的其数据最大值所在的索引值。例如，<code>tf.argmax(y，1)</code>是我们的模型认为每个输入最可能的标签，而<code>tf.argmax(y_，1)</code>是正确的标签。我们可以用<code>tf.equal</code>来检查我们我预测值与真实值是否相符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y,1), tf.argmax(y_,1))</span><br></pre></td></tr></table></figure>
<p>这行代码会给我们一组布尔值。为了确定正确预测项的比例，我们可以把布尔值转换成浮点数，然后取平均值。例如，<code>[True, False, True, True]</code>会变成<code>[1,0,1,1]</code>，取平均值后得到<code>0.75</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br></pre></td></tr></table></figure>
<p>最后，我们计算所学习到的模型在测试数据集上面的正确率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(accuracy.eval(feed_dict&#x3D;&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))</span><br></pre></td></tr></table></figure>
<h2 id="构建多层卷积网络"><a href="#构建多层卷积网络" class="headerlink" title="构建多层卷积网络"></a>构建多层卷积网络</h2><p>在MNIST数据集上获得92%的准确率是相当差的。甚至差到令人感到尴尬的地步。在本节中，我们将解决这个问题。我们将从一个非常简单的模型跳转到一个中等复杂的模型：一个小型的卷积神经网络。这将会使我们得到一个大概在99.2%的准确率。—虽然不是最好的结果，但还算是令人满意的一个结果。</p>
<h3 id="权值初始化"><a href="#权值初始化" class="headerlink" title="权值初始化"></a>权值初始化</h3><p>要创建这个模型，我们需要创建很多权值和偏置量。通常情况下，应该使用少量噪音数据来初始化权值以用于打破对称性，并且防止0梯度产生。由于我们使用的是<a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks">ReLU</a>)神经元，因此比较好的做法是用一个较小的正数来初始化偏置项，以避免神经元节点输出恒为0的问题（dead neurons）。为了不在建立模型的时候反复做初始化操作，我们定义两个用于初始化的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def weight_variable(shape):</span><br><span class="line">  initial &#x3D; tf.truncated_normal(shape, stddev&#x3D;0.1)</span><br><span class="line">  return tf.Variable(initial)</span><br><span class="line"></span><br><span class="line">def bias_variable(shape):</span><br><span class="line">  initial &#x3D; tf.constant(0.1, shape&#x3D;shape)</span><br><span class="line">  return tf.Variable(initial)</span><br></pre></td></tr></table></figure>
<h3 id="卷积和池化"><a href="#卷积和池化" class="headerlink" title="卷积和池化"></a>卷积和池化</h3><p>TensorFlow在卷积和池化上有很强的灵活性。我们怎么处理边界？步长应该设多大？在这个实例里，我们会一直使用vanilla版本。我们的卷积使用1步长（stride size），0边距（padding size）的模板，保证输出和输入是同一个大小。我们的池化用简单传统的2x2大小的模板做最大池（max pooling）。为了使代码更简洁，我们把这部分抽象成一个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def conv2d(x, W):</span><br><span class="line">  return tf.nn.conv2d(x, W, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;)</span><br><span class="line"></span><br><span class="line">def max_pool_2x2(x):</span><br><span class="line">  return tf.nn.max_pool(x, ksize&#x3D;[1, 2, 2, 1],</span><br><span class="line">                        strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="第一层卷积"><a href="#第一层卷积" class="headerlink" title="第一层卷积"></a>第一层卷积</h3><p>现在，我们可以实现我们的第一层了。它由一个卷积接一个最大池组成。卷积在每个5x5的patch中算出32个特征。卷积的权重tensor形状是<code>[5, 5, 1, 32]</code>。前两个维度是patch的大小，接着是输入的通道数目，最后是输出的通道数目。 而对于每一个输出通道都有一个对应的偏置量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W_conv1 &#x3D; weight_variable([5, 5, 1, 32])</span><br><span class="line">b_conv1 &#x3D; bias_variable([32])</span><br></pre></td></tr></table></figure>
<p>为了用这一层，我们把<code>x</code>变成一个4维tensor，其第<code>2</code>、第<code>3</code>维对应图片的宽、高，最后一维代表图片的颜色通道数(因为是灰度图所以这里的通道数为1，如果是rgb彩色图，则为3)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x_image &#x3D; tf.reshape(x, [-1,28,28,1])</span><br></pre></td></tr></table></figure>
<p>然后我们将<code>x_image</code>与权值tensor进行卷积，加上偏置量，然后应用ReLU激励函数，最后最大池化。<code>max_pool_2x2</code>方法可将图片大小缩小为14x14。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h_conv1 &#x3D; tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</span><br><span class="line">h_pool1 &#x3D; max_pool_2x2(h_conv1)</span><br></pre></td></tr></table></figure>
<h3 id="第二层卷积"><a href="#第二层卷积" class="headerlink" title="第二层卷积"></a>第二层卷积</h3><p>为了构建一个更深的网络，我们会把几个类似的层堆叠起来。第二层中，每个5x5的patch会得到64个特征。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W_conv2 &#x3D; weight_variable([5, 5, 32, 64])</span><br><span class="line">b_conv2 &#x3D; bias_variable([64])</span><br><span class="line"></span><br><span class="line">h_conv2 &#x3D; tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</span><br><span class="line">h_pool2 &#x3D; max_pool_2x2(h_conv2)</span><br></pre></td></tr></table></figure>
<h3 id="密集连接层"><a href="#密集连接层" class="headerlink" title="密集连接层"></a>密集连接层</h3><p>现在，图片尺寸减小到7x7，我们加入一个有1024个神经元的全连接层，用于处理整个图片。我们把池化层输出的tensor reshape成一些向量，乘上权重矩阵，加上偏置，然后对其使用ReLU。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W_fc1 &#x3D; weight_variable([7 * 7 * 64, 1024])</span><br><span class="line">b_fc1 &#x3D; bias_variable([1024])</span><br><span class="line"></span><br><span class="line">h_pool2_flat &#x3D; tf.reshape(h_pool2, [-1, 7*7*64])</span><br><span class="line">h_fc1 &#x3D; tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</span><br></pre></td></tr></table></figure>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>为了减少过拟合，我们在输出层之前加入<a href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf">dropout</a>。我们用一个<code>placeholder</code>来代表一个神经元的输出在dropout中保持不变的概率。这样我们可以在训练过程中启用dropout，在测试过程中关闭dropout。 TensorFlow的<code>tf.nn.dropout</code>操作除了可以屏蔽神经元的输出外，还会自动处理神经元输出值的scale。所以用dropout的时候可以不用考虑scale。</p>
<blockquote>
<p>对于这个小型卷积网络，性能实际上几乎相同，没有压差。Dropout往往是非常有效的减少过度拟合的方式，但当训练非常大的神经网络时，它是最有用的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keep_prob &#x3D; tf.placeholder(tf.float32)</span><br><span class="line">h_fc1_drop &#x3D; tf.nn.dropout(h_fc1, keep_prob)</span><br></pre></td></tr></table></figure>
<h3 id="读出层"><a href="#读出层" class="headerlink" title="读出层"></a>读出层</h3><p>最后，我们添加一个softmax层，就像前面的单层softmax 回归一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">W_fc2 &#x3D; weight_variable([1024, 10])</span><br><span class="line">b_fc2 &#x3D; bias_variable([10])</span><br><span class="line"></span><br><span class="line">y_conv &#x3D; tf.matmul(h_fc1_drop, W_fc2) + b_fc2</span><br></pre></td></tr></table></figure>
<h3 id="训练和评估模型"><a href="#训练和评估模型" class="headerlink" title="训练和评估模型"></a>训练和评估模型</h3><p>这个模型的效果如何呢？为了进行训练和评估，我们使用与之前简单的单层SoftMax神经网络模型几乎相同的一套代码。</p>
<p>不过有以下几点不同：</p>
<ul>
<li>我们将用更复杂的ADAM优化器来替换最陡的梯度下降优化器。</li>
<li>我们将在<code>feed_dict</code>中包含附加参数<code>keep_prob</code>来控制丢失率。</li>
<li>我们将在训练过程中的每执行100次迭代时，添加一次日志记录。</li>
</ul>
<p>随时可以继续运行此代码，但它会进行20,000次训练迭代，可能需要一段时间（可能长达半小时），具体时间取决于您的处理器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cross_entropy &#x3D; tf.reduce_mean(</span><br><span class="line">    tf.nn.softmax_cross_entropy_with_logits(labels&#x3D;y_, logits&#x3D;y_conv))</span><br><span class="line">train_step &#x3D; tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)</span><br><span class="line">correct_prediction &#x3D; tf.equal(tf.argmax(y_conv,1), tf.argmax(y_,1))</span><br><span class="line">accuracy &#x3D; tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line">for i in range(20000):</span><br><span class="line">  batch &#x3D; mnist.train.next_batch(50)</span><br><span class="line">  if i%100 &#x3D;&#x3D; 0:</span><br><span class="line">    train_accuracy &#x3D; accuracy.eval(feed_dict&#x3D;&#123;</span><br><span class="line">        x:batch[0], y_: batch[1], keep_prob: 1.0&#125;)</span><br><span class="line">    print(&quot;step %d, training accuracy %g&quot;%(i, train_accuracy))</span><br><span class="line">  train_step.run(feed_dict&#x3D;&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)</span><br><span class="line"></span><br><span class="line">print(&quot;test accuracy %g&quot;%accuracy.eval(feed_dict&#x3D;&#123;</span><br><span class="line">    x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;))</span><br></pre></td></tr></table></figure>
<p>以上代码，在最终测试集上的准确率大概是99.2%。</p>
<p>目前为止，我们已经学会了用TensorFlow快捷地搭建、训练和评估一个复杂一点儿的深度学习模型。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 文档翻译】通过tf.contrib.learn来构建输入函数</title>
    <url>/2017/03/06/%E3%80%90Tensorflow%20r1.0%20%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E3%80%91%E9%80%9A%E8%BF%87tf.contrib.learn%E6%9D%A5%E6%9E%84%E5%BB%BA%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本教程将介绍如何在tf.contrib.learn中创建输入函数。您将对如何构造一个用于预处理并将数据反馈到你的模型的<code>input_fn</code>操作有一个大致的了解。然后，您将实现一个<code>input_fn</code>，它将训练，评估和预测数据提供给神经网络回归，并用于预测房屋数据的中位数值。</p>
<h2 id="使用input-fn的自定义输入管道"><a href="#使用input-fn的自定义输入管道" class="headerlink" title="使用input_fn的自定义输入管道"></a>使用input_fn的自定义输入管道</h2><p>当通过使用tf.contrib.learn来训练一个神经网络时，可以将您的特征和目标数据直接传递到你的<code>fit</code>(拟合)、<code>evaluate</code>(评估)或<code>predict</code>(预测)操作中。下面是从<a href="/2017/03/05/【Tensorflow%20r1.0%20文档翻译】【tf.contrib.learn快速入门】/">tf.contrib.learn快速入门教程</a>中获取的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">training_set &#x3D; tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">    filename&#x3D;IRIS_TRAINING, target_dtype&#x3D;np.int, features_dtype&#x3D;np.float32)</span><br><span class="line">test_set &#x3D; tf.contrib.learn.datasets.base.load_csv_with_header(</span><br><span class="line">    filename&#x3D;IRIS_TEST, target_dtype&#x3D;np.int, features_dtype&#x3D;np.float32)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">classifier.fit(x&#x3D;training_set.data,</span><br><span class="line">               y&#x3D;training_set.target,</span><br><span class="line">               steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>这种数据量不大的情况下，我们即使不处理数据源，也可好获得良好的效果。但是在需要更多特征工程的情况下，<code>tf.contrib.learn</code>支持使用自定义输入函数（<code>input_fn</code>），它可以将预处理和管道数据的逻辑封装到模型中。</p>
<h3 id="input-fn的剖析"><a href="#input-fn的剖析" class="headerlink" title="input_fn的剖析"></a>input_fn的剖析</h3><p>以下代码说明了输入函数的基本框架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_input_fn():</span><br><span class="line"></span><br><span class="line">    # Preprocess your data here...</span><br><span class="line"></span><br><span class="line">    # ...then return 1) a mapping of feature columns to Tensors with</span><br><span class="line">    # the corresponding feature data, and 2) a Tensor containing labels</span><br><span class="line">    return feature_cols, labels</span><br></pre></td></tr></table></figure>
<p>输入函数的主体包含用于预处理输入数据的特定逻辑，例如<strong>擦除不良样本</strong>或<strong><a href="https://en.wikipedia.org/wiki/Feature_scaling">特征缩放</a></strong>。</p>
<p>输入函数必须返回以下两个值，这两个值包含要输入到模型中的最终特征和标签数据（如上面的代码框架中所示）：</p>
<p><code>feature_cols</code></p>
<pre><code>包含将特征列名称映射到包含相应特征数据的`Tensor`（或`SparseTensor`）的键/值对的字典。
</code></pre><p><code>labels</code></p>
<pre><code>包含您的标签（目标）值的`Tensor`：你的模型的值的目的是用于预测。
</code></pre><h3 id="将特征数据转换为Tensor"><a href="#将特征数据转换为Tensor" class="headerlink" title="将特征数据转换为Tensor"></a>将特征数据转换为Tensor</h3><p>如果你的特征/标签数据储存在<a href="http://pandas.pydata.org/">pandas</a>数据帧中或<a href="http://www.numpy.org/">numpy</a>数组中，那么你需要将其转换为<code>Tensor</code>，然后从您的<code>input_fn</code>中返回它。</p>
<p>对于连续数据，可以使用<code>tf.constant</code>创建和填充<code>Tensor</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feature_column_data &#x3D; [1, 2.4, 0, 9.9, 3, 120]</span><br><span class="line">feature_tensor &#x3D; tf.constant(feature_column_data)</span><br></pre></td></tr></table></figure>
<p>对于<a href="https://en.wikipedia.org/wiki/Sparse_matrix">稀疏分类数据</a>（大多数值为0的数据），您应该替换为填充一个<code>SparseTensor</code>，它使用三个参数来实例化：</p>
<p><code>dense_shape</code></p>
<pre><code>tensor的形状。获取一个列表，指示每个维度中元素的数量。例如：`dense_shape=[3,6]`指定了一个二维的3x6的tensor，`dense_shape=[2,3,4]`指定了一个三维的2x3x4的tensor，`dense_shape=[9]`指定了一个拥有9个元素的一维tensor。
</code></pre><p><code>indices</code></p>
<pre><code>您的tensor中包含非零元素的索引。值为一个列表，其中每一项本身是包含非零元素的索引的列表。（元素是零索引的 - 即，`[0,0]`是二维张量中第一行的第一列中的元素的索引值）。例如：`indices=[[1,3], [2,4]]`指定了索引为`[1,3]`和`[2,4]`的元素具有非零值。
</code></pre><p><code>values</code></p>
<pre><code>值为一维tensor。`values`的项`i`对应于`indices`中的项`i`，并且指定了它的值。例如，给定了`indices=[[1,3], [2,4]]`，那么参数`values=[18, 3.6]`就指定了tensor的元素`[1,3]`的值为18，元素`[2,4]`的值为3.6。
</code></pre><p>以下代码定义了一个具有3行和5列的二维<code>SparseTensor</code>。具有索引<code>[0,1]</code>的元素的值为6，并且索引为<code>[2,4]</code>的元素值为0.5（所有其他值为0）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sparse_tensor &#x3D; tf.SparseTensor(indices&#x3D;[[0,1], [2,4]],</span><br><span class="line">                                values&#x3D;[6, 0.5],</span><br><span class="line">                                dense_shape&#x3D;[3, 5])</span><br></pre></td></tr></table></figure>
<p>这对应了下面的稠密tensor(dense tensor)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0, 6, 0, 0, 0]</span><br><span class="line"> [0, 0, 0, 0, 0]</span><br><span class="line"> [0, 0, 0, 0, 0.5]]</span><br></pre></td></tr></table></figure>
<p>更多关于<code>SparseTensor</code>的内容，请见<a href="https://www.tensorflow.org/api_docs/python/tf/SparseTensor"><code>tf.SparseTensor</code></a></p>
<h3 id="将input-fn数据传递给您的模型"><a href="#将input-fn数据传递给您的模型" class="headerlink" title="将input_fn数据传递给您的模型"></a>将input_fn数据传递给您的模型</h3><p>要将数据馈送到您的模型进行训练，您只需将创建的输入函数作为<code>input_fn</code>参数的值传递到<code>fit</code>运算即可，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.fit(input_fn&#x3D;my_input_fn, steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>请注意，<code>input_fn</code>负责将特征和标签数据提供给模型，并在<code>fit</code>(拟合)中替换<code>x</code>和<code>y</code>参数。如果为<code>fit</code>提供了一个不为空的<code>input_fn</code>值与不为<code>None</code>的<code>x</code>或<code>y</code>结合，它将抛出一个<code>ValueError</code>。</p>
<p>还要注意一点，<code>input_fn</code>参数必须接收一个函数对象（例如<code>input_fn = my_input_fn</code>），而不是函数调用的返回值（<code>input_fn = my_input_fn()</code>）。这意味着，如果您尝试在<code>fit</code>的调用中按照下面的方式，将参数传递给输入函数，则会导致TypeError：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.fit(input_fn&#x3D;my_input_fn(training_set), steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>但是，如果你想要参数化你的输入函数，有一些其他的方法可以做到。您可以使用不带参数的包装函数作为<code>input_fn</code>，并使用它来调用具有所需参数的输入函数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_input_function_training_set():</span><br><span class="line">  return my_input_function(training_set)</span><br><span class="line"></span><br><span class="line">classifier.fit(input_fn&#x3D;my_input_fn_training_set, steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>或者，你可以使用Python的<a href="https://docs.python.org/2/library/functools.html#functools.partial"><code>functools.partial</code></a>方法来构造一个新的所有参数值固定的方法对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.fit(input_fn&#x3D;functools.partial(my_input_function,</span><br><span class="line">                                          data_set&#x3D;training_set), steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>第三种方式是将<code>input_fn</code>调用包装在<a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions"><code>lambda</code></a>中，并将其传递给<code>input_fn</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.fit(input_fn&#x3D;lambda: my_input_fn(training_set), steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>构建您的输入管道的一个很大的优势如上所示 — 可以接受数据集的参数 — 是你只需修改数据集的参数，就可以传递相同的<code>input_fn</code>到<code>evaluate</code>和<code>predict</code>操作上。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classifier.evaluate(input_fn&#x3D;lambda: my_input_fn(test_set), steps&#x3D;2000)</span><br></pre></td></tr></table></figure>
<p>这种方法增强了代码的可维护性：不需要针对每种类型的操作捕获单独变量（例如，<code>x_train</code>，<code>x_test</code>，<code>y_train</code>，<code>y_test</code>）中的<code>x</code>和<code>y</code>值。</p>
<h3 id="一个用于波士顿房屋数据的神经网络"><a href="#一个用于波士顿房屋数据的神经网络" class="headerlink" title="一个用于波士顿房屋数据的神经网络"></a>一个用于波士顿房屋数据的神经网络</h3><p>在本教程的剩余部分，您将编写一个输入函数，用于预处理从<a href="https://archive.ics.uci.edu/ml/datasets/Housing">UCI住宅数据集</a>中提取的一组波士顿房屋数据，并使用它来将数据馈送到神经网络回归器，以预测房屋中值。</p>
<p>您将用于训练神经网络的<a href="https://www.tensorflow.org/get_started/input_fn#setup">波士顿CSV数据集</a>包含以下波士顿郊区的<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.names">特征数据</a>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特征</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CRIM</td>
<td style="text-align:left">人均犯罪率</td>
</tr>
<tr>
<td style="text-align:left">ZN</td>
<td style="text-align:left">超过25,000+平方呎地段的住宅用地的部分</td>
</tr>
<tr>
<td style="text-align:left">INDUS</td>
<td style="text-align:left">非零售业的土地部分</td>
</tr>
<tr>
<td style="text-align:left">NOX</td>
<td style="text-align:left">一氧化氮浓度 以百万分之一为单位</td>
</tr>
<tr>
<td style="text-align:left">RM</td>
<td style="text-align:left">每个住宅平均房间数</td>
</tr>
<tr>
<td style="text-align:left">AGE</td>
<td style="text-align:left">在1940年之前建造的自用住宅的部分</td>
</tr>
<tr>
<td style="text-align:left">DIS</td>
<td style="text-align:left">到波士顿地区就业中心的距离</td>
</tr>
<tr>
<td style="text-align:left">TAX</td>
<td style="text-align:left">每$10,000的房产税税率</td>
</tr>
<tr>
<td style="text-align:left">PTRATIO</td>
<td style="text-align:left">学生 - 教师比例</td>
</tr>
</tbody>
</table>
</div>
<p>你的模型预测的标签是MEDV，自用住宅的价格中值，以千美元计。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>下载以下数据集：<a href="http://download.tensorflow.org/data/boston_train.csv">boston_train.csv</a>, <a href="http://download.tensorflow.org/data/boston_test.csv">boston_test.csv</a>, 和 <a href="http://download.tensorflow.org/data/boston_predict.csv">boston_predict.csv</a>。</p>
<p>以下部分提供了如何创建输入函数的手把手的步骤，将这些数据集送入神经网络回归，训练和评估模型，并进行房屋价值预测。完整的最终代码在<a href="https://www.tensorflow.org/code/tensorflow/examples/tutorials/input_fn/boston.py">这里</a>。</p>
<h3 id="输入房屋数据"><a href="#输入房屋数据" class="headerlink" title="输入房屋数据"></a>输入房屋数据</h3><p>要开始，请设置导入所需的库（包括<code>pandas</code>和<code>tensorflow</code>），并将<a href="https://www.tensorflow.org/get_started/monitors#enabling_logging_with_tensorflow">日志级别设置</a>为<code>INFO</code>以获取更详细的日志输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import absolute_import</span><br><span class="line">from __future__ import division</span><br><span class="line">from __future__ import print_function</span><br><span class="line"></span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br></pre></td></tr></table></figure>
<p>在<code>COLUMNS</code>中定义数据集的列名称。要区分特征和标签，还需要定义<code>FEATURES</code>和<code>LABEL</code>。然后将三个CSV（<code>tf.train</code>，<code>tf.test</code>和<code>predict</code>）读入pandas <code>DataFrame</code>s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COLUMNS &#x3D; [&quot;crim&quot;, &quot;zn&quot;, &quot;indus&quot;, &quot;nox&quot;, &quot;rm&quot;, &quot;age&quot;,</span><br><span class="line">           &quot;dis&quot;, &quot;tax&quot;, &quot;ptratio&quot;, &quot;medv&quot;]</span><br><span class="line">FEATURES &#x3D; [&quot;crim&quot;, &quot;zn&quot;, &quot;indus&quot;, &quot;nox&quot;, &quot;rm&quot;,</span><br><span class="line">            &quot;age&quot;, &quot;dis&quot;, &quot;tax&quot;, &quot;ptratio&quot;]</span><br><span class="line">LABEL &#x3D; &quot;medv&quot;</span><br><span class="line"></span><br><span class="line">training_set &#x3D; pd.read_csv(&quot;boston_train.csv&quot;, skipinitialspace&#x3D;True,</span><br><span class="line">                           skiprows&#x3D;1, names&#x3D;COLUMNS)</span><br><span class="line">test_set &#x3D; pd.read_csv(&quot;boston_test.csv&quot;, skipinitialspace&#x3D;True,</span><br><span class="line">                       skiprows&#x3D;1, names&#x3D;COLUMNS)</span><br><span class="line">prediction_set &#x3D; pd.read_csv(&quot;boston_predict.csv&quot;, skipinitialspace&#x3D;True,</span><br><span class="line">                             skiprows&#x3D;1, names&#x3D;COLUMNS)</span><br></pre></td></tr></table></figure>
<h3 id="定义特征列并创建回归"><a href="#定义特征列并创建回归" class="headerlink" title="定义特征列并创建回归"></a>定义特征列并创建回归</h3><p>接下来，为输入数据创建<code>FeatureColumn</code>list，正式指定要用于训练的特征集。由于房屋数据集中的所有特征都包含连续的值，因此可以使用<code>tf.contrib.layers.real_valued_column()</code>函数创建其<code>FeatureColumn</code>s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feature_cols &#x3D; [tf.contrib.layers.real_valued_column(k)</span><br><span class="line">                  for k in FEATURES]</span><br></pre></td></tr></table></figure>
<p>注意：有关特征列的更深入的内容，请参阅此<a href="https://www.tensorflow.org/tutorials/linear#feature_columns_and_transformations">简介</a>，以及说明如何为分类数据定义<code>FeatureColumns</code>的示例，请参阅线<a href="https://www.tensorflow.org/tutorials/wide">性模型教程</a>。</p>
<p>现在，为神经网络回归模型实例化一个<code>DNNRegressor</code>。这里你需要提供两个参数：<code>hidden_units</code>，指定每个隐藏层中的节点数量的超参数(hyperparameter)（这里，有两个隐藏层，每个隐藏层都具有10个节点），以及<code>feature_columns</code>，包含您刚定义的<code>FeatureColumns</code>list：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regressor &#x3D; tf.contrib.learn.DNNRegressor(feature_columns&#x3D;feature_cols,</span><br><span class="line">                                          hidden_units&#x3D;[10, 10],</span><br><span class="line">                                          model_dir&#x3D;&quot;&#x2F;tmp&#x2F;boston_model&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="构建input-fn"><a href="#构建input-fn" class="headerlink" title="构建input_fn"></a>构建input_fn</h3><p>要将输入数据传递到<code>regressor</code>，请创建一个输入函数，它将接受一个pandas <code>Dataframe</code>并返回特征列和标签值作为<code>Tensor</code>s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def input_fn(data_set):</span><br><span class="line">  feature_cols &#x3D; &#123;k: tf.constant(data_set[k].values)</span><br><span class="line">                  for k in FEATURES&#125;</span><br><span class="line">  labels &#x3D; tf.constant(data_set[LABEL].values)</span><br><span class="line">  return feature_cols, labels</span><br></pre></td></tr></table></figure>
<p>请注意，输入数据被传递到<code>data_set</code>参数中的<code>input_fn</code>中，这意味着该函数可以处理您导入的任何<code>DataFrames</code>：<code>training_set</code>，<code>test_set</code>和<code>prediction_set</code>。</p>
<h3 id="训练回归"><a href="#训练回归" class="headerlink" title="训练回归"></a>训练回归</h3><p>要训​​练神经网络回归，运行指定了包含有<code>training_set</code>的<code>input_fn</code>的<code>fit</code>函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regressor.fit(input_fn&#x3D;lambda: input_fn(training_set), steps&#x3D;5000)</span><br></pre></td></tr></table></figure>
<p>您应该能看到类似于以下内容的日志输出，它会报告每100步的训练loss值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Step 1: loss &#x3D; 483.179</span><br><span class="line">INFO:tensorflow:Step 101: loss &#x3D; 81.2072</span><br><span class="line">INFO:tensorflow:Step 201: loss &#x3D; 72.4354</span><br><span class="line">...</span><br><span class="line">INFO:tensorflow:Step 1801: loss &#x3D; 33.4454</span><br><span class="line">INFO:tensorflow:Step 1901: loss &#x3D; 32.3397</span><br><span class="line">INFO:tensorflow:Step 2001: loss &#x3D; 32.0053</span><br><span class="line">INFO:tensorflow:Step 4801: loss &#x3D; 27.2791</span><br><span class="line">INFO:tensorflow:Step 4901: loss &#x3D; 27.2251</span><br><span class="line">INFO:tensorflow:Saving checkpoints for 5000 into &#x2F;tmp&#x2F;boston_model&#x2F;model.ckpt.</span><br><span class="line">INFO:tensorflow:Loss for final step: 27.1674.</span><br></pre></td></tr></table></figure>
<h3 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h3><p>接下来，看看训练模型如何针对测试数据集执行。运行<code>evaluate</code>，这次将<code>test_set</code>传递给<code>input_fn</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ev &#x3D; regressor.evaluate(input_fn&#x3D;lambda: input_fn(test_set), steps&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>从<code>ev</code>的结果中检索损失并将其打印到输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loss_score &#x3D; ev[&quot;loss&quot;]</span><br><span class="line">print(&quot;Loss: &#123;0:f&#125;&quot;.format(loss_score))</span><br></pre></td></tr></table></figure>
<p>您应该会看到类似以下的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:tensorflow:Eval steps [0,1) for training step 5000.</span><br><span class="line">INFO:tensorflow:Saving evaluation summary for 5000 step: loss &#x3D; 11.9221</span><br><span class="line">Loss: 11.922098</span><br></pre></td></tr></table></figure>
<h3 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h3><p>最后，您可以使用模型预测<code>prediction_set</code>中的房屋中值，其中包含特征数据，但没有六个样本的标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; regressor.predict(input_fn&#x3D;lambda: input_fn(prediction_set))</span><br><span class="line"># .predict() returns an iterator; convert to a list and print predictions</span><br><span class="line">predictions &#x3D; list(itertools.islice(y, 6))</span><br><span class="line">print (&quot;Predictions: &#123;&#125;&quot;.format(str(predictions)))</span><br></pre></td></tr></table></figure>
<p>您的结果应包含以 $1000 计的六次房价预测，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predictions: [ 33.30348587  17.04452896  22.56370163  34.74345398  14.55953979</span><br><span class="line">  19.58005714]</span><br></pre></td></tr></table></figure>
<h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>本教程专注于为神经网络回归创建一个<code>input_fn</code>。要了解更多有关对其他类型模型使用<code>input_fn</code>的信息，请查看以下资源：</p>
<ul>
<li><a href="https://www.tensorflow.org/tutorials/linear">TensorFlow的大尺寸线性模型</a>：这种对TensorFlow中的线性模型的介绍提供了用于变换输入数据的特征列和技术的高级概述。</li>
<li><a href="https://www.tensorflow.org/tutorials/wide">TensorFlow线性模型教程</a>：本教程包括为线性分类模型创建<code>FeatureColumn</code>s和<code>input_fn</code>，该模型根据人口普查数据预测收入范围。</li>
<li><a href="https://www.tensorflow.org/tutorials/wide_and_deep">TensorFlow宽＆深学习教程</a>：基于<a href="https://www.tensorflow.org/tutorials/wide">TensorFlow线性模型教程</a>，本教程涵盖了使用<code>DNNLinearCombinedClassifier</code>组合线性模型和神经网络的“宽和深”模型的<code>FeatureColumn</code>和<code>input_fn</code>创建。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 程序员指南】-变量：创建，初始化，保存和加载</title>
    <url>/2017/08/08/%E3%80%90Tensorflow%20r1.0%20%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8C%87%E5%8D%97%E3%80%91-%E5%8F%98%E9%87%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>当你训练一个模型时，您可以使用<a href="https://www.tensorflow.org/api_guides/python/state_ops">variables</a>来保存和更新参数。variables是包含张量的内存缓冲区。variables必须明确地被初始化，并在训练期间和之后将其保存到磁盘。在之后您可以恢复保存的值，以运行或分析模型。</p>
<p>本文档引用了以下TensorFlow类。请参阅其参考手册的链接，了解其API的完整说明：</p>
<ul>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/Variable">tf.Variable</a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/train/Saver">tf.train.Saver</a></li>
</ul>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>当您创建一个<a href="https://www.tensorflow.org/api_guides/python/state_ops">Variable</a>时，您将<code>Tensor</code>作为其初始值传递给<code>Variable()</code>构造函数。TensorFlow提供了一个操作的集合，它们产生经常用于从<a href="https://www.tensorflow.org/api_guides/python/constant_op">常量或随机初始化的</a>张量。</p>
<p>请注意，所有这些操作都需要您指定张量的形状。该形状自动变为变量的形状。变量通常具有固定的形状，但是TensorFlow提供了重新变换变量的高级机制。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorflow r1.0 程序员指南】</title>
    <url>/2017/08/08/%E3%80%90Tensorflow%20r1.0%20%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8C%87%E5%8D%97%E3%80%91/</url>
    <content><![CDATA[<h2 id="程序员指南"><a href="#程序员指南" class="headerlink" title="程序员指南"></a>程序员指南</h2><p>这一部分文档将深入到TensorFlow的代码细节。这一节由以下几个指南开始，每一个指南都介绍了TensorFlow的一个特定的方面：</p>
<ul>
<li><a href="">变量：创建，初始化，保存和加载</a>，详细介绍了TensorFlow变量的机制。</li>
<li><a href="">张量等级，形状和类型</a>，这部分说明了Tensor等级（维数），形状（每个维的大小）和数据类型。</li>
<li><a href="">共享变量</a>，这部分解释了在构建复杂模型时如何共享和管理大量变量。</li>
<li><a href="">线程和队列</a>，这部分说明了TensorFlow的富队列系统。</li>
<li><a href="">读取数据</a>，其中记录了将数据导入TensorFlow程序的三种不同机制。</li>
</ul>
<p>以下指南适用于对复杂模型的多天训练：</p>
<ul>
<li><a href="">监督：多天训练的训练助手</a>，介绍如何在长时间的训练过程中妥善处理系统崩溃。</li>
</ul>
<p>TensorFlow提供了一个名叫<code>tfdbg</code>的调试器，它的文档见下面两个指南：</p>
<ul>
<li><p><a href="">TensorFlow Debugger（tfdbg）命令行界面教程：MNIST</a>，它将引导您使用<code>tfdbg</code>在低级TensorFlow API中编写的应用程序。</p>
</li>
<li><p><a href="">如何在tf.contrib.learn中使用TensorFlow Debugger（tfdbg）</a>，它演示了如何在Estimators API中使用<code>tfdbg</code>。</p>
</li>
</ul>
<p><code>MetaGraph</code>由计算图及其相关元数据组成。<code>MetaGraph</code>包含持续训练，执行评估或在先前训练过的图表上运行推断所需的信息。以下指南是<code>MetaGraph</code>对象的详细说明：</p>
<ul>
<li><a href="">MetaGraph的导入和导出</a></li>
</ul>
<p><code>SavedModel</code>是Tensorflow模型的通用序列化格式。TensorFlow提供SavedModel CLI（命令行界面）作为在<code>SavedModel</code>中检查和执行<code>MetaGraph</code>的工具。以下指南中记录了详细的用法和示例：</p>
<ul>
<li><a href="">SavedModel CLI（命令行界面）</a></li>
</ul>
<p>要了解TensorFlow版本控制方案，请参阅以下两个指南：</p>
<ul>
<li><a href="">TensorFlow版本语义</a>，这说明了TensorFlow的版本控制术语和兼容性规则。</li>
<li><a href="">TensorFlow数据版本控制：GraphDefs和检查点</a>，这解释了TensorFlow如何将版本信息添加到计算图形和检查点，以便支持跨版本的兼容性。</li>
</ul>
<p>结束本部分有关TensorFlow编程的常见问题：</p>
<ul>
<li><a href="">常见问题</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>【傅里叶变换及其应用】01-周期性，三角函数表示复杂函数</title>
    <url>/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://open.163.com/movie/2008/2/C/G/M7Q4BLENR_M7QBP61CG.html">课程视频地址</a></p>
<p>本质上，傅里叶级数可以看做是<strong>用数学的手段研究周期性现象</strong>的一门学科。</p>
<p>我们在初中高中学过cos和sin这些三角函数，我们是否可以使用这些三角函数来建模非常广泛的周期性现象呢？这正是这节课需要解决的问题。</p>
<h3 id="如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？"><a href="#如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？" class="headerlink" title="如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？"></a>如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？</h3><p>首先，我们这里说的<strong>复杂的周期性现象</strong>会普遍到什么程度呢？我们希望把这些方法应用在普遍的条件下，但是并不是所有的现象都是周期性的（其实甚至在一些周期性的现象中，这个假定也未必行得通）。所以，<strong>并不是所有的现象都试用这个方法</strong>。</p>
<p>其实现实生活中的现象，最终都会结束，我们只观察某一个特定时间段的现象。而数学函数，比如正余弦函数，都是无始无终的。那么如何用它们来描述那些会结束的现象呢？</p>
<p>在面对实际的现象时，比如下面这种现象：</p>
<p><img src=/img/18_10_27/001.png width="500" hegiht="313" align=center /></p>
<p>只存在于一个有限的时间段内，画出一个这样的信号。这并不是一个周期现象，但如果我们重复绘制这个图像，就可以强制使其成为周期性的函数了。</p>
<p><img src="/img/18_10_27/002.png" alt=""></p>
<p>或许我们只是对其中的一部分感兴趣，但对于数学分析，如果使其具有周期性，就对所有的都适用了。这个过程叫做<strong>信号的周期化（periodization of a signal）</strong>。它可以用于研究非周期性信号。</p>
<h4 id="信号周期化"><a href="#信号周期化" class="headerlink" title="信号周期化"></a>信号周期化</h4><p>我们通常把周期函数的周期设定为1，这样更加方便。因此函数$f(t)$需要满足：</p>
<ul>
<li>对任何$t$均有$f(t+1)=f(t)$，</li>
</ul>
<p>因此我们的信号模型可以表示为：</p>
<script type="math/tex; mode=display">sin(2πt) \tag{1-1}</script><p>以及</p>
<script type="math/tex; mode=display">cos(2πt) \tag{1-2}</script><p><strong><em>如果我们知道一个周期为1的周期性函数在任意一个单位为1的时间间隔内的形式，那么我们就可以知道整个函数了。</em></strong></p>
<h4 id="生成复杂的周期函数"><a href="#生成复杂的周期函数" class="headerlink" title="生成复杂的周期函数"></a>生成复杂的周期函数</h4><p>那么我们如何用简单的sin和cos函数来表示各种复杂的周期现象呢？</p>
<p>事实上，我们可以通过对$sin(2πt)$和$cos(2πt)$进行变换和相加的方式来得到相当普遍的周期为1的周期函数。</p>
<h5 id="对正余弦函数进行变换"><a href="#对正余弦函数进行变换" class="headerlink" title="对正余弦函数进行变换"></a>对正余弦函数进行变换</h5><p>下图是$sin(2πt)$的函数图像，其周期为1，频率为1：</p>
<p><img src=/img/18_10_27/003.png width="500" hegiht="313" align=center /></p>
<p>经过变换之后，$sin(4πt)$的函数图像如下，其周期为$1/2$，频率为2：</p>
<p><img src=/img/18_10_27/004.png width="500" hegiht="313" align=center /></p>
<blockquote>
<p>其实你也可以说他的周期是1。因为一秒之内它经历了两个完整的周期，你可以把这两个完整的周期看做一个周期，图形在整个坐标轴上一直在重复这个原始信号。</p>
</blockquote>
<p>再次变换之后，$sin(6πt)$的函数图像如下，其周期为$1/3$，频率为3：</p>
<p><img src=/img/18_10_27/005.png width="500" hegiht="313" align=center /></p>
<blockquote>
<p>同样，也可以把它看做周期是1。</p>
</blockquote>
<h5 id="对正余弦函数进行合并"><a href="#对正余弦函数进行合并" class="headerlink" title="对正余弦函数进行合并"></a>对正余弦函数进行合并</h5><p>现在把上面的三个函数合并：</p>
<script type="math/tex; mode=display">
y=sin(2πt) + sin(4πt) + sin(6πt)</script><p>其效果如下：</p>
<p><img src=/img/18_10_27/006.png width="300" hegiht="313" align=center /></p>
<p>组合之后的函数周期为1，它由3个不同频率的周期函数组成，频率分布为1，2，3。但把它们组合起来之后，却只有一个周期：周期为1。</p>
<p>我们不仅可以改变频率，也可以单独改变幅度，并且可以改变其中每一个的相位。</p>
<h4 id="表示一个复杂的周期函数的几种方式"><a href="#表示一个复杂的周期函数的几种方式" class="headerlink" title="表示一个复杂的周期函数的几种方式"></a>表示一个复杂的周期函数的几种方式</h4><h5 id="最基本的形式"><a href="#最基本的形式" class="headerlink" title="最基本的形式"></a>最基本的形式</h5><p>一个复杂的周期为1的信号，可以通过变换一系列的正余弦函数的<strong>频率</strong>、<strong>幅度</strong>和<strong>相位</strong>，然后将它们<strong>加起来</strong>，来得到。</p>
<script type="math/tex; mode=display">
y=\sum\_{k=1}^N A\_ksin(2πkt+φ\_k) \tag{1-3}</script><p>这是表示一个复杂周期的<strong>最一般</strong>的形式。</p>
<h5 id="利用和角公式来表示"><a href="#利用和角公式来表示" class="headerlink" title="利用和角公式来表示"></a>利用和角公式来表示</h5><p>正余弦和角公式：</p>
<script type="math/tex; mode=display">
sin(2πkt+φ_k)=sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k
\tag{1-4}</script><p>因此我们可以将上面的公式$(1-3)$展开成以下形式：</p>
<script type="math/tex; mode=display">
\begin{align\*}  
y&=\sum\_{k=1}^N A\_k(sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k)\\\\
&=\sum\_k^N  (a\_kcos(2πkt)+b\_ksin(2πkt))
\tag{1-5}
\end{align*}</script><p>这里的$a_k$和$b_k$是由A计算出的。</p>
<h5 id="加一个常数项的形式（直流分量形式）"><a href="#加一个常数项的形式（直流分量形式）" class="headerlink" title="加一个常数项的形式（直流分量形式）"></a>加一个常数项的形式（直流分量形式）</h5><script type="math/tex; mode=display">
y = \frac{a\_0}{2} + \sum\_{k=1}^N  (a\_kcos(2πkt)+b\_ksin(2πkt))
\tag{1-6}</script><p>这里的$\frac{a_0}{2}$是一个常数项，电器工程师常称之为<strong>直流分量(dc component)</strong>。因为电器工程师在研究交流电或直流电的过程中，发现有一部分是不随着周期发生改变的，这一部分称之为<strong>直流分量</strong>。</p>
<h5 id="复指数的表示形式"><a href="#复指数的表示形式" class="headerlink" title="复指数的表示形式"></a>复指数的表示形式</h5><p>上面几种都是比较常用的一些用于表示一个复杂信号的表示形式。但是迄今为止，最方便使用的还是用<strong>复指数</strong>的形式来表示：</p>
<script type="math/tex; mode=display">
e^{2πkt}=cos(2πkt) + i*sin(2πkt)
\tag{1-7}</script><p>在这里$i$的值为：</p>
<script type="math/tex; mode=display">
i=\sqrt{-1}
\tag{1-8}</script><p>根据著名的<strong>欧拉公式</strong>，我们可以用复指数的形式来表示正余弦函数，其中$cos$是实部，$sin$是虚部：</p>
<script type="math/tex; mode=display">
cos(2πkt)=\frac{e^{2πikt}+e^{-2πikt}}{2}
\\\\
sin(2πkt)=\frac{e^{2πikt}-e^{-2πikt}}{2i}
\tag{1-9}</script><p>你也可以将上面公式$(1-5)$的三角函数表示的和式的形式写成这种形式：</p>
<script type="math/tex; mode=display">
\sum\_{k=-n}^n C_ke^{2πikt}
\tag{1-10}</script><p>在这里$C_k$是复数。</p>
<blockquote>
<p><strong>共轭</strong></p>
<p>对于复数$a + bi$来说，其共轭为$a - bi$。<br>复数$C_k$的共轭表示为$\bar{C_k}$</p>
<p>另外，如果一个复数等于其自身的共轭意味着什么呢？$C_0=\bar{C_0}$</p>
<p>这意味着这个数本身是实数。</p>
</blockquote>
<p>如果你试着把余弦表示的方式全部转成了复指数的形式，你会发现$C_k$不仅仅是复数，它同时还满足<strong>对称性</strong>。并且由于它的对称性，所以$\sum_{k=-n}^n C_k $的总和为实数。</p>
<p>即：$ C_{-k} $等于$C_k$的共轭：</p>
<script type="math/tex; mode=display">
C_-k=\bar{C_k}
\tag{1-11}</script><p>这是一条重要的性质。</p>
<p>反过来，如果和式的系数满足对称性，那么总和就应该是实数。这是因为可以把所有项分成正项和负项两组，并且由于$(1-11)$的对称关系，复数和复数的共轭的和结果是实数，可以得出这个结论。</p>
<h4 id="我们生成的复杂的周期函数，其普遍性有多强？"><a href="#我们生成的复杂的周期函数，其普遍性有多强？" class="headerlink" title="我们生成的复杂的周期函数，其普遍性有多强？"></a>我们生成的复杂的周期函数，其普遍性有多强？</h4><p>$f(t)$是周期为1的周期函数，我们可以把$f(t)$写成$(1-10)$那种形式吗？</p>
<script type="math/tex; mode=display">
f(t)=\sum\_{k=-n}^n C_ke^{2πikt}
\tag{1-12}</script><p>换句话说，一个周期为1的复杂的周期函数，我们能用正余弦函数通过叠加变化以及组合来生成出来吗？</p>
<h5 id="假设我们能做到"><a href="#假设我们能做到" class="headerlink" title="假设我们能做到"></a>假设我们能做到</h5><p>假设我们可以做到用$(1-12)$来表示所有复杂的周期为1的周期函数，那么对于未知系数$C_k$我们如何求得呢？</p>
<p>以下是求$C_k$的过程：</p>
<script type="math/tex; mode=display">
\begin{align\*} 
f(t)&=\sum\_{k=-n}^n C_ke^{2πikt}\\\\
&=...+C_km^{2πikt}+...
\end{align\*}</script><p><img src="/img/18_10_27/007.png" alt=""></p>
<p>两边同时乘以$e^{-2\pi imt}$：</p>
<p><img src="/img/18_10_27/008.png" alt=""></p>
<p><img src="/img/18_10_27/009.png" alt=""></p>
<p>然后对两边同时求积分，积分区间是0到1，因为我们的频率是1：</p>
<p><img src="/img/18_10_27/010.png" alt=""></p>
<p>由于：</p>
<p><img src="/img/18_10_27/011.png" alt=""></p>
<p>所以：</p>
<p><img src="/img/18_10_27/012.png" alt=""></p>
<p><img src="/img/18_10_27/013.png" alt=""></p>
<p>其中：</p>
<p><img src="/img/18_10_27/014.png" alt=""></p>
<p><img src="/img/18_10_27/015.png" alt=""></p>
<p><img src="/img/18_10_27/016.png" alt=""></p>
<p><img src="/img/18_10_27/017.png" alt=""></p>
<p>这里的:</p>
<p><img src="/img/18_10_27/018.png" alt=""></p>
<p>是一个整数，就像$sin(2π)$乘以一个整数，这个整数是1，所以这里的结果是0。</p>
<p><img src="/img/18_10_27/019.png" alt=""></p>
<p>所以我们的$C_m$可以得到下面的结果：</p>
<p><img src="/img/18_10_27/020.png" alt=""></p>
<p>期初我们设定$f(t)$是已知的，所以我们就可以求得$C_m$了。</p>
<hr>
<p><strong>结论:</strong>给定周期为1的周期函数$f(t)$，如果能把$f(t)$写成和式的形式：$f(t)=\sum_{k=-n}^nC_ke^{2\pi ikt}$，那么溪水会按照这个公式给出，其中$C_k=\int_0^{1}e^{-2\pi ikt}f(t)dt$。</p>
<p>下节课我们将介绍，我们得到的这些参数，将带来什么意义。</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>公开课</category>
      </categories>
      <tags>
        <tag>斯坦福大学公开课</tag>
        <tag>傅里叶变换</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【傅里叶变换及其应用讲义】第一章 傅里叶级数</title>
    <url>/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><h2 id="介绍和选择"><a href="#介绍和选择" class="headerlink" title="介绍和选择"></a>介绍和选择</h2><p>基于傅里叶变换的方法几乎用于所有工程和科学领域，几乎所有工程师和科学家都使用。 比如对于以下领域的初学者：</p>
<ul>
<li>电路设计师</li>
<li>光谱学家</li>
<li>晶体学家</li>
<li>从事信号处理和通信工作的任何人</li>
<li>从事成像工作的人员</li>
</ul>
<p>我期待课堂上会有很不同领域的同学，这对我们所有人来说都很重要。 随着兴趣和背景的多样性，并非所有的例子和应用都是大家所熟悉的，并且与所有人相关。 我们都必须互相削减一些内容，这是我们所有人分出的机会。 同样，你也应该意识到这是许多可能课程中傅立叶变换的一门课程。 无论是在数学上还是在应用范围内，主题的丰富性意味着我们将几乎不断地做出选择。 关于这个主题的书看起来不一样，和这份讲义也不太一样 - 甚至用于基本对象和操作的符号也因书而异。 我会试着带大家在合适的时机选择一个合适的方向作为切入点来带领大家了解这门学科，并且我也会说出其他切入点会是什么。</p>
<hr>
<p>第一个选择是从哪里开始，我的选择是对傅立叶级数的简要处理。傅立叶分析最初涉及通过傅立叶级数表示和分析周期性现象，然后通过傅立叶将这些见解扩展到非周期性现象。 转变。 实际上，从傅立叶级数到傅立叶变换的一种方法是将非周期性现象（因此几乎任何一般函数）视为周期性现象的极限情况，因为周期趋于无穷大。 周期性情况下的一组离散频率在非周期情况下成为频率的连续体，频谱诞生了，随之而来的是该主题最重要的原则：</p>
<p><strong>每个信号都有一个频谱，由频谱决定。 您可以在时域（或空间）或频域中分析信号。</strong></p>
<p>我认为这条格言有资格成为宇宙组成的主要秘密之一。</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>公开课</category>
      </categories>
      <tags>
        <tag>斯坦福大学公开课</tag>
        <tag>傅里叶变换</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【原创】AI-QI量化平台搭建爬坑笔记-小心偏斜类问题</title>
    <url>/2017/12/20/%E3%80%90%E5%8E%9F%E5%88%9B%E3%80%91AI-QI%E9%87%8F%E5%8C%96%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E7%88%AC%E5%9D%91%E7%AC%94%E8%AE%B0-%E5%B0%8F%E5%BF%83%E5%81%8F%E6%96%9C%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>原创文章，转载请注明出处</p>
</blockquote>
<p>首先安利一波广告：</p>
<p>最近利用业余时间搭建了一个智能量化投资平台，代码已经全部开源：<a href="https://github.com/DannyLee1991/ai_qi">https://github.com/DannyLee1991/ai_qi</a></p>
<p>目前已经实现的功能有：</p>
<ul>
<li>数据的抓取（数据来源<a href="tushare.org">tushare</a>}）</li>
</ul>
<p><img src="/img/17_12_20/001.png" alt=""></p>
<ul>
<li>数据入库，并在界面上可以执行sql操作</li>
</ul>
<p><img src="/img/17_12_20/002.png" alt=""></p>
<ul>
<li>数据可视化</li>
</ul>
<p><img src="/img/17_12_20/003.png" alt=""><br><img src="/img/17_12_20/004.png" alt=""></p>
<ul>
<li>数据集创建</li>
</ul>
<p>数据集管理</p>
<p><img src="/img/17_12_20/005.png" alt=""></p>
<p>数据集创建</p>
<p><img src="/img/17_12_20/006.png" alt=""></p>
<p>数据集查看</p>
<p><img src="/img/17_12_20/005.png" alt=""></p>
<ul>
<li>数据预处理</li>
</ul>
<p>// 暂无界面</p>
<p>正在开发中的功能：</p>
<ul>
<li>数据建模</li>
<li>接入交易接口</li>
<li>…</li>
</ul>
<p>各个已有的功能目前也只是做了部分实现，先把各个环节打通，然后在慢慢填充。最终的目标是利用机器学习算法来预测分析各种投资数据。</p>
<p>欢迎各位大牛拍砖指导~</p>
<hr>
<p>好，以上不是本文的重点，本文重点是这两天在建立第一个模型过程中遇到的一个坑。</p>
<hr>
<h3 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h3><p>第一个模型，我准备使用日交易数据来预测次日的涨跌幅度，使用的数据来自日交易数据表：</p>
<p><img src="/img/17_12_20/008.png" alt=""></p>
<p>这是对应的原始数据集详情信息：</p>
<p><img src="/img/17_12_20/009.png" alt=""></p>
<p>其中  除了X的<strong>‘date’(时间)</strong>特征之外，其他的特征都是float类型的数据。暂时先剔除这一维度的数据，所以最后用来训练的X的shape是<code>(292583, 15)</code>。</p>
<p>Y的shape不变，是<code>(292583, 1)</code>。</p>
<p>Y的数据类型也是float。</p>
<blockquote>
<p>这里先解释一下<strong>Y</strong>的含义：Y对应的数据是涨跌幅，但和与之对应的X的数据并不是同一天的，这里<strong>日期间隔1</strong>的含义是Y取的是相对于X的数据的时间的下一日的数据，因为我们要预测的是次日涨跌幅。</p>
</blockquote>
<p>对于分类模型，我们的Y应该是类别标签，而不能是连续型数值，所以我们应该把当前的float类型的Y，转换成某种类别标签来表示。</p>
<p>一种很容易理解的方式，就是float转int，简单粗暴：</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; [1.1, 2.6, 3.5, -1.8, ...]</span><br></pre></td></tr></table></figure>
<p>转换为int之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; [1, 2, 3, -1, ...]</span><br></pre></td></tr></table></figure>
<p>但这里有一个小坑，负数的标签在带入到tensorflow中训练是会报错的，所以把标签数据+10，全部转为大于等于0的数据，处理之后的效果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; [11, 12, 13, 9, ...]</span><br></pre></td></tr></table></figure>
<p>在经过上述的预处理之后，Y被处理成了21个类别（-10到10之间一共21个int值）的数据集。</p>
<p>然后就是将数据打乱，按照6:2:2的比例将数据分割为<strong>训练集</strong>、<strong>验证集</strong>和<strong>测试集</strong>。</p>
<hr>
<h3 id="带入训练"><a href="#带入训练" class="headerlink" title="带入训练"></a>带入训练</h3><p>仿照tensorflow的<a href="https://www.tensorflow.org/get_started/estimator">demo</a>，将数据带入一个DNN模型，进行训练。</p>
<p>没有进行什么特殊的调参，最终准确率竟然达到了接近50%！</p>
<p><img src="/img/17_12_20/010.png" alt=""></p>
<p>要知道这是21个类别的分类问题，50%的准确率已经远远高于均匀分布情况下随机选择的准确率（大约是4.8%）了。</p>
<p>于是我觉得21类数据，准确率就能达到这么高，那如果我将类别改为2类，准确率应该会大幅提升的。</p>
<p>于是我重新将Y的数据改为了0和1两种类别，0代表跌1代表涨。</p>
<p>但实际情况，并没有好很多，准确率大概达到52%左右。</p>
<p>看到这种结果，第一时间，我是怀疑自己代码有没有哪里写错，但经过排查，并没有发现有什么异常。</p>
<p>后来，又尝试将数据分为4类，8类来训练，得到的结果依然是50%左右。</p>
<p>WTF？</p>
<h3 id="原来是偏斜类在搞鬼"><a href="#原来是偏斜类在搞鬼" class="headerlink" title="原来是偏斜类在搞鬼"></a>原来是偏斜类在搞鬼</h3><blockquote>
<p><a href="http://t.cn/RSh83NE">这里有篇关于偏斜类的文章</a>，值得一看。</p>
</blockquote>
<p>我将原始数据绘制成柱状图之后，发现了问题所在：</p>
<p><img src="/img/17_12_20/011.png" alt=""></p>
<p>数据在各个类别上<strong>并不是均匀分布的</strong>，大部分都聚集在了10（对应涨跌幅为0%）的位置上。而我训练出来的模型，带入一批测试数据后，预测结果也都是10。</p>
<p>也就是说，我们的分类器，就算完全没有识别能力，输入任何值，输出的结果都是10这种类别，那么这个分类器就有50%的准确率！！！</p>
<p>这是一个很傻的结果，就好比一个完全不懂股票的人，你问他某只股票明天会不会涨，他只要回答：“明天不涨不跌”，那么他就有50%的概率猜对了。</p>
<p>好吧，这并不是我们想要的效果，那么我们如何避免这种情况呢？</p>
<h3 id="想办法让各个类别的数据呈现均匀分布"><a href="#想办法让各个类别的数据呈现均匀分布" class="headerlink" title="想办法让各个类别的数据呈现均匀分布"></a>想办法让各个类别的数据呈现均匀分布</h3><p>我想到的办法是在标签数据生成的过程中做些手脚。使得各个类别的数据呈现出均匀分布的情况。</p>
<p>所以我写了一个函数，用来将数据处理成均匀分布的标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def uniform_distribution(Y, n, l_type&#x3D;&#39;b&#39;):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    平均分布</span><br><span class="line"></span><br><span class="line">    将Y按照值的大小进行均匀分布的方式分割成n等分</span><br><span class="line">    并生成对应的类别标签</span><br><span class="line"></span><br><span class="line">    :param Y: 数据源  形状为(num,)</span><br><span class="line">    :param n: 将数据分割为n等分</span><br><span class="line">    :param l_type: 分割数据之后 标签的取值类别&#123;&#39;b&#39;,&#39;s&#39;,&#39;n&#39;&#125;</span><br><span class="line">                &#39;b&#39; : 类别标签为区间范围内的最大值</span><br><span class="line">                &#39;s&#39; : 类别标签为区间范围内的最小值</span><br><span class="line">                &#39;n&#39; : 类别标签为区间范围内的平均值</span><br><span class="line"></span><br><span class="line">    :return:</span><br><span class="line"></span><br><span class="line">    eg：</span><br><span class="line">    Y &#x3D; [1,1,2,3,4,4,5,6,7]</span><br><span class="line">    n &#x3D; 5</span><br><span class="line">    l_type &#x3D; &#39;b&#39;</span><br><span class="line">    result &#x3D; [1 1 3 3 4 4 6 6 7]</span><br><span class="line"></span><br><span class="line">    n &#x3D; 3</span><br><span class="line">    l_type &#x3D; &#39;s&#39;</span><br><span class="line">    result &#x3D; [1 1 1 2 2 2 4 4 4]</span><br><span class="line"></span><br><span class="line">    n &#x3D; 5</span><br><span class="line">    l_type &#x3D; &#39;n&#39;</span><br><span class="line">    result &#x3D; [ 1.   1.   2.   2.   3.5  3.5  5.   5.   6.5]</span><br><span class="line"></span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">    node_list &#x3D; gen_nodelist(Y, n)</span><br><span class="line">    toY &#x3D; []</span><br><span class="line">    for num in Y:</span><br><span class="line">    	# 这里虽然得到的是float类型的值，但tensorflow的类别标签 只能是int类型，所以将对应的索引作为标签值来使用</span><br><span class="line">        index, val &#x3D; get_label(num, node_list, l_type)</span><br><span class="line">        toY.append(index)</span><br><span class="line"></span><br><span class="line">    print(&quot;node list &gt;&gt;&quot;)</span><br><span class="line">    print(node_list)</span><br><span class="line">    return np.array(toY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_label(num, node_list, l_type):</span><br><span class="line">    # 下限</span><br><span class="line">    lm &#x3D; 0</span><br><span class="line">    # 上限</span><br><span class="line">    um &#x3D; 0</span><br><span class="line">    target &#x3D; 0</span><br><span class="line"></span><br><span class="line">    # 节点区间是(lm,um]</span><br><span class="line">    for index, node in enumerate(node_list):</span><br><span class="line">        if node &gt;&#x3D; num:</span><br><span class="line">            if index &gt; 0:</span><br><span class="line">                um &#x3D; node</span><br><span class="line">                lm &#x3D; node_list[index - 1]</span><br><span class="line">                target &#x3D; index</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    label &#x3D; &#39;&#39;</span><br><span class="line">    if l_type &#x3D;&#x3D; &#39;s&#39;:</span><br><span class="line">        label &#x3D; lm</span><br><span class="line">    elif l_type &#x3D;&#x3D; &#39;b&#39;:</span><br><span class="line">        label &#x3D; um</span><br><span class="line">    elif l_type &#x3D;&#x3D; &#39;n&#39;:</span><br><span class="line">        label &#x3D; (lm + um) &#x2F; 2</span><br><span class="line"></span><br><span class="line">    return target, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def gen_nodelist(data, n):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    生成节点列表  节点是指示数据的分割点</span><br><span class="line">    :param data: 原始数据 需要被分割的数据</span><br><span class="line">    :param n: 分割的份数</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    sorted_list &#x3D; sorted(data)</span><br><span class="line">    size &#x3D; len(sorted_list)</span><br><span class="line">    node_list &#x3D; []</span><br><span class="line">    block_size &#x3D; math.ceil(size &#x2F; n)</span><br><span class="line">    for index, item in enumerate(sorted_list):</span><br><span class="line">        if (index + 1) % block_size &#x3D;&#x3D; 0:</span><br><span class="line">            node_list.append(item)</span><br><span class="line">        elif index &#x3D;&#x3D; 0:</span><br><span class="line">            node_list.append(item)</span><br><span class="line">        elif index &#x3D;&#x3D; size - 1:</span><br><span class="line">            node_list.append(item)</span><br><span class="line"></span><br><span class="line">    return node_list</span><br></pre></td></tr></table></figure>
<p>用这个函数重新预处理我们的Y，这里我们将Y分为10种类别，Y按照以下的标签值，重新赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[-10.08, -2.3900000000000001, -1.4199999999999999, -0.84999999999999998, -0.40999999999999998, 0.0, 0.28999999999999998, 0.68999999999999995, 1.24, 2.25, 10.16]</span><br></pre></td></tr></table></figure>
<p>可以看到，这些标签值并不是线性的，这是因为我们的数据不是均匀分布的。</p>
<p>按照这种标签处理之后，将数据绘制成柱状图后，如下：</p>
<p><img src="/img/17_12_20/012.png" alt=""></p>
<p>接下来带入训练就比较正常了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>AI-QI</tag>
      </tags>
  </entry>
  <entry>
    <title>【强化学习】1-1 K臂老虎机</title>
    <url>/2021/02/11/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%911-1K%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA/</url>
    <content><![CDATA[<p>在强化学习中，代理人通过与世界互动来生成自己的训练数据。 代理人必须通过试验和错误了解自己行为的后果，而不是被告知正确的行动。 </p>
<p>我们使用K臂老虎机（K-Armed Bandit）来描述强化学习中的基本概念，比如rewards、timesteps和values。</p>
<p>想象一下，有一名医生想要测量3种药物的效果：</p>
<p><img src="/img/rl_21_02_11/01.png" height=200 /></p>
<p>医生会随机开始一次治疗，然后观测患者的反映情况。</p>
<p>过了一段时间后，医生发现其中某种药物似乎比其他药物效果要更好：</p>
<p><img src="/img/rl_21_02_11/02.png" height=200 /></p>
<p>医生现在必须决定<strong>是否坚持最佳治疗</strong>或<strong>继续进行随机研究</strong>。如果医生只使用一种药物治疗， 那么他们就不能再收集另外两种药物治疗的数据（也许其他治疗方法之一实际上是更好的， 只是由于偶然而变得更糟）。 但如果其他两种治疗方法更糟， 那么继续研究会危及其他患者的健康。 </p>
<p>这种医疗试验的本质就是一个K臂老虎机的案例。</p>
<h2 id="K臂老虎机"><a href="#K臂老虎机" class="headerlink" title="K臂老虎机"></a>K臂老虎机</h2><p>在K臂老虎机问题中，我们有一个决策者（代理）负责在k个不同的行动之间进行选择，并根据他选择的行动获得奖励。</p>
<p>在<strong>医疗试验</strong>的例子中，代理人就是医生。医生必须在3种不同的治疗行动之间进行选择，选择不同的治疗会产生一些未知的回报，最后患者是否得到治疗就是医生获得的奖励。</p>
<p><img src="/img/rl_21_02_11/03.png" height=200 /></p>
<h3 id="Action-Values"><a href="#Action-Values" class="headerlink" title="Action-Values"></a>Action-Values</h3><p>为了让医生决定哪个动作是最好的，我们必须定义每个动作的价值（Action-Values）。</p>
<p>我们对动作价值的定义是<strong>奖励的期望</strong>：</p>
<script type="math/tex; mode=display">
q*(a) \doteq \mathbb{E}[R_t|A_t=a] 
\ \ \ \  \forall a \in \{1, ..., k\}</script><blockquote>
<p>说明：<script type="math/tex">\doteq</script> 符号的意思是 <strong>定义为</strong><br>上面公式的含义是：$q*(a)$被定义为$R_t$的期望，$R_t$是我们在选中某个动作的时候的奖惩值。</p>
</blockquote>
<script type="math/tex; mode=display">
q*(a) = \sum_r p(r|a) r</script><p>这个条件期望被定义为所有可能的奖励的总和。在该总和中，我们将可能的奖励（$r$）乘以观察到该奖励的概率（$p(r|a)$）。</p>
<p>代理（agent）的目标就是<strong>最大限度的提高预期的回报</strong>。</p>
<p>代理选择最大的value的操作的过程称为argmax:</p>
<p><img src="/img/rl_21_02_11/04.png" height=40 /></p>
<h3 id="连续型的reward"><a href="#连续型的reward" class="headerlink" title="连续型的reward"></a>连续型的reward</h3><p>在上面的例子中，我们把患者是否治愈作为reward，下面我们用一个更容易测量的指标来衡量患者的状态：<strong>接受治疗后血压的变化</strong>。</p>
<p>在每种不同的药物治疗之后，患者的血压会呈现出不同的概率分布，也许是伯努利分布（结果1）、二项式分布（结果2）、均值分布中的某一种（结果3）：</p>
<p><img src="/img/rl_21_02_11/05.png" height=300 /></p>
<p>$q*(a)$是a动作的reward的均值</p>
<h2 id="为什么要研究老虎机问题"><a href="#为什么要研究老虎机问题" class="headerlink" title="为什么要研究老虎机问题"></a>为什么要研究老虎机问题</h2><p>现实生活中，我们随时都需要做出各种各样的决策，除了医生对患者选择最佳药物的例子外，我们决定去看什么电影、听什么歌曲、即便是在餐厅点菜 我们都在做着类似的选择。</p>
<p>老虎机是对未知环境下动作选择问题的简单抽象，在这种简单的问题下去思考算法的设计会使问题更加清晰。</p>
]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【强化学习】1-2 RL在学什么？预估Action Value</title>
    <url>/2021/02/11/%E3%80%90%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%911-2RL%E5%9C%A8%E5%AD%A6%E4%BB%80%E4%B9%88%EF%BC%9F%E9%A2%84%E4%BC%B0Action%20Value/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【斯坦福cs231n】2-1图像分类</title>
    <url>/2017/07/30/%E3%80%90%E6%96%AF%E5%9D%A6%E7%A6%8Fcs231n%E3%80%912-1%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p><strong>动机.</strong>在这一部分，我们将介绍图像分类问题，这是将输入图像分配到一组固定类别标签中的某一个标签的任务。尽管这个问题很简单，但它是计算机视觉的核心问题之一，并且有着各种各样的实际应用。此外，正如我们将在后面看到的，许多其它不同的计算机视觉任务（例如对象检测，分割）都可以被简化为图像识别问题。</p>
<p><strong>示例.</strong>例如，在下面的图像识别的例子中，图像分类模型接收单张图片，并对四个标签{cat，dog，hat，mug}的概率赋值。如图所示，请记住，对于计算机而言，图像被表示为一个大的三维数组。在这个例子中，猫图像是248像素宽，400像素高，并且有三个颜色通道：红色，绿色，蓝色（或简称RGB）。因此，该图像由248 x 400 x 3数字组成，总共297,600个数字。其中每个数字都是一个范围在0（黑色）到255（白色）的整数。我们的任务就是把这将近30万个数字转成像{cat}这样的单一的标签。</p>
<p><img src="/img/17_07_30/001.png" alt=""></p>
<blockquote>
<p>图像分类的任务是预测给定图像的单个标签（或者类似这里的一个标签的概率分布，用于表示我们信心）。图像是包含0到255整数的3维整数，大小是宽度x高度x3。其中3表示RGB三色通道。</p>
</blockquote>
<hr>
<p><strong>挑战.</strong>由于视觉识别问题（例如识别“猫”的例子）对于人类来说，是再简单不过的问题，但从计算机视觉算法的角度来重新审视这个问题，就充满了挑战。在我们下面提出的这些挑战中，请记住图像的原始表示形式为3-D阵列的亮度值：</p>
<ul>
<li><strong>不同的观察点(Viewpoint variation)</strong>照相机可以从多个方向来拍摄同一个实例对象。</li>
<li><strong>大小变化(Scale variation)</strong>视觉分类通常会出现不同的尺寸变化（这里包含在现实世界中的尺寸，不仅仅是针对图像中的大小程度）。</li>
<li><strong>变形(Deformation)</strong>许多物体并不是刚体，并且可以以极端的方式变形。</li>
<li><strong>闭塞(Occlusion)</strong>我们所观察的目标对象可能处于被遮挡的状态。有的时候我们只能看到对象的一小部分（像素比较少）。</li>
<li><strong>光照情况(Illumination conditions)</strong>照明的效果在像素级上的影响是剧烈的。</li>
<li><strong>背景杂波(Background clutter)</strong>我们所观察的对象可能融入到他们的背景环境中，使其难以识别。</li>
<li><strong>类型内部变化(Intra-class variation)</strong>我们所关心的类别通常会比较宽泛，比如椅子。不同类型的椅子有着不同的外观，但他们都属于“椅子”这一类别。</li>
</ul>
<p>一个好的图片识别分类模型必须在所有这些情况交叉出现的情况下，都能产出不变的结果输出，同时保持类别变化时的敏感性。</p>
<p><img src="/img/17_07_30/002.jpeg" alt=""></p>
<hr>
<p><strong>数据驱动的方法.</strong>如何编写一个将图像分类到不同类别的算法呢？与编写一个像数字排序这样的算法不同的是，如何编写一个识别猫的算法的方法并不是显式的。我们不会视图在代码中指定每个不同的类别在代码中是什么样的，我们所采取的方法就像是在教一个小孩子一样：我们首先为每个类别提供许多个实例，然后开发学习算法，通过学习算法来输入这些类别实例图像，学习到这些每个类别的视觉外观。这种方法被称为数据驱动方法，因为它依赖于事先已经被标记过的标签的图像的训练数据集：</p>
<p><img src="/img/17_07_30/003.jpg" alt=""></p>
<blockquote>
<p>上图是四个视觉类别的训练集示例。在实际情况中，我们可能会有数千种类别和数十万种图像。</p>
</blockquote>
<hr>
<p><strong>图像分类流水线.</strong>正如我们已经看到的，图像分类中的任务是使用一个像素数组来代表一个图像，并且为其分配一个标签。完整的流水线可以表示成如下的流程：</p>
<ul>
<li><strong>输入：</strong>我们的输入由一组N个图像组成，每一个都标有K个不同的类别。我们将这些数据称为训练集。</li>
<li><strong>学习：</strong>我们的任务是使用训练集来了解每一个类别的样子。我们将此步骤称为<em>训练分类器（training a classifier）</em>，或者<em>学习模型（learning a model）</em>。</li>
<li><strong>评估：</strong>最后，我们通过预测一组从未见过的新图像的标签来评估分类器的质量。然后，我们将这些图像的真实标签与分类器预测的图像进行比较。直观地说，我们希望达到的效果是大多数预测结果与真实答案（我们称之为ground truth）相匹配。</li>
</ul>
<h2 id="最邻近分类器（Nearest-Neighbor-Classifier）"><a href="#最邻近分类器（Nearest-Neighbor-Classifier）" class="headerlink" title="最邻近分类器（Nearest Neighbor Classifier）"></a>最邻近分类器（Nearest Neighbor Classifier）</h2><p>我们将开发一种叫做<strong>最邻近分类器</strong>，来作为我们的第一个图片分类的实现。这种分类器与卷积网络无关，在实践中很少使用，但它可以使我们了解处理图像分类问题的基本方法。</p>
<p><strong>示例图像分类数据集：CIFAR-10.</strong><a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a>是一个流行的toy级别的图像分类数据集。这个数据集包含60,000个长宽都是32像素的小图片。每个图片都有一个标签（例如“飞机，汽车，鸟等”）。这60,000张图像被划分为50,000张图像的训练集和10,000张图像的测试集。在下面的图片中，您可以看到10个类别中的每个类别的10个随机示例图像：</p>
<p><img src="/img/17_07_30/004.jpg" alt=""></p>
<blockquote>
<p>左图：来自CIFAR-10数据集的示例图像。右图：第一列显示几个测试图像，并且在每个测试图像旁边，我们根据像素差异显示训练集中的前10个最近邻居。</p>
</blockquote>
<hr>
<p>假设现在我们有50,000张训练图像（50,000张图像都有其对应的标签数据），并且我们希望为剩余的10,000张图片打标签。最邻近分类器将接收一个测试图片，与每一张训练图片做对比，然后以其最接近的训练图像的标签作为其预测标签。在上面的右图中，您可以看到10个示例图片的十个用这种方式得到的最相近的结果图片。请注意，在这10个示例中，有三个图片在检索相同的类别，而其他7个示例并非如此。例如，在第八行最接近“马头图片”的训练的图像是一个“红色汽车图片”，也许是由于它们都拥有黑色背景的原因。这种结果，使得这匹马的形象在这种情况下会被误认为是汽车。</p>
<p>您可能已经注意到，我们并没有详细的说明我们是如何比较这两个尺寸为32 x 32 x 3的图像的细节的。一种最简单的处理方式是对像素点逐个比较，然后求差值绝对值之和。换句话说，给出两个图像，并将其表示为向量$I_1, I_2$，比较他们的一种合理的方式是求<strong>L1距离</strong>:</p>
<script type="math/tex; mode=display">
d_1 (I_1, I_2) = \sum\_p \left| I^p_1 - I^p_2 \right|</script><p>下面是将这段程序可视化的过程：</p>
<p><img src="/img/17_07_30/005.jpeg" alt=""></p>
<blockquote>
<p>一个使用L1距离来比较图片像素差异的示例（在这里例子中只有一个颜色通道）。将两个图像元素相减，然后将所有差值相加到一个数字上。如果两个图像相同，则结果将为零。但如果图像非常不同，结果会很大。</p>
</blockquote>
<hr>
<p>我们来看看我们如何在代码中实现分类器。首先，我们将CIFAR-10数据作为4个阵列加载到内存中：用于训练的数据/标签集合，以及用于测试的数据/标签集合。在下面的代码中，<code>Xtr</code>(尺寸是50,000 x 32 x 32 x 3)包含全部的用于训练的图像数据，与之对应的是一个一维数组<code>Ytr</code>(长度是50,000)持有训练集标签(标签是0到9的类别)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Xtr, Ytr, Xte, Yte &#x3D; load_CIFAR10(&#39;data&#x2F;cifar10&#x2F;&#39;) # a magic function we provide</span><br><span class="line"># flatten out all images to be one-dimensional</span><br><span class="line">Xtr_rows &#x3D; Xtr.reshape(Xtr.shape[0], 32 * 32 * 3) # Xtr_rows becomes 50000 x 3072</span><br><span class="line">Xte_rows &#x3D; Xte.reshape(Xte.shape[0], 32 * 32 * 3) # Xte_rows becomes 10000 x 3072</span><br></pre></td></tr></table></figure>
<p>现在我们把所有的图像都拉伸成行了，下面的代码演示了我们如何训练并且评估一个分类器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nn &#x3D; NearestNeighbor() # create a Nearest Neighbor classifier class</span><br><span class="line">nn.train(Xtr_rows, Ytr) # train the classifier on the training images and labels</span><br><span class="line">Yte_predict &#x3D; nn.predict(Xte_rows) # predict labels on the test images</span><br><span class="line"># and now print the classification accuracy, which is the average number</span><br><span class="line"># of examples that are correctly predicted (i.e. label matches)</span><br><span class="line">print &#39;accuracy: %f&#39; % ( np.mean(Yte_predict &#x3D;&#x3D; Yte) )</span><br></pre></td></tr></table></figure>
<p>请注意，作为评估标准，我们通常使用<strong>准确率(accuracy)</strong>来衡量预测结果的准确性。请注意，我们将构建的所有分类器都满足这一个常见的API：它们有一个接受用来学习的数据和标签的<code>train(X,y)</code>函数。在内部，该类应该建立一些标签的模型，以及如何从数据中预测结果的逻辑。同时还需要有一个用来接受新数据并且预测其标签的<code>predict(X)</code>函数。下面是一个L1距离的最邻近分类器的一个简单实现，它满足这套模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">class NearestNeighbor(object):</span><br><span class="line">  def __init__(self):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">  def train(self, X, y):</span><br><span class="line">    &quot;&quot;&quot; X is N x D where each row is an example. Y is 1-dimension of size N &quot;&quot;&quot;</span><br><span class="line">    # the nearest neighbor classifier simply remembers all the training data</span><br><span class="line">    self.Xtr &#x3D; X</span><br><span class="line">    self.ytr &#x3D; y</span><br><span class="line"></span><br><span class="line">  def predict(self, X):</span><br><span class="line">    &quot;&quot;&quot; X is N x D where each row is an example we wish to predict label for &quot;&quot;&quot;</span><br><span class="line">    num_test &#x3D; X.shape[0]</span><br><span class="line">    # lets make sure that the output type matches the input type</span><br><span class="line">    Ypred &#x3D; np.zeros(num_test, dtype &#x3D; self.ytr.dtype)</span><br><span class="line"></span><br><span class="line">    # loop over all test rows</span><br><span class="line">    for i in xrange(num_test):</span><br><span class="line">      # find the nearest training image to the i&#39;th test image</span><br><span class="line">      # using the L1 distance (sum of absolute value differences)</span><br><span class="line">      distances &#x3D; np.sum(np.abs(self.Xtr - X[i,:]), axis &#x3D; 1)</span><br><span class="line">      min_index &#x3D; np.argmin(distances) # get the index with smallest distance</span><br><span class="line">      Ypred[i] &#x3D; self.ytr[min_index] # predict the label of the nearest example</span><br><span class="line"></span><br><span class="line">    return Ypred</span><br></pre></td></tr></table></figure>
<p>如果你运行了上面的代码，你将看到这个分类器在CIFAR-10的数据集上只有<strong>38.6%</strong>的准确率。比我们随机选取的结果准确率高一些（随机选取的准确率是10%，因为我们有10个类别），但这个结果与人类真实的识别准确率（估计<a href="http://karpathy.github.io/2011/04/27/manually-classifying-cifar10/">约为94%</a>）或者最先进的卷积神经网络能达到的95%准确率相比，差的很远。（见CIFAR-10在Kaggle上的<a href="http://www.kaggle.com/c/cifar-10/leaderboard">排行榜</a>）</p>
<p><strong>距离的选择.</strong>有许多其他的方式来计算两个向量之间的距离。一种比较常用的方式是计算两个向量之间的欧几里得距离，即<strong>L2距离</strong>。公式如下:</p>
<script type="math/tex; mode=display">
d\_2 (I\_1, I\_2) = \sqrt{\sum\_{p} \left( I^p\_1 - I^p\_2 \right)^2}</script><p>换句话说，我们之前需要计算两者的像素差，而这一次，我们需要计算像素差的平方，并且把他们加起来之后开根号。在numpy中，我们可以用一行代码来实现上述的计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distances &#x3D; np.sqrt(np.sum(np.square(self.Xtr - X[i,:]), axis &#x3D; 1))</span><br></pre></td></tr></table></figure>
<p>请注意，在上面的计算中，我引入了<code>np.sqrt</code>，但在实际的最邻近应用中，我们可以省略求平方根的操作，因为平方根是一个单调函数。也就是说，它对距离的绝对值的差值起到了缩放的作用，但它依然保留了排序结果，因此对于最邻近问题来说，有没有这一步开根号的运算，其结果都是相同的。如果你在CIFAR-10上运行这个L2最邻近分类器，那么你得到的准确率是<strong>35.4%</strong>（比L1的结果略低一些）。</p>
<p><strong>L1 vs L2.</strong>这两者之间存在什么样的差异呢？这是一个很有意思的问题。在特定的情况下，当涉及两个向量之间的差异时，L2距离比L1距离更糟一些。L1和L2距离（或等效地，一对图像之间的差异的L1 / L2范数）是<a href="http://planetmath.org/vectorpnorm">p范数</a>最常用的特殊情况。</p>
<h3 id="KNN分类器（k-Nearest-Neighbor-Classifier）"><a href="#KNN分类器（k-Nearest-Neighbor-Classifier）" class="headerlink" title="KNN分类器（k - Nearest Neighbor Classifier）"></a>KNN分类器（k - Nearest Neighbor Classifier）</h3><p>您可能已经注意到，当我们想进行预测时，只使用最接近的一个图像的标签是很奇怪的。事实上，通过使用所谓的<strong>KNN分类器</strong>，人们可以做得更好。实际上这个想法很简单：不是在训练集中找到单个最接近的图像，我们将找到最接近的<strong>k</strong>个图像，并让他们对测试图像的标签进行投票。尤其是，当$k=1$的时候，我们KNN分类器实际上就是最邻近分类器。从直觉上来说，较高的<strong>k</strong>值有更平滑的效果，使得分类器更能抵抗离群值：</p>
<p><img src="/img/17_07_30/006.jpeg" alt=""></p>
<blockquote>
<p>上图中，使用二维散点图用三种颜色（红、蓝、绿）来表示三种类别，分别展示了原始数据在最邻近分类器上和在5-NN分类器上的效果。彩色的区域显示在L2距离下生成的<strong>判定边界</strong>。白色区域显示出不能被明确分类的点（即，类别投票至少被分为两类）。请注意，在使用最邻近分类器的情况下，异常值数据点（例如蓝色区域中的绿点）会产生可能不正确的预测的区块，而5-NN分类器在这种情况下会得到相对平滑的效果，这也意味着对测试数据的<strong>泛化</strong>能力更好（未被显示）。还要注意，5-NN图像中的灰色区域是由最邻近的几个邻居颜色不同导致的（例如，有两个是红色的，两个是蓝色的，一个是绿色的）。</p>
</blockquote>
<hr>
<p>在实践中，当我们使用kNN分类器时，应该选择什么样的k值才合适呢？接下来我们来谈谈这个问题。</p>
<h2 id="验证集，交叉验证，超参数调谐"><a href="#验证集，交叉验证，超参数调谐" class="headerlink" title="验证集，交叉验证，超参数调谐"></a>验证集，交叉验证，超参数调谐</h2><p>kNN分类器需要指定一个k值，但是当k取什么值时效果最好呢？另外，我们还可以选择L1范数、L2范数，等，以及许多我们甚至没有考虑到的选择。这些选择被称为<strong>超参数（Hyperparameter）</strong>，他们在许多机器学习算法的设计过程中都会出现。通常这些值应该被设置为多少，并不是十分显而易见。</p>
<p>你也许会试图建议我们尝试许多不同的值，然后看看哪些值的效果最好。这的确是一个好办法，这也是我们接下来要做的，但这个过程必须非常仔细地进行。特别要说吗的是，<strong>我们不能使用测试集来调整参数</strong>。当您在设计一款机器学习算法时，您应该将将测试集视为一个非常宝贵的资源，在理想情况下，除非在测试阶段，都不要去触碰它。否则，你调整的参数将会作用域测试集上，这样做非常危险，因为当你开始在真实的数据上使用该模型时，你会发现性能显著降低。在实践过程中，我们称这种现象为<strong>过拟合</strong>测试集。关于这一现象的另一种解释是，如果你在测试集上调整了参数，你实际上是在把测试集当做训练集在使用，因此，你实现的模型的性能对于实际观察到的情况来说都是过于乐观的。但与之相反的，如果我们只是在最后的测试过程中使用一次测试集，那么它仍然是测量分类器<strong>泛化</strong>的一个很好的代理（我们将在以后的课程中看到更多关于泛化的讨论）。</p>
<blockquote>
<p>评估测试集在每次训练结束后只运行一次。</p>
</blockquote>
<p>幸运的是，有一种不触碰测试集的调整超参数的方法。这个方法就是将我们的训练集分为两部分：其中稍微小一些的那部分训练集，我们称之为<strong>验证集(validation set)</strong>。使用CIFAR-10为例，我们使用49,000的样本作为训练集，然后使用剩下的1,000个样本作为验证集。这个验证集是用来调整超参数的一个假测试集。</p>
<p>在CIFAR-10中，这个例子看起来可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># assume we have Xtr_rows, Ytr, Xte_rows, Yte as before</span><br><span class="line"># recall Xtr_rows is 50,000 x 3072 matrix</span><br><span class="line">Xval_rows &#x3D; Xtr_rows[:1000, :] # take first 1000 for validation</span><br><span class="line">Yval &#x3D; Ytr[:1000]</span><br><span class="line">Xtr_rows &#x3D; Xtr_rows[1000:, :] # keep last 49,000 for train</span><br><span class="line">Ytr &#x3D; Ytr[1000:]</span><br><span class="line"></span><br><span class="line"># find hyperparameters that work best on the validation set</span><br><span class="line">validation_accuracies &#x3D; []</span><br><span class="line">for k in [1, 3, 5, 10, 20, 50, 100]:</span><br><span class="line">  </span><br><span class="line">  # use a particular value of k and evaluation on validation data</span><br><span class="line">  nn &#x3D; NearestNeighbor()</span><br><span class="line">  nn.train(Xtr_rows, Ytr)</span><br><span class="line">  # here we assume a modified NearestNeighbor class that can take a k as input</span><br><span class="line">  Yval_predict &#x3D; nn.predict(Xval_rows, k &#x3D; k)</span><br><span class="line">  acc &#x3D; np.mean(Yval_predict &#x3D;&#x3D; Yval)</span><br><span class="line">  print &#39;accuracy: %f&#39; % (acc,)</span><br><span class="line"></span><br><span class="line">  # keep track of what works on the validation set</span><br><span class="line">  validation_accuracies.append((k, acc))</span><br></pre></td></tr></table></figure>
<p>在此过程结束之前，我们可以绘制一个图表，来显示哪个k值表现的更好。然后我们使用这个最好的k值，对真正的测试集进行一次评估。</p>
<blockquote>
<p>将你的训练集分割为训练集和验证集。使用验证集来调整所有的超参数。最后在测试集上仅运行一次评估操作，并上报结果。</p>
</blockquote>
<p><strong>交叉验证.</strong>在你的训练集（同时也包括验证集）可能非常小的情况下，人们有时使用一个更复杂叫做<strong>交叉验证</strong>的技术来调节超参数。作用于我们之前的例子中，取代之前我们选取1000个数据点来作为验证集、剩下的部分用做测试集这种方式，我们通过迭代不同的验证集以及求得他们的平均表现这种方式，来得到一个更好的，噪音更小的k值。举个例子，在5倍交叉验证中，我们将数据分为5等份，使用其中4份来训练，用剩余的1份作为验证。然后我们迭代所有其他份数据来作为验证集，计算每一份作为验证集的最终表现，最终将每次得到的表现求和在求平均值。</p>
<p><img src="/img/17_07_30/007.png" alt=""></p>
<blockquote>
<p>参数k的五倍交叉验证运行示例。对于k的每个值，我们都在4份数据上训练，并且在第5份数据上评估。因此，对于每个k，我们在交叉验证上都会有5个评估得到的准确率（y轴是准确率，每个结果对应一个点）。趋势曲线通过每个k的结果的平均值绘制，错误条表明标准偏差。注意在这里的一个特定场景，交叉验证集建议我们选取的k=7，此时在数据集上的预测效果最好（对应于图中的峰值处）。如果我们使用超过5份的数据，我们也许会看到一个更平滑（低噪音）的曲线。</p>
</blockquote>
<hr>
<p><strong>实践.</strong>在实践中，人们更倾向于避免使用交叉验证，人们更愿意接受单个的验证集分割，因为交叉验证的计算是十分昂贵的。人们倾向使用的分割方式是将训练集分割50%-90%用作训练，剩下的部分用作验证。然而，这取决于多个因素：例如如果超参数数量很大，你也许更倾向于使用一个更大的验证集分割。如果验证集样本的数量很少（可能只有几百个），那么使用交叉验证则更安全一些。正如你所见的，典型的交叉验证可能会是三等分、5等分或者10等分的交叉验证。</p>
<p><img src="/img/17_07_30/008.jpeg" alt=""></p>
<blockquote>
<p>常见的数据分割。给定训练集和测试集。训练集被分割为几等份（例如这里的五等分）。第1-4份数据作为训练集。一份作为验证集（例如这里的黄颜色的第五份），用来调节超参数。交叉验证更进一步的操作是迭代循环这5份数据，分别作为验证集的预测结果。这被称为5倍交叉验证。一旦模型被训练，并且确定了所有的最佳的超参数，最终在测试集（红色）上单词评估干模型。</p>
</blockquote>
<hr>
<h2 id="最近邻分类器的优缺点"><a href="#最近邻分类器的优缺点" class="headerlink" title="最近邻分类器的优缺点"></a>最近邻分类器的优缺点</h2><p>思考最邻近分类器的优缺点是一件值得做的事情。很明显，一个优点是：它的实现很简单，理解起来也很简单。此外，这个分类器不需要训练的时间，因为用于预测结果的数据全部来自于被存储的以及可能被索引的训练数据。但是，我们需要消耗一次测试的时间，因为对测试数据进行分类，我们需要将每个训练样本进行比较。这是一种不好的方式，因为在实践过程中，我们往往很在意测试运行的时间，而不太在意训练所花费的时间。事实上，我们将在稍后的深度神经网络课程中，我们将看到另一个极端：它会在训练样本的过程中花费巨大的开销，但一旦训练结束，在一个新的测试样本上执行分类任务时的开销是非常小的。这种模式在实践中更为理想。</p>
<p>除此之外，关于最邻近分类器的计算复杂度问题，一直是一个活跃的研究领域，并且有一些可以加速数据集中最邻近数据的查找的<strong>近似最邻近（Approximate Nearest Neighbor(ANN)）</strong>算法和库存在（例如<a href="http://www.cs.ubc.ca/research/flann/">FLANN</a>）。这些算法允许在检索期间以其空间/时间复杂度来折衷最近相邻检索的正确性，并且通常依赖于涉及构建kdtree或运行k-means算法的预处理/索引阶段。</p>
<p>在某些场景中，最近邻分类器有时可能是一个很好的选择（特别是如果数据是低维数据），但很少适用于实际的图像分类场景。其中一个问题是图像是高维度对象（即它们通常包含许多像素），并且高维空间的距离是非常不直观的。下面的图像说明了我们上面开发的基于像素的L2相似度与人类感知相似性的区别：</p>
<p><img src="/img/17_07_30/009.png" alt=""></p>
<blockquote>
<p>高维数据（尤其是图像）上基于像素的距离可能非常不直观。基于L2像素距离，原始图像（左）和旁边的三个其他图像都距离它们相同。显然，像素方向的距离并不能与人类感知上的相似性相对应。</p>
</blockquote>
<hr>
<p>这里有更多的可视化数据来说服你，使用像素差异来比较图像是不够的。我们可以使用一种名为t-SNE的可视化技术来拍摄CIFAR-10图像，并将其嵌入到二维空间中，使其（局部）成对距离最好地保留下来。在这种可视化中，根据我们上面开发的L2像素距离，我们将其L2距离相对较小的图像聚集在一起：</p>
<p><img src="/img/17_07_30/010.jpg" alt=""></p>
<blockquote>
<p>使用t-SNE嵌入二维的CIFAR-10图像。该图像附近的图像被认为是基于L2像素距离接近的。注意到背景的强烈影响，而不是语义层次的差异。点击<a href="http://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg">这里</a>查看这个可视化的更大版本。</p>
</blockquote>
<hr>
<p>特别地，请注意，彼此相邻的图像更多是图像的平均颜色分布或背景的类型相似的图像，而不是其相似的标签类型的图像。例如，可以看到一张狗的图片和一张青蛙的照片像邻，因为两者都是在白色背景上。理想情况下，我们希望所有10个类中的图像形成自己的集群，使得同一类的图像在彼此附近，而不管不相关的特征和变化（如背景）。然而，要获得这个属性，我们将不得不超越像素级别的去考虑问题。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>综上所述：</p>
<ul>
<li>我们引入了<strong>图像分类</strong>的问题，其中给出了一组全部标记为单一类别的图像。然后，我们要求为这些类别预测一组新的测试图像，并测量预测的准确性。</li>
<li>我们引入了一个称为<strong>最近邻分类器</strong>的简单分类<strong>器</strong>。我们看到有与此分类器相关联的多个超参数（如k值或用于比较示例的距离类型），并没有明显的选择方式。</li>
<li>我们看到设置这些超参数的正确方法是将训练数据分为两个：训练集和假测试集，我们称之为<strong>验证集</strong>。我们尝试不同的超参数值，并保持在验证集上达到最佳性能的值。</li>
<li>如果缺乏培训数据是一个问题，我们讨论了一个称为<strong>交叉验证</strong>的过程，它可以帮助减少噪声，以估计哪些超参数最有效。</li>
<li>一旦找到了最佳的超参数，我们修复它们，并对实际测试集执行单个<strong>评估</strong>。</li>
<li>我们看到最近邻居可以在CIFAR-10上获得约40％的准确性。它实现起来很简单，但要求我们存储整个训练集，并且在测试图像上进行评估是很昂贵的。</li>
<li>最后，我们看到在原始像素值上使用L1或L2距离是不够的，因为这些距离与图像的背景和颜色分布相比，与其语义内容相比更强烈。</li>
</ul>
<p>在接下来的课程中，我们将着手解决这些挑战，最终达成90％精度的解决方案，让我们在完成学习后完全丢弃训练集，并允许我们在不到一毫秒内评估测试图像。</p>
<h2 id="总结：在实践中应用kNN"><a href="#总结：在实践中应用kNN" class="headerlink" title="总结：在实践中应用kNN"></a>总结：在实践中应用kNN</h2><p>如果您希望在实践中应用kNN（希望不是在图像上），请按如下步骤进行：</p>
<ul>
<li>1.预处理数据：规范数据中的特征（例如图像中的一个像素），使其具有零均值和单位方差。我们将在后面的章节中更详细地介绍这一点，并且选择不覆盖本节中的数据规范化，因为图像中的像素通常是均匀的，并且不会展现出广泛不同的分布，从而减轻了数据规范化的需要。</li>
<li>2.如果您的数据非常高，请考虑使用维度降低技术，如PCA（<a href="http://en.wikipedia.org/wiki/Principal_component_analysis">wiki ref</a>，<a href="http://cs229.stanford.edu/notes/cs229-notes10.pdf">CS229ref</a>，<a href="http://www.bigdataexaminer.com/cgi-sys/suspendedpage.cgi">博客引用</a>），甚至使用<a href="http://scikit-learn.org/stable/modules/random_projection.html">随机投影</a>。</li>
<li>3.将您的训练数据随机分成训练集/验证集。根据经验，70-90％的数据通常会分配到训练集上。此设置取决于您拥有多少超参数以及您期望他们拥有多少影响力。如果有很多超参数需要估计，那么您应该在验证集更大的一边进行有效的估计。如果您的验证数据集比较小，最好将训练数据拆分为几等分，并执行交叉验证。如果你能负担得起计算机的运算量，那么交叉验证（更多的份数越好，但是更昂贵）总是更安全。</li>
<li>4.对于k的许多选择（比如越多越好）和不同距离类型（L1和L2都是不错的选择），对验证数集（对于所有份数，如果进行交叉验证）训练和评估kNN分类器。</li>
<li>5.如果您的kNN分类器运行时间过长，请考虑使用近似最近邻库（<a href="http://www.cs.ubc.ca/research/flann/">FLANN</a>）来加速检索（以某种精度为代价）。</li>
<li>6.记下提供最佳效果的超参数。有一个问题是您应该使用最佳超参数的完整训练集，因为如果要将验证数据折叠到训练集中（因为数据的大小会更大），最佳超参数可能会改变。实际上，在最终分类器中不使用验证数据更为清晰，并且在估计超参数时认为它被刻录。评估测试集上的最佳模型。上报在测试集上的准确率，这个结果作为kNN分类器的最终表现。</li>
</ul>
<h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>这里有一些（可选）链接，您可能会发现更多有趣的东西：</p>
<ul>
<li><a href="http://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf">关于机器学习的一些有用的事情</a>，其中特别是第6部分是相关的，但这整篇文章都是值得一读的。</li>
<li><a href="http://people.csail.mit.edu/torralba/shortCourseRLOC/index.html">认可和学习对象类别</a>，ICCV 2005的短期课程对象分类。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>cs231n</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>【斯坦福cs231n】2-2线性分类</title>
    <url>/2017/08/03/%E3%80%90%E6%96%AF%E5%9D%A6%E7%A6%8Fcs231n%E3%80%912-2%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p>在最后一节中，我们介绍了图像分类的问题，这是从一组固定的类别向一个图像分配单个标签的任务。更多的，我们描述了通过将图像与来自训练集的（注释）图像进行比较来标记图像的k-最近邻（kNN）分类器。我们看到，kNN有一些缺点：</p>
<ul>
<li>分类器必须记住所有的训练数据并将其存储，以便将来与测试数据进行比较。这在空间上是低效的，因为数据集的大小可能很容易达到千兆字节。</li>
<li>分类器执行对单个测试样本进行预测的操作是昂贵的，因为它需要与所有训练图像进行比较。</li>
</ul>
<p><strong>概述.</strong>我们现在要开发更强大的图像分类方法，我们最终将自然地扩展到整个神经网络和卷积神经网络。该方法将有两个主要部分：一个<strong>得分函数</strong>，这个函数是原始数据到预测分类的得分的映射；以及<strong>损失函数</strong>，这个函数衡量了预测得分与真实结果之间的差值。然后，我们将图像分类问题作为一个最小化相对于得分函数的损失函数的优化问题。</p>
<h2 id="从图像到标签分数的参数化映射"><a href="#从图像到标签分数的参数化映射" class="headerlink" title="从图像到标签分数的参数化映射"></a>从图像到标签分数的参数化映射</h2><p>该方法的第一个组成部分是定义将图像的像素值映射到每个类的置信度得分的分数函数。我们将以具体的例子来介绍这种方法。像以前一样，我们假设一个图像训练数据集$x_i \in R^D$，每个图像都有一个相关的标签$y_i$。在这里，我们定义$i = 1 \dots N$，并且$y_i \in { 1 \dots K }$。也就是说我们拥有$N$个样本（每个样本的维数都是$D$）和$K$个不同的类别。例如，在CIFAR-10中，我们有一个训练集，它有$N=50,000$张图片，其中每张图片都是$D=32 x 32 x 3 = 3072$像素，并且由于一共有10个不同的类别（狗，猫，车等等），所以$K=10$。我们现在将定义将原始图像像素映射到类分数的分数函数：$f: R^D \mapsto R^K$。</p>
<p><strong>线性分类器.</strong>在这个模块中，我们可以从最简单的一个线性映射函数开始：</p>
<script type="math/tex; mode=display">
f(x_i, W, b) =  W x_i + b</script><p>在上述等式中，我们假设图像$x_i$将其所有像素平坦化形状为[D x 1]的列向量。矩阵$W$(大小是[K x D])，向量$b$（大小是[K x 1]）是函数的<strong>参数</strong>。在CIFAR-10中，$x_i$包含第i张图中的所有像素，并且展开成为单列的尺寸为[3072 x 1]的向量，$W$尺寸是[10 x 3072]，$b$的尺寸是[10 x 1]，所以这个函数每次有3072个参数输入（原始像素值），并且有10个参数输出（10个类别的得分）。参数$W$通常被称为<strong>权重(weights)</strong>，$b$被称为<strong>偏差向量(bias vector)</strong>，因为它会在不与实际输入数据$x_i$发生交互的情况下，影响输出分数值。但是，您经常会听到人们用<em>权重</em>或者<em>参数</em>这样的术语来描述这一概念。</p>
<p>有一些注意事项：</p>
<ul>
<li>首先，注意$Wx_i$的矩阵乘法部分，正在对10个独立的分类器进行并行的评估，其中$W$的每一行分别是一个类别的分类器。</li>
<li>同时也要注意，给定的输入数据$(x_i, y_i)$是不可变的，但是我们可以控制调节参数$W,b$。我们的目标是通过设置这些参数，使得最终分类器计算出来的得分与整个训练集中的真实标签数据相匹配。我们将详细介绍如何做到这一点，但从直觉上来说，我们希望被正确分类的分数是高于错误分类的分数的。</li>
<li>这种方法的一个优点是训练数据被用于学习参数$W,b$，但一旦学习完成，我们就可以忽略训练数据集，并且只保留学习得到的参数值即可。这是因为一个新的测试图像可以通过调用这个方法来基于已经算出的分数进行分类。</li>
<li>最后，注意测试图像分类涉及到一个单个的矩阵乘法和加法操作，这明显比将测试图像与所有训练图像进行比较更快。</li>
</ul>
<blockquote>
<p>卷积：卷积神经访问将图像像素映射到如上所示的分数，但映射(f)更复杂，并且包含更多的参数。</p>
</blockquote>
<h2 id="解释线性分类器"><a href="#解释线性分类器" class="headerlink" title="解释线性分类器"></a>解释线性分类器</h2><p>请注意，线性分类器将其分类计算为其所有3个颜色通道中的所有像素值的加权和。分类结果取决于我们为这些权重设置什么具体值，该函数具有在图像中某些位置的某些颜色的喜欢或者不喜欢的能力（取决于每个权重的符号）。例如，你可以想象，如果图像的边缘部分有很多的蓝色（这部分可能是水），那么这张图片是“船”的类别的可能性更大。你可能希望“船”分类器在其蓝色通道有着正权重（蓝色增加“船”类别的分值），而在红色/绿色通道中有着负权重（红色/绿色的存在降低“船”类别的分值）。</p>
<hr>
<p><img src="/img/17_08_03/001.jpg" alt=""></p>
<blockquote>
<p>一个将图像到分类得分的映射例子。为了方便可视化，我们假设图像只有4个像素（4个单色像素，这里我们不考虑彩色通道），我们有三个类别（红色（猫），绿色（狗），蓝色（船））。（说明：这里的颜色简单的表示了3个类别，但与RGB通道无关。）我们将图像像素拉伸成一列，并执行矩阵乘法以得到每个类的分数。请注意，这里给定的权重W不是很好：我们传入一张猫的图片，通过这个权重计算得到的对应的猫的得分很低。实际上，这套权重对应得到的得分似乎在说明它看到的是一条狗。</p>
</blockquote>
<hr>
<p><strong>将图像比作高维点.</strong>由于图像被拉伸成高维列向量，我们可以将每个图像解释为该空间中的单个点（例如，CIFAR-10中的每个图像是32×32×3像素的3072维空间中的点）。类似地，整个数据集是一个（被标记的）的点集合。</p>
<p>由于我们将每一个类的分数定义为所有图像像素的加权和，所以每个类对应的分数在这个空间上是一个线性函数。我们无法想象3072维空间的样子，但如果我们想象将所有的维度都挤压到两个维度时，那么我们就可以试着去可视化分类器正在做的事情：</p>
<p><img src="/img/17_08_03/002.jpeg" alt=""></p>
<blockquote>
<p>图像空间中，每个图像都是单个点，并且有三个分类器被可视化。使用汽车分类器（红色）的示例，红色线显示空间中为汽车分类得分为0的所有点。红色箭头表示的是分数增加方向，所以红线右侧的所有点都是正（线性增加）得分，并且左边的所有点都是负（线性递减）得分。</p>
</blockquote>
<hr>
<p>正如我们上面所见到的，权重矩阵$W$的每一行都对应一个类别的分类器。这些数字的几何解释是：当我们更改$W$的其中一行时，像素控件中的相应行将沿不同方向旋转。另一方面，偏置量$b$允许我们的分类器转换行。特别要注意的是，没有偏置量时，插入$x_i=0$时，不管权值为何值，最终得到的分数总是0，所以所有分类器的线条都被迫穿过原点。</p>
<p><strong>将线性分类器解释为模板匹配.</strong>对于权重$W$的另外一种解释是每一行都对应一个类的模板（有时也称为原型）。然后，通过使用<em>内积</em>（或<em>点积</em>）逐个比较每个模板与图像，以获得最适合的图像，从而获得每个类的分数。当我们执行内积操作的时候，线性分类器正在进行模板匹配，其中模板是通过学习得到的。另一种看待这个问题的方法是我们依然在执行最邻近操作，但是，相比与成千上万的训练图像进行比较，我们这里只是使用单个图像进行比较（尽管我们会学习这张图，但它不一定是训练集中的图像），并且我们使用（负）内积作为距离而不是L1或L2距离。</p>
<p><img src="/img/17_08_03/003.jpg" alt=""></p>
<blockquote>
<p>CIFAR-10学习结束时得到的权重示例。注意，例如，船模板包含大量蓝色像素。因此，一旦与其内部在海洋上的船舶图像相匹配，该模板就会得到高分。</p>
</blockquote>
<hr>
<p>此外，请注意，马模板似乎包含一个双头马，这是由于数据集中有左右两匹马造成的。线性分类器将这两种模式的马在数据中合并成一个模板。类似地，汽车分类器似乎已经将多种模式合并成了单个模板，其必须从各方面以及所有颜色识别汽车。特别地，这个模板最终表现是红色的，这暗示着CIFAR-10数据集中红色的车占汽车类别的大部分。线性分类器太弱，无法正确识别不同颜色的汽车，但正如我们将看到的，神经网络将允许我们执行此任务。神经网络能够通过其隐藏层来开发出可以检测特定汽车类型的中间神经元（例如面向左方的绿色汽车，面向前方的蓝色汽车等），并且下一层的神经元可以通过各个车辆检测器的加权和来将它们组合成更准确的车辆分数。</p>
<p><strong>偏置技巧.</strong>在继续下面的内容之前，我们将介绍一个通用的简化技巧，将两个参数$W,b$表示为一个参数。回想一下，我们将得分函数定义为：</p>
<script type="math/tex; mode=display">
f(x_i, W, b) =  W x_i + b</script><p>对两个参数分别跟踪考虑（偏置$b$和重量$W$）是有点麻烦的。一个常用的技巧是将两组参数组合成一个单一的矩阵，我们通过将向量$x_i$扩展一个额外的维度，其值为常数1—一个默认的偏置维度。使用额外的维度，新的分数函数将简化为单个矩阵乘法：</p>
<script type="math/tex; mode=display">
f(x_i, W) =  W x_i</script><p>在我们的CIFAR-10例子中，$x_i$现在的维度由[3072 x 1]变为了[3073 x 1]-（额外的维度的值为常数1），$W$现在由[10 x 3072]变为了[10 x 3073]。现在$W$矩阵额外增加的那一列对应了偏置量$b$。下面是一个帮助我们理解的例子：</p>
<p><img src="/img/17_08_03/004.jpeg" alt=""></p>
<blockquote>
<p>上图介绍了调整偏置量的小技巧。执行一次矩阵乘法，然后将结果与偏置量（左侧）相加，等效于对所有输入向量添加常数为1的偏置维度，并将权重矩阵向右扩展一列偏置列（右侧）。因此，如果我们通过将其附加到所有向量来预处理我们的数据，我们只需要学习一个权重矩阵，而不是保存权重和偏差两个矩阵。</p>
</blockquote>
<hr>
<p><strong>图像数据预处理.</strong>请注意，在上面的例子中，我们使用了原始像素值（范围从[0 … 255]）。在机器学习中，对输入数据进行归一化操作是非常常见的做法（在图像识别的例子中，每一个像素被认为是一个特征）。特别地，通过减去每个特征的平均值来<strong>确定数据的中心值</strong>是很重要的。在图像识别的例子中，这对应于计算训练图像上的平均图像，并从每个图像中减去它，以获得像素范围大约在[-127 … 127]的图像。进一步的常用预处理是缩放每个输入特征，使其值范围落在[-1,1]的区间内。其中，均值为0是更为重要的步骤，但我们理解动态梯度下降之后我们才可以解释这一原因。</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>在上一节中，我们定义了由一组权重$W$参数化的像素到得分的映射函数。此外，我们并没有控制数据$(x_i,y_i)$(这些数据是外部给到并不可改变的)，但我们控制了权重，并且我们希望通过设置这些权值来预测分类得分，从而达到与真实标签相符合的效果。</p>
<p>例如，回到我们前面的那个将猫的图片分类到“猫”，“狗”和“船”的例子中，我们可以看到那个例子中的特定定权值并不是非常好：我们传入了一张画有猫的图片，但对于猫的分类得分，相比对于其他类别（狗的得分是437.9，船的得分是61.95）却非常低(-96.8)。我们可以通过<strong>损失函数</strong>（有时也被称为<strong>代价函数</strong>或<strong>目标</strong>）来衡量我们的分类器有多差。直观的说，如果我们在训练集上分类的效果不好，那么损失值将会很高，反之，则会很低。</p>
<h3 id="多类SVM损失函数"><a href="#多类SVM损失函数" class="headerlink" title="多类SVM损失函数"></a>多类SVM损失函数</h3><p>有几种方法来定义损失函数的细节。作为第一个例子，我们将首先开发一种称为<strong>多类别支持向量机（SVM）</strong>损失函数的常用损失函数。SVM损失函数被设置为使得SVM“想要”每个图像的正确类别具有比不正确类别高得多的固定的余量$\Delta$。请注意，如上所述，有时有助于拟合损失函数：SVM“想要”某种结果，意味着结果将产生较低的损失（这是好的）。</p>
<p>我们来看一下更准确的描述。回想一下我们给出的第i个样本的图像$x_i$以及其标识对应类别的标签$y_i$。得分函数$f(x_i, W)$接受像素值并且计算出得分向量，我们简称为$s$(分数的简写)。例如，第j个类别的得分是函数结果的第j个元素：$s_j = f(x_i, W)_j$。然后将第i个例子的多类SVM损失函数表示如下形式：</p>
<script type="math/tex; mode=display">
L\_i = \sum\_{j\neq y_i} \max(0, s\_j - s\_{y_i} + \Delta)</script><p><strong>例如.</strong>让我们通过一个例子来了解他是如何工作的。假设我们有三个类，可以得到$s = [13, -7, 11]$，第一个类别对应的是true（即$y_i = 0$）。并且假设$\Delta$（一个我们稍后会介绍到的超参数）的值是10。根据上面的针对错误分类得分的求和表达式（$j \neq y_i$），我们可以得到下面的结果：</p>
<script type="math/tex; mode=display">
L_i = \max(0, -7 - 13 + 10) + \max(0, 11 - 13 + 10)</script><p>你可以看到第一部分的结果是0，因为[-7 - 13 + 10]得出的是一个负数，然后通过函数$max(0,-)$将其阈值化为0。我们得到的损失值为0，因为正确分类的得分（13）比不正确分类的得分（-7）相距大于10。事实上，他们的距离是20，这个值是远大于10的，但SVM只关心差值最多在10以内；任何高于此间距的额外差值被取最大值操作控制在了0的位置上。第二部分关于[11 - 13 + 10]的计算结果是8。也就是说，即使正确的分类比不正确的分类（13&gt;11）有更高的分数，但并没有超过10的间隔值。其差值仅仅为2，所以其损失值为8（即，差额要高出多少才能超过间隔值）。总而言之，SVM损失函数希望被正确分类的到$y_i$的得分要比不正确分类的得分至少要大$\Delta$。如果不是这样，我们就会累计损失值。</p>
<p>请注意，在这个特定的模块中我们正在使用线性评分函数($f(x_i; W) =  W x_i$)，所以我们也可以以等效的方式重写损失函数：</p>
<script type="math/tex; mode=display">
L\_i = \sum\_{j\neq y_i} \max(0, w\_j^T x\_i - w\_{y_i}^T x\_i + \Delta)</script><p>这里的$w_j$是权重矩阵$W$的第j行转化为列的形式。然而，在更复杂的评分函数$f$的形式中，不一定是这样的。</p>
<p>在我们完成本节之前，我们将提到的最后一个术语是值域为0的$max(0,-)$函数，我们通常称为<strong>转折点损失(hinge loss)</strong>。有时候您会听到有关人们使用形式为$max(0,-)^2$的对违规惩罚更强烈（二次而不是线性）的平方转折点损失SVM（或L2-SVM）。无平方计算的是更为标准的版本，但在某些数据集中，平方转折点损失可以工作的更好。这一点可以在交叉验证期间确定。</p>
<blockquote>
<p>损失函数量化了我们对训练集的预测结果的不满意程度。</p>
</blockquote>
<hr>
<p><img src="/img/17_08_03/005.jpg" alt=""></p>
<blockquote>
<p>多类别支持向量机“想要”正确分类的分数比其他分数至少多出delta的大小。如果任何类别在红色区域内（或者更高）都有分数，那么就会有累计的损失。否则损失值为0。</p>
</blockquote>
<hr>
<p><strong>正则化.</strong>上面提到的损失函数有一个bug。假设我们有一个数据集，并且有一组用于正确分类每个样本的参数$W$（例如，所有的分数都是满足所有的边距值，并且对于所有的i都有$L_i = 0$）。问题是这套$W$不一定是唯一的：可能有许多与$W$类似的参数可以正确分类示例。一种看待这个问题的简单的方式是如果$W$的一些参数正确分类了所有样本（对于每个样本来说损失值为0），那么任意倍数的这些参数$\lambda W$（其中$\lambda &gt; 1$）也可以得出损失值为0的结果，因为这种变换均匀地拉伸了所有的得分幅度，以及它们的绝对差异。但是，如果正确分类的和最近的不正确分类的分数差异为15，然后将$W$的所有元素乘以2会使得新的差异值为30。</p>
<p>换句话说，我们希望对某些权重$W$进行一些偏好编码，以消除这种歧义。我们可以通过用<strong>正则化乘法$R(W)$</strong>来扩展损失函数，做到这一点。最常见的正则化惩罚是<strong>L2</strong>范数，通过对所有参数进行二次方的惩罚来阻止大权重出现：</p>
<script type="math/tex; mode=display">
R(W) = \sum\_k\sum\_l W\_{k,l}^2</script><p>在上面的表达式中，我们将$W$中所有元素的平方求和。请注意，正则化函数不是基于数据的函数，它只是基于权重。包括了正则化惩罚在内的完整的多类支持向量机的损失函数由两部分组成：<strong>数据损失</strong>(这是全部样本中平均损失值$L_i$)和<strong>正则化损失</strong>。也就是说，完整的多类SVM损失函数变为以下形式：</p>
<p><img src="/img/17_08_03/006.png" alt=""></p>
<p>或者将其扩展为完整形式：</p>
<script type="math/tex; mode=display">
L = \frac{1}{N} \sum\_i \sum\_{j\neq y\_i} 
\left[ \max(0, f(x\_i; W)\_j - f(x\_i; W)\_{y\_i} + \Delta) \right] + \lambda \sum\_k\sum\_l W\_{k,l}^2</script><p>其中$N$是训练样本的数量。正如你所见的，我们将正则化惩罚附加到损失目标上，由超参数$\lambda$加权。这个超参数通常是由交叉验证来设置，除此之外没有别的简单的方法。</p>
<p>事实上关于引入正则化惩罚除了上述的动机之外，正则化惩罚还给我们带来了许多理想的性质，其中有许多内容我们将在后面的部分讲到。例如，包括L2惩罚在内的SVM中的<strong>最大间隔</strong>属性（如果你感兴趣的话，见<a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf">CS229</a>）。</p>
<p>正则化最具吸引力的功能是可以惩罚大量的权重值使其倾向于增强泛化性能，因此这意味着没有输入数据的情况下也可以通过其自身大幅度的影响评分分值。例如，假设我们有一些输入向量$x = [1,1,1,1]$，以及两个权重向量$w_1 = [1,0,0,0]$，$w_2 = [0.25,0.25,0.25,0.25]$。然后可以得到$w_1^Tx = w_2^Tx = 1$，因此可见两个权重向量得到了相同的结果，但$w_1$的L2惩罚是1.0而$w_2$的L2惩罚仅仅是0.25。因此，根据L2惩罚的结果来看，权重向量$w2$应该被优先选择，因为它实现了较低的正则化损失。从直觉上来看，这是因为$w_2$的权重值更小并且更扩散。由于L2惩罚倾向于更小且更弥散的权重向量，所以最终的分类器更倾向于是将所有的维度都考虑到，而不是一小部分输入维度影响很大。正如我们在稍后的课程中看到的，这种效果可以提高分类器在测试图像上的泛化性能，并防止产生<em>过拟合</em>。</p>
<p>注意，偏置量具有与权重不同的效果，它不能控制输入数据的影响力。因此，我们通常只对权重$W$进行正则化操作，而不是偏置量$b$。但是，在实践中，这一点通常会忽略不计（即我们统一使用权重和偏置量组合后的矩阵来计算偏差）。最后，请注意，由于正则化惩罚，所以我们绝对不能在所有的样本中的损失值完全为0，除非你错误的把权重矩阵设置为了$W=0$。</p>
<p><strong>代码.</strong>这是在Python中实现的损失函数（无正则化），这是无向量化以及半向量化的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i</span>(<span class="params">x, y, W</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  unvectorized version. Compute the multiclass svm loss for a single example (x,y)</span></span><br><span class="line"><span class="string">  - x is a column vector representing an image (e.g. 3073 x 1 in CIFAR-10)</span></span><br><span class="line"><span class="string">    with an appended bias dimension in the 3073-rd position (i.e. bias trick)</span></span><br><span class="line"><span class="string">  - y is an integer giving index of correct class (e.g. between 0 and 9 in CIFAR-10)</span></span><br><span class="line"><span class="string">  - W is the weight matrix (e.g. 10 x 3073 in CIFAR-10)</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  delta = <span class="number">1.0</span> <span class="comment"># see notes about delta later in this section</span></span><br><span class="line">  scores = W.dot(x) <span class="comment"># scores becomes of size 10 x 1, the scores for each class</span></span><br><span class="line">  correct_class_score = scores[y]</span><br><span class="line">  D = W.shape[<span class="number">0</span>] <span class="comment"># number of classes, e.g. 10</span></span><br><span class="line">  loss_i = <span class="number">0.0</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> xrange(D): <span class="comment"># iterate over all wrong classes</span></span><br><span class="line">    <span class="keyword">if</span> j == y:</span><br><span class="line">      <span class="comment"># skip for the true class to only loop over incorrect classes</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># accumulate loss for the i-th example</span></span><br><span class="line">    loss_i += <span class="built_in">max</span>(<span class="number">0</span>, scores[j] - correct_class_score + delta)</span><br><span class="line">  <span class="keyword">return</span> loss_i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_i_vectorized</span>(<span class="params">x, y, W</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  A faster half-vectorized implementation. half-vectorized</span></span><br><span class="line"><span class="string">  refers to the fact that for a single example the implementation contains</span></span><br><span class="line"><span class="string">  no for loops, but there is still one loop over the examples (outside this function)</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  delta = <span class="number">1.0</span></span><br><span class="line">  scores = W.dot(x)</span><br><span class="line">  <span class="comment"># compute the margins for all classes in one vector operation</span></span><br><span class="line">  margins = np.maximum(<span class="number">0</span>, scores - scores[y] + delta)</span><br><span class="line">  <span class="comment"># on y-th position scores[y] - scores[y] canceled and gave delta. We want</span></span><br><span class="line">  <span class="comment"># to ignore the y-th position and only consider margin on max wrong class</span></span><br><span class="line">  margins[y] = <span class="number">0</span></span><br><span class="line">  loss_i = np.<span class="built_in">sum</span>(margins)</span><br><span class="line">  <span class="keyword">return</span> loss_i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span>(<span class="params">X, y, W</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  fully-vectorized implementation :</span></span><br><span class="line"><span class="string">  - X holds all the training examples as columns (e.g. 3073 x 50,000 in CIFAR-10)</span></span><br><span class="line"><span class="string">  - y is array of integers specifying correct class (e.g. 50,000-D array)</span></span><br><span class="line"><span class="string">  - W are weights (e.g. 10 x 3073)</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="comment"># evaluate loss over all examples in X without using any for loops</span></span><br><span class="line">  <span class="comment"># left as exercise to reader in the assignment</span></span><br></pre></td></tr></table></figure>
<p>这一部分主要介绍了：SVM损失函数采用一种特定的方法来衡量训练数据的预测与实际标签的一致性。此外，对训练集进行良好预测也等同于最大限度地减少损失值。</p>
<blockquote>
<p>我们现在要做的是找到一种可以减少损失值的权重的方法。</p>
</blockquote>
<h3 id="实际操作中的注意事项"><a href="#实际操作中的注意事项" class="headerlink" title="实际操作中的注意事项"></a>实际操作中的注意事项</h3><p><strong>设置Delta值.</strong>请注意，我们已经学习过超参数$\Delta$以及其设置。那么应该选择设么样的值才是合适的呢？我们是否必须通过交叉验证才能得到呢？事实证明，这个超参数可以在任何情况下被安全的设置为$\Delta = 1.0$。超参数$\Delta$和$\lambda$看起来似乎是两个不同的超参数，但事实上他们控制着相同的操作：都是数据损失和正则化损失直接的权衡。理解这一点的关键是，权重$W$的大小对最终评分有直接影响（这也是他们之间的差异）：当我们缩小$W$的所有数值时，评分的差异将变得更小，反之当我们放大权值$W$时，评分结果的差异也将变大。因此，评分之间的准确的间隔值（例如$\Delta = 1$或者$\Delta = 100$）在某种意义上是无意义的。因为权值可以被任意的缩小或放大。因此，唯一真正的权衡指标是我们允许权值增长的成都（通过正则化强度$\lambda$来控制）。</p>
<p><strong>与二分类支持向量机的关系.</strong>你可能在参加这个课程之前了解过二分类支持向量机，所以，其中第i个样本的损失可以写成：</p>
<script type="math/tex; mode=display">
L\_i = C \max(0, 1 - y\_i w^Tx\_i) + R(W)</script><p>这里的$C$是一个超参数，并且$y_i \in ｛ -1,1 ｝$。你可以尝试自己证明，我们本节所讨论的多类别SVM实际上是包含了二分类SVM这一特例的。也就是说，如果我们只有两个类，那么损失值就降低到上面的二分类SVM损失函数的表达形式。此外，这个表达式中的$C$与之前的$\lambda$对结果起着相同的控制作用，他们之间的关系是：$C \propto \frac{1}{\lambda}$。</p>
<p><strong>题外话：原始优化.</strong>如果你在此课程之前就已经知道了SVM，那么你可能还听说过SVM的内核，对偶，以及SMO算法等等。在这节课中（与神经网络的情况一样）我们将在无约束的原始形式的情况下优化目标。许多目标在技术上是不可区分的（例如，函数max(x,y)在x=y时无法区分哪一个是大的），但实际上这不是问题，并且常见的是使用子梯形图。</p>
<p><strong>题外话：其他SVM表达式.</strong>值得注意的是，本节介绍的多类别SVM是在几个多类别SVM中的其中一个。另外一个常用的形式是<em>一对全部One-Vs-All(OVA)</em>SVM，其中每个类别分别对应一个独立的该类别到全部其他类别的二分类SVM。与之相关的一个在实践中不常用到的是<em>全部对全部All-vs-All(AVA)</em>策略。我们的策略是遵循<a href="https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es1999-461.pdf">Weston和Watkins 1999（pdf）</a>的版本，这是一个比OVA更强大的版本（在这个版本的SVM中，您可以构建多类别的数据集，并且实现数据损失为0，但OVA无法做到这一点。如果对此感兴趣，请参阅论文中的细节）。最后一个你可能会见到的表达式是<em>结构化SVM</em>，这最大限度地提高了正确分类的得分与不正确得分中第二高的得分的间隔值的大小。对于这些SVM表达形式的差异的讨论超出了本课程的范畴。这些版本的SVM在实践过程中是可以安全的使用的，但是即使是最简单的OVA策略的形式也可以有效的分类（关于这些讨论，Rikin等人在2004年的<a href="http://www.jmlr.org/papers/volume5/rifkin04a/rifkin04a.pdf">In Defense of One-Vs-All Classification (pdf)</a>也有提到）。</p>
<h3 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="Softmax分类器"></a>Softmax分类器</h3><p>结果表明，SVM是两种常用的分类器之一。另外一个流行的选择是<strong>Softmax分类器</strong>，它拥有与SVM不同的损失函数。如果你之前有听过二分类逻辑回归分类器，那么对于Softmax分类器来说，实际上就是它在多类别上的泛化形式。不同于SVM那样通过函数$f(x_i,W)$为每个类别输出评分（未经校准的评分可能很难定义），Softmax分类器给出了一个稍微更直观的输出（归一化的分类概率），并且还有一个对于概率的解释，我们将在稍后介绍。在Softmax分类器中，映射函数$f(x_i; W) =  W x_i$保持不变，但是我们现在将这些分数解释为每个类的归一化对数概率，并用<strong>交叉熵损失</strong>代替<em>合页损失(hinge loss)</em>：</p>
<script type="math/tex; mode=display">
L\_i = -\log\left(\frac{e^{f\_{y\_i}}}{ \sum\_j e^{f\_j} }\right) \hspace{0.5in} \text{or equivalently} \hspace{0.5in} L\_i = -f\_{y\_i} + \log\sum\_j e^{f\_j}</script><p>这里我们使用了符号$f_j$来表示类别分数向量$f$的第j个元素。如上所述，数据集的完全损失是所有训练样本中的$L_i$均值与正则化项$R(W)$所组成。函数$f_j(z) = \frac{e^{z_j}}{\sum_k e^{z_k}}$称为<strong>softmax函数</strong>：它接受一个包含任意真实值的分数向量($z$)，并将其向量值压缩到总和为1的0到1之间的值。如果你是第一次看到涉及softmax功能的完整的交叉熵损失函数，可能会觉得看起来很恐怖，但对于它的功能的理解是相对简单的。</p>
<p><strong>信息论的观点.</strong>真实分布$p$与假设分布$q$之间的交叉熵定义为：</p>
<script type="math/tex; mode=display">
H(p,q) = - \sum_x p(x) \log q(x)</script><p>Softmax分类器最小化了预测分类的概率分布（正如上面所见到的$q = e^{f<em>{y_i}}  / \sum_j e^{f_j}$）与真实分类的的概率分布的交叉熵，在这里我们指的是所有在正确类别上的概率分布（例如$p = [0, \ldots 1, \ldots, 0]$只包含在$y_i$处的一个1）。此外，由于交叉熵可以写作熵和Kullback-Leibler分歧的和的形式：$H(p,q) = H(p) + D</em>{KL}(p||q)$，并且delta函数$p$的熵是0，这也相当于最小化两个分布之间的KL分歧（距离的度量）。换句话说，交叉熵的目标是希望对于正确类别的预测结果的分布与真实分布达到一致。</p>
<p><strong>概率的解释.</strong>看看下面的表达式：</p>
<script type="math/tex; mode=display">
P(y\_i \mid x\_i; W) = \frac{e^{f\_{y\_i}}}{\sum\_j e^{f\_j} }</script><p>这个式子可以解释为对于给定图片$x_i$，并由$W$参数化的分配给正确标签$y_i$的（归一化）概率。为了理解这一点，请回忆一下Softmax分类器将输出向量$f$中的评分值解释为没有归一化的对数概率。那么以这些数值做指数函数的幂就得到了没有归一化的概率，而除法操作则对数据进行了归一化处理，使得这些概率的和为1。从概率论的角度来理解，我们就是在最小化正确分类的负对数概率，这可以看做是在进行<em>最大似然估计</em>（MLE）。该解释的另一个好处是，损失函数中的正则化部分$R(W)$可以被看做是权重矩阵$W$的高斯先验，这里进行的是最大后验估计（MAP）而不是最大似然估计。提及这些解释只是为了让读者形成直观的印象，具体细节就超过本课程范围了。</p>
<p><strong>实操事项：数值稳定。</strong>编程实现softmax函数计算的时候，中间项$e^{f_{y_i}}$和$\sum_j e^{f_j}$因为存在指数函数，所以数值可能非常大。除以大数值可能导致数值计算的不稳定，所以学会使用归一化技巧非常重要。如果在分式的分子和分母都乘以一个常数C，并把它变换到求和之中，就能得到一个从数学上等价的公式：</p>
<script type="math/tex; mode=display">
\frac{e^{f\_{y\_i}}}{\sum\_j e^{f\_j}}
= \frac{Ce^{f\_{y\_i}}}{C\sum\_j e^{f\_j}}
= \frac{e^{f\_{y\_i} + \log C}}{\sum\_j e^{f\_j + \log C}}</script><p>$C$的值可自由选择，不会影响计算结果，通过使用这个技巧可以提高计算中的数值稳定性。通常将$C$设为$logC=-max_jf_j$。该技巧简单地说，就是应该将向量$f$中的数值进行平移，使得最大值为0。代码实现如下：</p>
<h3 id="SVM-vs-Softmax"><a href="#SVM-vs-Softmax" class="headerlink" title="SVM vs Softmax"></a>SVM vs Softmax</h3><h2 id="线性分类的可交互网页演示"><a href="#线性分类的可交互网页演示" class="headerlink" title="线性分类的可交互网页演示"></a>线性分类的可交互网页演示</h2><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2>]]></content>
      <categories>
        <category>机器学习</category>
        <category>cs231n</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】TextRank:对文本排序</title>
    <url>/2017/04/26/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91TextRank-%E5%AF%B9%E6%96%87%E6%9C%AC%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>本文翻译自：<a href="http://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf">http://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf</a></p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本篇论文中，我们将介绍TextRank算法，这是一种针对于文本处理的基于图的排序模型算法，并且展示这个模型是如何能够被成功的应用在自然语言应用中。特别的，我们提出了两个创新的无监督方法用于关键词和句子提取，并且展示我们得到的测试结果与先前公布的基准结果的对比。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>基于图的排序算法，像Kleinberg的HITS算法（Kleinberg，1999）或Google的PageRank算法（Brin和Page，1998）已成功应用于引文分析，社交网络和万维网链接结构分析。可以说，这些算法通过提供一种依靠Web架构师的集体知识而不是网页的单独内容分析的网页排名机制,可以作为网页搜索技术领域触发的范式转换的关键要素。简而言之，基于图的排序算法是通过考虑从整个图形递归计算的全局信息，而不是仅依赖于局部顶点特定信息来决定图中的顶点的重要性的一种方式。</p>
<p>对从自然语言文档中提取的词汇或语义图，使用类似的思路，可以得出一种基于图形的排名模型，这种模型可以应用于各种自然语言处理的应用程序中，其中从整个文本中获取的知识用于得出本地 排名/选择 的决策。 这种面向文本的排序方法，可以应用于关键短语的自动提取，摘要提取，以及词义消歧的任务（Mihalcea et等等，2004）。</p>
<p>在这篇论文中，我们会介绍基于从自然语言文本中提取的图形，来介绍TextRank图的排序模型。我们调查并评估了TextRank对于由无监督关键词和句子提取，这两种语言处理任务的应用，并展示使用TextRank获得的结果与在这些领域开发的最先进的系统进行比较。</p>
<h2 id="2-TextRank模型"><a href="#2-TextRank模型" class="headerlink" title="2 TextRank模型"></a>2 TextRank模型</h2><p>基于图的排序算法本质上是基于从整个图形递归绘制的全局信息，来决定图中顶点的重要性的一种方式。基于图表的排名模式实现的基本思想是“投票”或“推荐”。当一个顶点链接到另一个顶点时，它主要是在为另一个顶点投票。顶点投射的投票数越多，顶点的重要性就越高。此外，顶点投票的重要性决定了投票本身的重要性，而这一信息也被排名模型考虑在内。因此，与顶点相关联的分数，取决于为其投的票，以及投射这些投票的顶点的分数来确定。</p>
<p>正式的，令集合$G=(V,E)$是具有顶点$V$和边$E$集合的有向图，其中$E$是$V×V$的子集。对于给定的顶点$V_i$，令$In(V_i)$是指向它的顶点集（前辈），并且令$Out(V_i)$是顶点$V_i$指向（后继）的顶点集合。顶点$V_i$的分数定义如下（Brin和Page，1998）：</p>
<p><img src="/img/17_04_26/001.png" alt=""></p>
<p>其中$d$是0和1之间的阻尼因子，它作用于将从给定顶点跳转到图中的另一个随机顶点的概率集成到模型中。在网页浏览的上下文中，这种基于图表的排名算法实现了“随机冲浪者模型”，其中用户以概率$d$随机点击链接，并以概率$1-d$跳转到一个全新的页面。因子$d$通常设置为0.85（Brin和Page，1998），这也是我们在具体实现中所使用的值。</p>
<p>从图中分配给每个节点的任意值开始，迭代计算直到达到低于给定的阈值。运行算法之后，得到一个与每个顶点相关联的分数，这表示图中顶点的“重要性”。请注意，TextRank运行到完成后获得的最终值，不受初始值的选择的影响，初始值的选择只会影响到收敛的迭代次数。</p>
<p>重要的是要注意，尽管本文中描述的TextRank应用程序依赖于从Google的PageRank（Brin和Page，1998）导出的算法，但是其他基于图表的排序算法，例如 HITS（Kleinberg，1999）或位置函数（Herings等，2001）也可以轻松地整合到TextRank模型中（Mihalcea，2004）。</p>
<h3 id="2-1-无向图"><a href="#2-1-无向图" class="headerlink" title="2.1 无向图"></a>2.1 无向图</h3><p>虽然传统上应用于有向图，但是也可以将基于递归图的排序算法应用于无向图，在这种情况下，顶点的出度（out-degree）等于顶点的入度（in-degree）。对于松散连接的图形，随着边缘数量与顶点数量成比例，无向图趋向于具有更多的逐渐收敛曲线。</p>
<p>图1绘制了具有250个顶点和250个边缘的随机生成图的收敛曲线，收敛阈值为0.0001。随着图形的连通性增加（即较大数量的边缘），通常在较少迭代之后实现收敛，并且有向和无向图的收敛曲线实际上是重叠的。</p>
<p><img src="/img/17_04_26/002.png" alt=""></p>
<p>图1：基于图的收敛曲线排名：有向/无向，加权/未加权图，250个顶点，250个边。</p>
<h3 id="2-2-权重图"><a href="#2-2-权重图" class="headerlink" title="2.2 权重图"></a>2.2 权重图</h3><p>在网页浏览的上下文中，页面中包含多个或部分链接到另一个页面是不寻常的，因此，基于图的原始PageRank定义是假设未加权的图。</p>
<p>然而，在我们的模型中的图是由自然语言文本构造的，并且也可以由包括从文本中提取的单元（顶点）之间的多个或部分链接构造。因此，可以在模型中指示并将两个顶点$V_i$和$V_j$之间的连接的“强度”作为加到连接两个顶点的对应边缘的权重$w_{ij}$来指示并合并到该模型中。因此，我们引入了一个新的基于图的排名公式，在计算与图中顶点相关的分数时考虑了边权重。请注意，可以定义类似的公式来整合顶点权重。</p>
<p><img src="/img/17_04_26/003.png" alt=""></p>
<p>图1绘制了2.1节中相同样本图的收敛曲线，其中对边进行了0到10的随机加权。尽管与未加权相比，最终顶点得分（因此排名）显着不同，但是对于加权和未加权图，收敛次数和收敛曲线的形状几乎相同。</p>
<h3 id="2-3-文本作为图"><a href="#2-3-文本作为图" class="headerlink" title="2.3 文本作为图"></a>2.3 文本作为图</h3><p>为了使基于图的排序算法能够应用于自然语言文本，我们必须构建一个表示文本的图形，并将具有有意义关系的单词或其他文本实体进行互连。 根据手头的应用，各种尺寸和特征的文本单位可以作为图中的顶点添加，例如。 单词，搭配，整个句子或其他。 类似地，它是指示用于绘制任何两个这样的顶点之间的连接的关系的类型，例如。 词汇或语义关系，语境重叠等。</p>
<p>无论添加到图形中的元素的类型和特征如何，将基于图的排序算法应用于自然语言文本包括以下主要步骤：</p>
<ul>
<li>1.识别最佳定义手头任务的文本单位，并将其作为顶点添加到图形中。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>论文翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】kaggle竞赛 房价预测</title>
    <url>/2018/03/09/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91kaggle%E7%AB%9E%E8%B5%9B%20%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p><a href="https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python">原文链接</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果你有一些R或者Python的经验，并且掌握一些基本的机器学习知识。对于完成机器学习在线课程的数据科学学生来说，这是一个很适合练手的比赛。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>如果让一个想要买房的人来描述他们梦想中的住宅，他们可能不会从地下室天花板的高度或与东西方地铁的距离开始描述。但是这个游乐场比赛的数据集证明，购房者考虑的主要因素中，对价格谈判的影响远远超过卧室或白色栅栏的数量的影响。</p>
<p>有79个解释变量描述（几乎）爱荷华州埃姆斯的住宅房屋的每个方面，这个竞赛的目标是需要你来预测每个房屋的最终价格。</p>
<h3 id="实践技能"><a href="#实践技能" class="headerlink" title="实践技能"></a>实践技能</h3><ul>
<li>创意特征工程</li>
<li>先进的回归算法技术，如随机森林和梯度提升</li>
</ul>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p><a href="http://www.amstat.org/publications/jse/v19n3/decock.pdf">Ames Housing数据集</a>由Dean De Cock编制，用于数据科学教育。对于那些寻找比Boston Housing数据集更现代化的扩展版本数据集的数据科学家来说，这的确是一个很赞的选择。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h3><ul>
<li>train.csv - 训练集</li>
<li>test.csv - 测试集</li>
<li>data_description.txt - 记录了每个特征的完整描述信息，最初由Dean De Cock编写，后来做了略微的改动</li>
<li>sample_submission.csv - 来自销售年份和月份的线性回归的基准提交，批量平方英尺和卧室数量（a benchmark submission from a linear regression on year and month of sale, lot square footage, and number of bedrooms）</li>
</ul>
<h3 id="字段信息"><a href="#字段信息" class="headerlink" title="字段信息"></a>字段信息</h3><p>以下是您可以在数据描述文件中找到的简要版本。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:left">英文解释</th>
<th style="text-align:left">中文解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SalePrice</td>
<td style="text-align:left">the property’s sale price in dollars. This is the target variable that you’re trying to predict.</td>
<td style="text-align:left">房屋的销售价格以美元计价。这是你试图预测的目标变量。</td>
</tr>
<tr>
<td style="text-align:center">MSSubClass</td>
<td style="text-align:left">The building class</td>
<td style="text-align:left">建筑类</td>
</tr>
<tr>
<td style="text-align:center">MSZoning</td>
<td style="text-align:left">The general zoning classification</td>
<td style="text-align:left">一般分区分类</td>
</tr>
<tr>
<td style="text-align:center">LotFrontage</td>
<td style="text-align:left">Linear feet of street connected to property</td>
<td style="text-align:left">连接到财产的街道的线性脚</td>
</tr>
<tr>
<td style="text-align:center">LotArea</td>
<td style="text-align:left">Lot size in square feet</td>
<td style="text-align:left">地块面积（平方英尺）</td>
</tr>
<tr>
<td style="text-align:center">Street</td>
<td style="text-align:left">Type of road access</td>
<td style="text-align:left">道路通行类型</td>
</tr>
<tr>
<td style="text-align:center">Alley</td>
<td style="text-align:left">Type of alley access</td>
<td style="text-align:left">胡同通道的类型</td>
</tr>
<tr>
<td style="text-align:center">LotShape</td>
<td style="text-align:left">General shape of property</td>
<td style="text-align:left">财产的一般形状</td>
</tr>
<tr>
<td style="text-align:center">LandContour</td>
<td style="text-align:left">Flatness of the property</td>
<td style="text-align:left">物业的平整度</td>
</tr>
<tr>
<td style="text-align:center">Utilities</td>
<td style="text-align:left">Type of utilities available</td>
<td style="text-align:left">可用的实用程序类型</td>
</tr>
<tr>
<td style="text-align:center">LotConfig</td>
<td style="text-align:left">Lot configuration</td>
<td style="text-align:left">批量配置</td>
</tr>
<tr>
<td style="text-align:center">LandSlope</td>
<td style="text-align:left">Slope of property</td>
<td style="text-align:left">财产的倾斜</td>
</tr>
<tr>
<td style="text-align:center">Neighborhood</td>
<td style="text-align:left">Physical locations within Ames city limits</td>
<td style="text-align:left">Ames城市限制内的物理位置</td>
</tr>
<tr>
<td style="text-align:center">Condition1</td>
<td style="text-align:left">Proximity to main road or railroad</td>
<td style="text-align:left">靠近主干道或铁路</td>
</tr>
<tr>
<td style="text-align:center">Condition2</td>
<td style="text-align:left">Proximity to main road or railroad (if a second is present)</td>
<td style="text-align:left">靠近主要道路或铁路（如果存在第二个）</td>
</tr>
<tr>
<td style="text-align:center">BldgType</td>
<td style="text-align:left">Type of dwelling</td>
<td style="text-align:left">住宅类型</td>
</tr>
<tr>
<td style="text-align:center">HouseStyle</td>
<td style="text-align:left">Style of dwelling</td>
<td style="text-align:left">住宅风格</td>
</tr>
<tr>
<td style="text-align:center">OverallQual</td>
<td style="text-align:left">Overall material and finish quality</td>
<td style="text-align:left">总体材料和加工质量</td>
</tr>
<tr>
<td style="text-align:center">OverallCond</td>
<td style="text-align:left">Overall condition rating</td>
<td style="text-align:left">总体状况的评价</td>
</tr>
<tr>
<td style="text-align:center">YearBuilt</td>
<td style="text-align:left">Original construction date</td>
<td style="text-align:left">原始施工日期</td>
</tr>
<tr>
<td style="text-align:center">YearRemodAdd</td>
<td style="text-align:left">Remodel date</td>
<td style="text-align:left">重构日期</td>
</tr>
<tr>
<td style="text-align:center">RoofStyle</td>
<td style="text-align:left">Type of roof</td>
<td style="text-align:left">屋顶类型</td>
</tr>
<tr>
<td style="text-align:center">RoofMatl</td>
<td style="text-align:left">Roof material</td>
<td style="text-align:left">屋顶材料</td>
</tr>
<tr>
<td style="text-align:center">Exterior1st</td>
<td style="text-align:left">Exterior covering on house</td>
<td style="text-align:left">房屋外墙</td>
</tr>
<tr>
<td style="text-align:center">Exterior2nd</td>
<td style="text-align:left">Exterior covering on house (if more than one material)</td>
<td style="text-align:left">房屋外墙（如果多于一种）</td>
</tr>
<tr>
<td style="text-align:center">MasVnrType</td>
<td style="text-align:left">Masonry veneer type</td>
<td style="text-align:left">Masonry贴面类型</td>
</tr>
<tr>
<td style="text-align:center">MasVnrArea</td>
<td style="text-align:left">Masonry veneer area in square feet</td>
<td style="text-align:left">砖石面积平方英尺</td>
</tr>
<tr>
<td style="text-align:center">ExterQual</td>
<td style="text-align:left">Exterior material quality</td>
<td style="text-align:left">外部材料质量</td>
</tr>
<tr>
<td style="text-align:center">ExterCond</td>
<td style="text-align:left">Present condition of the material on the exterior</td>
<td style="text-align:left">外部材料的现状</td>
</tr>
<tr>
<td style="text-align:center">Foundation</td>
<td style="text-align:left">Type of foundation</td>
<td style="text-align:left">基础类型</td>
</tr>
<tr>
<td style="text-align:center">BsmtQual</td>
<td style="text-align:left">Height of the basement</td>
<td style="text-align:left">地下室的高度</td>
</tr>
<tr>
<td style="text-align:center">BsmtCond</td>
<td style="text-align:left">General condition of the basement</td>
<td style="text-align:left">地下室的一般状况</td>
</tr>
<tr>
<td style="text-align:center">BsmtExposure</td>
<td style="text-align:left">Walkout or garden level basement walls</td>
<td style="text-align:left">罢工或花园级地下室的墙壁</td>
</tr>
<tr>
<td style="text-align:center">BsmtFinType1</td>
<td style="text-align:left">Quality of basement finished area</td>
<td style="text-align:left">地下室成品面积质量</td>
</tr>
<tr>
<td style="text-align:center">BsmtFinSF1</td>
<td style="text-align:left">Type 1 finished square feet</td>
<td style="text-align:left">1型方形脚</td>
</tr>
<tr>
<td style="text-align:center">BsmtFinType2</td>
<td style="text-align:left">Quality of second finished area (if present)</td>
<td style="text-align:left">第二个完成区域的质量（如果存在）</td>
</tr>
<tr>
<td style="text-align:center">BsmtFinSF2</td>
<td style="text-align:left">Type 2 finished square feet</td>
<td style="text-align:left">2型完成的平方英尺</td>
</tr>
<tr>
<td style="text-align:center">BsmtUnfSF</td>
<td style="text-align:left">Unfinished square feet of basement area</td>
<td style="text-align:left">未完成的地下室面积</td>
</tr>
<tr>
<td style="text-align:center">TotalBsmtSF</td>
<td style="text-align:left">Total square feet of basement area</td>
<td style="text-align:left">地下室面积的平方英尺</td>
</tr>
<tr>
<td style="text-align:center">Heating</td>
<td style="text-align:left">Type of heating</td>
<td style="text-align:left">加热类型</td>
</tr>
<tr>
<td style="text-align:center">HeatingQC</td>
<td style="text-align:left">Heating quality and condition</td>
<td style="text-align:left">供热质量和条件</td>
</tr>
<tr>
<td style="text-align:center">CentralAir</td>
<td style="text-align:left">Central air conditioning</td>
<td style="text-align:left">中央空调</td>
</tr>
<tr>
<td style="text-align:center">Electrical</td>
<td style="text-align:left">Electrical system</td>
<td style="text-align:left">电气系统</td>
</tr>
<tr>
<td style="text-align:center">1stFlrSF</td>
<td style="text-align:left">First Floor square feet</td>
<td style="text-align:left">一楼平方英尺</td>
</tr>
<tr>
<td style="text-align:center">2ndFlrSF</td>
<td style="text-align:left">Second floor square feet</td>
<td style="text-align:left">二楼平方英尺</td>
</tr>
<tr>
<td style="text-align:center">LowQualFinSF</td>
<td style="text-align:left">Low quality finished square feet (all floors)</td>
<td style="text-align:left">低质量成品平方英尺（所有楼层）</td>
</tr>
<tr>
<td style="text-align:center">GrLivArea</td>
<td style="text-align:left">Above grade (ground) living area square feet</td>
<td style="text-align:left">以上（地面）生活区平方英尺</td>
</tr>
<tr>
<td style="text-align:center">BsmtFullBath</td>
<td style="text-align:left">Basement full bathrooms</td>
<td style="text-align:left">地下室完整的浴室</td>
</tr>
<tr>
<td style="text-align:center">BsmtHalfBath</td>
<td style="text-align:left">Basement half bathrooms</td>
<td style="text-align:left">地下室半浴室</td>
</tr>
<tr>
<td style="text-align:center">FullBath</td>
<td style="text-align:left">Full bathrooms above grade</td>
<td style="text-align:left">全年以上的浴室</td>
</tr>
<tr>
<td style="text-align:center">HalfBath</td>
<td style="text-align:left">Half baths above grade</td>
<td style="text-align:left">半浴半高</td>
</tr>
<tr>
<td style="text-align:center">Bedroom</td>
<td style="text-align:left">Number of bedrooms above basement level</td>
<td style="text-align:left">地下室数量</td>
</tr>
<tr>
<td style="text-align:center">Kitchen</td>
<td style="text-align:left">Number of kitchens</td>
<td style="text-align:left">厨房数量</td>
</tr>
<tr>
<td style="text-align:center">KitchenQual</td>
<td style="text-align:left">Kitchen quality</td>
<td style="text-align:left">厨房质量</td>
</tr>
<tr>
<td style="text-align:center">TotRmsAbvGrd</td>
<td style="text-align:left">Total rooms above grade (does not include bathrooms)</td>
<td style="text-align:left">房间总数（不含浴室）</td>
</tr>
<tr>
<td style="text-align:center">Functional</td>
<td style="text-align:left">Home functionality rating</td>
<td style="text-align:left">家庭功能评级</td>
</tr>
<tr>
<td style="text-align:center">Fireplaces</td>
<td style="text-align:left">Number of fireplaces</td>
<td style="text-align:left">壁炉数量</td>
</tr>
<tr>
<td style="text-align:center">FireplaceQu</td>
<td style="text-align:left">Fireplace quality</td>
<td style="text-align:left">壁炉质量</td>
</tr>
<tr>
<td style="text-align:center">GarageType</td>
<td style="text-align:left">Garage location</td>
<td style="text-align:left">车库位置</td>
</tr>
<tr>
<td style="text-align:center">GarageYrBlt</td>
<td style="text-align:left">Year garage was built</td>
<td style="text-align:left">年建车库</td>
</tr>
<tr>
<td style="text-align:center">GarageFinish</td>
<td style="text-align:left">Interior finish of the garage</td>
<td style="text-align:left">车库内部装修</td>
</tr>
<tr>
<td style="text-align:center">GarageCars</td>
<td style="text-align:left">Size of garage in car capacity</td>
<td style="text-align:left">车库的车库容量</td>
</tr>
<tr>
<td style="text-align:center">GarageArea</td>
<td style="text-align:left">Size of garage in square feet</td>
<td style="text-align:left">平方英尺车库大小</td>
</tr>
<tr>
<td style="text-align:center">GarageQual</td>
<td style="text-align:left">Garage quality</td>
<td style="text-align:left">车库质量</td>
</tr>
<tr>
<td style="text-align:center">GarageCond</td>
<td style="text-align:left">Garage condition</td>
<td style="text-align:left">车库条件</td>
</tr>
<tr>
<td style="text-align:center">PavedDrive</td>
<td style="text-align:left">Paved driveway</td>
<td style="text-align:left">铺设的车道</td>
</tr>
<tr>
<td style="text-align:center">WoodDeckSF</td>
<td style="text-align:left">Wood deck area in square feet</td>
<td style="text-align:left">木甲板面积平方英尺</td>
</tr>
<tr>
<td style="text-align:center">OpenPorchSF</td>
<td style="text-align:left">Open porch area in square feet</td>
<td style="text-align:left">平方英尺开放门廊</td>
</tr>
<tr>
<td style="text-align:center">EnclosedPorch</td>
<td style="text-align:left">Enclosed porch area in square feet</td>
<td style="text-align:left">封闭的门廊面积平方英尺</td>
</tr>
<tr>
<td style="text-align:center">3SsnPorch</td>
<td style="text-align:left">Three season porch area in square feet</td>
<td style="text-align:left">三季门廊面积平方英尺</td>
</tr>
<tr>
<td style="text-align:center">ScreenPorch</td>
<td style="text-align:left">Screen porch area in square feet</td>
<td style="text-align:left">屏幕门廊面积平方英尺</td>
</tr>
<tr>
<td style="text-align:center">PoolArea</td>
<td style="text-align:left">Pool area in square feet</td>
<td style="text-align:left">游泳池面积平方英尺</td>
</tr>
<tr>
<td style="text-align:center">PoolQC</td>
<td style="text-align:left">Pool quality</td>
<td style="text-align:left">游泳池质量</td>
</tr>
<tr>
<td style="text-align:center">Fence</td>
<td style="text-align:left">Fence quality</td>
<td style="text-align:left">栅栏质量</td>
</tr>
<tr>
<td style="text-align:center">MiscFeature</td>
<td style="text-align:left">Miscellaneous feature not covered in other categories</td>
<td style="text-align:left">其他类别未涉及的其他功能</td>
</tr>
<tr>
<td style="text-align:center">MiscVal</td>
<td style="text-align:left">$Value of miscellaneous feature</td>
<td style="text-align:left">$杂项功能的值</td>
</tr>
<tr>
<td style="text-align:center">MoSold</td>
<td style="text-align:left">Month Sold</td>
<td style="text-align:left">月销售</td>
</tr>
<tr>
<td style="text-align:center">YrSold</td>
<td style="text-align:left">Year Sold</td>
<td style="text-align:left">年销售</td>
</tr>
<tr>
<td style="text-align:center">SaleType</td>
<td style="text-align:left">Type of sale</td>
<td style="text-align:left">销售类型</td>
</tr>
<tr>
<td style="text-align:center">SaleCondition</td>
<td style="text-align:left">Condition of sale</td>
<td style="text-align:left">销售条件</td>
</tr>
</tbody>
</table>
</div>
<h2 id="用Python进行全面的数据探索"><a href="#用Python进行全面的数据探索" class="headerlink" title="用Python进行全面的数据探索"></a>用Python进行全面的数据探索</h2><blockquote>
<p>Pedro Marcelino 创建</p>
</blockquote>
<p><a href="https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python">link</a></p>
<p><strong>‘The most difficult thing in life is to know yourself’</strong></p>
<p>这句话引用自古希腊米利都的Thales。Thales是希腊/印第安哲学家，数学家和天文学家，被公认为西方文明中第一位享有娱乐和参与科学思想的人（来源：<a href="https://en.wikipedia.org/wiki/Thales">https://en.wikipedia.org/wiki/Thales</a>）。</p>
<p>我不会说了解数据是数据科学中最困难的事情，但这的确是一件非常耗时的事情。很多人可能会忽略这一步骤，就直接下水了。</p>
<p>所以我试着在下水之前先学会游泳。基于Hair等人（2013）整理的’Examining your data’一章中，我尽我所能对数据进行全面而非详尽的分析。我没有在这个内核中上报严谨的研究过程，但我希望它对社区有所帮助，所以我分享了我如何将这些数据分析原理应用于这个问题的思路。</p>
<p>尽管我给这些章写了一些奇怪的名字，但我们在这个内核中所做的是：</p>
<ul>
<li>1.<strong>理解问题</strong>：我们将研究每个变量，并对这个问题的意义和重要性进行哲学分析。</li>
<li>2.<strong>单变量研究</strong>：我们只关注因变量（’SalePrice’）并尝试更多地了解它。</li>
<li>3.<strong>多变量研究</strong>：我们将尝试了解因变量和自变量之间的关系。</li>
<li>4.<strong>基本的清理工作</strong>：我们将清理数据集并处理缺失的数据，异常值和分类变量。</li>
<li>5.<strong>测试假设</strong>：我们将检查我们的数据是否符合大多数多元技术所需的假设。</li>
</ul>
<p>现在，让我们好好玩吧！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邀请人们来参加Kaggle聚会</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">df_train = pd.read_csv(<span class="string">&#x27;../input/train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查描述信息</span></span><br><span class="line">df_train.columns</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Index([&#39;Id&#39;, &#39;MSSubClass&#39;, &#39;MSZoning&#39;, &#39;LotFrontage&#39;, &#39;LotArea&#39;, &#39;Street&#39;,</span><br><span class="line">       &#39;Alley&#39;, &#39;LotShape&#39;, &#39;LandContour&#39;, &#39;Utilities&#39;, &#39;LotConfig&#39;,</span><br><span class="line">       &#39;LandSlope&#39;, &#39;Neighborhood&#39;, &#39;Condition1&#39;, &#39;Condition2&#39;, &#39;BldgType&#39;,</span><br><span class="line">       &#39;HouseStyle&#39;, &#39;OverallQual&#39;, &#39;OverallCond&#39;, &#39;YearBuilt&#39;, &#39;YearRemodAdd&#39;,</span><br><span class="line">       &#39;RoofStyle&#39;, &#39;RoofMatl&#39;, &#39;Exterior1st&#39;, &#39;Exterior2nd&#39;, &#39;MasVnrType&#39;,</span><br><span class="line">       &#39;MasVnrArea&#39;, &#39;ExterQual&#39;, &#39;ExterCond&#39;, &#39;Foundation&#39;, &#39;BsmtQual&#39;,</span><br><span class="line">       &#39;BsmtCond&#39;, &#39;BsmtExposure&#39;, &#39;BsmtFinType1&#39;, &#39;BsmtFinSF1&#39;,</span><br><span class="line">       &#39;BsmtFinType2&#39;, &#39;BsmtFinSF2&#39;, &#39;BsmtUnfSF&#39;, &#39;TotalBsmtSF&#39;, &#39;Heating&#39;,</span><br><span class="line">       &#39;HeatingQC&#39;, &#39;CentralAir&#39;, &#39;Electrical&#39;, &#39;1stFlrSF&#39;, &#39;2ndFlrSF&#39;,</span><br><span class="line">       &#39;LowQualFinSF&#39;, &#39;GrLivArea&#39;, &#39;BsmtFullBath&#39;, &#39;BsmtHalfBath&#39;, &#39;FullBath&#39;,</span><br><span class="line">       &#39;HalfBath&#39;, &#39;BedroomAbvGr&#39;, &#39;KitchenAbvGr&#39;, &#39;KitchenQual&#39;,</span><br><span class="line">       &#39;TotRmsAbvGrd&#39;, &#39;Functional&#39;, &#39;Fireplaces&#39;, &#39;FireplaceQu&#39;, &#39;GarageType&#39;,</span><br><span class="line">       &#39;GarageYrBlt&#39;, &#39;GarageFinish&#39;, &#39;GarageCars&#39;, &#39;GarageArea&#39;, &#39;GarageQual&#39;,</span><br><span class="line">       &#39;GarageCond&#39;, &#39;PavedDrive&#39;, &#39;WoodDeckSF&#39;, &#39;OpenPorchSF&#39;,</span><br><span class="line">       &#39;EnclosedPorch&#39;, &#39;3SsnPorch&#39;, &#39;ScreenPorch&#39;, &#39;PoolArea&#39;, &#39;PoolQC&#39;,</span><br><span class="line">       &#39;Fence&#39;, &#39;MiscFeature&#39;, &#39;MiscVal&#39;, &#39;MoSold&#39;, &#39;YrSold&#39;, &#39;SaleType&#39;,</span><br><span class="line">       &#39;SaleCondition&#39;, &#39;SalePrice&#39;],</span><br><span class="line">      dtype&#x3D;&#39;object&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="1-那么，我们能得到什么呢？"><a href="#1-那么，我们能得到什么呢？" class="headerlink" title="1.那么，我们能得到什么呢？"></a>1.那么，我们能得到什么呢？</h3><p>为了理解我们的数据，我们可以看看每个变量，并试图理解它们的含义以及与这个问题的相关性。我知道这个工作很耗时，但它会给我们数据集增添一些味道。</p>
<p>为了在我们的分析中掌握一些规则，我们可以创建一个Excel电子表格，其中包含以下列：</p>
<ul>
<li><strong>变量名</strong> - 变量名称。</li>
<li><strong>类型</strong> - 识别变量的类型。该字段有两种可能的值：’数值型’或’类别型’。“数值型”是指值为数字的变量，而“类别型”是指值为类别的变量。</li>
<li><strong>细分</strong> - 识别变量的细分。我们可以定义三个可能的部分：building，space或location。当我们说“building”时，我们是指与建筑物的物理特性相关的变量（例如’OverallQual’&lt;总体材料和加工质量&gt;）。当我们说“space”时，我们是指报告房屋空间属性的变量（例如’TotalBsmtSF’&lt;地下室面积的平方英尺&gt;）。最后，当我们说’location’时，我们说的是指能提供有关房屋所在地的信息（例如’Neighborhood’<Ames城市限制内的物理位置>）的变量。</li>
<li><strong>期望</strong> - 我们对’SalePrice’中的可变影响力的期望。我们可以使用“高”，“中”和“低”作为可能值的分类比例。</li>
<li><strong>结论</strong> - 在我们快速查看数据后，可以得出关于变量重要性的结论。我们可以保持与“期望”相同的分类尺度。</li>
<li><strong>评论</strong> - 我们手动赋予的通用评论信息。</li>
</ul>
<p>虽然“类型”和“细分”仅供以后使用参考，但“期望”一栏非常重要，因为它有助于我们发展我们的“第六感”。为了填补这个专栏，我们应该阅读所有变量的描述，并逐个问自己：</p>
<ul>
<li>当我们买房子时，我们是否考虑这个变量？（例如，当我们想到梦想中的房子时，我们是否在意它的’砌体贴面类型’？）</li>
<li>如果是这样，这个变量有多重要？（例如，外部材料这个属性的影响到底是“非常大”还是“非常小”，或者是“一般”呢）？</li>
<li>这些信息是否已在任何其他变量中描述过？（例如，如果’LandContour’&lt;物业的平整度&gt;给出了房产的平坦性，我们是否真的需要知道’LandSlope’&lt;物业的倾斜度&gt;？）。</li>
</ul>
<p>经过这个艰巨的练习之后，我们可以过滤电子表格并仔细查看具有“高”’期望’的变量。然后，我们可以绘制出这些变量和’SalePrice’之间的一些散点图，填入’结论’栏，这只是我们预期的修正。</p>
<p>我经历了这个过程并得出结论，下面的变量可以在这个问题中发挥重要作用：</p>
<ul>
<li>OverallQual&lt;总体材料和加工质量&gt;（这是一个我不喜欢的变量，因为我不知道它是如何计算的;你可以把使用所有其他可用变量来预测’OverallQual’来作为一个有趣的练习）。</li>
<li>YearBuilt&lt;原始施工日期&gt;</li>
<li>TotalBsmtSF&lt;地下室面积的平方英尺&gt;</li>
<li>GrLivArea&lt;以上（地面）生活区平方英尺&gt;</li>
</ul>
<p>我选择了两个’building’变量（’OverallQual’和’YearBuilt’）和两个’space’变量（’TotalBsmtSF’和’GrLivArea’）。这可能有点意外，因为它违背了房地产的核心，即在房地产中重要的影响因素是“位置”、“位置”和“位置”。对于类别变量，这种快速数据检查过程可能有点苛刻。例如，我预计’Neigborhood’变量更具相关性，但在数据检查之后，我最终排除了它。也许这与使用散点图而不是箱图有关，它更适合分类变量可视化。我们对数据进行可视化的方式通常会影响到我们的结论。</p>
<p>但是，这个练习的要点是想一想我们的数据和期望值，所以我认为我们达到了目标。现在是’少一点谈话，多一点行动’的时候了。让我们开始吧！</p>
<h3 id="2-首先要做的是分析’SalePrice’"><a href="#2-首先要做的是分析’SalePrice’" class="headerlink" title="2.首先要做的是分析’SalePrice’"></a>2.首先要做的是分析’SalePrice’</h3><p>‘SalePrice’是我们所追求的理由。就像我们要参加派对时一样。我们总是有一个理由去那里。比如，和女性交往也许就是我们去参加派对的原因。 （免责声明：根据您的喜好将其适应男性，跳舞或酒精）。</p>
<p>让我们来构建一个使用女性来比喻‘SalePrice’的小故事 — ‘我们如何认识’SalePrice’’的故事。</p>
<p><em>这一切都始于我们的Kaggle派对。当我们在舞池里寻找一段时间舞伴之后，我们看到一个女孩在酒吧附近使用舞蹈鞋。这说明了她在那里跳舞。我们花了很多时间进行预测建模并参与分析竞赛，因此与女孩谈话并不是我们的主要能力之一。即便如此，我们试了一下：</em></p>
<p><em>嗨，我是Kaggly！你呢？ ‘SalePrice’？多么美丽的名字！你知道’SalePrice’，你能给我提供一些关于你的数据吗？我刚刚开发了一个模型来计算两个人之间关系成功的可能性。我想在我们身上试一试！’</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述性统计数据汇总</span></span><br><span class="line">df_train[<span class="string">&#x27;SalePrice&#x27;</span>].describe()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count      1460.000000</span><br><span class="line">mean     180921.195890</span><br><span class="line">std       79442.502883</span><br><span class="line">min       34900.000000</span><br><span class="line">25%      129975.000000</span><br><span class="line">50%      163000.000000</span><br><span class="line">75%      214000.000000</span><br><span class="line">max      755000.000000</span><br><span class="line">Name: SalePrice, dtype: float64</span><br></pre></td></tr></table></figure>
<p><em>很好……看起来你的最低价格大于零。很棒！你没有那些会毁掉我的模特的个人特质！你可以寄给我一些你的照片吗？……就像你在沙滩上……或者在健身房里自拍的那种一样？“</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直方图</span><br><span class="line">sns.distplot(df_train[&#39;SalePrice&#39;]);</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/001.png" alt=""></p>
<p><em>啊!我看到你在出门的时候使用了seaborn化妆……太优雅了！我也看到你：</em></p>
<ul>
<li><strong><em>偏离正态分布。</em></strong></li>
<li><strong><em>有明显的正偏态。</em></strong></li>
<li><strong><em>显示尖锐度。</em></strong></li>
</ul>
<p><em>这很有趣！’SalePrice’，你能给我你的身体指标吗？’</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 偏度和峰度</span><br><span class="line">print(&quot;Skewness: %f&quot; % df_train[&#39;SalePrice&#39;].skew())</span><br><span class="line">print(&quot;Kurtosis: %f&quot; % df_train[&#39;SalePrice&#39;].kurt())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Skewness: 1.882876</span><br><span class="line">Kurtosis: 6.536282</span><br></pre></td></tr></table></figure>
<p><em>‘Amazing！如果我的爱情计算器是正确的，我们的成功概率是97.834657％。我想我们应该再见面！如果下星期五有空，请留下我的电话号码并给我打电话。再见！</em></p>
<h4 id="‘SalePrice’，她的好友和她的兴趣"><a href="#‘SalePrice’，她的好友和她的兴趣" class="headerlink" title="‘SalePrice’，她的好友和她的兴趣"></a>‘SalePrice’，她的好友和她的兴趣</h4><p><em>选择你将要战斗的地形是重要的军事智慧。离开了“SalePrice”，我们就去了她的Facebook。请注意，这不是在跟踪她。我们只是对她做深入的研究。</em></p>
<p><em>据她介绍，我们有一些共同的朋友。除了Chuck Norris之外，我们都知道’GrLivArea’和’TotalBsmtSF’。此外，我们也有共同的兴趣，如’OverallQual’和’YearBuilt’。这看起来我们有希望！</em></p>
<p><em>为了充分利用我们的研究成果，我们将首先仔细研究我们的共同朋友的概况，然后我们将重点关注我们的共同利益。</em></p>
<p><strong>与数值变量的关系</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制 GrLivArea/SalePrice 的散点图</span></span><br><span class="line">var = <span class="string">&#x27;GrLivArea&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">&#x27;SalePrice&#x27;</span>, ylim=(<span class="number">0</span>,<span class="number">800000</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/002.png" alt=""></p>
<p><em>嗯……看起来’SalePrice’和’GrLivArea’是真正的老朋友，具有线性关系。</em></p>
<p><em>那么’TotalBsmtSF’呢？</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 绘制 TotalBsmtSF&#x2F;SalePrice 的散点图</span><br><span class="line">var &#x3D; &#39;TotalBsmtSF&#39;</span><br><span class="line">data &#x3D; pd.concat([df_train[&#39;SalePrice&#39;], df_train[var]], axis&#x3D;1)</span><br><span class="line">data.plot.scatter(x&#x3D;var, y&#x3D;&#39;SalePrice&#39;, ylim&#x3D;(0,800000));</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/003.png" alt=""></p>
<p><em>‘TotalBsmtSF’也是’SalePrice’的好朋友，但这似乎是一种更加情感化的关系！在一开始的时候，一切似乎都很顺利，突然间，他们的关系呈现出强烈的线性（指数？）反应，一切都在变化。此外，很明显，有时’TotalBsmtSF’本身就会关闭，并且对’SalePrice’给予零分。</em></p>
<p><strong>与类别特征的关系</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 绘制 OverallQual&#x2F;SalePrice 的箱图</span><br><span class="line">var &#x3D; &#39;OverallQual&#39;</span><br><span class="line">data &#x3D; pd.concat([df_train[&#39;SalePrice&#39;], df_train[var]], axis&#x3D;1)</span><br><span class="line">f, ax &#x3D; plt.subplots(figsize&#x3D;(8, 6))</span><br><span class="line">fig &#x3D; sns.boxplot(x&#x3D;var, y&#x3D;&quot;SalePrice&quot;, data&#x3D;data)</span><br><span class="line">fig.axis(ymin&#x3D;0, ymax&#x3D;800000);</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/004.png" alt=""></p>
<p><em>像所有漂亮女孩一样，’SalePrice’很享受’OverallQual’。提醒自己：考虑麦当劳是否适合作为第一次约会的场所。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var &#x3D; &#39;YearBuilt&#39;</span><br><span class="line">data &#x3D; pd.concat([df_train[&#39;SalePrice&#39;], df_train[var]], axis&#x3D;1)</span><br><span class="line">f, ax &#x3D; plt.subplots(figsize&#x3D;(16, 8))</span><br><span class="line">fig &#x3D; sns.boxplot(x&#x3D;var, y&#x3D;&quot;SalePrice&quot;, data&#x3D;data)</span><br><span class="line">fig.axis(ymin&#x3D;0, ymax&#x3D;800000);</span><br><span class="line">plt.xticks(rotation&#x3D;90);</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/005.png" alt=""></p>
<p><em>虽然这不是一个强烈的趋势，但我认为相比旧的东西，’SalePrice’更喜欢在新的东西上花钱</em></p>
<p><strong>注意：</strong>我们不知道’SalePrice’是否处于不变价格。不变的价格试图消除通货膨胀的影响。如果’SalePrice’价格不是固定的，那么它应该是这样的，因为多年来价格是可比的。</p>
<p><strong>综上所述</strong>，我们可以得出以下结论：</p>
<ul>
<li>‘GrLivArea’和’TotalBsmtSF’似乎与’SalePrice’线性相关。这两种关系都是积极的，这意味着随着一个变量增加，另一个变量也增加。在’TotalBsmtSF’的情况下，我们可以看到线性关系的斜率特别高。</li>
<li>‘OverallQual’和’YearBuilt’似乎也与’SalePrice’有关。在’OverallQual’的情况下，这种关系似乎更强一些，箱子图显示了销售价格随整体质量的变化情况。</li>
</ul>
<p>我们只分析了四个变量，但还有很多其他的我们应该分析。这里的诀窍似乎是选择正确的特征（特征选择），而不是它们之间复杂关系的定义（特征工程）。</p>
<h3 id="3-保持客观，理性工作"><a href="#3-保持客观，理性工作" class="headerlink" title="3.保持客观，理性工作"></a>3.保持客观，理性工作</h3><p>到现在为止，我们只是遵循我们的直觉，分析了我们认为重要的变量。尽管我们努力为我们的分析提供客观性，但我们必须说，我们的出发点是主观的。</p>
<p>作为一名工程师，我对这种方法感到不舒服。我所有的教育都是为了培养一个训练有素的头脑，能够抵挡主观性的思维。因为如果在结构工程中扮演主观性的角色，你会发现主观的想法是站不住脚的。</p>
<p>所以，让我们克服惯性，做一个更客观的分析。</p>
<p><strong>‘等离子汤’</strong></p>
<p>“一开始除了等离子汤以外没有其他任何东西。在我们研究宇宙学的时候，我们知道这些短暂的时刻，在很大程度上是推测得出的。然而，科学已经根据今天宇宙已知的情况设计了可能发生的事情的一些草图。’（来源：<a href="http://umich.edu/~gs265/bigbang.htm">http://umich.edu/~gs265/bigbang.htm</a>）</p>
<p>为了探索宇宙，我们将从一些实用的食谱开始，以理解我们的“等离子汤”：</p>
<ul>
<li>相关矩阵（热图样式）。</li>
<li>‘SalePrice’相关矩阵（放大热图样式）。</li>
<li>最相关的变量之间的散点图（move like Jagger样式）</li>
</ul>
<p><strong>相关矩阵（热图样式）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#相关矩阵</span><br><span class="line">corrmat &#x3D; df_train.corr()</span><br><span class="line">f, ax &#x3D; plt.subplots(figsize&#x3D;(12, 9))</span><br><span class="line">sns.heatmap(corrmat, vmax&#x3D;.8, square&#x3D;True);</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/006.png" alt=""></p>
<p>在我看来，这张热图是快速了解我们的“等离子汤”及其关系的最佳方式。 （谢谢你@seaborn！）</p>
<p>乍一看，有两个红色的正方形引起了我的注意。第一个引用’TotalBsmtSF’和’1stFlrSF’变量，第二个引用’GarageX’变量。两种情况都表明这些变量之间的相关性有多大。实际上，这种相关性非常强，可以表明多重共线性的情况。如果我们考察了这些变量，我们可以得出相同的结论。热图非常适合检测这种情况，并且在像我们这样的特征选择占主导地位的问题中，它们是必不可少的工具。</p>
<p>另一件引起我注意的事情是’SalePrice’相关性。我们可以看到我们众所周知的’GrLivArea’，’TotalBsmtSF’和’OverallQual’这样明显的变量在向我们说“Hi！”，但我们也可以看到许多其他应该考虑的变量。这就是我们接下来要做的。</p>
<p><strong>‘SalePrice’相关矩阵（放大热图样式）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SalePrice相关矩阵</span></span><br><span class="line">k = <span class="number">10</span> <span class="comment">#热图的变量数</span></span><br><span class="line">cols = corrmat.nlargest(k, <span class="string">&#x27;SalePrice&#x27;</span>)[<span class="string">&#x27;SalePrice&#x27;</span>].index</span><br><span class="line">cm = np.corrcoef(df_train[cols].values.T)</span><br><span class="line">sns.<span class="built_in">set</span>(font_scale=<span class="number">1.25</span>)</span><br><span class="line">hm = sns.heatmap(cm, cbar=<span class="literal">True</span>, annot=<span class="literal">True</span>, square=<span class="literal">True</span>, fmt=<span class="string">&#x27;.2f&#x27;</span>, annot_kws=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;, yticklabels=cols.values, xticklabels=cols.values)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/007.png" alt=""></p>
<p>根据我们的水晶球显示，这些是与“SalePrice”最相关的变量。因此我得出以下结论：</p>
<ul>
<li>OverallQual’，’GrLivArea’和’TotalBsmtSF’与’SalePrice’密切相关。需要检查！</li>
<li>‘GarageCars’和’GarageArea’也是一些与强度相关的变量。但是，正如我们在最后一点所讨论的那样，车库所能容纳的车辆数量是车库面积的结果。’GarageCars’和’GarageArea’就像孪生兄弟。你永远无法区分它们。因此，我们只需要分析其中的一个变量（我们可以保留’GarageCars’，因为它与’SalePrice’的关联性更高）。</li>
<li>‘TotalBsmtSF’和’1stFloor’也似乎是双胞胎兄弟。我们可以只保留’TotalBsmtSF’（重新阅读’那么，我们能得到什么呢？’部分）。</li>
<li>‘FullBath’?? 真的需要吗?</li>
<li>‘TotRmsAbvGrd’和’GrLivArea’，再次是双胞胎兄弟。这是来自切尔诺贝利的数据集吗？</li>
<li>啊……’YearBuilt’……看起来’YearBuilt’与’SalePrice’略有关联。老实说，对于’YearBuilt’变量来说，我是有一些额外的顾虑的，因为这让我觉得我们应该做一些时间序列分析来分析这一变量。我会把这个问题作为你的homework。</li>
</ul>
<p>我们继续看散点图。</p>
<p>‘SalePrice’和相关变量之间的散点图（move like Jagger style）</p>
<p>前方高能！我第一次看到这些散点图的时候，我完全震惊了。</p>
<p>在如此短的空间里有如此多的信息.​​…..这真是太神奇了。再一次谢谢@seaborn！你让我’move like Jagger’！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">sns.<span class="built_in">set</span>()</span><br><span class="line">cols = [<span class="string">&#x27;SalePrice&#x27;</span>, <span class="string">&#x27;OverallQual&#x27;</span>, <span class="string">&#x27;GrLivArea&#x27;</span>, <span class="string">&#x27;GarageCars&#x27;</span>, <span class="string">&#x27;TotalBsmtSF&#x27;</span>, <span class="string">&#x27;FullBath&#x27;</span>, <span class="string">&#x27;YearBuilt&#x27;</span>]</span><br><span class="line">sns.pairplot(df_train[cols], size = <span class="number">2.5</span>)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/008.png" alt=""></p>
<p>虽然我们已经知道一些主要的变量，但这个巨大的散点图给了我们关于变量关系的一个合理的解释。</p>
<p>我们可能会对’TotalBsmtSF’和’GrLiveArea’组成的散点图感兴趣。在这个图中，我们可以看到许多点画出了一条线，几乎就像一个边界。这种结果是完全有道理的，并且大多数的点保持在该线以下。地下室的面积可以等于地面上的居住面积，但预计地下室面积不会超过地上居住面积（除非你想购买的是地堡）。</p>
<p>关于’SalePrice’和’YearBuilt’的情况也可以让我们进一步思考。在“点云”的底部，我们看到一个看起来几乎是一个指数函数的曲线。我们也可以在’点云’的上限中看到同样的趋势。另外，请注意过去几年中的一系列点数是如何保持在这个极限之上的（我只是想说价格增速正在变快）。</p>
<p>好吧，现在我们已经完成了足够多的罗夏测试。让我们来探讨下一步的内容：缺失数据！</p>
<h3 id="4-缺失的数据"><a href="#4-缺失的数据" class="headerlink" title="4.缺失的数据"></a>4.缺失的数据</h3><p>在考虑缺失数据时的几个重要问题：</p>
<ul>
<li>缺失的数据有多普遍？</li>
<li>丢失数据是随机现象的还是有一定的规律？</li>
</ul>
<p>这些问题的答案很重要，因为缺少数据可能意味着样本量减少。这可能会使我们的分析工作无法进行。此外，从实质的角度来看，我们需要确保缺失的数据流程没有偏见，并确保没有将一些不易洞察的事实所隐藏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缺失数据</span></span><br><span class="line">total = df_train.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">percent = (df_train.isnull().<span class="built_in">sum</span>()/df_train.isnull().count()).sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">missing_data = pd.concat([total, percent], axis=<span class="number">1</span>, keys=[<span class="string">&#x27;Total&#x27;</span>, <span class="string">&#x27;Percent&#x27;</span>])</span><br><span class="line">missing_data.head(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Total</th>
<th style="text-align:left">Percent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PoolQC</td>
<td style="text-align:left">1453</td>
<td style="text-align:left">0.995205</td>
</tr>
<tr>
<td style="text-align:left">MiscFeature</td>
<td style="text-align:left">1406</td>
<td style="text-align:left">0.963014</td>
</tr>
<tr>
<td style="text-align:left">Alley</td>
<td style="text-align:left">1369</td>
<td style="text-align:left">0.937671</td>
</tr>
<tr>
<td style="text-align:left">Fence</td>
<td style="text-align:left">1179</td>
<td style="text-align:left">0.807534</td>
</tr>
<tr>
<td style="text-align:left">FireplaceQu</td>
<td style="text-align:left">690</td>
<td style="text-align:left">0.472603</td>
</tr>
<tr>
<td style="text-align:left">LotFrontage</td>
<td style="text-align:left">259</td>
<td style="text-align:left">0.177397</td>
</tr>
<tr>
<td style="text-align:left">GarageCond</td>
<td style="text-align:left">81</td>
<td style="text-align:left">0.055479</td>
</tr>
<tr>
<td style="text-align:left">GarageType</td>
<td style="text-align:left">81</td>
<td style="text-align:left">0.055479</td>
</tr>
<tr>
<td style="text-align:left">GarageYrBlt</td>
<td style="text-align:left">81</td>
<td style="text-align:left">0.055479</td>
</tr>
<tr>
<td style="text-align:left">GarageFinish</td>
<td style="text-align:left">81</td>
<td style="text-align:left">0.055479</td>
</tr>
<tr>
<td style="text-align:left">GarageQual</td>
<td style="text-align:left">81</td>
<td style="text-align:left">0.055479</td>
</tr>
<tr>
<td style="text-align:left">BsmtExposure</td>
<td style="text-align:left">38</td>
<td style="text-align:left">0.026027</td>
</tr>
<tr>
<td style="text-align:left">BsmtFinType2</td>
<td style="text-align:left">38</td>
<td style="text-align:left">0.026027</td>
</tr>
<tr>
<td style="text-align:left">BsmtFinType1</td>
<td style="text-align:left">37</td>
<td style="text-align:left">0.025342</td>
</tr>
<tr>
<td style="text-align:left">BsmtCond</td>
<td style="text-align:left">37</td>
<td style="text-align:left">0.025342</td>
</tr>
<tr>
<td style="text-align:left">BsmtQual</td>
<td style="text-align:left">37</td>
<td style="text-align:left">0.025342</td>
</tr>
<tr>
<td style="text-align:left">MasVnrArea</td>
<td style="text-align:left">8</td>
<td style="text-align:left">0.005479</td>
</tr>
<tr>
<td style="text-align:left">MasVnrType</td>
<td style="text-align:left">8</td>
<td style="text-align:left">0.005479</td>
</tr>
<tr>
<td style="text-align:left">Electrical</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0.000685</td>
</tr>
<tr>
<td style="text-align:left">Utilities</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0.000000</td>
</tr>
</tbody>
</table>
</div>
<p>让我们分析一下这个表里的信息，来理解如何处理丢失的数据。</p>
<p>我们会考虑当超过15％的数据丢失时，删除相应的变量并假设它从来都不存在。这意味着在这些情况下，我们不会尝试填补缺失数据。按照这个逻辑，我们应该删除一组变量（例如’PoolQC’，’MiscFeature’，’Alley’等）。这么做的重点是：我们会错过这些数据吗？我不这么认为。这些变量中没有一个看起来很重要，因为其中大多数不是我们在购买房屋时考虑的方面（或许这就是这些数据会缺失的原因？）。此外，仔细观察变量，像’PoolQC’，’MiscFeature’和’FireplaceQu’这样的变量是异常值的强有力候选者，所以我们很乐意删除它们。</p>
<p>在其余的案例中，我们可以看到“GarageX”系列的变量具有相同数量的缺失数据。我敢打赌，缺少的数据来自同一组观察结果（我不会检查它，缺失值只有5％的占比）。由于表示关于车库信息的最重要信息的字段是“GarageCars”，并且考虑到我们只是谈论了5％的缺失数据，所以我将删除提及的“GarageX”变量。同样的逻辑适用于’BsmtX’变量。</p>
<p>关于’MasVnrArea’和’MasVnrType’，我们可以认为这些变量不是必需的。此外，它们与已经考虑过的“YearBuilt”和“OverallQual”有很强的相关性。因此，如果我们删除’MasVnrArea’和’MasVnrType’这两个变量，我们不会丢失信息。</p>
<p>最后，我们在’Electrical’中有一个缺失的观察。由于这只是一个观察，我们将删除此记录并保留该变量。</p>
<p>总之，为了处理缺失的数据，我们将删除所有缺少数据的变量，但变量’Electrical’除外。在’Electrical’中，我们只需删除缺少数据的观察结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缺失数据处理</span></span><br><span class="line">df_train = df_train.drop((missing_data[missing_data[<span class="string">&#x27;Total&#x27;</span>] &gt; <span class="number">1</span>]).index,<span class="number">1</span>)</span><br><span class="line">df_train = df_train.drop(df_train.loc[df_train[<span class="string">&#x27;Electrical&#x27;</span>].isnull()].index)</span><br><span class="line">df_train.isnull().<span class="built_in">sum</span>().<span class="built_in">max</span>() <span class="comment">#just checking that there&#x27;s no missing data missing...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="离群值！"><a href="#离群值！" class="headerlink" title="离群值！"></a>离群值！</h3><p>离群值也是我们应该意识到的。为什么？因为异常值可以显着影响我们的模型，并且可以成为宝贵的信息来源，为某些特定行为提供解释。</p>
<p>离群值是一个复杂的问题，值得给与更多关注。在这里，我们将通过“SalePrice”的标准偏差和一组散点图进行快速分析。</p>
<p><strong>单变量分析</strong></p>
<p>这里主要关心的是建立一个阈值，将观测定义为异常值。为此，我们将标准化数据。在此情况下，数据标准化意味着将数据值转换为平均值为0，标准偏差为1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 标准化数据</span><br><span class="line">saleprice_scaled &#x3D; StandardScaler().fit_transform(df_train[&#39;SalePrice&#39;][:,np.newaxis]);</span><br><span class="line">low_range &#x3D; saleprice_scaled[saleprice_scaled[:,0].argsort()][:10]</span><br><span class="line">high_range&#x3D; saleprice_scaled[saleprice_scaled[:,0].argsort()][-10:]</span><br><span class="line">print(&#39;outer range (low) of the distribution:&#39;)</span><br><span class="line">print(low_range)</span><br><span class="line">print(&#39;\nouter range (high) of the distribution:&#39;)</span><br><span class="line">print(high_range)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outer range (low) of the distribution:</span><br><span class="line">[[-1.83820775]</span><br><span class="line"> [-1.83303414]</span><br><span class="line"> [-1.80044422]</span><br><span class="line"> [-1.78282123]</span><br><span class="line"> [-1.77400974]</span><br><span class="line"> [-1.62295562]</span><br><span class="line"> [-1.6166617 ]</span><br><span class="line"> [-1.58519209]</span><br><span class="line"> [-1.58519209]</span><br><span class="line"> [-1.57269236]]</span><br><span class="line"></span><br><span class="line">outer range (high) of the distribution:</span><br><span class="line">[[3.82758058]</span><br><span class="line"> [4.0395221 ]</span><br><span class="line"> [4.49473628]</span><br><span class="line"> [4.70872962]</span><br><span class="line"> [4.728631  ]</span><br><span class="line"> [5.06034585]</span><br><span class="line"> [5.42191907]</span><br><span class="line"> [5.58987866]</span><br><span class="line"> [7.10041987]</span><br><span class="line"> [7.22629831]]</span><br></pre></td></tr></table></figure>
<p>对’SalePrice’的新衣服，感觉如何？：</p>
<ul>
<li>低范围值与0相似且不太远。</li>
<li>高范围值远离0，大概是7.多的值。</li>
</ul>
<p>目前，我们不会将这些值视为异常值，但我们应该小心这两个值。</p>
<p><strong>双变量分析</strong></p>
<p>我们已经了解了以下散点图。但是，当我们从新的角度来看事物时，总会有一些东西需要发现。正如Alan Kay所说，“视角的改变相当于提高80点智商”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 双变量分析SalePrice&#x2F;GrLivArea</span><br><span class="line">var &#x3D; &#39;GrLivArea&#39;</span><br><span class="line">data &#x3D; pd.concat([df_train[&#39;SalePrice&#39;], df_train[var]], axis&#x3D;1)</span><br><span class="line">data.plot.scatter(x&#x3D;var, y&#x3D;&#39;SalePrice&#39;, ylim&#x3D;(0,800000));</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/009.png" alt=""></p>
<p>它所揭示的是：</p>
<ul>
<li>这两个变量中，更大的’GrLivArea’的数据看起来很奇怪，这些较大的’GrLivArea’离群了。我们可以推测为什么会发生这种情况。也许这些样本是农业领域的，这样想可以解释低价的原因。我不确定这一点，但我确信这两点并不代表典型案例。因此，我们将它们定义为异常值并删除它们。</li>
<li>顶部的两个观察结果是那些7.多的那两个，我们应该小心处理这些观察结果。他们看起来像两个特殊情况，但他们似乎正在追随上涨的趋势。出于这个原因，我们会保留它们。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃ 删除点</span><br><span class="line">df_train.sort_values(by = <span class="string">&#x27;GrLivArea&#x27;</span>, ascending = <span class="literal">False</span>)[:<span class="number">2</span>]</span><br><span class="line">df_train = df_train.drop(df_train[df_train[<span class="string">&#x27;Id&#x27;</span>] == <span class="number">1299</span>].index)</span><br><span class="line">df_train = df_train.drop(df_train[df_train[<span class="string">&#x27;Id&#x27;</span>] == <span class="number">524</span>].index)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 双变量分析SalePrice/GrLivArea</span></span><br><span class="line">var = <span class="string">&#x27;TotalBsmtSF&#x27;</span></span><br><span class="line">data = pd.concat([df_train[<span class="string">&#x27;SalePrice&#x27;</span>], df_train[var]], axis=<span class="number">1</span>)</span><br><span class="line">data.plot.scatter(x=var, y=<span class="string">&#x27;SalePrice&#x27;</span>, ylim=(<span class="number">0</span>,<span class="number">800000</span>));</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/010.png" alt=""></p>
<p>我们可以想象消除一些观察结果（例如TotalBsmtSF&gt; 3000的结果），但我认为这么做不值得。我们可以接受这些值，所以我们不会做任何事情。</p>
<h3 id="5-硬核部分"><a href="#5-硬核部分" class="headerlink" title="5.硬核部分"></a>5.硬核部分</h3><p>在Ayn Rand的小说“阿特拉斯耸耸肩”中，有一个经常重复的问题：John Galt是谁？本书很大一部分是关于寻求发现这个问题的答案。</p>
<p>我现在体会到了Rand的感受，’SalePrice’是谁呢？</p>
<p>这个问题的答案在于测试多变量分析统计基础的假设。我们已经做了一些数据清理，并发现了很多关于’SalePrice’的信息。现在是深入了解’SalePrice’如何符合统计假设的时候了，这些假设使我们能够应用多元技术。</p>
<p>根据Hair et al. (2013)，我们应该测试四个假设：</p>
<ul>
<li><strong>正态性</strong> - 当我们谈论正态性时，我们的意思是数据应该看起来像正态分布。这很重要，因为几个统计测试依赖于此（例如t-statistics）。在本练习中，我们将检查’SalePrice’的单变量正态性（这是一种有限的方法）。请记住，单变量正态性并不能确保多元正态性（这是我们想要的），但这么做是有帮助的。需要考虑的另一个细节是，在大样本（&gt; 200个观测值）的情况下，正态性不是一个重要的问题。但是，如果我们解决正态性问题，就可以避免很多其他问题（例如异质性），这就是我们进行这种分析的主要原因。</li>
<li><strong>方差齐性</strong> - 希望我写的是对的。 方差齐性指的是“假设变量（一个或多个）在预测​​变量范围内表现出相同的方差水平”（Hair et al。，2013）。考虑方差齐性是合理的，因为我们希望误差项在自变量的所有值中都是相同的。</li>
<li><strong>线性</strong> - 评估线性的最常见方法是检查散点图并搜索线性模式。如果模式不是线性的，那么可以尝试探索数据转换。但是，在这里我们去转换数据，因为我们看到的大多数散点图似乎都具有线性关系。</li>
<li><strong>缺少相关错误</strong> - 如定义所示，相关的错误发生在一个错误与另一个错误相关时。例如，如果一个正误差系统地产生负误差，则意味着这些变量之间存在关系。这通常以时间序列发生，其中一些模式与时间相关。我们在这里不会涉及这一点。但是，如果您检测到某些内容，请尝试添加一个可以解释您获得的效果的变量。这是相关错误的最常见解决方案。</li>
</ul>
<p>你认为猫王会对这个漫长的解释说些什么？ ‘请少一点谈话，多一点行动’？可能……顺便说一下，你知道Elvis最后一次承受的重大的打击是什么吗？</p>
<p>(…)</p>
<p>是浴室的地板。</p>
<p><strong>寻找正态性</strong></p>
<p>这里的要点是以非常精益的方式测试’SalePrice’。我们将这样做：</p>
<ul>
<li><strong>直方图</strong> - 峰度和偏度。</li>
<li><strong>正态概率图</strong> - 数据分布应该紧跟代表正态分布的对角线。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 直方图和正态概率图</span><br><span class="line">sns.distplot(df_train[&#39;SalePrice&#39;], fit&#x3D;norm);</span><br><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">res &#x3D; stats.probplot(df_train[&#39;SalePrice&#39;], plot&#x3D;plt)</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/011.png" alt=""></p>
<p><img src="/img/18_03_11/012.png" alt=""></p>
<p>好吧，’SalePrice’不服从正态分布。它显示’顶峰’呈现出正偏斜状态，并且不遵循对角线。</p>
<p>但一切都没有丢失。简单的数据转换可以解决问题。这是您可以在统计书籍中学到的很棒的东西之一：如果是正偏态，使用log函数转换通常效果不错。当我发现这一点时，我感觉自己就像一个霍格沃茨的学生发现了一个新的咒语一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃ 应用log函数转换</span><br><span class="line">df_train[<span class="string">&#x27;SalePrice&#x27;</span>] = np.log(df_train[<span class="string">&#x27;SalePrice&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换的直方图和正态概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;SalePrice&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/013.png" alt=""></p>
<p><img src="/img/18_03_11/014.png" alt=""></p>
<p>完成！让我们来看看’GrLivArea’的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃ 直方图和正态概率分布图</span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/015.png" alt=""></p>
<p><img src="/img/18_03_11/016.png" alt=""></p>
<p>看起来有点歪…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据转换</span></span><br><span class="line">df_train[<span class="string">&#x27;GrLivArea&#x27;</span>] = np.log(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换的直方图和正态概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/017.png" alt=""></p>
<p><img src="/img/18_03_11/018.png" alt=""></p>
<p>下一个…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图和正态概率分布图</span></span><br><span class="line">sns.distplot(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/019.png" alt=""></p>
<p><img src="/img/18_03_11/020.png" alt=""></p>
<p>好的，现在我们要处理几个大麻烦了：</p>
<ul>
<li>总体来说，数据分布呈现偏斜状态。</li>
<li>有大量的零值观察（比如没有地下室的房屋）。</li>
<li>0是不能求log的，这是一个很大的问题。</li>
</ul>
<p>为了在这里应用log转换，我们将创建一个变量来获得有或没有地下室（二进制变量）的效果。然后，我们将对所有非零观测值进行对数转换，忽略零值。这样我们就可以转换数据，而不会失去有或没有地下室的影响。</p>
<p>我不确定这种方法是否正确。但这对我来说似乎是正确的。这就是我所说的“高风险工程”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为新变量创建列（一个足够了，因为它是一个二进制分类特征）</span></span><br><span class="line"><span class="comment"># 如果 area&gt;0 值为1，否则 值为0</span></span><br><span class="line">df_train[<span class="string">&#x27;HasBsmt&#x27;</span>] = pd.Series(<span class="built_in">len</span>(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]), index=df_train.index)</span><br><span class="line">df_train[<span class="string">&#x27;HasBsmt&#x27;</span>] = <span class="number">0</span> </span><br><span class="line">df_train.loc[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>,<span class="string">&#x27;HasBsmt&#x27;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据转换</span></span><br><span class="line">df_train.loc[df_train[<span class="string">&#x27;HasBsmt&#x27;</span>]==<span class="number">1</span>,<span class="string">&#x27;TotalBsmtSF&#x27;</span>] = np.log(df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图和正态概率分布图</span></span><br><span class="line">sns.distplot(df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;TotalBsmtSF&#x27;</span>], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;TotalBsmtSF&#x27;</span>], plot=plt)</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/021.png" alt=""></p>
<p><img src="/img/18_03_11/022.png" alt=""></p>
<p><strong>在第一次尝试中寻找“方差齐性”</strong></p>
<p>测试两个度量变量的同方差性的最佳方法是图形化。对不同特征使用相同的分布方式，生成锥形（样本在一侧分布的少，另一侧分布的多）或钻石（大量点分布在中心区域）等形状的分布情况。</p>
<p>绘制SalePrice’和’GrLivArea’的分布：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃散点图</span><br><span class="line">plt.scatter(df_train[<span class="string">&#x27;GrLivArea&#x27;</span>], df_train[<span class="string">&#x27;SalePrice&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/023.png" alt=""></p>
<p>此散点图的旧版本（在对数转换之前）具有圆锥形状（返回并检查’SalePrice’和相关变量之间的散点图（move like Jagger style））。如您所见，当前的散点图不再具有圆锥形状。这是正态化的力量！只要确保一些变量的正态性，我们解决了同方差问题。</p>
<p>我们继续检查’SalePrice’和’TotalBsmtSF’。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃散点图</span><br><span class="line">plt.scatter(df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;TotalBsmtSF&#x27;</span>], df_train[df_train[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">0</span>][<span class="string">&#x27;SalePrice&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_03_11/024.png" alt=""></p>
<p>总的来说，’SalePrice’在’TotalBsmtSF’范围内表现出相等的变化水平。Cool!</p>
<h3 id="Last-but-not-the-least-虚拟变量"><a href="#Last-but-not-the-least-虚拟变量" class="headerlink" title="Last but not the least, 虚拟变量"></a>Last but not the least, 虚拟变量</h3><p>简单模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃ 虚拟变量转换</span><br><span class="line">df_train = pd.get_dummies(df_train)</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到了练习的最后部分。</p>
<p>在整个这个kernel中，我们实践了许多由Hair等人提出的策略。 （2013年）。我们对变量进行了哲学研究，我们单独分析了“SalePrice”，并且与最相关的变量进行了分析，我们处理了缺失的数据和异常值，我们测试了一些基本的统计假设，甚至将分类变量转换为虚拟变量。 Python帮助我们轻松完成了很多工作。</p>
<p>但是我们的任务还没有结束。别忘了，我们的故事还停留在对’SalePrice’的Facebook的研究那一步呢。现在是时候打电话给’SalePrice’并邀请她共进晚餐。试着预测她的行为。你认为她是一个喜欢正规化线性回归方法的女孩吗？或者你认为她喜欢合奏方法？或者也许别的东西？</p>
<p>答案由你找出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://pmarcelino.com/">作者blog</a></p>
<p><a href="https://www.amazon.com/Multivariate-Data-Analysis-Joseph-Hair/dp/0138132631">Hair等人，2013，多变量数据分析，第7版</a></p>
<h2 id="致谢-1"><a href="#致谢-1" class="headerlink" title="致谢"></a>致谢</h2><p>感谢JoãoRico的审阅。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】图解信息论</title>
    <url>/2017/06/13/%E3%80%90%E7%BF%BB%E8%AF%91%E3%80%91%E8%A7%86%E8%A7%89%E4%BF%A1%E6%81%AF%E8%AE%BA/</url>
    <content><![CDATA[<ul>
<li><a href="http://colah.github.io/posts/2015-09-Visual-Information/">原文地址</a></li>
</ul>
<p>我很喜欢那种获得一种新的方式来思考我们的世界时的那种感觉。尤其是在一些模糊的想法变成一个具体的概念的时候。<strong>信息论</strong>就是这样一种把模糊的概念具象化的典型的例子。</p>
<p>信息理论为我们描述很多事情提供了准确的语言。关于某个问题我到底有多不确定？问题A的答案会告诉我们多少关于问题B的答案的信息？一组信息和另一组信息的相似度如何衡量？在我小的时候，我就已经形成了一些关于这些问题的模糊的想法，但是信息论将我的这些想法形成了精确的强大的理论。这些理论有着巨大的应用范围，例如数据压缩、量子物理学、机器学习以及其他更广泛的领域。</p>
<p>不过，信息论看起来似乎有些不容易理解，但我不认为信息论应该是这样难以理解的。事实上，信息论中许多核心理论都可以完全用图解的方式来解释！</p>
<h2 id="可视化概率分布"><a href="#可视化概率分布" class="headerlink" title="可视化概率分布"></a>可视化概率分布</h2><p>在我们深入信息理论之前，让我们考虑一下如何可视化简单的概率分布。</p>
<p>我住在加利福尼亚州。有些时候这里是下雨天，但大多数时间里这里都是晴天！我们假设有75%的时间是晴天。我们很容易就可以将这些信息可视化的展示出来：</p>
<p><img src="/img/17_06_13/001.png" width=100 height=100 /></p>
<p>大多数的时间，我都穿T恤衫，但在某些时间，我会穿外套。那么假设我38%的时间里是穿外套的。可视化这个信息也很容易：</p>
<p><img src="/img/17_06_13/002.png" width=100 height=100 /></p>
<p>如果我想将这两件事同时可视化该怎么做呢？如果这两件事情相互不影响（相互独立），那么这很容易做到。例如，我穿T恤或者外套与下一周的天气并不相关。我们可以通过两个轴分别表示两种不同的变量的方式来可视化这些信息：</p>
<p><img src="/img/17_06_13/003.png" width=300 height=300 /></p>
<p>请注意水平方向和竖直方向上穿过的直线。<em>这就是独立性的标识！</em>我穿外套的概率并不受那一周天气都是下雨天而改变。换句话说，在下周要下雨并且我恰好也穿外套的概率，是我穿外套的概率与下雨天的概率之积。它们互不影响。</p>
<p>当变量之间相互作用时，对于某组相互排斥的变量而言，他们组成的概率会减少；而某组相互促进影响的变量而言，他们组成的概率会增加。对于在下雨天我穿外套的这种情况，会有额外的概率增加，因为下雨天和外套这两个变量是相关的，它们使得彼此之间更有可能发生。在下雨天我穿外套的概率，比我在其他某天穿外套的概率高。</p>
<p>可视化之后，这些看起来有肿胀的部分是因为额外增加的概率导致的，而其他收缩的部分，是因为这一对事件不太可能同时出现。</p>
<p><img src="/img/17_06_13/004.png" width=300 height=300 /></p>
<p>这张图虽然这看起来很酷，但对于理解具体发生了什么并不是很有帮助。</p>
<p>相反，让我们焦点集中在其中的某一个变量上，例如天气。我们知道某天是晴天或者下雨天的可能性。对于是否穿外套的两种情况，我们可以看看<em>条件概率</em>。我在晴天穿外套的可能性有多大？如果是下雨天，那么我穿外套的可能性又是多大？</p>
<p><img src="/img/17_06_13/005.png" width=500 height=300 /></p>
<p>有25%的时间是下雨天。如果是下雨天，那么有75%的可能性我会穿外套。所以，我在下雨天穿外套的概率是25%乘以75%，结果大约是19%。下雨天的概率乘以我在下雨天的情况下穿外套的概率，就是在所有情况下，天气为下雨天并且我穿外套的概率。我们用这样的式子来描述：</p>
<script type="math/tex; mode=display">
p(\text{rain}, \text{coat}) = p(\text{rain}) \cdot p(\text{coat} ~|~ \text{rain})</script><p>这就是概率论的最基本的定理之一：</p>
<script type="math/tex; mode=display">
p(x,y) = p(x)\cdot p(y|x)</script><p>我们把一个整体的概率拆分成两部分来看。首先，我们来看其中一个变量的概率的值，例如不同天气的概率。然后我们观察另一个变量，例如我的穿衣情况，观察它在第一个变量的条件下的概率。</p>
<p>具体选择哪个变量开始，是任意的。我们可以以我的穿衣情况为第一个被观察的条件，这也许会有点不直观，因为我们知道穿衣情况是受到天气情况影响的，而天气情况并不会受到我的穿衣情况影响的…但其实这里两种方式的效果是一样有效的！</p>
<p>让我们来看一个例子。我已经知道穿外套的概率是38%。假设我已经知道我在某一天是穿外套的，那么这一天下雨的概率有多大呢？我在下雨天比在晴天穿外套的可能性更大，但在加州是很少下雨的，所以有50%的概率这一天是下雨天。因此，某天是雨天并且我穿了外套的概率就等于我穿外套的概率（38%）乘以我穿外套的情况下是下雨天的概率（50%），结果大约是19%。</p>
<script type="math/tex; mode=display">
p(\text{rain}, \text{coat}) = p(\text{coat}) \cdot p(\text{rain} ~|~ \text{coat})</script><p>这为我们提供了第二种来可视化这些概率分布的方法：</p>
<p><img src="/img/17_06_13/006.png" width=300 height=500 /></p>
<p>注意，这里的标签与之前图中稍有不同：T恤和外套现在是<em>边际概率</em>，我穿外套的概率是不需要考虑天气情况的。另一方面，现在有两个雨天和晴天的标签，分别来标识我穿T恤情况下的概率和我穿外套情况下的概率。</p>
<blockquote>
<p>你可能已经听说过<strong>贝叶斯定理</strong>。其实你也完全可以使用贝叶斯定理来解释这部分内容。</p>
</blockquote>
<h2 id="Aside：辛普森悖论"><a href="#Aside：辛普森悖论" class="headerlink" title="Aside：辛普森悖论"></a>Aside：辛普森悖论</h2><p>这些可视化概率分布的技巧真的很有用吗？我认为的确很有用！在我们图解信息论之前，我还需要一些时间来用可视化的技术探索一下辛普森悖论。辛普森悖论是一种非常不直观的统计状况。它真的很不容易被直观的理解。迈克尔·尼尔森（Michael Nielsen）撰写了一篇很有爱的文章：<a href="http://michaelnielsen.org/reinventing_explanation/">“创新说明”</a>，探讨了不同方式来解释它。而我想尝试使用我们在上一节中学到的技巧来解释它。</p>
<p>测试两种肾结石治疗方法。对一半的患者使用A治疗方案，而另一半则使用B治疗方案。接受治疗方案B的患者比接受治疗方案A的患者更容易存活。</p>
<p><img src="/img/17_06_13/007.png" width=400 height=400 /></p>
<p>然而，如果接受治疗方案A的话，患肾小结石的患者更有可能存活。然而大肾结石患者如果接受治疗方案A也更有可能存活！这怎么可能呢？</p>
<p>这个问题的核心是因为患者样本没有被正确随机分组。接受治疗方案A的患者大部分可能患有大肾结石，而接受治疗方案B的患者大部分可能患有小肾结石。</p>
<p><img src="/img/17_06_13/008.png" width=400 height=400 /></p>
<p>事实证明，肾结石较小的患者通常更有可能生存。</p>
<p>为了更好地理解这一点，我们可以将前两个图表组合为一个三维图，其中将小型和大型肾结石的存活率分开展示。</p>
<p><img src="/img/17_06_13/009.png" width=400 height=400 /></p>
<p>我们现在可以看到，在两种小肾结石和大肾结石的病例中，治疗方案A是超过治疗方案B的。治疗方案B看起来似乎更好，仅仅是因为应用它的患者本身更有可能存活！</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>现在我们有了可视化概率的方法，我们可以深入到信息论中了。</p>
<p>首先我向你介绍一位我假想的朋友，Bob。Bob很喜欢动物。他一直不停在谈论动物。事实上，他只会说四个字：“dog”, “cat”, “fish” 和 “bird”。</p>
<p>几周前（虽然这只是我的想象)Bob搬到了澳大利亚。另外，他决定只想要使用二进制来交流。来自Bob的所有（虚构的）消息都是这样的：</p>
<p><img src="/img/17_06_13/010.png" width=300 height=100 /></p>
<p>为了沟通，Bob和我必须建立一个编码，一种将单词映射成位序列的方式。</p>
<p><img src="/img/17_06_13/011.png" width=300 height=300 /></p>
<p>要发送消息，Bob用相应的编码字来替换每个单词，然后将它们连接在一起形成编码的字符串。</p>
<p><img src="/img/17_06_13/012.png" width=300 height=150 /></p>
<h3 id="可变长度码"><a href="#可变长度码" class="headerlink" title="可变长度码"></a>可变长度码</h3><p>不幸的是，在假想中的澳大利亚，通信服务是昂贵的。从Bob收到的每条消息中，每一位（bit）数据我都必须支付5美元。我是不是还没有提到Bob喜欢说很多话这件事？为了防止我破产，Bob和我决定来研究一些可以使我们的平均消息长度变得更短的方法。</p>
<p>事实证明，并不是所有的词Bob都会经常说。Bob很喜欢狗，他一直在说“dog”。同时他也会不定期地说其他的动物，尤其是他的狗喜欢追的猫，但它大多数时间他还是在说“dog”。这是一个他的单词频率图：</p>
<p><img src="/img/17_06_13/013.png" width=300 height=200 /></p>
<p>这似乎看来是有优化空间的。因为我们可以看到，按照旧的编码方式，对于不同的词无论它们是多么常见，都在使用2位长的码字来表示。</p>
<p>我们可以用下面这张图来可视化这些信息。在下面这张图中，我们使用竖直方向的坐标轴来表示每个词的概率$p(x)$，水平方向的坐标轴来表示相应的码字的长度$L(x)$。可以看到在这种情况下平均码字是2位。</p>
<p><img src="/img/17_06_13/014.png" width=500 height=300 /></p>
<p>也许我们可以用一种非常聪明的方式来制作一种可变长度的编码方式，使得其中常用单词对应的码字特别短。这样做的挑战就是码字之间是存在竞争关系的，我们需要让一部分词对应的码字变短，而另一部分则会变长。为了最大限度地减少消息长度，我们希望理想状态下所有的码字都很短，尤其是那些常用的词我们更希望它们能变短。因此，最终得到的编码对于常用词（例如“dog”）具有较短的码字，并且较长的码字被应用到了不常用的词之上（例如“bird”）。</p>
<p><img src="/img/17_06_13/015.png" width=300 height=300 /></p>
<p>让我们再次可视化这些信息。注意那些最常用的词变短了，那些不常用的词变长了。经过这样处理之后，对于传递与之前相同的信息，我们的流量开销的确变少了。平均来说，码字长度现在是1.75位！</p>
<p><img src="/img/17_06_13/016.png" width=500 height=300 /></p>
<blockquote>
<p>你也许会好奇：为什么不用1来作为码字？因为可惜的是，如果我们这么做，当我们对编码的字符串进行解码时，会引起歧义。我们稍后会介绍这些内容。</p>
</blockquote>
<p>事实证明，这种编码方式是最好的。对于这个分配问题，没有其他的编码方式能带来平均码字长度小于1.75位的效果了。</p>
<p>这是一个简单的基本限制。这要求我们传达的信息平均码字长度至少是1.75位。无论我们用多么聪明的代码，都不可能让平均消息长度变得更短。我们称这种限制为<strong>熵</strong>。关于熵的内容，我们将在稍后详细讨论。</p>
<p><img src="/img/17_06_13/017.png" width=500 height=300 /></p>
<p>如果我们想了解这个平均最短码字长度的限制，这个问题的关键在于理解如何在使得一些码字变短但同时其他码字变长的过程中进行权衡。一旦我们弄明白了如何进行这种权衡，我们就能够找出最好的编码方式了。</p>
<h3 id="码字的空间"><a href="#码字的空间" class="headerlink" title="码字的空间"></a>码字的空间</h3><p>码字长度为1时，能表示2种编码：0和1的编码；码字长度为2时，能表示4中编码：00，01，10和11。下面是每增加一位码字长度，能表示的编码种类数量的递增情况：</p>
<p><img src="/img/17_06_13/018.png" width=350 height=300 /></p>
<p>但我们感兴趣的是那些可变长度编码。一种比较简单的情况是有八个长度为3位的码字。我们也可能有一些比较复杂的组合，比如长度为2的两个码字，与长度为3的四个码字的组合。那么究竟是什么决定了我们可以有不同长度的码字呢？</p>
<p>回想一下，Bob通过用它的码字替换每个单词并将它们连接在一起，将他的消息转换成编码的字符串。</p>
<p><img src="/img/17_06_13/019.png" width=300 height=200 /></p>
<p>当制作可变长度代码时，需要注意一个微妙的问题。我们如何将编码过的字符串分割回码字呢？当所有的码字长度相同时，这很简单。我们只需将这个字符串按照固定的码字长度分割成不同的码字即可。但是由于存在不同长度的码字，所以我们需要关注编码过的字符串的内容。</p>
<p>我们希望只有一种方式来解码编码过的字符串。我们不希望我们的编码方式在解码过程中变得含糊不清。如果我们有一些特殊的“码字结束”符号，这个问题这就会变得很容易。但其实我们没有这种符号，我们只能够发送0和1。因此，我们需要能够查看一系列连续的码字，并且说明每个码字应该停止的位置。</p>
<p>而这，很可能出现编码不能被唯一解码的情况。例如，假设0和01都是码字，那么我们就会搞不清楚符串0100111的第一个码字到底是什么。因为这个字符串的第一个码字既可以是0也可以是01！因此，我们想要的效果是没有哪个码字是另一个码字的前缀。这称为<strong>前缀属性</strong>，遵守它的编码称为<strong>前缀编码</strong>。</p>
<p>思考这个问题的一个好的方法是每个码字需要从可能的码字的空间中做出牺牲。如果我们取代码字01，那么我们就失去了使用任何以01前缀开头的码字的能力。我们不能使用010或011010110，因为会产生歧义。</p>
<p><img src="/img/17_06_13/020.png" width=400 height=400 /></p>
<p>由于所有码字中，有$\frac{1}{1}$都是从01开始，所以我们牺牲了$\frac{1}{1}$的所有可能的码字。这是我们付出的代价，而换来的结果只是使得其中一个码字的长度缩短到2位长！反过来，这种牺牲意味着所有其他码字需要更长一些。在不同码字的长度之间总是有这种折衷。为获取一个比较短的码字，需要你牺牲更多的其他码字的空间。而我们需要弄清楚，正确的权衡方式是什么？</p>
<h3 id="最佳编码"><a href="#最佳编码" class="headerlink" title="最佳编码"></a>最佳编码</h3><p>可以理解为简短编码的长度是有一个限定的度量在里面，每减短一个bit的密文就会牺牲一些编码的可能性从而让其它密文的长度增长。 </p>
<p>购买长度为0的码字的成本为1，会牺牲掉所有的码字空间，如果这样做，就不会有其他码字了。长度为1的码字（如“0”）的代价是$\frac{1}{2}$的码字空间，因为有一半的码字以“0”开始的。长度为2的码字的成本(例如“01”)是$\frac{1}{4}$码字空间，因为有$\frac{1}{4}$的码字以“01”开始的。一般来说，码字的代价随代码字的长度而呈指数减小。</p>
<p><img src="/img/17_06_13/021.png" width=600 height=300 /></p>
<p>如果代价是以指数衰减，那么这个高度和面积也是成指数衰减。</p>
<p>我们想要通过得到比较短的码字来缩短平均消息长度。每个码字的期望长度是每个码字出现的概率乘以码字的长度。假设我们有一个4bit的密文，出现概率是50%，那么我们的期望就是4*50%=2bit。我们可以作图来表示。</p>
<p><img src="/img/17_06_13/022.png" width=300 height=300 /></p>
<p>这两个值（代价和期望长度）与码字的长度相关。信息的长度决定了码字的平均长度。我们可以把这两者画在一起，就像这样。</p>
<p><img src="/img/17_06_13/023.png" width=600 height=300 /></p>
<p>短码字减少了平均消息长度，但是越短的码字越昂贵，而长码字增加了平均消息长度，但长码字相对便宜。</p>
<p><img src="/img/17_06_13/024.png" width=600 height=300 /></p>
<p>使用有限预算的最佳方法是什么？我们应该在每个事件的码字上投入多少花费呢？</p>
<p>就像一个人想要把较多的钱投入在经常定期使用的工具上一样，我们更愿意对那些频繁使用的码字支付更高的花费。有一种特别顺其自然的处理方式：按照事件的普遍程度分配我们的预算。如果一个事件发生的概率是50％，那么我们就花费预算的50％来购买这个短的码字。但是，如果一个事件的发生概率只有1％，那么我们就只花1％的预算，因为我们并不是很在意这个不常见的码字变得很长。</p>
<p>这是一件很顺其自然的解决方案，但它是最优解吗？没错，它是，我接下来会证明它！</p>
<p><em>以下是可视化的证明过程，应该是可以理解的，但理解起来有一定难度，而这部分绝对是这篇文章中最难的部分。读者应该自由地选择是否默认接受这一结论跳过这一部分。</em></p>
<p>我们来看一个具体的例子，我们需要比较两个可能发生的事件。事件a发生的概率是$p(a)$，事件b发生的概率是$p(b)$。我们按照上述自然的方式分配预算，花费$p(a)$的预算在a获得一个较短的码字上，花费$p(b)$的预算在b获得较短的码字上。</p>
<p><img src="/img/17_06_13/025.png" width=600 height=300 /></p>
<p>花费的成本和对应的长度贡献的边界完美的对齐了，这是否意味着什么？</p>
<p>那么，请考虑一个问题，如果我们稍微改变码字的长度，会对花费的成本和码字长度贡献值有什么样的影响呢？如果我们稍微增加码字的长度，则消息长度的贡献值将与其边界的高度成比例地增加，而成本则会与边界的高度成正比。</p>
<p><img src="/img/17_06_13/026.png" width=600 height=300 /></p>
<p>所以，使码字a缩短的代价的值是$p(a)$。同时，我们不关心每个码字的具体长度，我们关心的是使用它们的占比。在a这种情况下，占比就是$p(a)$。对我们来说，就是$p(a)$使码字a的长度变得更短一些。</p>
<p>然而有趣的是，这两者的导数都是一样的。这意味着我们的初始预算有一个有趣的属性，如果你花费了一些用于缩短码字的投入，那么这个投入对于投在任何码字上，效果都是一样的。我们真正关心的是最终的利益/成本比例 - 这就决定了我们应该投资多少。在这种情况下，这个比例是$\frac{p(a)}{p(a)}$等于1。这与$p(a)$的值无关，因为这个结果总是1。我们也可以将相同的参数应用于其他事件。利益/成本总是一，所以在其中任何一方投资更多是平等的。</p>
<p><img src="/img/17_06_13/027.png" width=600 height=300 /></p>
<p>无论如何，改变预算是没有意义的。但这不证明这是最好的预算。为了证明这一点，我们会考虑使用一个不同的预算。我们将在$b$中投资$ε$，并在$a$中投资相反的花费。这使得a的码字稍短一些，而b的码字稍长一些。</p>
<p>现在为a购买一个较短的码字的成本是$p(a)+ε$，为b购买较短码字的费用b是$p(b)-ε$。但收益还是一样的。这导致了购买$a$的收益成本比例为一个小于1的值：$\frac{p(a)}{p(a) + ε}$。而另一边，对于购买$b$的收益成本比例是一个大于1的值：$\frac{p(b)}{p(b) - ε}$</p>
<p><img src="/img/17_06_13/028.png" width=600 height=300 /></p>
<p>价格不再保持平衡。b相对于a来说是一笔更好的交易。投资者们尖叫道：“买b！卖a！”我们通过这样做，结束了我们原来的预算计划。所有预算都可以通过转向原始预算的方式来得到改进。</p>
<p>原始预算 - 按照我们使用频率的比例投入每个码字 - 这不仅仅是自然而然的事情，而且这是最好的方法。（虽然这个证明仅适用于两个码字，但它很容易泛化为更多的情况。）</p>
<blockquote>
<p>认真的读者可能已经注意到，我们的最优预算有可能提出码字具有分数长度的编码，这似乎很有用！这是意味着什么呢？当然，在实践中，如果你想通过发送一个单码字，你必须取整，但是我们稍后会看到，当我们一次发送很多码字时，可以发送分数码字！现在请你耐心的看我现在的讲解！</p>
</blockquote>
<h3 id="计算熵"><a href="#计算熵" class="headerlink" title="计算熵"></a>计算熵</h3><p>回想一下，一个长度为$L$的消息代价是$\frac{1}{2^L}$。再做一个简单的变换后，这个信息的长度就是：$\log_2\left(\frac{1}{\text{cost}}\right)$。因为我们对每个码字$x$花费$p(x)$的成本，长度是$\log_2\left(\frac{1}{p(x)}\right)$。这是长度的最佳选择。</p>
<p><img src="/img/17_06_13/029.png" width=600 height=300 /></p>
<p>早些时候，我们讨论了如何从一个特定的概率分布$p$中获取平均消息来传达事件的基本限制。这个将平均消息长度缩短到最优的编码的限制，我们称之为$p$的熵，$H(p)$。现在我们知道了码字的最佳长度，而且我们可以精确的计算出来！</p>
<script type="math/tex; mode=display">
H(p) = \sum_x p(x)\log_2\left(\frac{1}{p(x)}\right)</script><blockquote>
<p>人们通常将熵写作$H(p) = - \sum p(x)\log_2(p(x))$这种形式，因为$\log(1/a) = -\log(a)$。但我认为第一种写法更直观，并且我在这篇文章的后续部分会继续使用这种形式。</p>
</blockquote>
<p>无论我做什么，平均来说，如果我想要进行通信交流，信息平均长度最少都是这个值。</p>
<p>这个需要发送的信息的平均长度对信息的压缩有明显的影响，这个熵还有其它方面的意义吗？当然！它描述了随机性，并且提供了一种量化信息的方式。</p>
<p>如果我确实知道会发生什么事件，我根本就不必发消息！如果有两件可能发生的概率为50％，我只需要发送1bit的数据。如果有64个不同的事情可能以相等的概率发生，我必须发送6bit。发生的概率越集中在某一件事上，就越能用巧妙的编码方式来减少信息的平均长度。概率扩散的范围越大，信息越长。发生的概率越分散到不同事情上，我需要发送的信息平均长度就越长。</p>
<p>结果越不明确，在发生事情时就能学到越多的东西。</p>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>在Bob搬到澳大利亚不久之后，他和我假想的另一个女孩Alice结婚了(让我惊讶的是，我脑海里居然还有其他角色)。然而Alice并不是一个狗狗爱好者。她是一个猫猫爱好者。尽管如此，他们俩也可以在仅有非常有限的关于动物的词汇的情况下，找到共同话题。</p>
<p><img src="/img/17_06_13/030.png" width=300 height=300 /></p>
<p>他们两以不同的频率说着相同的话。Bob总是谈论狗，而Alice却总是谈论猫。</p>
<p>最初，Alice使用Bob的编码向我发送消息。不幸的是，她的消息比他们实际需要的要长。Bob的编码是按照Bob的概率分布优化得到的。而Alice与Bob有不同的信息概率分布，并且Bob编码对她来说并不是最佳的。当Bob使用自己的编码时，码字的平均长度是1.75，但Alice在使用这组编码时，她的码字平均长度是2.25。如果他们两的概率密度越不相似，这个结果就越糟糕。</p>
<p>这种根据一边信息概率分布优化过的编码方式来传输另一种概率分布不同的信息时，消息的平均长度称为交叉熵。关于交叉熵，更正式的定义如下：</p>
<script type="math/tex; mode=display">
H_p(q) = \sum_x q(x)\log_2\left(\frac{1}{p(x)}\right)</script><p>在这种情况下，Alice的猫爱好者的词频与Bob的狗爱好者词频存在交叉熵。</p>
<p><img src="/img/17_06_13/031.png" width=300 height=300 /></p>
<p>为了让我们的通信的花费减少，我让Alice来使用她自己的编码。让我感到安慰的是，这使得她的平均消息长度变短了。但是，这也引入了一个新的问题：有时Bob会不小心使用Alice的编码。令人惊讶的是，Bob使用Alice的编码时，Bob信息的平均长度比Alice用Bob编码时的最优方式还长</p>
<p>所以，现在我们有四种可能的情况：</p>
<ul>
<li>Bob使用它自己的编码$(H(p) = 1.75 ~\text{bits})$</li>
<li>Alice使用Bob的编码$(H_p(q) = 2.25 ~\text{bits})$</li>
<li>Alice使用她自己的编码$(H(q) = 1.75 ~\text{bits})$</li>
<li>Bob使用Alice的编码$(H_q(p) = 2.375 ~\text{bits})$</li>
</ul>
<p>这并不能直观的展示出这种值之间的关联关系。我们可以使用下图来寻找它们之间的关系。</p>
<p>在下图中，每个子图分别表示这四种情况之一。每个子图以与之前相同的方式来显示平均消息长度。处于同一行的两种情况有相同的概率分布，处于同一列的两种情况有相同的编码方式。通过这种方式，可以可视化的观测到概率分布和编码方式的关系。</p>
<p><img src="/img/17_06_13/032.png" width=500 height=500 /></p>
<p>你能看出来为什么$H_p(q) \neq H_q(p)$吗？$H_q(p)$比较大因为在概率分布$p$之下有一个非常常见的码字比较长的事件（蓝色），因为这个事件在概率分布$q$的情况下并不常见。然而，另一边，在$q$的情况下比较常见的事件，在$p$的情况下比较少见，但差异较小，所以$H_p(q)$不是很高。</p>
<p>因此我们发现交叉熵是不对称的。</p>
<p>那么，为什么要关心交叉熵呢？交叉熵给我们一种表达两种概率分布不同的方法。概率分布$p$和$q$的差异越大，那么$p$关于$q$的交叉熵就比$p$的熵越大。</p>
<p><img src="/img/17_06_13/033.png" width=300 height=300 /></p>
<p>同样的，概率分布$p$和$q$差异越大，$q$关于$p$的交叉熵就比$q$本身的熵越大。</p>
<p><img src="/img/17_06_13/034.png" width=300 height=300 /></p>
<p>真正有趣的东西是熵与交叉熵之间的差异。差异在于我们的信息具体长多少，因为我们对不同的概率分布使用了同一套优化过的编码方式。如果概率分布相同，那么这个差异将为零。随着差异的增长，这个差值将变得更大。</p>
<p>我们称这种差异为Kullback-Leibler分歧，或者简称为KL分歧。概率分布$p$关于$q$的KL分歧$D_q(p)$定义如下：</p>
<script type="math/tex; mode=display">
D_q(p) = H_q(p) - H(p)</script><p>关于KL分歧真正在做的事情，其实就像是在衡量不同概率分布之间的差异程度。（如果继续研究这个概念就会进入信息几何的领域。）</p>
<p>交叉熵和KL分歧在机器学习中有着难以置信的用处。通常，我们希望一个分布与另一个分布相互靠近。例如，我们希望一个用于预测的概率分布与真实情况更接近。KL分歧为我们提供了一种很自然的方式来做到这一点，所以它在任何地方都有用武之地。</p>
<h2 id="熵和多变量"><a href="#熵和多变量" class="headerlink" title="熵和多变量"></a>熵和多变量</h2><p>让我回到之前关于天气和穿着的例子：</p>
<p><img src="/img/17_06_13/035.png" width=300 height=300 /></p>
<p>我的妈妈，就像大多数的家长一样，都会担心我的衣着跟天气不搭配。（她的这种担心不是没有道理的，因为我在冬天经常不穿外套。）所以她总是想要知道我这边有关天气和穿衣的信息。我需要发送几个bit的数据来传达这些信息呢？</p>
<p>为了更方便的分析这个问题，我们把概率扁平化分析：</p>
<p><img src="/img/17_06_13/036.png" width=600 height=300 /></p>
<p>现在我们可以找出这些概率的事件的最优码字，并计算平均消息长度：</p>
<p><img src="/img/17_06_13/037.png" width=600 height=300 /></p>
<p>我们把这个称之为$X$和$Y$的联合熵，定义如下：</p>
<script type="math/tex; mode=display">
H(X,Y) = \sum_{x,y} p(x,y) \log_2\left(\frac{1}{p(x,y)}\right)</script><p>这与我们关于熵的正规定义完全相同，唯一的区别就是这里有两个变量，而之前是一个。</p>
<p>我们再把这个图形表现得更形象话一些，加入码字长度作为第三个维度，让图形更立体。现在，熵的大小就是体积的大小。</p>
<p><img src="/img/17_06_13/038.png" width=300 height=600 /></p>
<p>假设我的妈妈已经知道了天气信息（她可以通过新闻知道这些信息）。那么现在我需要提供多少的信息量呢？</p>
<p>似乎我需要发送很多信息来传达我的穿衣情况。但实际情况，我发送的信息比之前要少，因为天气与我的衣着有着密切的联系！我们来分别思考关于下雨天和晴天下的两种情况。</p>
<p><img src="/img/17_06_13/039.png" width=400 height=400 /></p>
<p>在这两种情况下，平均来看，我不需要发送特别多的信息，因为天气信息对我的穿衣情况有着很好的预示。当阳光明媚的晴天，我可以使用一个特定的“晴天优化版”编码，对于下雨天，我可以使用一个特定的“雨天优化版”编码。分别在这两种情况下用不同的编码会比用同一种通用编码的长度少很多。为了得到我需要发送给我妈妈的平均信息量，我把这两个例子放在一起…</p>
<p><img src="/img/17_06_13/040.png" width=200 height=300 /></p>
<p>我们称之为条件熵。可以把它写成如下的数学表达式：</p>
<script type="math/tex; mode=display">
H(X|Y) = \sum_y p(y) \sum_x p(x|y) \log_2\left(\frac{1}{p(x|y)}\right)</script><script type="math/tex; mode=display">
~~~~ = \sum_{x,y} p(x,y) \log_2\left(\frac{1}{p(x|y)}\right)</script><h2 id="交互信息"><a href="#交互信息" class="headerlink" title="交互信息"></a>交互信息</h2><p>在上一节，我们得到一个结论，那就是在知道一个变量的情况下，可能会意味着导致传达另一个变量需要更少的信息。</p>
<p>一种思考这种情况的很好方式是将信息的总量想象成一个条。如果不同的消息之间在共享信息，就叠加显示。例如，$X$和$Y$存在一部分共享信息，因此$H(X)$和$H(Y)$是有重叠部分。并且$H(X,Y)$是两者的共同信息，是$H(X)$和$H(Y)$的集合。</p>
<p><img src="/img/17_06_13/041.png" width=300 height=200 /></p>
<p>一旦我们开始以这种方式思考事情，很多事情就变得简单了。</p>
<p>例如，我们之前注意到同时传递$X$和$Y$（“联合熵”$H(X,Y)$）比仅仅使用$X$来通信（“边际熵”$H(X)$）需要更多的信息。如果你已经知道了$Y$，那么它会用更少的信息来对$X$进行通信（“条件熵”$H(X|Y)$）。</p>
<p><img src="/img/17_06_13/042.png" width=500 height=400 /></p>
<p>这听起来有点复杂，但从条状显示图来看，就很简单了。$H(X|Y)$是指我们在向已经知道$Y$的信息的人在传达$X$的信息时的熵，蕴含在$X$中的信息并不包含在$Y$中。从视觉上来看，这意味着$H(X|Y)$是$H(X)$的条中，不与$H(Y)$重叠的那一部分。</p>
<p>你可以从下图中得出这个不等式:$H(X,Y) \geq H(X) \geq H(X|Y)$。</p>
<p><img src="/img/17_06_13/043.png" width=300 height=200 /></p>
<p>另一个特性：$H(X,Y) = H(Y) + H(X|Y)$。也就是说$X$和$Y$的信息也就是$Y$的信息加上不在$Y$中的$X$的信息。</p>
<p><img src="/img/17_06_13/044.png" width=500 height=400 /></p>
<p>从方程中很难看出这些信息，但如果你将这些信息用条状图显示出来，就变得容易了。</p>
<p>在这里，我们以多种方式组织了$X$和$Y$的信息。我们有每个变量所包含的信息$H(X)$和$H(Y)$。我们有着两种信息的交集$H(X,Y)$。我们有只存在与一个变量但不存在与另一个变量的信息$H(X|Y)$和$H(Y|X)$。还有很多这些围绕着变量之间共享的信息，即他们之间信息的交集。我们称之为“相互信息”$I(X,Y)$，定义如下：</p>
<script type="math/tex; mode=display">
I(X,Y) = H(X) + H(Y) - H(X,Y)</script><p>这个定义是有效的，因为$H(X) + H(Y)$存在有两个相互信息的副本，因为他们同时蕴含在$X$中以及$Y$中，而$H(X,Y)$只有一份。(想想上一个条形图。)</p>
<p>与信息密切相关的是信息的变化。信息的变化是变量之间不共享的信息。我们可以这样定义它：</p>
<script type="math/tex; mode=display">
V(X,Y) = H(X,Y) - I(X,Y)</script><p>信息的变化很有趣，因为它给了我们一个不同变量之间度量距离的概念。两个变量如果知道一个值的值可以得出另一个变量的值，那么这两者之间的信息变化是零，并且这个信息变化的值随着他们彼此之间变得更加独立而增加。</p>
<p>这和同样可以告诉我们距离信息的KL分歧之间的关系是什么呢？KL分歧给了我们两个分布之间在同一个变量或一组变量上的距离。相反，信息的变化给我们两个相同分布的变量之间的距离。KL分歧是应用在不同信息的概率分布中的，标识这概率分布中的信息变化。</p>
<p>我们可以将所有这些信息全部汇集成一个单独的图表：</p>
<p><img src="/img/17_06_13/045.png" width=400 height=400 /></p>
<h2 id="分数形式的位"><a href="#分数形式的位" class="headerlink" title="分数形式的位"></a>分数形式的位</h2><p>关于信息理论的一个非常不直观的事情是我们可以拥有小数位数。这看起来很奇怪，半个位(0.5bit)意味着什么？</p>
<p>有一种简单的答案：通常，我们对消息的平均长度感兴趣，而不是任何特定的消息长度。如果一半的时间发送一个位的长度，一半时间发送两个位的长度，那么平均发送的长度是1.5位。对于平均数是小数的情况并没有什么奇怪的。</p>
<p>但是，这个答案其实是在避开这个问题。通常，码字的最佳长度都是分数形式。这意味着什么呢？</p>
<p>具体来说，让我们考虑一个概率分布，其中事件$a$发生的概率是$71%$，另一个事件$b$发生的概率为$29%$。</p>
<p><img src="/img/17_06_13/046.png" width=300 height=300 /></p>
<p>最佳编码将使用0.5位来表示$a$，用1.7位来表示$b$。那么，如果我们要发送这些码字中的任何一个，都是不可能的。我们会强制被安排发送整数位数的信息，并且发送的平均消息长度是1位。</p>
<p>但是，如果我们一次性发送多条消息，我们可以处理的更好。让我们来考虑按照这种概率分布的情况下来同时传递两个事件。如果我们每次只发送一个事件，那么我们需要发送两位的长度。我们可以处理的更好吗？</p>
<p><img src="/img/17_06_13/047.png" width=300 height=300 /></p>
<p>有一半的概率，我们需要传递$aa$的信息，有21%的概率我们需要发送$ab$或者$ba$，而我们传递$bb$的概率只有8%。我们再一次把编码优化到理想的小数位数的形式。</p>
<p><img src="/img/17_06_13/048.png" width=500 height=300 /></p>
<p>如果我们对码字长度取整，我们将得到这样的结果：</p>
<p><img src="/img/17_06_13/049.png" width=500 height=300 /></p>
<p>这个编码给我们带来的平均消息长度为1.8位。这比我们每次分别只传递一个事件的平均消息长度2位要小。另一种思考这个问题的方式是我们平均每个事件发送的信息是0.9位。如果我们一次发送更多的事件，那么这个值会更小。由于$n$趋向于无穷大，取整造成的损失将逐渐减少，并且每个码字的位数将接近熵。</p>
<p>另外，请注意，$a$的理想码字为0.5位，$aa$的理想码字是1位。即使理想码字的长度是小数，它们的长度也在增加！所以，如果我们一次传达很多事件时，长度会增加。</p>
<p>即使在实际的编码中，只能使用整数长度的码字，这里也有使用小数位数码字的实际的意义。</p>
<blockquote>
<p>在实践中，人们使用在不同程度上有效的特定编码方案。<a href="https://en.wikipedia.org/wiki/Huffman_coding">霍夫曼编码</a>，是一种基本类似于我们在这里草拟的这种编码，并没有非常优雅地处理小数位。你必须像上面那样对符号进行分组，或者使用更复杂的技巧来处理熵限制。<a href="https://en.wikipedia.org/wiki/Arithmetic_coding">算术编码</a>有点不同，它优雅地处理了小数位以渐近最优。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们关心如何使用最少数量数据进行通信，那么这些想法显然是最基本的。如果我们关心压缩数据，信息理论将可以解决数据压缩的核心问题，并给出我们从根本上正确的抽象。但是，如果我们不在乎这些问题，那么除了好奇，我们还有其他什么原因呢？</p>
<p>来自信息理论的观点在很多情况下都会出现：机器学习，量子物理学，遗传学，热力学，甚至赌博。这些领域的从业者通常不关心信息理论。量子纠缠可以用熵来描述，通过假定关于你不知道的事物的最大熵，可以得出统计力学和热力学中的许多结果。赌徒的胜利或损失与KL分歧直接相关，特别是迭代设置。</p>
<p>信息理论在所有这些地方出现，因为它为许多我们需要表达的事情提供了具体的，有原则的形式化表示。它给了我们衡量和表达不确定性的方法，两组数据有多么的不同，不同概率分布之间的距离是多少，以及但对于某个问题的答案中蕴含了多少其他问题的信息：扩散概率是怎样的，概率分布之间的距离以及相互依赖的两个变量是怎样的。有其他类似的理论或者观点吗？当然。但是信息论的思想是干净的，它们具有很好的性质和原则性的起源。在某些情况下，它们正是你所关心的，而在其他情况下，它是混乱世界中的一个方便的代理。</p>
<p>机器学习是我最了解的领域，所以我们来谈一下。在机器学习中，分类是一种非常常见的问题。假设我们想看一张图片，并预测它是一只狗还是一只猫。我们的模型可能会告诉我们“这张图片中有80%的概率是一只狗，有20%的概率是一只猫”。那么我们就说正确答案是狗，那么我们以80%的概率做出的判断是好还是坏呢？以85%的概率做出的判断会比80%好多少呢？</p>
<p>这是一个重要的问题，因为我们需要一些衡量我们模型好坏的概念，以便把它优化的更好。我们应该优化什么呢？正确的答案确实取决于我们使用的模型：我们是只关心最顶部的猜测是否正确呢，还是关心我们在获取正确答案中的信心呢？错误的自信会有多糟？没有一个正确的答案。而且通常不可能知道正确的答案，因为我们不知道如何以精确的方式使用模型来形式化我们最终关心的内容。然而很多问题中，交叉熵都是我们真正需要在意的，但并不总是如此。更常见的情况是我们并不知道我们关心什么，而交叉熵就是解决这些问题的一个很好的工具。</p>
<p>信息为我们提供了一个强大的新框架来思考我们的世界。有时它能完美的解决一些问题，而有时并不可以，但它依然很有用。这篇文章仅仅是对信息论的一个概览，而信息论中还有许多其他主要的概念，例如我们没有提到的纠错码，但我希望我已经展示出了信息论是一个很美丽的主题，它并不是那么高不可攀。</p>
<h2 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h2><p>这里是<strong>克劳德·香农（Claude Shannon）</strong>关于信息论的原创论文<a href="http://worrydream.com/refs/Shannon%20-%20A%20Mathematical%20Theory%20of%20Communication.pdf">通信数学理论</a>。（这在早期的信息论论文中，似乎是一个重复的模式。是时代原因吗？还是因为缺少页面限制？或者是来自贝尔实验室的文化？）</p>
<p>封面和托马斯的信息要素理论似乎是标准参考。我觉得很有帮助。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>我非常感谢<a href="https://github.com/danmane">Dan Mané</a>，<a href="https://www.cs.cmu.edu/~dga/">David Andersen</a>，<a href="http://obsessionwithregression.blogspot.com/">Emma Pierson</a>和Dario Amodei抽出时间来给出这篇文章令人难以置信的详细和广泛征求意见。我也很感激<a href="http://michaelnielsen.org/">Michael Nielsen</a>，<a href="http://research.google.com/pubs/GregCorrado.html">Greg Corrado</a>，<a href="http://www.iro.umontreal.ca/~bengioy/yoshua_en/index.html">Yoshua Bengio</a>，<a href="https://aaroncourville.wordpress.com/">Aaron Courville</a>，<a href="http://www.nickbeckstead.com/">Nick Beckstead</a>，<a href="http://research.google.com/pubs/JonathonShlens.html">Jon Shlens</a>，Andrew Dai，<a href="http://research.google.com/pubs/ChristianHoward.html">Christian Howard</a>和<a href="http://www.bewitched.com/">Martin Wattenberg</a>的评论。</p>
<p>还感谢我的前两个神经网络研讨会系列作为这些想法的豚鼠。</p>
<p>最后，感谢读者发现错误和遗漏。尤其感谢Connor Zwick，Kai Arulkumaran，Jonathan Heusser，Otavio Good，以及匿名评论者。</p>
<h2 id="更多的文章"><a href="#更多的文章" class="headerlink" title="更多的文章"></a>更多的文章</h2><p><a href="http://colah.github.io/posts/2014-07-Understanding-Convolutions/">了解卷积</a></p>
<p><a href="http://colah.github.io/posts/2014-12-Groups-Convolution/">分组和分组卷积</a></p>
<p><a href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/">神经网络，歧管和拓扑</a></p>
<p><a href="http://colah.github.io/posts/2015-01-Visualizing-Representations/">可视化展示深度学习和人类</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>【原创】不用一句深度学习术语来讲解神经网络运作原理</title>
    <url>/2017/09/24/%E4%B8%8D%E7%94%A8%E4%B8%80%E5%8F%A5%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%AF%E8%AF%AD%E6%9D%A5%E8%AE%B2%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>原创文章，转载请注明出处</p>
</blockquote>
<h2 id="神经网络-多层级组织架构的公司"><a href="#神经网络-多层级组织架构的公司" class="headerlink" title="神经网络==多层级组织架构的公司"></a>神经网络==多层级组织架构的公司</h2><p>假设有一家公司，这家公司的组织架构是下面这种多层级的结构：</p>
<p><img src="/img/17_09_24/001.png" alt=""></p>
<p>公司每天接待一批固定数量的用户，这些用户会将自己的数据告诉给公司，公司做的事情就是通过每个用户上报的数据来推测当前用户群体整体所表现出来的状态。</p>
<p><img src="/img/17_09_24/002.png" alt=""></p>
<p>公司中直接与用户打交道的只有基层业务员，小部门经理只与基层业务员打交道，大部门经理只与小部门经理打交道…依此类推，层层递进，直到CEO这一层。</p>
<p>并且其中每一个基层业务员会了解每个用户的数据，每个小部门经理也会了解每个基层业务员输出的情况，…，依次类推，直到CEO。而CEO需要了解的是每个副总经理输出的情况。</p>
<p>公司拿到一批用户的数据之后，首先交给基层业务员。每个基层业务员看到了每个用户的数据之后，都会针对每一个用户出一份数据分析报表（由于每个人的观点不同，所以每个人得出的报表都不一样）；然后每个小部门经理也会分别去看每个业务员输出的报表，然后自己再输出一个针对每一个基层业务员输出的数据的分析报表；同样，每个大部门经理也会去这样看每个小部门经理输出的报表，然后出一份针对每一个小部门经理输出的数据的分析报表；…；以此类推，最终CEO会输出一个针对每一个副总经理输出的数据的分析报表，这份报表里就是公司当前对用户状态的理解。</p>
<p><img src="/img/17_09_24/003.png" alt=""></p>
<p>那么公司对用户状态把握到底准确不准确呢？这需要一个衡量标准。</p>
<p>所以我们需要对公司进行考核，将一部分已知状态的用户数据给到公司，看公司是否能足够准确的预测出这个状态。换句话说，就是CEO最后输出的这份报表，与用户的真实状态之间相差有多大。</p>
<p><img src="/img/17_09_24/004.png" alt=""></p>
<p>如果CEO发现自己的预测和真实情况偏差很大，它会带头思考自己工作上到底哪里做的不够好导致最终的判断失误，以及自己需要如何调整状态才能使公司表现更好，然后号召副总经理反思并调整状态。副总经理反思调整之后，会号召他的直属下级部门反思并调整状态。以此类推，直到基层业务员。但其实每个人都不能完全保证调整的状态是否可靠，所以大家就比较保守的<strong>稍微调整一下</strong>自己的工作状态。</p>
<p>当全公司员工调整状态完成之后，在面对新的用户数据，看是否能更加准确的预测用户群体的状态。如果发现上面的调整确实有效，那么继续按照上面的方式调整：由CEO再次依次号召下面的员工来调整工作状态，调整之后继续面对新的用户。重复执行上面的操作若干次之后，直到公司的预测效果趋于稳定为止（和真实状态对比之后，差值基本不再变化了）。</p>
<p><img src="/img/17_09_24/005.png" alt=""></p>
<p>此时的公司就相当于经历了若干次碰壁，并且若干次全员反思、调整状态之后，各个员工都成为了精兵强将了，对于用户数据的把握也更加准确了。</p>
<p>现在，我们回头看看公司接待的客户。假设公司每天共接待1024位用户，每个用户都举着一个纯色的卡片，卡片颜色是灰度值介于0到255之间的某个颜色。</p>
<p><img src="/img/17_09_24/006.png" alt=""></p>
<p>将这些用户按顺序排在32×32的平面上，每个用户占一格。当他们将手里的纯色卡片高举并拼凑起来之后，我们会看到一个写有数字的图片。</p>
<p><img src="/img/17_09_24/007.png" alt=""></p>
<p>公司做的事情就是每天接待这1024个用户，他们会告诉公司自己手里卡片的灰度值，但不会告诉公司卡片拼起来的图片是什么，然后公司经过层层分析来得出当前所有用户卡片拼起来的图像是什么。</p>
<p>这就是一个用户识别手写数字的DNN模型的形象比喻。</p>
<hr>
<h3 id="几个问题的思考"><a href="#几个问题的思考" class="headerlink" title="几个问题的思考"></a>几个问题的思考</h3><h4 id="公司员工数量一定的情况下，组织架构是越扁平越好，还是层级越多越好？"><a href="#公司员工数量一定的情况下，组织架构是越扁平越好，还是层级越多越好？" class="headerlink" title="公司员工数量一定的情况下，组织架构是越扁平越好，还是层级越多越好？"></a>公司员工数量一定的情况下，组织架构是越扁平越好，还是层级越多越好？</h4><p>扁平化的架构带来的好处是快速直接触达用户，但最终的准确率会比较低；多层级的架构带来的好处是更合理的分工，但会带来沟通和管理上的开销和数据损失。</p>
<p>所以如何设置公司层级是一门学问。</p>
<h4 id="每个员工是如何生成报表的？"><a href="#每个员工是如何生成报表的？" class="headerlink" title="每个员工是如何生成报表的？"></a>每个员工是如何生成报表的？</h4><p>每个员工根据自己对每个数据的重要程度的看法，计算出自己对每个数据的看法。然后在经过一层加工处理之后输出报表。</p>
<h4 id="公司招聘员工的时候，应该招聘类似的人群，还是招聘差异化的人群？"><a href="#公司招聘员工的时候，应该招聘类似的人群，还是招聘差异化的人群？" class="headerlink" title="公司招聘员工的时候，应该招聘类似的人群，还是招聘差异化的人群？"></a>公司招聘员工的时候，应该招聘类似的人群，还是招聘差异化的人群？</h4><p>应该招聘差异化大的人群，这样每个人能够产生对数据的不同看法。如果公司大部分人背景相似，那么他们对待同一类问题，产生的看法也都相似，没有多样化的观点，也容易导致公司做出错误判断。</p>
<hr>
<h3 id="带入术语"><a href="#带入术语" class="headerlink" title="带入术语"></a>带入术语</h3><ul>
<li>神经网络 -&gt; 多层级结构的公司</li>
<li>神经网络架构 -&gt; 公司组织架构</li>
<li>神经元 -&gt; 每一位员工</li>
<li>损失函数/代价函数 -&gt; 公司最终预测结果 - 真实结果</li>
<li>输入数据源 -&gt; 每天所有用户的卡片灰度值向量</li>
<li>输入数据标签值 -&gt; 所有用户卡片拼凑起来的数字图像的真实数值</li>
<li>反向传播 -&gt; 由CEO牵头，依次带领全公司员工反思</li>
<li>正向传递 -&gt; 带入每天的用户数据，层层递进，输出最终预测结果</li>
<li>激活函数 -&gt; 每个员工对数据的加工</li>
<li>参数 -&gt; 每个员工对数据的主观看法</li>
<li>随机初始化参数 -&gt; 招聘差异化人群</li>
<li>输入层 -&gt; 用户层</li>
<li>隐藏层 -&gt; 除了CEO之外的所有员工层级</li>
<li>输出层 -&gt; CEO层</li>
<li>梯度下降 -&gt; 公司朝着缩小预测错误程度的方向全员反思调整状态的过程</li>
<li>学习率 -&gt; 每次调整状态的程度α</li>
<li>训练/学习 -&gt; 带入大量已知状态的用户数据来根据公司的预测结果调整全员状态的过程</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>神经网络是一个灵活的结构，当带入图片像素值以及图片标签数据时，它训练的就是一个图片识别模型；当带入的数据是邮件特征数据，以及邮件是否为垃圾邮件的类别数据时，它可能就是一个垃圾邮件识别模型。</p>
<p>这里的类比并不严谨，准确的定义还需要参考标准定义。不过通过形象化的类比，可以使我们对神经网络建立起系统化的认知。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能五子棋实现原理</title>
    <url>/2016/03/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BA%94%E5%AD%90%E6%A3%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>这两天Alpha go 和李世石的围棋大战被炒的沸沸扬扬，今天李世石终于为人类扳回了挽回脸面的一局，不管是不是Alpha go故意放水，也不管是不是李世石找到了Alpha go的bug，总之这次围棋大战，是深度学习领域的一个影响深远的重大事件，更多的行业将开始更深入的关注人工智能深度学习领域了。个人认为，人工智能领域必定会成为即移动互联网之后的又一个更大的趋势。</p>
<p>好了，废话不多说，今天主要是展示一个这两天实现的一个五子棋AI，实现方式很简陋，完全不能和阿法狗相提并论，和大家分享的同时也当作自己练手，写的不好请多多包含。</p>
<p>项目地址见文章末尾。</p>
<hr>
<p>关于棋盘棋子的实现逻辑我就不多说了，大家可以看源码，并不复杂，说说AI部分的实现吧：</p>
<p>我的实现思路是：</p>
<p>当玩家走下一步棋的时候，AI要考虑两个因素：</p>
<p>1.走对自己获得胜利最有利的点（说白了就是最接近5子连线的点）</p>
<p>2.堵对对方获得胜利最有利的点（说白了就是堵对方的棋子）</p>
<p>做到这两步就能实现一个初级阶段的人工智能了。</p>
<p>那么接下来就讲讲<strong>关于计算获得胜利最有利的点</strong>是如何计算出来的：</p>
<p>其实原理也比较简单：</p>
<p>在棋盘上计算每个空白位置的点的4个方向（横向，纵向，左上角到右下角方向，右上角到左下角方向）每个有可能获胜的方向所连成的以当前棋子为出发点的长度为获胜棋子数量的（五子棋为5）中途没有被敌方棋子阻挡的所覆盖的己方棋子数。（是不是很绕，反正如果是我看到会被绕晕，没看懂不要紧，下面有栗子，对是栗子）得出每个方向上最大棋子数之后，然后取出每个棋子四个值里最大的值作为获胜权重（win_weight）。</p>
<p>以下图为例：</p>
<p><img src="/img/ai_01_01.png" alt=""></p>
<p>这是一个6x6的棋盘，现在我们来计算一下白子获胜的权重：</p>
<p><img src="/img/ai_01_02.png" alt=""></p>
<p>那么权重是如何计算的呢？举个栗子来说明吧：</p>
<p><img src="/img/ai_01_04.png" alt=""></p>
<p>首先定义这个棋盘坐标系x方向是向右的，y方向是向下的，左上角的位置是(0,0)，(x,y)可以定义一个棋子的坐标。定义xy方向为左上角到右下角方向，yx方向为右上角到左下角方向。</p>
<p>（0，0）点的权重计算：首先判断这一点没有连成5子的可能性，权重为0。</p>
<p>（0，2）点的权重计算：首先判断这一点没有连成5子的可能性，权重为0。</p>
<p>（0，3）点的权重计算：首先判断这一点有连成5子的可能性，接下来x轴方向上经过当前位置可连成五子的棋子有0个，y轴方向上经过当前位置可连成五子的棋子有1个，xy方向不存在连成5子的可能性，yx方向上不存在连成5子的可能性，四个方向中，取最大值，结果为1，那么当前点的获胜权重为1。</p>
<p>以此类推，可以得出所有空白点的白字获胜权重。</p>
<p>那么我们下一步让AI直接走获胜权重最大的点是不是就可以了呢？</p>
<p>非也非也。我们不能只考虑自己获胜，也要考虑防止对手获胜。那么如何防止对手获胜呢？我的方式就是走对手获胜权重最高的位置就可以了，就素堵住对方的棋子（传说中的走别人的路，让别人无路可走）。</p>
<p>同样的方式，我们可以求得黑子的获胜权重(win_weight)分布：</p>
<p><img src="/img/ai_01_03.png" alt=""></p>
<p>可以看出在(0,0),(0,2),(0,4),(0,5)这几个点是黑子获胜概率最大的点。白子走在这些点就可以堵住黑棋。</p>
<p>好的我们得到了白子赢得胜利最有利的点，以及白子阻止黑子获得胜利最有利的点，那么问题来了：我们到底该如何选择具体走哪个点呢？</p>
<p>有个比较粗劣的实现方式，就是将这两个权重相加，相当于将这两个条件同等来对待，认为对白子获得胜利的影响重要性是相同的，然后取加起来权重最高的点。</p>
<p>但实际情况是这两个条件对获得胜利的影响是不等价的，我们要想办法来得到描述这两者之间关系的公式。这里的实现方式有：</p>
<ul>
<li>1.通过试探法（就是瞎猜）</li>
</ul>
<p>尝试去将这两个参数相乘，取得的结果作为最终权重，来进行取值。</p>
<p>或者 白子的获胜权重 + R * 黑子的获胜权重， R是一个系数，我们需要通过不断的调整来接近最好的结果。</p>
<p>通过不断的尝试，来将最接近答案的公式猜出来。</p>
<ul>
<li>2.通过条件分情况来判断</li>
</ul>
<p>比如下过五子棋的人都知道一个常识：当对手有三子相连，是一个很危险的情况，如果自己目前没有三子相连，那么你应该去堵住对方的连在一起的三子。那么就可以判断，当对手的win_weight &gt;= 3 的时候，加入对手权重的判断，其余情况不考虑对手获胜权重。</p>
<ul>
<li>3.通过机器学习来让机器理解人类走棋的逻辑</li>
</ul>
<p>构建机器学习算法，通过大量的训练数据来训练机器，从而让机器通过历史数据来算出下一步该怎么走</p>
<p>我认为第三种方式是最理想的实现，因为前面两种无法覆盖到所有的情况。不过目前我只是做了第一种的简单的实现，接下来会考虑逐渐完善机器学习算法。</p>
<p>好了，这就是我实现五子棋AI的一个大致思路，有很多人问我什么是机器学习，我觉得在这里可以用一个简单的比喻告诉大家：</p>
<p>人生会经历很多事情，当你年幼无知的时候，可能会由于涉世未深而犯很多次错误，当你渐渐长大了，成熟了，经历的事情多了起来，尤其是当你犯错的时候，有人对你指出这样做是错的，你犯错误的次数就会慢慢减少，这个过程就像是一个机器学习的过程。</p>
<p>机器积累训练数据之前，很容易出错，经过大量的训练数据训练之后，就会做的越来越好，这就是机器学习。</p>
<p>好了，今天就写到这里，文笔不好，请多多见谅。</p>
<p>欢迎交流，互相学习，互相进步，转载请表明出处。</p>
<p>项目地址：<a href="https://github.com/DannyLee1991/AI_wuziqi">https://github.com/DannyLee1991/AI_wuziqi</a></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则之 依赖倒置原则</title>
    <url>/2015/09/16/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则（<strong>Dependence Inversion Principle,DIP</strong>） 它的原始定义是这样的：</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p>
</blockquote>
<p>翻译过来，包括三层含义</p>
<blockquote>
<p>1.高层模块不应该依赖低层模块，两者都应该依赖其抽象；</p>
<p>2.抽象不应该依赖细节；</p>
<p>3.细节应该依赖抽象。</p>
</blockquote>
<p>在Java语言中的表现就是：</p>
<blockquote>
<p>1.模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p>
<p>接口或抽象类不依赖于实现类；</p>
<p>实现类依赖接口或抽象类。</p>
</blockquote>
<p>更加精简的定义就是：</p>
<blockquote>
<p>面向接口编程 — OOD(Object-Oriented Design, 面向对象设计)的精髓之一.</p>
</blockquote>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>中国象棋 </p>
<p>每个棋子都拥有<strong>“移动（move）”</strong>的动作，但每个棋子的这个方法又有不同，比如<strong>“马走日，象走田”</strong>就是体现了移动的不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IChess</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPlayer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(IChess chess)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ma</span> <span class="keyword">implements</span> <span class="title">IChess</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;马走日&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xiang</span> <span class="keyword">implements</span> <span class="title">IChess</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;象走田&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPlayer</span> <span class="keyword">implements</span> <span class="title">IPlayer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(IChess chess)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;红方移动&quot;</span>);</span><br><span class="line">		chess.move();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackPlayer</span> <span class="keyword">implements</span> <span class="title">IPlayer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(IChess chess)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;黑方移动&quot;</span>);</span><br><span class="line">		chess.move();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clint</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		IChess ma = <span class="keyword">new</span> Ma();</span><br><span class="line">		IChess xiang = <span class="keyword">new</span> Xiang();</span><br><span class="line">		</span><br><span class="line">		IPlayer redPlayer = <span class="keyword">new</span> RedPlayer();</span><br><span class="line">		IPlayer blackPlayer = <span class="keyword">new</span> BlackPlayer();</span><br><span class="line">		</span><br><span class="line">		redPlayer.handle(ma);</span><br><span class="line">		blackPlayer.handle(xiang);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果:</span><br><span class="line"></span><br><span class="line">红方移动</span><br><span class="line">马走日</span><br><span class="line">黑方移动</span><br><span class="line">象走田</span><br></pre></td></tr></table></figure>
<h2 id="究竟何为依赖倒置"><a href="#究竟何为依赖倒置" class="headerlink" title="究竟何为依赖倒置"></a>究竟何为依赖倒置</h2><p>首先看依赖二字，依赖体现共通的逻辑，对接口方法的实现就是体现了子类依赖其接口或抽象类。</p>
<p>那么何为“倒置”呢？“倒置”是相对“正置”而言的，人类正常的思维方式都是正置的，怎么理解呢？就是我们接触到的都是具体实现类，比如马走日，就是指我们接触到的是马所行走的方式，而倒置就是指我们根据系统设计的角度，来找出事物间的抽象模型，抽取出抽象间的依赖，来代替传统思维中对事物间依赖关系的描述。比如“司机开车”就是抽象的依赖关系，其具体的实现包括“卡车司机开卡车”，“公交车司机开小轿车”等。</p>
<h2 id="依赖倒置原则的三个实现："><a href="#依赖倒置原则的三个实现：" class="headerlink" title="依赖倒置原则的三个实现："></a>依赖倒置原则的三个实现：</h2><p>1.构造函数传递依赖对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</span><br><span class="line">	<span class="comment">//司机的驾驶方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ICar car</span><br><span class="line">	<span class="comment">//构造函数注入</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">(ICar _car)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = _car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//司机的驾驶方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Setter方法传递依赖对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line">	<span class="comment">//车辆型号</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>;</span><br><span class="line">	<span class="comment">//司机的驾驶方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ICar car;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//司机的驾驶方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.接口声明依赖对象</p>
<p>上面对依赖倒置的举例就是接口声明的方式，该方法也叫做<strong>接口注入</strong></p>
<h2 id="建议遵循的规则"><a href="#建议遵循的规则" class="headerlink" title="建议遵循的规则"></a>建议遵循的规则</h2><p>1.每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</p>
<p>2.变量的表面类型尽量是接口或者是抽象类</p>
<p>3.任何类都不应该从具体类派生</p>
<p>4.尽量不要复写基类的方法</p>
<p>5.结合里氏替换原则使用</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>关于机器学习的一些思考</title>
    <url>/2017/03/05/%E5%85%B3%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>我大概是在两年前开始正式关注机器学习领域的，当时一心想做一个基于机器学习的五子棋程序，希望能达到机器自动理解五子棋游戏规则的效果，但没能成功，于是我开始找一些机器学习领域的课程和书籍开始啃。</p>
<p>当时机器学习在国内还是一个很少听到的名词，但当我学习这方面的东西的时候，我深深的感受到这个领域的东西和我之前学到的技术不是一个维度的东西，并且它将深远的影响未来的发展。直到后来AlphaGo的出现，以及Google开源了TensorFlow，这一系列的大事件的发生，悄然在业内刮起了一股人工智能风。</p>
<p>TensorFlow在开源之初，国内的<strong>极客学院</strong>发起了文档的翻译工作，还记的在其翻译文档的首页这样写到：</p>
<blockquote>
<p>你正在阅读的项目可能会比 Android 系统更加深远地影响着世界！</p>
</blockquote>
<p>不管这句话说得是否过于夸大，但TensorFlow在github上开源一个月之内就收到了10000+的star，这是github上机器学习领域也是python领域star增长最快的项目了。截止目前，TensorFlow的star为49227，已经超过了linux的42490。可见，机器学习的发展速度之迅猛，是不容小视的。</p>
<p>本文是我对机器学习领域的一些见解和思考，主要涉及<strong>机器学习的定义</strong>，<strong>机器学习的学习方式</strong>以及<strong>相关概念的理解</strong>。你会看到很多教科书上看不到的解读，虽然不是很严谨，但有助于你对一些概念建立起直觉上的理解，从而帮助你更好的了解这一领域的知识。</p>
<h2 id="思考1：机器学习是什么"><a href="#思考1：机器学习是什么" class="headerlink" title="思考1：机器学习是什么"></a>思考1：机器学习是什么</h2><h3 id="机器学习定义"><a href="#机器学习定义" class="headerlink" title="机器学习定义"></a>机器学习定义</h3><blockquote>
<p>机器学习(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p>
</blockquote>
<p>这是百度百科给出的定义，更加通俗的解释一下，机器学习是人工智能领域下的子领域，通过对大量现有数据的分析运算来对未知数据进行预测的一种学科。（虽然说法不严谨，但这种解释有助于理解）</p>
<p>将机器学习的通用模型类比于养一个小孩：</p>
<ul>
<li>训练过程就像是养一个小孩子</li>
<li>如果小孩子小的时候接触到了正确的教育（这里正确的教育就是<strong>训练数据集</strong>）</li>
<li>如果小孩子本身的悟性很高（悟性很高类比于有很好的<strong>学习算法</strong>）</li>
<li>那么这个孩子经过一段时间的成长学习后（类比于机器学习的<strong>训练</strong>阶段）</li>
<li>会成为一个有用之才（得到和很好的<strong>假设函数</strong>，即训练模型）</li>
<li>当他遇到新的人和事的时候（接受<strong>测试数据</strong>）</li>
<li>就能够处理的很好（<strong>预测结果</strong>）</li>
</ul>
<p>这就是机器学习的通用模型，虽然不是严谨的学术定义，但相信这能使你建立一种直觉上的认识。</p>
<h3 id="这是一项新技术吗？"><a href="#这是一项新技术吗？" class="headerlink" title="这是一项新技术吗？"></a>这是一项新技术吗？</h3><p>机器学习目前处于学术界迈向工业界的一个过程，其核心算法几十年前就有了，理念也绝非新鲜事物，达到工业级别是一个时间问题，而现在<strong>我们就处在这一学术界迈向工业界的关键阶段</strong>。</p>
<p>其实，机器学习的核心概念早在第一台计算机制造之前就已经产生了。这里也不做过多介绍，大家可以自行去搜索。</p>
<h2 id="思考2：如何学习机器学习"><a href="#思考2：如何学习机器学习" class="headerlink" title="思考2：如何学习机器学习"></a>思考2：如何学习机器学习</h2><h3 id="学习框架-or-学习算法"><a href="#学习框架-or-学习算法" class="headerlink" title="学习框架 or 学习算法?"></a>学习框架 or 学习算法?</h3><p>完全没有学过这一领域的东西，是否应该直接上手TensorFlow之类的框架呢？</p>
<p>框架只是工具，不管是TensorFlow还是Caffe还是Torch，都是对算法的封装，很多之前做其他方面开发的程序员，在接触一个框架或者工具时，都倾向于追求能达到“直接去调用一下就得到结果”这样的效果，但机器学习领域的框架并不是如此，它要求你对机器学习领域的算法有一定了解，要明白自己在做什么。</p>
<p>所以先对这个领域的算法知识有个掌握之后，再去学习和使用框架来实践操作可能是效率更高的一种学习模式。相反，直接上手来学习框架，期望直接调用一些API就得出结果的想法会让你有种寸步难行的感觉。</p>
<p>这里安利一下<a href="https://www.coursera.org/">coursera</a>上的吴恩达老师的<a href="https://www.coursera.org/learn/machine-learning">机器学习</a>课程（可能会需要翻墙才能访问，自行购买vpn）。这门课深入浅出的讲解了机器学习领域的流行的算法的实现原理。</p>
<blockquote>
<p>介绍一下吴恩达老师，在最强大脑第四季开播之前，可能知道他的人很少。吴恩达是华裔美国人，是斯坦福大学计算机科学系和电子工程系副教授，人工智能实验室主任，是Coursera的联合创始人。之前是google负责google大脑项目，后来在14年5月16日加入百度，担任百度首席科学家，负责百度研究院的领导工作，尤其是Baidu Brain计划。这是中国互联网公司迄今为止引进的最重量级人物。</p>
</blockquote>
<h3 id="深入底层-or-关注上层？"><a href="#深入底层-or-关注上层？" class="headerlink" title="深入底层 or 关注上层？"></a>深入底层 or 关注上层？</h3><p>在技术领域一直流传着这样一种理念：底层的就是牛X的。上层技术变化无常，但底层技术万变不离其宗。再加上底层技术的学习成本远高于上层技术，而且吃透了底层技术能够对上层技术有更深刻的理解，导致程序员对底层技术有一种神圣的向往情节。</p>
<p>技术领域，专注细节不是坏事，但对于机器学习这个领域呢？恐怕我们需要重新考量一下这种思维模式了。</p>
<p>其实在机器学习领域，也是提倡对底层实现算法有一定的了解的，但并不代表我们要去亲自实现一些算法，比如神经网络中的反向传播算法的实现，很多框架都已经写的很完善了，而且都是数值计算领域的专家来实现的高质量高性能的代码，我们没必要花时间和精力来重新造轮子，也没必要去研究他们是如何造的这个轮子。我们更应该把宝贵的时间留在理解这些算法的原理上，以及学会使用这些算法来应用到实际中的问题，这才是把好钢用到了刀刃上。</p>
<p>实际上，正确的学习方式是，首先学习并理解算法原理，在直觉层面建立起对算法的认识，然后快速动手实践，将学到的算法应用到小项目里，不用太过在意写的东西是不是很挫，重要的是开始写！然后再不断的完善你的项目。带着一些问题去继续学习，你会有更多的收获。</p>
<h3 id="不要想太多有的没的"><a href="#不要想太多有的没的" class="headerlink" title="不要想太多有的没的"></a>不要想太多有的没的</h3><p>可能很多人跟我一样，刚开始了解这一领域的东西的时候，很是兴奋，感觉造出一个通用人工智能指日可待了。再加上近些年随着人工智能概念的兴起，出来了一批相关影视作品和科幻小说，更让我们对人工智能产生了一系列不切实际的想法。</p>
<p>对于这一点，我想说明的是，不要过分执迷于AI能创建出智能大脑的想法，除非你是业内出类拔萃的专家。科幻小说与电影只是一种艺术表现手法，并不代表着未来。通常，人们看不懂看不透的地方就容易形成骗局，通用智能虽然是人工智能一直以来在追求的一个目标，但目前主流学术发展方向并没有朝着这方面走。机器学习、深度学习的确在飞速的进步，未来也会波及到很多行业，但这个学科归根结底还是一门基于数据的学科，并没有达到拥有情感、独立思考等这方面的能力，实际上，绝大多数业内专家对这方面的想法是持有厌恶态度的，倒是相关的社科类软文在这个时代被吹上了天。</p>
<p>因此，与其花时间想这些有的没的，还不如花时间脚踏实地的去学习一下算法、写写代码，除非你想成为一个科幻小说作家。</p>
<h2 id="思考3：机器学习中一些概念的解读"><a href="#思考3：机器学习中一些概念的解读" class="headerlink" title="思考3：机器学习中一些概念的解读"></a>思考3：机器学习中一些概念的解读</h2><p>机器学习领域中有很多很有趣、很耐人寻味的原理值得细细品味，下面是我对其中部分概念的直觉上的理解，可能你在教科书或者教学视频上看不到这种解读，但这些概念所折射出来的现象也许就是我所描述的那样。当然，如果你没有看过这个领域，甚至没有写过代码也没关系，我保证能让你能读得懂。</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p><strong>神经网络</strong>是机器学习领域出镜率很高的一个词汇，很多人对它的理解一直是停留在“<strong>很牛X，很复杂</strong>”的状态。下面用一个例子来解释神经网络的使用原理：</p>
<p>假设你有一个下周六是否要去电影院看电影的决定。这个决定的结果无非只有两种：<strong>去</strong>或者<strong>不去</strong>。</p>
<p>影响你去或不去的因素有很多：</p>
<ul>
<li>是否有人陪</li>
<li>是否有想看的电影</li>
<li>是否有时间</li>
<li>天气是否足够好</li>
<li>…</li>
</ul>
<p>我相信你可以列出足够多的理由来拒绝周末去看电影，但为了方便描述起见，我们先用三个条件：<strong>是否有人陪</strong>、<strong>是否有想看的电影</strong>、<strong>是否有时间</strong>。</p>
<p>好，现在我们来用三个圈来表示这三个条件。</p>
<p><img src="/img/17_03_05/002.png" alt=""></p>
<p>圆圈中间的数值代表对做出去看电影的决策的影响程度，可以看到这里<strong>是否有时间</strong>的影响程度是最大的（这里的每个小圈，其实就是神经网络中的<strong>神经元</strong>，上面的数值就是<strong>权值</strong>）。</p>
<p>我们接下来把我们的神经网络补充完整：</p>
<p><img src="/img/17_03_05/003.png" alt=""></p>
<p>我们又加了两个圈和一些箭头。好，对应图中，如果我们现在<strong>有想看的电影，可是没有人陪，但有时间</strong>，那么我们的计算方式就是:</p>
<p><img src="/img/17_03_05/004.png" alt=""></p>
<script type="math/tex; mode=display">
(-1)×0.3 + 1×0.6 + 1×1.0 = 1.3</script><p>输出结果是一个大于0的值：1.3，代表我们会做出去看电影的决定。</p>
<p>类似的，假如我们<strong>有人陪，有想看的电影，但是没时间</strong>：</p>
<script type="math/tex; mode=display">
1×0.3 + 1×0.6 + (-1)×1.0 = -0.1</script><p>是一个负数，代表我们不会去看电影。</p>
<p>这就是一个训练好的神经网络的使用方式，这幅图就是一个典型的三层神经网络，从左到右依次是<strong>输出层</strong>、<strong>隐藏层</strong>、<strong>输出层</strong>，其中0.3，0.6，1.0是通过<strong>训练</strong>得出的<strong>权值</strong>。</p>
<p><img src="/img/17_03_05/005.png" alt=""></p>
<p>我相信你对神经网络还是有很多疑问，比如0.3，0.6和1.0是怎么得来的（实际上是通过<strong>反向传播算法</strong>得来的），但神经网络运作的大体模式就是这样，希望你能对它产生一种宏观层面的认识。</p>
<h3 id="偏拟合-和-过拟合"><a href="#偏拟合-和-过拟合" class="headerlink" title="偏拟合 和 过拟合"></a>偏拟合 和 过拟合</h3><p><strong>偏拟合</strong>和<strong>过拟合</strong>具体是什么意思呢？不要被陌生的名词吓到。</p>
<p>首先要说明的是，这两个词都不是褒义词，都是我们不想看到的一种状态。</p>
<p>其实所谓<strong>偏拟合</strong>就是相当于某一领域经验不足的人，由于经历的事情太少，容易做出一些错误的判断，这种现象就是<strong>偏拟合</strong>。</p>
<p>所谓<strong>过拟合</strong>，恰恰相反，是指某一领域经验非常丰富的人，由于经历的事情太多，反而容易对新的事物产生偏见（因为既往的经验会告诉他这是不对的），从而产生错误的决定。</p>
<p>教科书上不会这么解释<strong>偏拟合</strong>和<strong>过拟合</strong>的概念，但事实上这个概念描述的就是这样的现象。是不是我们身边随处可见这两种现象呢？</p>
<h3 id="查准率-和-召回率"><a href="#查准率-和-召回率" class="headerlink" title="查准率 和 召回率"></a>查准率 和 召回率</h3><p>假设我们现在写了个用于预测病人是否患有肺癌的程序，我们出入了100个病人的体征数据，然后来告知这一批病人有谁不幸得了肺癌。</p>
<p>假设我们的预测准确率为98%，这个结果乍一看是不是很高呢？但我告诉你另一个事实，那就是我们只有两个病人是真正患有肺癌的，然而我们的算法正确的识别了两者中的一位，并且还错误的认为在98名没有患有肺癌的患者里有一位癌症患者。那这还是一个好结果吗？</p>
<p>很明显，100个人里只有两个人患有癌症，其中一个还预测错误，这是一个很差的结果，但我们的准确率为98%，因为我们预测对了100个人中的98个人，所以从准确率上来看并不差，但实际结果却很差。</p>
<p>这就是典型的<strong>偏斜类</strong>问题。</p>
<p>也许有人会说，这表明了数据会说谎，但实际情况是，数据并没有说谎，只不过我们看待数据的方式不够科学。</p>
<p>科学的方式就是引入<strong>查准率</strong>和<strong>召回率</strong>。</p>
<p>在这里:</p>
<script type="math/tex; mode=display">
查准率 = \frac{在预测患有肺癌的病人中，预测正确的数量} {预测患有肺癌的病人数量}</script><script type="math/tex; mode=display">
召回率 = \frac{在预测患有肺癌的病人中，预测正确的数量} {实际患有肺癌病人的数量}</script><p>可见，<strong>查准率</strong>和<strong>召回率</strong>都是越高越好的。</p>
<p>那么我们的例子中<strong>查准率</strong>和<strong>召回率</strong>的真实值分别为：</p>
<script type="math/tex; mode=display">
查准率 = \frac{在预测患有肺癌的病人中，预测正确的数量} {预测患有肺癌的病人数量} = \frac{1} {2} = 0.5</script><script type="math/tex; mode=display">
召回率 = \frac{在预测患有肺癌的病人中，预测正确的数量} {实际患有肺癌病人的数量} = \frac{1} {2} = 0.5</script><p>我们的查准率和召回率都很低。所以换个角度来看待数据，会有新的发现。</p>
<p>查准率和召回率是两个维度的数据，有的时候我们为了追求高查准率，会得到一个低召回率的结果；有的时候我们为了追求高召回率，却会得到一个低查准率的结果。这种顾此失彼的状态，也不是我们想要。</p>
<p>所以我们引入了一个叫做<strong>Fscore</strong>的方法来对两种进行一个整体的衡量，其表达式为：</p>
<script type="math/tex; mode=display">
Fscore = \frac{查准率×召回率} {查准率+召回率}</script><p>这里我们的$Fscore=0.25$。</p>
<p>我们生活中也处处充满着<strong>准确率高但查准率和召回率低的例子</strong>：</p>
<p>我们往往会有这种体验，一些成功的名人说的话似乎都很有道理，但其实他们说的有道理的话似乎都比较“大”；而有些人，专注于某一特定领域的专家，在发表一些观点的时候，用词都非常谨慎，因为他们在描述一件具体的事物。</p>
<p>所以，我们会发现，<strong>越“大”的话，越容易获得较高的准确率；越“专”的话，越不容易获得较高的准确率</strong>。</p>
<p>所以带着这种角度，我们去审视一下：</p>
<ul>
<li>失败是成功之母。</li>
<li>天才是99%的汗水加1%的灵感。</li>
<li>…</li>
</ul>
<p>类似这类的<strong>鸡汤名言</strong>，我们会有新的思考。我们会发现，真正的牛人说的话，不仅仅准确率高，而且查准率和召回率也很高。</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p><strong>无监督学习</strong>是相对于<strong>监督学习</strong>而言的。那么什么是<strong>监督学习</strong>呢？</p>
<p><strong>监督学习</strong>通俗的将就是我们告诉机器一堆格式为：</p>
<p><strong>bulabulabula的东西，是xxx</strong></p>
<p>来预测未知类别的数据：</p>
<p><strong>bulabulabula的东西，是？</strong></p>
<p>例如通过体征来预测性别：</p>
<p>已有100个数据：</p>
<ul>
<li>身高175cm，短发，70kg的人是男性</li>
<li>身高165cm，长发，48kg的人是女性</li>
<li>…</li>
</ul>
<p>那么：</p>
<ul>
<li>身高170cm，长发，55kg的人是？</li>
</ul>
<p>这种预测类别已知的机器学习，就是<strong>监督学习</strong>。典型的<strong>监督学习</strong>的案例有<strong>语音识别</strong>、<strong>图像识别</strong>、<strong>人脸识别</strong>等等。</p>
<p>所谓<strong>无监督学习</strong>就是我们并不能知道数据所属的类别，通过算法使数据自动地按照相似的类别聚合起来，即所谓的<strong>聚类算法</strong>。</p>
<p>我们俗话所说的<strong>物以类聚，人以群分</strong>就是无监督学习的体现。</p>
<p>其实，仔细想想，人类社会的发展演化过程，是不是就是一个大型的<strong>无监督学习</strong>的过程呢？我们都是这个学习过程中的一环，是这个大型的神经网络中的一个神经元，我们社会的发展形态和目标在各个阶段都是不一样的，即使我们无法过远地预测到未来进化的方向，但我们一直在自我学习的过程中不断进化。也许这正是生命的本质。</p>
<hr>
<p>以上观点可能不是很严谨，也不是正统的机器学习理论，是本人对机器学习的一些思考。如有概念上的错误，欢迎斧正。也欢迎在评论区和我一起讨论<strong>机器学习</strong>的相关问题。</p>
<p>非常感谢您能读完我的文章，最后安利一下我的一个实验项目<a href="http://118.190.96.169:3389/iw/help/">智能背词算法</a>，目前处于数据采集阶段，具体使用方式见帮助页面。谢谢~</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则之 单一职责原则</title>
    <url>/2015/09/06/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则的英文名称是<strong>Single Responsibility Principle</strong>,简称<strong>SRP</strong>.</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>单一职责的定义是：</strong></p>
<blockquote>
<p>There should never be more than one reason for a class to change.</p>
<p>应该有且仅有一个原因引起类的变更。</p>
</blockquote>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例如IUserInfo接口定义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">IUserInfo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+void setUserID(String userID)</td>
</tr>
<tr>
<td style="text-align:left">+String getUserID()</td>
</tr>
<tr>
<td style="text-align:left">+void setPassword(String password)</td>
</tr>
<tr>
<td style="text-align:left">+String getPassword()</td>
</tr>
<tr>
<td style="text-align:left">+void setUserName(String userName)</td>
</tr>
<tr>
<td style="text-align:left">+String getUserName()</td>
</tr>
<tr>
<td style="text-align:left">+boolean changePassword(String oldPassword)</td>
</tr>
<tr>
<td style="text-align:left">+boolean deleteUser()</td>
</tr>
<tr>
<td style="text-align:left">+void mapUser()</td>
</tr>
<tr>
<td style="text-align:left">+boolean addOrg(int orgID)</td>
</tr>
<tr>
<td style="text-align:left">+boolean addRole(int roleID)</td>
</tr>
</tbody>
</table>
</div>
<p>这个接口按照<strong>单一职责</strong>的原则进行拆分，将<strong>用户信息</strong>抽取成一个<strong>BO</strong>(Business Object,业务对象)，将<strong>用户行为</strong>抽取成一个<strong>Biz</strong>(Business Logic,业务逻辑)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">IUserBO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+void setUserID(String userID)</td>
</tr>
<tr>
<td style="text-align:left">+String getUserID()</td>
</tr>
<tr>
<td style="text-align:left">+void setPassword(String password)</td>
</tr>
<tr>
<td style="text-align:left">+String getPassword()</td>
</tr>
<tr>
<td style="text-align:left">+void setUserName(String userName)</td>
</tr>
<tr>
<td style="text-align:left">+String getUserName()</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">IUserBiz</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+boolean changePassword(String oldPassword)</td>
</tr>
<tr>
<td style="text-align:left">+boolean deleteUser()</td>
</tr>
<tr>
<td style="text-align:left">+void mapUser()</td>
</tr>
<tr>
<td style="text-align:left">+boolean addOrg(int orgID)</td>
</tr>
<tr>
<td style="text-align:left">+boolean addRole(int roleID)</td>
</tr>
</tbody>
</table>
</div>
<p>IUserInfo接口继承IUserBO和IUserBiz</p>
<p>分清职责后的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">IUserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line"><span class="comment">//我要赋值了，我就认为它是一个纯粹的BO</span></span><br><span class="line">IUserBO userBO = (IUserBO)userInfo;</span><br><span class="line">userBO.setPassword(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//我要执行动作了，我就认为是一个业务逻辑类</span></span><br><span class="line">IUserBiz userBiz = (IUserBiz)userInfo;</span><br><span class="line">userBiz.deleteUser();</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p>单一职责原则最难划分的就是职责。一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责那些职责？这些职责该怎样细化？细化后是否都要有一个接口或类？这些都需要从实际的项目去考虑。</p>
<p>对于接口，我们在设计的时候一定要做到单一，但是对于实现类酒需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的，硬要拆成两个类，然后再使用聚合或组合的方式藕合在一起，人为地制造了系统的复杂性。<strong><em>所以原则是死的，人是活的，这句话很有道理。</em></strong></p>
<p>单一职责适用于接口，类，同时也适用于方法，什么意思呢？一个方法尽可能只做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法点颗粒度很粗，比如下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个方法承担多个职责</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeUser</span><span class="params">(IUserBO userBO,String..changeOptions)</span></span></span><br></pre></td></tr></table></figure>
<p>相比较而言，比较好的写法应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeUserName</span><span class="params">(String newUserName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeHomeAddress</span><span class="params">(String newHomeAddress)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeOfficeTel</span><span class="params">(String telNumber)</span></span></span><br></pre></td></tr></table></figure>
<p>对于单一职责原则，笔者的建议是<strong><em>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</em></strong></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>发布aar到jcenter的正确姿势</title>
    <url>/2016/12/03/%E5%8F%91%E5%B8%83aar%E5%88%B0jcenter%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>前段时间开发了一个android测试小插件<a href="https://github.com/DannyLee1991/ATestKit">ATestKit</a>，准备发布到jcenter库中，可期间碰壁无数，折腾了两天最终终于上传成功。</p>
<p>下面是我的最终整理：</p>
<h2 id="上传aar到jcenter的正确姿势"><a href="#上传aar到jcenter的正确姿势" class="headerlink" title="上传aar到jcenter的正确姿势"></a>上传aar到jcenter的正确姿势</h2><p>打开<a href="https://bintray.com">https://bintray.com</a>。</p>
<h3 id="第一坑：你需要一个vpn。"><a href="#第一坑：你需要一个vpn。" class="headerlink" title="第一坑：你需要一个vpn。"></a>第一坑：你需要一个vpn。</h3><p>注册时国内的qq邮箱，163邮箱通通用不了，gmail可用。</p>
<p>天朝国情，访问google需要翻墙，不解释。</p>
<h3 id="第二坑：注意注册入口"><a href="#第二坑：注意注册入口" class="headerlink" title="第二坑：注意注册入口"></a>第二坑：注意注册入口</h3><p>首页有一个<strong>START YOUR FREE TRIAL</strong>:</p>
<p><img src="/img/16_12_03/001.png" alt=""></p>
<p>如果你按照网上搜到排名很靠前的的其他教程来进行，比如说这几篇：</p>
<ul>
<li><a href="http://blog.csdn.net/wwj_748/article/details/51913280">Android Library上传到JCenter仓库实践</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/51148825">Android 快速发布开源项目到jcenter</a></li>
<li><a href="http://www.cnblogs.com/qianxudetianxia/p/4322331.html">使用Gradle发布aar项目到JCenter仓库</a></li>
<li><a href="http://www.jianshu.com/p/31410d71eaba">Android Studio提交库至Bintray jCenter从入门到放弃</a></li>
</ul>
<p>那么恭喜你，你成功的入坑了，你会发现按照他们的配置一步步进行，但到最后就是不成功，而且错误的提示也很不明确，让你找不到一点头绪。</p>
<p>仔细看看，你看到的jcenter的个人主页似乎和他们的不太一样。</p>
<p>原因可能是因为bintray.com这个网站改版了，导致注册流程和以前不一样了，如果你点击上图的那个注册入口，会引导你创建一个组织，然后你只能在组织下新建自己的仓库，而上面的几篇文章根本就没有组织这一说啊。</p>
<p>在这里有一个关于网站首页的说明：</p>
<p><a href="https://bintray.com/docs/usermanual/starting/starting_gettingstarted.html#_the_bintray_homepage">https://bintray.com/docs/usermanual/starting/starting_gettingstarted.html#_the_bintray_homepage</a></p>
<p>注意看这里：</p>
<p><img src="/img/16_12_03/003.png" alt=""></p>
<p>好吧，难道说明我们还有另外一个针对于open source plan的注册入口吗？这个入口听起来有点像上面几篇文章描述的那样啊。</p>
<p>果然有！</p>
<p>继续回到首页，拉到页面最底端，有另外一个入口：</p>
<p><img src="/img/16_12_03/004.png" alt=""></p>
<p>从这里注册进入，你就可以不用创建组织了。</p>
<h3 id="第三坑：收费？！"><a href="#第三坑：收费？！" class="headerlink" title="第三坑：收费？！"></a>第三坑：收费？！</h3><p>如果你不幸点击了首页的<strong>START YOUR FREE TRIAL</strong>，那么你的首页上会有这么一个奇怪的标识：</p>
<p><img src="/img/16_12_03/007.png" alt=""></p>
<p>点进来看一看，虽然没有明确说免费版到期后会怎样，但手动终止免费版后会删掉你库里所有的东东：</p>
<p><img src="/img/16_12_03/008.png" alt=""></p>
<p>如果想继续使用，那么150刀一月。</p>
<p><strong>没想到jcenter如此恶毒的把免费试用入口放在最显眼的位置，而且不明确告诉你试用账号到期后的后果，并且把免费使用的社区版入口藏的那么深。</strong></p>
<h3 id="正常配置流程"><a href="#正常配置流程" class="headerlink" title="正常配置流程"></a>正常配置流程</h3><p>通过社区版注册入口进入之后，就没有了奇怪的标识，我们可以创建一个个人仓库了：</p>
<p><img src="/img/16_12_03/009.png" alt=""></p>
<p>配置选择public，类型选择Maven：</p>
<p><img src="/img/16_12_03/010.png" alt=""></p>
<p>然后创建新的Package：</p>
<p><img src="/img/16_12_03/011.png" alt=""></p>
<p>填写相关信息：</p>
<p><img src="/img/16_12_03/012.png" alt=""></p>
<p>在你的编辑你android项目根目录下的<code>build.gradle</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#39;com.android.tools.build:gradle:2.2.0&#39;</span><br><span class="line">        &#x2F;&#x2F; 添加上传到jcenter所需的插件</span><br><span class="line">        classpath &#39;com.github.dcendents:android-maven-gradle-plugin:1.5&#39;</span><br><span class="line">        classpath &#39;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.1&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编辑library下的<code>build.gradle</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;com.android.library&#39;</span><br><span class="line">apply plugin: &#39;com.github.dcendents.android-maven&#39;</span><br><span class="line">apply plugin: &#39;com.jfrog.bintray&#39;</span><br><span class="line"></span><br><span class="line">version &#x3D; &quot;0.2&quot;	&#x2F;&#x2F;aar的版本号</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;23.0.3&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 14</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br><span class="line">    compile &#39;com.android.support:appcompat-v7:23.4.0&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def siteUrl &#x3D; &#39;https:&#x2F;&#x2F;github.com&#x2F;DannyLee1991&#x2F;ATestKit&#39;    &#x2F;&#x2F; 项目主页</span><br><span class="line">def gitUrl &#x3D; &#39;https:&#x2F;&#x2F;github.com&#x2F;DannyLee1991&#x2F;ATestKit.git&#39; &#x2F;&#x2F; 项目的git地址</span><br><span class="line">def module_name &#x3D; &#39;ATestKit&#39;	&#x2F;&#x2F; 项目的名称</span><br><span class="line">group &#x3D; &#39;com.dannylee&#39;	&#x2F;&#x2F; 所在组</span><br><span class="line"></span><br><span class="line">install &#123;</span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        &#x2F;&#x2F; This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &#39;aar&#39;</span><br><span class="line">                name &#39;ATestKit&#39; &#x2F;&#x2F; 名称</span><br><span class="line">                url siteUrl</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &#39;The Apache Software License, Version 2.0&#39; &#x2F;&#x2F; 开源协议名称</span><br><span class="line">                        url &#39;http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0.txt&#39; &#x2F;&#x2F; 协议地址</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id &#39;dannylee&#39;	&#x2F;&#x2F; 账号</span><br><span class="line">                        name &#39;dannylee&#39;	&#x2F;&#x2F; 名称</span><br><span class="line">                        email &#39;leejianan1@gmail.com&#39; &#x2F;&#x2F; 邮箱地址</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier &#x3D; &#39;sources&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source &#x3D; android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath +&#x3D; project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier &#x3D; &#39;javadoc&#39;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Properties properties &#x3D; new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&#39;local.properties&#39;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">	 &#x2F;&#x2F; 读取配置文件中的用户名和key</span><br><span class="line">    user &#x3D; properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key &#x3D; properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations &#x3D; [&#39;archives&#39;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo &#x3D; &quot;maven&quot;		&#x2F;&#x2F; 你在bintray上创建的库的名称</span><br><span class="line">        name &#x3D; module_name               &#x2F;&#x2F; 在jcenter中的项目名称</span><br><span class="line">        websiteUrl &#x3D; siteUrl</span><br><span class="line">        vcsUrl &#x3D; gitUrl</span><br><span class="line">        licenses &#x3D; [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到bintray，在你的个人信息配置页中，查看APK Key：</p>
<p><img src="/img/16_12_03/013.png" alt=""></p>
<p><img src="/img/16_12_03/014.png" alt=""></p>
<p>在项目根目录下创建<code>local.properties</code>配置文件（如果有就直接打开），写入账号信息：</p>
<p><img src="/img/16_12_03/015.png" alt=""></p>
<p>由于key是比较重要的信息，不能泄露出去，所以需要编辑<code>.gitignore</code>添加过滤规则来把它过滤掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local configuration file (sdk path, etc)</span><br><span class="line">local.properties</span><br></pre></td></tr></table></figure>
<p>然后命令行进入到你的library项目中执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradle build</span><br></pre></td></tr></table></figure>
<p>比较坑的是有的时候可能会失败，多试几次就会成功。</p>
<p>成功之后执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradle bintrayUpload</span><br></pre></td></tr></table></figure>
<p>如果不出意外的话，会成功上传，如果失败了，很有可能是你的网络问题，换个vpn试试说不定可以成功。如果是其他原因的失败，请自行google。</p>
<p>回到jcenter中项目的管理页面，就可以看到上传的版本信息了，点击<strong>Add to JCenter</strong>就可以正式上传到jcenter中了：</p>
<p><img src="/img/16_12_03/016.png" alt=""></p>
<p>上传后，需要系统审核大概半小时，之后就可以在你的项目中使用这个aar了：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compile &#39;com.dannylee:atestkit:0.2&#39;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>如果你选择的是第一个注册入口，流程也是一样的，唯一不同的就是在library中的<code>build.gradle</code>中要填写组织名称，否则也找不到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install &#123;</span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        &#x2F;&#x2F; This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">            	   userOrg &#39;your organisation name&#39; &#x2F;&#x2F; 填写组织名称</span><br><span class="line">                ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>房价预测（1）-搜房网数据爬取</title>
    <url>/2016/11/30/%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%EF%BC%881%EF%BC%89-%E6%90%9C%E6%88%BF%E7%BD%91%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<h2 id="搜房网数据爬取"><a href="#搜房网数据爬取" class="headerlink" title="搜房网数据爬取"></a>搜房网数据爬取</h2><blockquote>
<p>如今<strong>房事</strong>牵动着每家每户的心，所以以搜房网数据为例，用程序员的角度去客观分析一下房价走势，并对房价数据进行预测，也顺便对学到的<strong>机器学习</strong>相关知识练练手。</p>
</blockquote>
<h3 id="爬虫Scrapy"><a href="#爬虫Scrapy" class="headerlink" title="爬虫Scrapy"></a>爬虫Scrapy</h3><p>数据分析的第一步，当然是数据的采集。这里我使用的是<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/">Scrpy</a>。这是一个开源的python爬虫框架，可以很方便的处理很多爬虫方面的工作，而且中文的文档写的也比较明确。</p>
<p>安装好python环境后，通过pip即可安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install Scrapy</span><br></pre></td></tr></table></figure>
<p>具体使用方式，可以看一下这个<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/intro/tutorial.html">Scrapy入门教程</a>，也不难，这里就不做过多的介绍了。</p>
<h3 id="fang-com从何处入手呢？"><a href="#fang-com从何处入手呢？" class="headerlink" title="fang.com从何处入手呢？"></a>fang.com从何处入手呢？</h3><p>大致了解了Scrapy的用法之后，我们就可以实际操作一把了。那么我们面对搜房网这个庞然大物到底要从何处开始爬呢？</p>
<p>首先，先声明一下我的目的：目的是分析房价数据，所以要爬取的数据主要是每个房源信息的数据咯。</p>
<p>想要拿到每条房源信息的url，通常我们是拿到每个列表页的数据。</p>
<p>那么我们第一个要爬取的数据就是房源列表信息了。</p>
<h4 id="列表爬取"><a href="#列表爬取" class="headerlink" title="列表爬取"></a>列表爬取</h4><p>所谓列表页，就是这个页面：<a href="http://esf.sh.fang.com/housing/">上海二手房</a>，下面“全部小区”部分的列表信息就是我们想要的。</p>
<p>通过观察搜房网，我发现还有另外一个列表页入口，看起来似乎更容易爬取一些，就是：<a href="http://esf.sh.fang.com/map/">地图页</a>。</p>
<p>在这个页面左侧有个列表：</p>
<p><img src="/img/16_11_30/001.png" alt=""></p>
<p>进一步点击这个列表，最后我们可以得到这个页面：</p>
<p><img src="/img/16_11_30/002.png" alt=""></p>
<p>通过抓包工具，我们可以看到这个列表通过Ajax发送get请求，得到一段json数据：</p>
<p><img src="/img/16_11_30/003.png" alt=""></p>
<p>我们真正想要的数据在这段json中最后的<code>item</code>中：</p>
<p><img src="/img/16_11_30/004.png" alt=""></p>
<p>这里藏的就是这个列表的html代码。</p>
<p>回过头来，再来看看我们请求的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;esf.sh.fang.com&#x2F;map&#x2F;?mapmode&#x3D;y&amp;district&#x3D;996&amp;subwayline&#x3D;&amp;subwaystation&#x3D;&amp;price&#x3D;&amp;room&#x3D;&amp;area&#x3D;&amp;towards&#x3D;&amp;floor&#x3D;&amp;hage&#x3D;&amp;equipment&#x3D;&amp;keyword&#x3D;&amp;comarea&#x3D;21929&amp;orderby&#x3D;30&amp;isyouhui&#x3D;&amp;x1&#x3D;120.798&amp;y1&#x3D;30.926054&amp;x2&#x3D;122.177798&amp;y2&#x3D;31.571157&amp;newCode&#x3D;&amp;houseNum&#x3D;&amp;schoolDist&#x3D;&amp;schoolid&#x3D;&amp;ecshop&#x3D;ecshophouse&amp;PageNo&#x3D;1&amp;zoom&#x3D;16&amp;a&#x3D;ajaxSearch&amp;city&#x3D;sh&amp;searchtype&#x3D;loupan</span><br></pre></td></tr></table></figure>
<p>这里需要凭借直觉来剔除掉一些多余的参数的，至少满足请求到的数据不是局限于<strong>崇明区</strong>的，而是全上海的。</p>
<p>经过一些尝试之后，我发现下面这个url可以请求到全部的列表数据，其中<code>PageNo</code>参数是页数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;esf.sh.fang.com&#x2F;map&#x2F;?mapmode&#x3D;y&amp;orderby&#x3D;30&amp;ecshop&#x3D;ecshophouse&amp;PageNo&#x3D;2&amp;a&#x3D;ajaxSearch&amp;city&#x3D;sh&amp;searchtype&#x3D;loupan</span><br></pre></td></tr></table></figure>
<p>我们可以先通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy shell &quot;http:&#x2F;&#x2F;esf.sh.fang.com&#x2F;map&#x2F;?mapmode&#x3D;y&amp;orderby&#x3D;30&amp;ecshop&#x3D;ecshophouse&amp;PageNo&#x3D;2&amp;a&#x3D;ajaxSearch&amp;city&#x3D;sh&amp;searchtype&#x3D;loupan&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来找出房源详情页的url。</p>
<p>最终，我发现通过<code>response.xpath(&quot;//a/@href&quot;).extract()</code>可以提取出所有的链接地址，其中如果url中包含<code>&quot;esf&quot;</code>字符串，是二手房房源的url地址。所以<code>parse()</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line"></span><br><span class="line">        infos &#x3D; response.xpath(&quot;&#x2F;&#x2F;a&#x2F;@href&quot;).extract()</span><br><span class="line"></span><br><span class="line">        for i in infos:</span><br><span class="line">            i_str &#x3D; str(i).encode(&quot;utf-8&quot;)</span><br><span class="line">            if &quot;esf&quot; in i_str:</span><br><span class="line">                url &#x3D; i_str.replace(&#39;\\&#39;, &#39;&#39;).strip()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样我们就得到了所有二手房房源详情页面的url了。</p>
<blockquote>
<p>这里有一个小坑：</p>
<p>这一行代码<code>i_str = str(i).encode(&quot;utf-8&quot;)</code>中，由于i默认没有解码成utf-8的格式，所以不能直接和字符串<code>&quot;esf&quot;</code>进行运算，所以需要一部encode操作。</p>
</blockquote>
<h4 id="详情页爬取"><a href="#详情页爬取" class="headerlink" title="详情页爬取"></a>详情页爬取</h4><p>对于详情页，我主要想爬取的数据如下：</p>
<p><img src="/img/16_11_30/005.png" alt=""></p>
<p>这个页面似乎没有什么取巧的方式了，只能硬着头皮去看他的源码，一层层的抽取了。下面是详情页解析的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse_details(self, response):</span><br><span class="line"></span><br><span class="line">        # path</span><br><span class="line">        xpath &#x3D; &quot;&#x2F;&#x2F;body&#x2F;div[@class&#x3D;&#39;wrap&#39;]&#x2F;div[@class&#x3D;&#39;main clearfix&#39;]&#x2F;div[@class&#x3D;&#39;mainBoxL&#39;]&quot;</span><br><span class="line">        div_title &#x3D; &quot;&#x2F;div[@class&#x3D;&#39;title&#39;]&quot;</span><br><span class="line">        p_gray9 &#x3D; &quot;&#x2F;p[@class&#x3D;&#39;gray9&#39;]&quot;</span><br><span class="line">        h1 &#x3D; &quot;&#x2F;h1&quot;</span><br><span class="line">        span_mr10 &#x3D; &quot;&#x2F;span[@class&#x3D;&#39;mr10&#39;]&quot;</span><br><span class="line">        div_houseInfor_clearfix &#x3D; &quot;&#x2F;div[@class&#x3D;&#39;houseInfor clearfix&#39;]&quot;</span><br><span class="line">        div_inforTxt &#x3D; &quot;&#x2F;div[@class&#x3D;&#39;inforTxt&#39;]&quot;</span><br><span class="line">        dl &#x3D; &quot;&#x2F;dl&quot;</span><br><span class="line">        dt_gray6_zongjia1 &#x3D; &quot;&#x2F;dt[@class&#x3D;&#39;gray6 zongjia1&#39;]&quot;</span><br><span class="line">        span_red20b &#x3D; &quot;&#x2F;span[@class&#x3D;&#39;red20b&#39;]&quot;</span><br><span class="line">        dd_gray6 &#x3D; &quot;&#x2F;dd[@class&#x3D;&#39;gray6&#39;]&quot;</span><br><span class="line">        dd &#x3D; &quot;&#x2F;dd&quot;</span><br><span class="line">        dt &#x3D; &quot;&#x2F;dt&quot;</span><br><span class="line"></span><br><span class="line">        item &#x3D; ESFItem()</span><br><span class="line">        item[&#39;id&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                    div_title +</span><br><span class="line">                                    p_gray9 +</span><br><span class="line">                                    span_mr10).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        item[&#39;publish_time&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                              div_title +</span><br><span class="line">                                              p_gray9).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        item[&#39;title&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                       div_title +</span><br><span class="line">                                       h1).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        item[&#39;total_price&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                             div_houseInfor_clearfix +</span><br><span class="line">                                             div_inforTxt +</span><br><span class="line">                                             dl +</span><br><span class="line">                                             dt_gray6_zongjia1 +</span><br><span class="line">                                             span_red20b).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        dd_infos &#x3D; response.xpath(xpath + div_houseInfor_clearfix + div_inforTxt + dl + dd).extract()</span><br><span class="line">        huxing_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;户&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;型：&quot;</span><br><span class="line">        jzmj_str &#x3D; &quot;&lt;dd class&#x3D;\&quot;gray6\&quot;&gt;建筑面积：&lt;span class&#x3D;\&quot;black \&quot;&gt;&quot;</span><br><span class="line">        symj_str &#x3D; &quot;&lt;dd class&#x3D;\&quot;gray6\&quot;&gt;使用面积：&lt;span class&#x3D;\&quot;black \&quot;&gt;&quot;</span><br><span class="line">        nd_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;年&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;代：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        cx_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;朝&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;向：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        lc_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;楼&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;层：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        jg_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6 \&quot;&gt;结&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;构：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        zx_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;装&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;修：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        zzlb_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;住宅类别：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        jzlb_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;建筑类别：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        cqxz_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6 \&quot;&gt;产权性质：&lt;&#x2F;span&gt;&quot;</span><br><span class="line"></span><br><span class="line">        for i in dd_infos:</span><br><span class="line">            if huxing_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_type&#39;] &#x3D; i.strip()</span><br><span class="line"></span><br><span class="line">            elif jzmj_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_build_area&#39;] &#x3D; i.strip()</span><br><span class="line"></span><br><span class="line">            elif symj_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_use_area&#39;] &#x3D; i.strip()</span><br><span class="line"></span><br><span class="line">            elif nd_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_age&#39;] &#x3D; i.strip()</span><br><span class="line">               </span><br><span class="line">            elif cx_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;orientation&#39;] &#x3D; i.strip()</span><br><span class="line">                </span><br><span class="line">            elif lc_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;floor&#39;] &#x3D; i.strip()</span><br><span class="line">                </span><br><span class="line">            elif jg_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;structure&#39;] &#x3D; i.strip()</span><br><span class="line">                </span><br><span class="line">            elif zx_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;decoration&#39;] &#x3D; i</span><br><span class="line">                </span><br><span class="line">            elif zzlb_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;residential_category&#39;] &#x3D; i.strip()</span><br><span class="line">                </span><br><span class="line">            elif jzlb_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;building_class&#39;] &#x3D; i.strip()</span><br><span class="line">                </span><br><span class="line">            elif cqxz_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;property_right&#39;] &#x3D; i.strip()</span><br><span class="line">               </span><br><span class="line"></span><br><span class="line">        dt_infos &#x3D; response.xpath(xpath + div_houseInfor_clearfix + div_inforTxt + dl + dt + &quot;&#x2F;a&quot;).extract()</span><br><span class="line">        for i in dt_infos:</span><br><span class="line">            if &quot;查看此楼盘的更多二手房房源&quot; in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;property_name&#39;] &#x3D; i.strip()</span><br><span class="line">                </span><br><span class="line">            elif &quot;&lt;span class&#x3D;\&quot;gray6 floatl\&quot;&gt;学&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;校：&lt;&#x2F;span&gt;&quot; in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;school&#39;] &#x3D; i.strip()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样我们就可以得到详情页的信息了。</p>
<p>接下来，把上面两个爬取的操作链接在一起：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse(self, response):</span><br><span class="line">       infos &#x3D; response.xpath(&quot;&#x2F;&#x2F;a&#x2F;@href&quot;).extract()</span><br><span class="line"></span><br><span class="line">       for i in infos:</span><br><span class="line">           i_str &#x3D; str(i).encode(&quot;utf-8&quot;)</span><br><span class="line">           if &quot;esf&quot; in i_str:</span><br><span class="line">               url &#x3D; i_str.replace(&#39;\\&#39;, &#39;&#39;).strip()</span><br><span class="line">               </span><br><span class="line">               # 执行下一个request，回去自动调用callback函数，去解析详情页</span><br><span class="line">               yield scrapy.Request(url&#x3D;url.replace(&quot;\&quot;&quot;, &quot;&quot;), callback&#x3D;self.parse_details)</span><br></pre></td></tr></table></figure>
<h4 id="设置起始url"><a href="#设置起始url" class="headerlink" title="设置起始url"></a>设置起始url</h4><p>由于要爬取的不仅仅是一页数据，所以我们的<code>start_urls</code>列表不能只有一个url，我们需要有一个<code>PageNo</code>自增长的url的list。</p>
<p>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base_url &#x3D; &quot;http:&#x2F;&#x2F;esf.sh.fang.com&#x2F;map&#x2F;?mapmode&#x3D;y&amp;orderby&#x3D;30&amp;ecshop&#x3D;ecshophouse&amp;PageNo&#x3D;$&amp;a&#x3D;ajaxSearch&amp;city&#x3D;sh&amp;searchtype&#x3D;loupan&quot;</span><br><span class="line">    start_urls &#x3D; []</span><br><span class="line">    # 可以把10设置成一个比较大的数字，由于测试使用，所以写死一个较小的数</span><br><span class="line">    for i in range(2, 10):</span><br><span class="line">        start_urls.append(str(base_url).replace(&quot;$&quot;, str(i)))</span><br></pre></td></tr></table></figure>
<h4 id="可以开始了吗？"><a href="#可以开始了吗？" class="headerlink" title="可以开始了吗？"></a>可以开始了吗？</h4><p>列表爬取和详情爬取，以及起始url都设置ok了，那么我们是不是可以让我们的蜘蛛行动起来了呢？</p>
<p>且慢，这里也有坑。</p>
<p>这里我将页面数设置了200页，开始爬取，结果悲剧就发生了，由于短时间内访问量过大，搜房网的二手房页面似乎把我的ip屏蔽了：</p>
<p><img src="/img/16_11_30/006.png" alt=""></p>
<p>这里我参考了<a href="http://www.tuicool.com/articles/VRfQR3U">这篇文章</a>，通过</p>
<ul>
<li>设置随机UserAgent</li>
<li>添加代理IP</li>
<li>禁用cookies</li>
<li>设置加载延迟</li>
</ul>
<p>这些方式来防止被屏蔽。</p>
<p>设置完毕后，就可以愉快的开始爬取了~</p>
<h4 id="蜘蛛代码"><a href="#蜘蛛代码" class="headerlink" title="蜘蛛代码"></a>蜘蛛代码</h4><p>最终蜘蛛的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">import scrapy</span><br><span class="line">from ..items import ESFItem</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ESFListSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &quot;esflist&quot;</span><br><span class="line"></span><br><span class="line">    # allowed_domains &#x3D; [&quot;fang.com&quot;]</span><br><span class="line"></span><br><span class="line">    base_url &#x3D; &quot;http:&#x2F;&#x2F;esf.sh.fang.com&#x2F;map&#x2F;?mapmode&#x3D;y&amp;orderby&#x3D;30&amp;ecshop&#x3D;ecshophouse&amp;PageNo&#x3D;$&amp;a&#x3D;ajaxSearch&amp;city&#x3D;sh&amp;searchtype&#x3D;loupan&quot;</span><br><span class="line">    start_urls &#x3D; []</span><br><span class="line">    for i in range(2, 4):</span><br><span class="line">        start_urls.append(str(base_url).replace(&quot;$&quot;, str(i)))</span><br><span class="line"></span><br><span class="line">    def __init__(self, user_agent&#x3D;&#39;&#39;):</span><br><span class="line">        self.user_agent &#x3D; user_agent</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider):</span><br><span class="line">        # 这句话用于随机选择user-agent</span><br><span class="line">        ua &#x3D; random.choice(self.user_agent_list)</span><br><span class="line">        if ua:</span><br><span class="line">            request.headers.setdefault(&#39;User-Agent&#39;, ua)</span><br><span class="line"></span><br><span class="line">    user_agent_list &#x3D; [</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;22.0.1207.1 Safari&#x2F;537.1&quot; \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (X11; CrOS i686 2268.111.0) AppleWebKit&#x2F;536.11 (KHTML, like Gecko) Chrome&#x2F;20.0.1132.57 Safari&#x2F;536.11&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.6 (KHTML, like Gecko) Chrome&#x2F;20.0.1092.0 Safari&#x2F;536.6&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.2) AppleWebKit&#x2F;536.6 (KHTML, like Gecko) Chrome&#x2F;20.0.1090.0 Safari&#x2F;536.6&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.2; WOW64) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Chrome&#x2F;19.77.34.5 Safari&#x2F;537.1&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;536.5 (KHTML, like Gecko) Chrome&#x2F;19.0.1084.9 Safari&#x2F;536.5&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.0) AppleWebKit&#x2F;536.5 (KHTML, like Gecko) Chrome&#x2F;19.0.1084.36 Safari&#x2F;536.5&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1063.0 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 5.1) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1063.0 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1063.0 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.2) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1062.0 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1062.0 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.2) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1061.1 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1061.1 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.1) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1061.1 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.2) AppleWebKit&#x2F;536.3 (KHTML, like Gecko) Chrome&#x2F;19.0.1061.0 Safari&#x2F;536.3&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;535.24 (KHTML, like Gecko) Chrome&#x2F;19.0.1055.1 Safari&#x2F;535.24&quot;, \</span><br><span class="line">        &quot;Mozilla&#x2F;5.0 (Windows NT 6.2; WOW64) AppleWebKit&#x2F;535.24 (KHTML, like Gecko) Chrome&#x2F;19.0.1055.1 Safari&#x2F;535.24&quot;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line"></span><br><span class="line">        infos &#x3D; response.xpath(&quot;&#x2F;&#x2F;a&#x2F;@href&quot;).extract()</span><br><span class="line"></span><br><span class="line">        for i in infos:</span><br><span class="line">            i_str &#x3D; str(i).encode(&quot;utf-8&quot;)</span><br><span class="line">            if &quot;esf&quot; in i_str:</span><br><span class="line">                url &#x3D; i_str.replace(&#39;\\&#39;, &#39;&#39;).strip()</span><br><span class="line"></span><br><span class="line">                yield scrapy.Request(url&#x3D;url.replace(&quot;\&quot;&quot;, &quot;&quot;), callback&#x3D;self.parse_details)</span><br><span class="line"></span><br><span class="line">    def parse_details(self, response):</span><br><span class="line">        print &quot;+++++++++++++被执行了+++++++++++++++++++&quot;</span><br><span class="line"></span><br><span class="line">        # path</span><br><span class="line">        xpath &#x3D; &quot;&#x2F;&#x2F;body&#x2F;div[@class&#x3D;&#39;wrap&#39;]&#x2F;div[@class&#x3D;&#39;main clearfix&#39;]&#x2F;div[@class&#x3D;&#39;mainBoxL&#39;]&quot;</span><br><span class="line">        div_title &#x3D; &quot;&#x2F;div[@class&#x3D;&#39;title&#39;]&quot;</span><br><span class="line">        p_gray9 &#x3D; &quot;&#x2F;p[@class&#x3D;&#39;gray9&#39;]&quot;</span><br><span class="line">        h1 &#x3D; &quot;&#x2F;h1&quot;</span><br><span class="line">        span_mr10 &#x3D; &quot;&#x2F;span[@class&#x3D;&#39;mr10&#39;]&quot;</span><br><span class="line">        div_houseInfor_clearfix &#x3D; &quot;&#x2F;div[@class&#x3D;&#39;houseInfor clearfix&#39;]&quot;</span><br><span class="line">        div_inforTxt &#x3D; &quot;&#x2F;div[@class&#x3D;&#39;inforTxt&#39;]&quot;</span><br><span class="line">        dl &#x3D; &quot;&#x2F;dl&quot;</span><br><span class="line">        dt_gray6_zongjia1 &#x3D; &quot;&#x2F;dt[@class&#x3D;&#39;gray6 zongjia1&#39;]&quot;</span><br><span class="line">        span_red20b &#x3D; &quot;&#x2F;span[@class&#x3D;&#39;red20b&#39;]&quot;</span><br><span class="line">        dd_gray6 &#x3D; &quot;&#x2F;dd[@class&#x3D;&#39;gray6&#39;]&quot;</span><br><span class="line">        dd &#x3D; &quot;&#x2F;dd&quot;</span><br><span class="line">        dt &#x3D; &quot;&#x2F;dt&quot;</span><br><span class="line"></span><br><span class="line">        item &#x3D; ESFItem()</span><br><span class="line">        item[&#39;id&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                    div_title +</span><br><span class="line">                                    p_gray9 +</span><br><span class="line">                                    span_mr10).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        item[&#39;publish_time&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                              div_title +</span><br><span class="line">                                              p_gray9).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        item[&#39;title&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                       div_title +</span><br><span class="line">                                       h1).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        item[&#39;total_price&#39;] &#x3D; response.xpath(xpath +</span><br><span class="line">                                             div_houseInfor_clearfix +</span><br><span class="line">                                             div_inforTxt +</span><br><span class="line">                                             dl +</span><br><span class="line">                                             dt_gray6_zongjia1 +</span><br><span class="line">                                             span_red20b).extract_first().strip()</span><br><span class="line"></span><br><span class="line">        dd_infos &#x3D; response.xpath(xpath + div_houseInfor_clearfix + div_inforTxt + dl + dd).extract()</span><br><span class="line">        huxing_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;户&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;型：&quot;</span><br><span class="line">        jzmj_str &#x3D; &quot;&lt;dd class&#x3D;\&quot;gray6\&quot;&gt;建筑面积：&lt;span class&#x3D;\&quot;black \&quot;&gt;&quot;</span><br><span class="line">        symj_str &#x3D; &quot;&lt;dd class&#x3D;\&quot;gray6\&quot;&gt;使用面积：&lt;span class&#x3D;\&quot;black \&quot;&gt;&quot;</span><br><span class="line">        nd_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;年&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;代：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        cx_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;朝&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;向：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        lc_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;楼&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;层：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        jg_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6 \&quot;&gt;结&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;构：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        zx_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;装&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;修：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        zzlb_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;住宅类别：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        jzlb_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6\&quot;&gt;建筑类别：&lt;&#x2F;span&gt;&quot;</span><br><span class="line">        cqxz_str &#x3D; &quot;&lt;span class&#x3D;\&quot;gray6 \&quot;&gt;产权性质：&lt;&#x2F;span&gt;&quot;</span><br><span class="line"></span><br><span class="line">        for i in dd_infos:</span><br><span class="line">            if huxing_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_type&#39;] &#x3D; i.strip()</span><br><span class="line">            elif jzmj_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_build_area&#39;] &#x3D; i.strip()</span><br><span class="line">            elif symj_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_use_area&#39;] &#x3D; i.strip()</span><br><span class="line">            elif nd_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;house_age&#39;] &#x3D; i.strip()</span><br><span class="line">            elif cx_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;orientation&#39;] &#x3D; i.strip()</span><br><span class="line">            elif lc_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;floor&#39;] &#x3D; i.strip()</span><br><span class="line">            elif jg_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;structure&#39;] &#x3D; i.strip()</span><br><span class="line">            elif zx_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;decoration&#39;] &#x3D; i</span><br><span class="line">            elif zzlb_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;residential_category&#39;] &#x3D; i.strip()</span><br><span class="line">            elif jzlb_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;building_class&#39;] &#x3D; i.strip()</span><br><span class="line">            elif cqxz_str in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;property_right&#39;] &#x3D; i.strip()</span><br><span class="line"></span><br><span class="line">        dt_infos &#x3D; response.xpath(xpath + div_houseInfor_clearfix + div_inforTxt + dl + dt + &quot;&#x2F;a&quot;).extract()</span><br><span class="line">        for i in dt_infos:</span><br><span class="line">            if &quot;查看此楼盘的更多二手房房源&quot; in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;property_name&#39;] &#x3D; i.strip()</span><br><span class="line">            elif &quot;&lt;span class&#x3D;\&quot;gray6 floatl\&quot;&gt;学&lt;span class&#x3D;\&quot;padl27\&quot;&gt;&lt;&#x2F;span&gt;校：&lt;&#x2F;span&gt;&quot; in str(i).encode(&quot;utf-8&quot;):</span><br><span class="line">                item[&#39;school&#39;] &#x3D; i.strip()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="what-s-next"><a href="#what-s-next" class="headerlink" title="what`s next?"></a>what`s next?</h3><p>接下来我会将爬取到的数据进行加工后持久化到本地，不过今天就先到这里吧~</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>房价预测（2）-数据清洗与持久化</title>
    <url>/2016/12/08/%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%EF%BC%882%EF%BC%89-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>在<a href="/2016/11/30/房价预测（1）-搜房网数据爬取/">房价预测（1）-搜房网数据爬取</a>中，已经介绍了爬虫的核心代码，但是爬取到的数据是没有经过加工且带有html标签的，很不利于阅读和使用，并且我们没有把数据持久化到本地，那么这篇文章主要介绍的就是这两步工作。</p>
</blockquote>
<h2 id="Item-Pipeline介绍"><a href="#Item-Pipeline介绍" class="headerlink" title="Item Pipeline介绍"></a>Item Pipeline介绍</h2><p>Scrapy中有个很好用的工具<a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/topics/item-pipeline.html">Item Pipeline</a>。</p>
<p>通过阅读文档我们可以看到它的作用是：</p>
<ul>
<li>清理HTML数据</li>
<li>验证爬取的数据(检查item包含某些字段)</li>
<li>查重(并丢弃)</li>
<li>将爬取结果保存到数据库中</li>
</ul>
<p>真是完全符合我们的要求。</p>
<blockquote>
<p><strong>Pipeline</strong>的意思是<strong>管道</strong>,如果你玩过Linux的话，对这个名称一定不会陌生。管道是计算机中一个非常常见且重要的概念，大致的作用就是<strong>将管道前一部分的输出结果作为它后一部分的输入</strong>。类似这种设计都可以称为<strong>管道</strong>。</p>
</blockquote>
<p>还记得我们之前写的蜘蛛吗？在<code>ESFListSpider</code>这个蜘蛛中，开始爬取数据时会走到这个方法中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 爬取房源列表信息</span><br><span class="line">def parse(self, response):</span><br><span class="line">        self.log(&#39;A response from %s just arrived!&#39; % response.url)</span><br><span class="line">        infos &#x3D; response.xpath(&quot;&#x2F;&#x2F;a&#x2F;@href&quot;).extract()</span><br><span class="line"></span><br><span class="line">        for i in infos:</span><br><span class="line">            i_str &#x3D; str(i).encode(&quot;utf-8&quot;)</span><br><span class="line">            if &quot;esf&quot; in i_str:</span><br><span class="line">                url &#x3D; i_str.replace(&#39;\\&#39;, &#39;&#39;).strip()</span><br><span class="line">                yield scrapy.Request(url&#x3D;url.replace(&quot;\&quot;&quot;, &quot;&quot;), callback&#x3D;self.parse_details)</span><br></pre></td></tr></table></figure>
<p>在这个方法的内部的循环中会遍历链接地址，再次发起request，之后会自动调用回调函数<code>self.parse_details</code>，自动执行<code>parse_details</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 爬取房源详情信息</span><br><span class="line">def parse_details(self, response):</span><br><span class="line">	...</span><br><span class="line">	# 顺便爬取一下详情页 url</span><br><span class="line">	item &#x3D; ESFItem()</span><br><span class="line">    item[&#39;url&#39;] &#x3D; response.url</span><br><span class="line">    </span><br><span class="line">    # 详情页对应的 城市-一级区域-二级区域 信息</span><br><span class="line">	bread_list &#x3D; response.xpath(&quot;&#x2F;&#x2F;body&#x2F;div[@class&#x3D;&#39;wrap&#39;]&#x2F;div[@class&#x3D;&#39;bread&#39;]&#x2F;p[@class&#x3D;&#39;floatl&#39;]&#x2F;a&quot;).extract()</span><br><span class="line">    for index,bread in enumerate(bread_list[1:]):</span><br><span class="line">        if index &#x3D;&#x3D; 0:</span><br><span class="line">            item[&quot;bread_city&quot;] &#x3D; bread</span><br><span class="line">        elif index &#x3D;&#x3D; 1:</span><br><span class="line">            item[&quot;bread_area&quot;] &#x3D; bread</span><br><span class="line">        elif index &#x3D;&#x3D; 2:</span><br><span class="line">            item[&quot;bread_positon&quot;] &#x3D; bread</span><br><span class="line">	...</span><br><span class="line">	# 这句很重要，保证item可以传递到后面的Pipeline中</span><br><span class="line">	yield item</span><br></pre></td></tr></table></figure>
<p>以上是我们蜘蛛的部分核心代码，如果我们配置了Pipeline，蜘蛛会把塞满信息的item传递到我们定义的Pipeline中。</p>
<h3 id="创建Pipeline"><a href="#创建Pipeline" class="headerlink" title="创建Pipeline"></a>创建Pipeline</h3><p>为了满足<strong>清洗数据</strong>和<strong>存储数据</strong>的功能，我们创建两个Pipeline来分别处理这两类逻辑：</p>
<p>在<code>pipelines.py</code>中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ExtractDataPipeline(object):</span><br><span class="line">	def process_item(self, item, spider):</span><br><span class="line">		...</span><br><span class="line">		return item</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SaveDataPipline(object):</span><br><span class="line">	def process_item(self, item, spider):</span><br><span class="line">		...</span><br><span class="line">		return item</span><br></pre></td></tr></table></figure>
<p>并在<code>settings.py</code>中进行注册：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   &#39;soufang.pipelines.ExtractDataPipeline&#39;: 300,</span><br><span class="line">   &#39;soufang.pipelines.SaveDataPipline&#39;:500,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>后面的数字范围是0-1000之内的任意整数，代表的是优先级。可以看出来我们是优先清洗数据，然后保存数据。</p>
<h2 id="清洗数据"><a href="#清洗数据" class="headerlink" title="清洗数据"></a>清洗数据</h2><p>清洗数据的代码如下，就是将每一个字段的信息的html标签进行剥离，并且截取掉冗余的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 剔除html代码</span><br><span class="line">def take_out_html(str):</span><br><span class="line">    dr &#x3D; re.compile(r&#39;&lt;[^&gt;]+&gt;&#39;, re.S)</span><br><span class="line">    return dr.sub(&#39;&#39;, str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ExtractDataPipeline(object):</span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        print &quot;&gt;&gt;&gt; ExtractDataPipeline &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span><br><span class="line">        self.extract_data(item, &quot;url&quot;)</span><br><span class="line">        self.extract_data(item, &quot;id&quot;, f&#x3D;5)</span><br><span class="line">        self.extract_data(item, &quot;publish_time&quot;, f&#x3D;-10)</span><br><span class="line">        self.extract_data(item, &quot;title&quot;)</span><br><span class="line">        self.extract_data(item, &quot;total_price&quot;)</span><br><span class="line">        self.extract_data(item, &quot;house_type&quot;, f&#x3D;3)</span><br><span class="line">        self.extract_data(item, &quot;house_build_area&quot;, f&#x3D;5)</span><br><span class="line">        self.extract_data(item, &quot;house_use_area&quot;, f&#x3D;5)</span><br><span class="line">        self.extract_data(item, &quot;house_age&quot;, f&#x3D;3)</span><br><span class="line">        self.extract_data(item, &quot;orientation&quot;, f&#x3D;3)</span><br><span class="line">        self.extract_data(item, &quot;floor&quot;, f&#x3D;3)</span><br><span class="line">        self.extract_data(item, &quot;structure&quot;, f&#x3D;3)</span><br><span class="line">        self.extract_data(item, &quot;decoration&quot;, f&#x3D;3)</span><br><span class="line">        self.extract_data(item, &quot;residential_category&quot;, f&#x3D;5)</span><br><span class="line">        self.extract_data(item, &quot;building_class&quot;, f&#x3D;5)</span><br><span class="line">        self.extract_data(item, &quot;property_right&quot;, f&#x3D;5)</span><br><span class="line">        self.extract_data(item, &quot;property_name&quot;)</span><br><span class="line">        self.extract_data(item, &quot;school&quot;)</span><br><span class="line">        self.extract_data(item, &quot;supporting_facilities&quot;)</span><br><span class="line">        self.extract_data(item, &quot;bread_city&quot;, t&#x3D;-3)</span><br><span class="line">        self.extract_data(item, &quot;bread_area&quot;, t&#x3D;-3)</span><br><span class="line">        self.extract_data(item, &quot;bread_positon&quot;, t&#x3D;-3)</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    # 剔除数据中的多余部分</span><br><span class="line">    def extract_data(self, item, key_bread_positon, f&#x3D;None, t&#x3D;None):</span><br><span class="line">        if self.check_key_exist(item, key_bread_positon):</span><br><span class="line">            item[key_bread_positon] &#x3D; take_out_html(item[key_bread_positon]).strip()[f:t]</span><br><span class="line">        else:</span><br><span class="line">            item[key_bread_positon] &#x3D; &quot;&quot;</span><br><span class="line">        self.print_itme_value(item, key_bread_positon)</span><br><span class="line"></span><br><span class="line">    # 检查key是否存在</span><br><span class="line">    def check_key_exist(self, item, key):</span><br><span class="line">        return key in item.keys()</span><br><span class="line"></span><br><span class="line">    # 输出数据</span><br><span class="line">    def print_itme_value(self, item, key):</span><br><span class="line">        print key + &quot; &gt;&gt;&gt; &quot; + item[key]</span><br></pre></td></tr></table></figure>
<h2 id="保存数据到MongoDB"><a href="#保存数据到MongoDB" class="headerlink" title="保存数据到MongoDB"></a>保存数据到MongoDB</h2><p>保存数据我们使用<a href="http://www.mongodb.org/">MongoDB</a>，这是一个很简单易用且功能强大的<strong>非关系型数据库</strong>，它可以把数据保存成一种类似Json的格式。</p>
<p>使用教程网上很容易搜到，推荐一个自学网站：<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB教程</a></p>
<p>mongo的可视化工具也有很多，我使用的是<a href="https://robomongo.org/">Robomongo</a>。</p>
<p>使用mongo我们需要在<code>settings.py</code>中增添下面的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">MONGO_URI &#x3D; &quot;mongodb:&#x2F;&#x2F;localhost:27017&quot;;</span><br><span class="line">MONGO_DATABASE &#x3D; &quot;soufang&quot;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>下面是<code>SaveDataPipline</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SaveDataPipline(object):</span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DATABASE&#39;, &#39;items&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        print &quot;&gt;&gt;&gt; SaveDataPipline &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span><br><span class="line">        collection_name &#x3D; self.mongo_db</span><br><span class="line">        self.db[collection_name].insert(dict(item))</span><br><span class="line">        return item</span><br></pre></td></tr></table></figure>
<h3 id="去除重复项"><a href="#去除重复项" class="headerlink" title="去除重复项"></a>去除重复项</h3><p>为了保证id重复的房源信息不再重复爬取，我们可以对数据库建立<strong>唯一索引</strong>，这样既能够提高查询效率，又能够去除重复数据。</p>
<p>后台建立唯一索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.soufang.ensureIndex(&#123;&quot;id&quot;:1&#125;,&#123;&quot;unique&quot;:true&#125;,&#123;&quot;background&quot;:true&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="开始爬取！"><a href="#开始爬取！" class="headerlink" title="开始爬取！"></a>开始爬取！</h2><p>终于可以开心的爬取数据啦~</p>
<p>命令行输入<code>mongod</code>开启mongo服务后，进入我们的爬虫项目，开启我们的爬虫：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrapy crawl esflist</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_07/001.gif" alt=""></p>
<p>在Robomongo中我们执行一条查询语句<code>db.soufang.find()</code>就可以看到我们爬取到的全部数据：</p>
<p><img src="/img/16_12_07/002.png" alt=""></p>
<p>执行<code>db.soufang.findOne()</code>可以查询到一条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.soufang.findOne()</span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot; : ObjectId(&quot;58497108f26cd3d1ac97004b&quot;),</span><br><span class="line">	&quot;orientation&quot; : &quot;&quot;,</span><br><span class="line">	&quot;bread_area&quot; : &quot;普陀&quot;,</span><br><span class="line">	&quot;publish_time&quot; : &quot;2016-10-20&quot;,</span><br><span class="line">	&quot;id&quot; : &quot;268151561&quot;,</span><br><span class="line">	&quot;property_name&quot; : &quot;甘泉一村&quot;,</span><br><span class="line">	&quot;title&quot; : &quot;甘泉一村 边套全明户型 黄金3楼 得房率高 配套成熟 便利&quot;,</span><br><span class="line">	&quot;building_class&quot; : &quot;板楼&quot;,</span><br><span class="line">	&quot;bread_positon&quot; : &quot;甘泉&quot;,</span><br><span class="line">	&quot;house_build_area&quot; : &quot;55.27㎡&quot;,</span><br><span class="line">	&quot;bread_city&quot; : &quot;上海&quot;,</span><br><span class="line">	&quot;house_use_area&quot; : &quot;&quot;,</span><br><span class="line">	&quot;house_type&quot; : &quot;2室1厅1厨1卫&quot;,</span><br><span class="line">	&quot;structure&quot; : &quot;平层&quot;,</span><br><span class="line">	&quot;decoration&quot; : &quot;简装修&quot;,</span><br><span class="line">	&quot;school&quot; : &quot;&quot;,</span><br><span class="line">	&quot;total_price&quot; : &quot;275&quot;,</span><br><span class="line">	&quot;url&quot; : &quot;http:&#x2F;&#x2F;esf.sh.fang.com&#x2F;chushou&#x2F;3_268151561.htm&quot;,</span><br><span class="line">	&quot;house_age&quot; : &quot;1987年&quot;,</span><br><span class="line">	&quot;floor&quot; : &quot;中层(共6层)&quot;,</span><br><span class="line">	&quot;property_right&quot; : &quot;个人产权&quot;,</span><br><span class="line">	&quot;supporting_facilities&quot; : &quot;&quot;,</span><br><span class="line">	&quot;residential_category&quot; : &quot;普通住宅&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全上海目前在售的二手房源大概有60到70万套之间，我们可以把速度缩短到1秒中爬取一条，如果24小时爬取的话，预计6天可以爬完全上海。不过我们的目的是对数据进行分析，没必要盲目的采集大量的数据，只要数据够用即可。</p>
<p>如果数据量过大，后面进行训练机器性能也跟不上，所以我准备将总数据量控制在5万条（按照各区域房源数量占比进行组合）。</p>
<h2 id="what-s-next"><a href="#what-s-next" class="headerlink" title="what`s next?"></a>what`s next?</h2><p>接下来我们将构建一个可视化的界面来直观的观察我们爬取到的房源数据。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>房价预测（3）-数据可视化</title>
    <url>/2016/12/15/%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%EF%BC%883%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h2 id="数据的可视化"><a href="#数据的可视化" class="headerlink" title="数据的可视化"></a>数据的可视化</h2><p>经过前两部的处理：</p>
<p><a href="/2016/11/30/房价预测（1）-搜房网数据爬取/">房价预测（1）-搜房网数据爬取</a></p>
<p><a href="/2016/12/08/房价预测（2）-数据清洗与持久化/">房价预测（2）-数据清洗与持久化</a></p>
<p>我们已经能够爬取fang.com上的数据并持久化到本地的<strong>MongoDB</strong>中，这一节主要介绍如何将数据进行可视化的展示。</p>
<h3 id="R语言引入"><a href="#R语言引入" class="headerlink" title="R语言引入"></a>R语言引入</h3><p>数据可视化的处理方式有很多种，可以用js，python。你可以选择任何你喜欢的支持可视化的库来进行操作，这里我选择<strong>R语言</strong>。</p>
<blockquote>
<p>R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。</p>
<p>R是一套完整的数据处理、计算和制图软件系统。其功能包括：数据存储和处理系统；数组运算工具（其向量、矩阵运算方面功能尤其强大）；完整连贯的统计分析工具；优秀的统计制图功能；简便而强大的编程语言；可操纵数据的输入和输出，可实现分支、循环，用户可自定义功能。</p>
<p>R是一个免费的自由软件，它有UNIX、MacOS和Windows版本，都是可以免费下载和使用的。在R的安装程序中只包含了8个基础模块，其他外在模块可以通过CRAN获得。</p>
<p>官方网站：<a href="http://www.r-project.org">http://www.r-project.org</a></p>
</blockquote>
<p>有关<strong>R</strong>的介绍以及入门使用方式，之前整理过两篇文章：</p>
<p><a href="/2016/02/29/R语言（01）－R快速入门/">R语言（01）－R快速入门</a></p>
<p><a href="/2016/03/06/R语言（02）绘图/">R语言（02）－R绘图</a></p>
<p>不熟悉R的同学可以先行了解一下~</p>
<h3 id="RStudio"><a href="#RStudio" class="headerlink" title="RStudio"></a>RStudio</h3><p>这里再推荐一个比较好用的R语言集成环境:</p>
<p><strong>RStudio</strong></p>
<p><img src="/img/16_12_14/001.png" alt=""></p>
<h3 id="数据导入到R"><a href="#数据导入到R" class="headerlink" title="数据导入到R"></a>数据导入到R</h3><p>安装好R的开发环境之后，如果想要导入mongo的数据，需要安装<code>mongolite</code>。</p>
<p>打开RStudio，点击<code>Tools-&gt;Install Packages...</code>，搜索<code>mongolite</code>，点击确认安装即可。</p>
<p>安装成功后，在R的命令行下引入<code>mongolite</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; library(mongolite)</span><br></pre></td></tr></table></figure>
<p>导入mongo数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con &lt;- mongo(&quot;soufang&quot;, url &#x3D; &quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;soufang&quot;)</span><br><span class="line">mydata &lt;- con$find()</span><br></pre></td></tr></table></figure>
<p>这样就把我们爬取到的所有数据都导入到了R中的mydata变量中。这里我暂时爬取了13198条数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Imported 13198 records. Simplifying into dataframe...</span><br></pre></td></tr></table></figure>
<h3 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h3><p>接下来我们就可以绘制一些图表了：</p>
<p>比如说:</p>
<p>我们可以绘制出<strong>价格-数量</strong>关系的柱状图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; barplot(table(x&lt;-as.numeric(mydata$total_price)))</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/002.png" alt=""></p>
<p>可以看到，价格区间在260万到450万之间是一个数量比较高房价范围。</p>
<hr>
<p><strong>面积-总价</strong>关系的散点图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; plot(x&lt;-as.numeric(mydata$house_build_area),x&lt;-as.numeric(mydata$total_price),xlab &#x3D; &quot;面积&quot;,ylab &#x3D; &quot;总价&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/003.png" alt=""></p>
<blockquote>
<p>这里可能你会遇到中文无法显示的问题，如果你遇到了，需要安装以下三个包：</p>
<ul>
<li>showtext</li>
<li>showtextdb</li>
<li>sysfonts</li>
</ul>
<p>如果遇到无法下载，请尝试命令行输入：</p>
<p>install.packages(‘package_name’, dependencies=TRUE, repos=’<a href="http://cran.rstudio.com/">http://cran.rstudio.com/</a>‘)</p>
<p>下载成功之后，执行以下操作即可：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; library(sysfonts)</span><br><span class="line">&gt; library(showtext)</span><br><span class="line">&gt; dev.new() #如果已打开图形设备，本句可以不用</span><br><span class="line">&gt; showtext.begin()</span><br></pre></td></tr></table></figure></h2></blockquote>
<p><strong>户型分布</strong>的饼图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; pie(table(mydata$house_type))</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/004.png" alt=""></p>
<p>可以看到在售的二手房中，最多的户型是<code>2室2厅1厨1卫</code>，其次<code>2室1厅1厨1卫</code>和<code>3室2厅1厨2卫</code>的户型数量相当，在其次是<code>1室1厅1厨1卫</code>。</p>
<hr>
<p><strong>区域分布</strong>的饼图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; pie(table(mydata$bread_area))</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/007.png" alt=""></p>
<p>可以看出来，在售的二手房中，浦东区的数量是最多的。</p>
<hr>
<p><strong>发布时间</strong>的柱状图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; barplot(table(mydata$publish_time))</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/005.png" alt=""></p>
<p>可以看出来，我们通过这个接口爬取数据的话，爬取到的数据几乎都是靠近当前日期的。</p>
<hr>
<p><strong>每平米价格</strong>的箱图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; boxplot(as.numeric(mydata$total_price)&#x2F;as.numeric(mydata$house_build_area),ylim&#x3D;c(0,15))</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/006.png" alt=""></p>
<p>可以看出来，上海二手房的均价目前基本维持在5万元左右。</p>
<hr>
<p><strong>浦东区的每平米价格</strong>的箱图：</p>
<p>首先导入浦东区的数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; pudongData &lt;- con$find(&#39;&#123;&quot;bread_area&quot;:&quot;浦东&quot;&#125;&#39;)</span><br></pre></td></tr></table></figure><br>绘制箱图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; boxplot(as.numeric(pudongData$total_price)&#x2F;as.numeric(pudongData$house_build_area),ylim&#x3D;c(0,15))</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_12_14/008.png" alt=""></p>
<p>也许是由于浦东在售房数量占总体数量较多，且浦东房价与上海平均房价接近，所以浦东区的房价也是在5万出头的样子。</p>
<p>同样的方式我们可以看看松江区：</p>
<p><img src="/img/16_12_14/009.png" alt=""></p>
<p>可以看出，松江区大概在4万以下的。</p>
<hr>
<h3 id="查询房价走势"><a href="#查询房价走势" class="headerlink" title="查询房价走势"></a>查询房价走势</h3><p>最后我们来查一下每平米房价随发布时间的柱状图。</p>
<p>首先，我们需要对房价数据按照发布日期进行<strong>分组（group by）</strong>操作。</p>
<p>有两种方式：</p>
<ul>
<li>1.在R中进行分组处理</li>
<li>2.在mongo中分组处理</li>
</ul>
<p>显然第二种方式的效率是高于第一种的，并且操作上也更方便一些。</p>
<p>那么我们就先通过mongo的<code>group</code>操作来查询出每个发布日期的每平米均价：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.soufang.group(</span><br><span class="line">   &#123;</span><br><span class="line">     key: &#123; publish_time: 1&#125;,</span><br><span class="line">     reduce: function ( curr, result ) &#123; </span><br><span class="line">     	avg_prace &#x3D; curr.total_price &#x2F; curr.house_build_area </span><br><span class="line"></span><br><span class="line">     	result.total +&#x3D; avg_prace;</span><br><span class="line">        result.count++;</span><br><span class="line">     &#125;,</span><br><span class="line">     finalize: function(result) &#123;</span><br><span class="line">          result.avg &#x3D; result.total &#x2F; result.count;</span><br><span class="line">      &#125;,</span><br><span class="line">     initial: &#123; total : 0, count: 0 &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>由于坑爹的<code>mongolite</code>没有提供<code>group()</code>函数，我们可以在mongo中把group出的结果导入到一个新的表中，然后再导入R中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.soufang_gb_publish_time.insert( db.soufang.group(</span><br><span class="line">   &#123;</span><br><span class="line">     key: &#123; publish_time: 1&#125;,</span><br><span class="line">     reduce: function ( curr, result ) &#123; </span><br><span class="line">     	avg_prace &#x3D; curr.total_price &#x2F; curr.house_build_area </span><br><span class="line"></span><br><span class="line">     	result.total +&#x3D; avg_prace;</span><br><span class="line">        result.count++;</span><br><span class="line">     &#125;,</span><br><span class="line">     finalize: function(result) &#123;</span><br><span class="line">          result.avg &#x3D; result.total &#x2F; result.count;</span><br><span class="line">      &#125;,</span><br><span class="line">     initial: &#123; total : 0, count: 0 &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>导入成功后，我们可以通过执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.soufang_gb_publish_time.find()</span><br></pre></td></tr></table></figure>
<p>来验证一下数据是否导入成功。</p>
<p>我这里导入之后有61天的数据。</p>
<p>再回到R中，将数据导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; con_gb_publis_time &lt;- mongo(&quot;soufang_gb_publish_time&quot;, url &#x3D; &quot;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;soufang&quot;)</span><br><span class="line">&gt; myGbData &lt;- con_gb_publis_time$find(sort&#x3D;&#39;&#123;&quot;publish_time&quot;:1&#125;&#39;)</span><br></pre></td></tr></table></figure>
<p>我们可以通过find来验证一下是否导入成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; myGbData</span><br><span class="line">   publish_time      total count      avg</span><br><span class="line">1    2016-10-14  199.98178    34 5.881817</span><br><span class="line">2    2016-10-15  127.66077    24 5.319199</span><br><span class="line">3    2016-10-16   53.00914    13 4.077626</span><br><span class="line">4    2016-10-17   74.76187    11 6.796534</span><br><span class="line">5    2016-10-18  172.64432    34 5.077774</span><br><span class="line">6    2016-10-19  232.46693    47 4.946105</span><br><span class="line">7    2016-10-20  274.33694    50 5.486739</span><br><span class="line">8    2016-10-21  205.77986    40 5.144496</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>看到这样的结果，说明我们导入成功了。</p>
<p>接下来的操作就比较easy了，我们来绘制出这个数据的柱状图即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">barplot(height&#x3D;as.numeric(myGbData$avg),table(myGbData$publish_time))</span><br></pre></td></tr></table></figure>
<p>横坐标为日期，纵坐标为均价：</p>
<p><img src="/img/16_12_14/010.png" alt=""></p>
<p>可以看出，由于我们远离当前日期越远的日期，数据量越少，所以会导致数据波动比较大。所以后半部分的数据比前半部分的相对准确一些。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则之 接口隔离原则</title>
    <url>/2015/09/17/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则其定义有两种：</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>Clients should not be forced to depend upon interfaces that they don’t use.<br>(客户端不应该依赖它不需要的接口。)</p>
<p>The dependency of one class to another one should depend on the smallest possible interface.<br>(类间的依赖关系应该建立在最小的接口上。)</p>
</blockquote>
<p>定义可以通俗的被翻译为：</p>
<blockquote>
<p>建立单一接口，不要建立臃肿庞大的接口。<br>或者：<br>接口尽量细化，同时接口中的方法尽量少。</p>
</blockquote>
<h2 id="与单一职责原则的不同"><a href="#与单一职责原则的不同" class="headerlink" title="与单一职责原则的不同"></a>与单一职责原则的不同</h2><p>定义听起来和单一职责原则所做的事情是一样的，都是<strong>给接口瘦身</strong>,减少接口中过多的方法。但实质上，与单一职责还是不一样的。两者的审视角度不一样。</p>
<p>单一职责强调的是类和接口职责要单一，强调的是<strong>职责</strong>,而某些情况下，相同职责下的方法可能很多，例如一个接口的职责包含了10个方法，这十个方法提供给多个模块使用，不同模块下根据各自的权限来访问，这在单一职责的角度来看是允许的，但按照接口隔离的角度来看，可能就不合理了，因为它要求“尽量使用多个专门的接口”。专门的接口指的是什么？就是指提供给每个模块的单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。</p>
<h2 id="对接口规范的约束"><a href="#对接口规范的约束" class="headerlink" title="对接口规范的约束"></a>对接口规范的约束</h2><p>1.接口要尽量小</p>
<pre><code>但前提要求是要满足单一职责原则
</code></pre><p>2.接口要高内聚</p>
<p>3.定制服务</p>
<pre><code>例如一个图书管理系统的查询接口

IBookSearcher
+ void searchByAuthor()
+ void searchByTitle()
+ void searchByPublisher()
+ void searchByCatagory()
+ void complexSearch(Map map)

按照模块进行接口拆分后，分成了两个接口

ISimpleBookSearcher
+ void searchByAuthor()
+ void searchByTitle()
+ void searchByPublisher()
+ void searchByCatagory()

IComplexBookSearcher
+ void complexSearch(Map map)
</code></pre><p>4.接口设计是有限度的</p>
<pre><code>接口的设计颗粒度越小，系统越灵活，但是，灵活的同时带来了结构的复杂化，开发难度增加，可维护性降低，
所以接口设计一定要注意适度，这个“度”通常是根据经验和常识来判断，没有一个固化或可测量的标准。
</code></pre>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数学之美 技术详解(1)</title>
    <url>/2016/05/03/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E-%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3(01)/</url>
    <content><![CDATA[<h2 id="统计语言模型（关键人物：贾里尼克）"><a href="#统计语言模型（关键人物：贾里尼克）" class="headerlink" title="统计语言模型（关键人物：贾里尼克）"></a>统计语言模型（关键人物：贾里尼克）</h2><p>计算机需要知道一个文字序列是否能构成一个大家理解而且有意义的句子，然后显示或者打印给使用者。</p>
<p>比如：</p>
<blockquote>
<p>美联储主席本·伯南克昨天告诉媒体7000亿美元的救助资金将借给上百家银行、保险公司和汽车公司。</p>
</blockquote>
<p>如果改变一些词的顺序或者换掉一些词，将这句话变成：</p>
<blockquote>
<p>本·伯南克美联储主席昨天7000亿美元的救助资金告诉媒体将借给银行、保险公司和汽车公司上百家。</p>
</blockquote>
<p>意思就含混了，虽然多少还能猜测到一点。</p>
<p>但是如果换成：</p>
<blockquote>
<p>联主美储本·伯诉体南将借天的救克告媒昨助资金70元亿00美给上百百百家银保行、汽车险公司公司和。</p>
</blockquote>
<p>基本上读者就不知所云了。</p>
<p><strong>贾里尼克</strong>的出发点很简单：</p>
<p><strong>一个句子是否合理，就看看它的可能性大小如何。至于可能性就用概率来衡量。</strong></p>
<p>第一个句子出现的概率大致是10^-20，第二个句子出现的概率是10^-25,第三个句子出现的概率是10^70。因此，第一个最有可能，它的可能是第二个句子的10万倍，是第三个句子的一百亿亿亿亿亿亿倍。</p>
<p>更通俗的描述：<br>假定S表示一个有意义的句子，由一连串特定顺序排列的词w1，w2，……，wn组成，这里n是句子的长度。既然S=w1,w2,…,wn,那么不妨把P(S)展开表示：</p>
<script type="math/tex; mode=display">
\begin{cases}
    P(S)=P(w1,w2,...,wn)
\end{cases}</script><p>利用条件概率公式，S这个序列出现的概率等于每一个词出现的条件概率相乘，于是$P(w1,w2,…,wn)$可展开为：</p>
<script type="math/tex; mode=display">
\begin{cases}
    P(w1,w2,...,wn) = P(w1)·P(w2|w1)·P(w3|w1,w2)...P(wn|w1,w2,...,wn-1)
\end{cases}</script><p>其中$P(w1)$表示第一个词$w1$出现的概率；$P(w2|w1)$是在已知第一个词的前提下，第二个词出现的概率；以此类推。不难看出，到了词$wn$,<br>它的出现概率取决于它前面的所有词。</p>
<p>从计算上来看，前两个词的概率还是可以算的，到了第三个词的条件概率$P(w3|w1,w2)$已经非常难算了，因为它涉及到三个变量，每个变量到可能性都是一种语言字典的大小。</p>
<p>19世纪到20世纪初，俄罗斯有个数学家叫马尔可夫(Andrey Markov)，他给了个偷懒但还颇为有效的方法，也就是每当遇到这种情况时，<br>就假设任意一个词wi出现的概率只同它前面的词wi-1有关，于是问题就变得很简单了。这种假设在数学上称为马尔科夫假设。现在,S出现<br>的概率就变得简单了：</p>
<pre><code>P(S) = P(w1)·P(w2|w1)·P(w3|w2)...P(wi|wi-1)...P(wn|wn-1)    (3.3)
</code></pre><p>公式(3.3)对应的统计语言模型是二元模型。<br>当然，也可以假设一个词由前面的N-1个词决定，对应的模型稍微复杂些，被称为N元模型。</p>
<p>接下来的问题就是如何估计条件概率P(wi|wi-1):</p>
<pre><code>P(wi|wi-1) = P(wi-1,wi)/P(wi-1)
</code></pre><p>而估计联合概率P(wi-1,wi)和边缘概率P(wi-1),现在变得很简单。因为有了大量机读文本，也就是专业人士讲的语料库（Corpus），<br>只要数一数wi-1，wi这对词在统计的文本中前后相邻出现了多少次#(wi-1,wi),以及wi-1本身在同样的文本中出现了多少次#(wi-1),然后用两个<br>数分别除以语料库的大小#,即可得到这些词或者二元组的相对频度：</p>
<pre><code>f(wi-1,w1) = #(wi-1,wi)/#
f(wi-1) = #(wi-1)/#
</code></pre><p>根据大数定理，只要统计量足够，相对频度就等于概率，即：</p>
<pre><code>P(wi-1,wi) ≈ #(wi-1,wi)/#
P(wi-1) ≈ #(wi-1)/#
</code></pre><p>而P(wi|wi-1)就是这两个数的比值，再考虑到上面的两个概率有相同的坟墓，可以约掉，因此：</p>
<pre><code>P(wi|wi-1) ≈ #(wi-1,wi)/#(wi-1)
</code></pre><p>现在，读者也许已经开始能感受到数学的美妙之处了，它把一些复杂的问题变得如此简单。这似乎有点让人难以置信，用这么简单的<br>数学模型能解决复杂的语音识别、机器翻译等问题，而用很复杂的文法规则和人工智能却做不到。</p>
<p>在Google语音搜索Google Voice和中英文自动翻译（罗塞塔）中，发挥了最重要作用的就是这个统计语言模型。值得一提的是罗赛塔使用的是四元模型，<br>该模型存储于500台以上的google服务器中。</p>
<p>－－－－－－</p>
<p>（思考：是否可以通过词的信息量来动态计算N的值呢？）</p>
<p>－－－－－－<br>数据的平滑处理：</p>
<p>(wi-1,wi)在语料库中出现的次数#(wi-1,wi)为0怎么办？是否意味着P(wi|wi-1)＝0？<br>如果#(wi-1,wi)和#(wi-1)都只出现了一次，那么是否敢得出P(wi|wi-1)=1这样的绝对结论呢？</p>
<p>这样是不对的，因为我们敢于用对采样数据的观察结果来预测概率，是因为有大数定理在背后做支持，它的要求是有足够的观测值。</p>
<p>正确训练一个语言模型的办法之一就是：增加数据量，但即便如此，也亦然会遇到0概率或者统计量不足的问题。</p>
<p>1953年古德在他的老板图灵的指导下，提出了：在统计中相信可靠的统计数据，而对不可信的统计数据打折扣的一种概率估计方法，<br>同时将折扣出来的那一小部分概率给予未看见的事件。他们给出了一个很漂亮的重新估算概率的公式，这个公式后来别成为：古德－图灵估计。</p>
<p>其原理如下：<br>对于没有看见的事件，我们不能认为它发生的概率就是0，因此我们从概率总量中，分配一个很小的比例给予这些没有看见的事件，<br>这样一来，看见的那些事件的概率总和就要小于1了，因此，需要将所有看见的事件概率调小一点。至于小多少，要根据“越是不可信的统计折扣越多”<br>的方法进行。</p>
<p>以统计字典中每个词的概率为例，来说明古德-图灵估计公式：</p>
<p>假定在语料库中出现r次的词有Nr个，特别地，未出现的词数量为N0。语料库的大小为N。那么，很显然</p>
<p>(3.11 公式)</p>
<p>出现r次的词在整个语料库中的相对频度则是r/N，如果不做任何优化处理，就以这个相对频度作为这些词的概率估计。</p>
<p>现在假定当r比较小时，它的统计可能不可靠，因此出现r次的那些词在计算它们的概率时要使用一个更小一点的次数，是dr（而不直接使用r），古德－图灵估计按照下面的公式计算dr：</p>
<p>（3.12 公式）<br>显然</p>
<p>（3.13 公式）</p>
<p>一般来说，出现的次数越多，单词数量越少。这种规律称为Zipf定律。</p>
<p>(见图3.2 )</p>
<p>可以看出r越大，词的数量Nr越小，即Nr+1<Nr。因此，一般情况下dr<r，而d0>0。这样就给未出现的词赋于了一个很小的非零值，从而解决了0概率的问题。同时下调了出现频率很低的词的概率。当然，在实际的自然语言处理中，一般对出现次数超过某个阈值对词，频率不下调，只对出现次数低于这个阈值的词，频率才下调，下调得到的频率总和给未出现的词。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第一周 (1)欢迎来到机器学习</title>
    <url>/2016/07/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E5%91%A8%20(1)%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="欢迎来到机器学习"><a href="#欢迎来到机器学习" class="headerlink" title="欢迎来到机器学习"></a>欢迎来到机器学习</h2><p>欢迎来到这门关于机器学习的免费网络课程。机器学习是近年来最激动人心的技术之一。在这门课中，你不仅可以了解机器学习的原理，更有机会进行实践操作，并且亲自运用所学的算法。在生活中，每天你都可能在不知不觉中使用了各种各样的机器学习算法。比如，当你每一次使用像诸如谷歌 (Google)或必应 (Bing) 的搜索引擎时，它们运作得如此之好的原因之一便是，由Google或微软实现的一种学习算法可以“学会”如何对网页进行排名；每当你使用脸书 (Facebook)或苹果 (Apple) 的照片处理应用时，它们都能自动识别出你朋友的照片，这也是机器学习的一种；每当你阅读电子邮件时，你的垃圾邮件过滤器帮你免受大量垃圾邮件的困扰，这也是通过一种学习算法实现的。还有一个让我兴奋的理由，是一个关于人工智能的梦想：有朝一日，我们能创造出像你我一样聪明的机器，尽管我们离这个目标仍有很长的距离，但许多的人工智能专家相信，实现这一目标最好的途径是通过学习算法，来模拟人类大脑的学习方式。关于这点，我也会在这门课程中有所提及。</p>
<p>在这门课中你将会掌握机器学习的前沿原理。但是，仅仅了解其中的算法和数学是不够的。尤其是如果你并不知道如何将所学的理论知识用到你的实际问题上时。因此，我们也将花费大量时间来让大家进行编程练习，帮助你实现所学的算法，并体验到它们究竟是怎么运作的。</p>
<p>话说，为什么机器学习在当今如此流行呢？ 机器学习发源于人工智能领域 我们希望能够创造出具有智慧的机器。我们通过编程来让机器完成一些基础的工作，比如如何找到从A到B的最短路径，但在大多数情况下，我们并不知道如何显式地编写人工智能程序，来做一些更有趣的任务。比如网页搜索，标记照片和拦截垃圾邮件等。人们意识到唯一能够达成这些目标的方法，就是让机器自己学会如何去做。因而，机器学习已经发展成为计算机的一项新能力，并且与工业界和基础科学界有着紧密的联系。</p>
<p>身处机器学习领域。我常常会在短短一周中与形形色色的人打交道 如直升机飞行员、生物学家、还有许多计算机系统专家。比如我在斯坦福的同事们，同时平均每周我还会数次收到来自硅谷的业界人士的email，咨询我是否有兴趣将机器学习算法应用到他们所遇到的实际问题中，以上的例子都彰显了机器学习所能处理的问题范围之广。在硅谷，机器学习引导着大量的课题。如自主机器人、计算生物学等。机器学习的实例还有很多，比如数据库挖掘。机器学习变得如此流行的原因之一，便是网络和自动化算法的爆炸性增长，这意味着我们掌握了比以往多得多的数据集。举例来说，当今有数不胜数的硅谷企业，在收集有关网络点击的数据 (Clickstream Data) 并试图在这些数据上运用机器学习的算法来更好的理解和服务用户，这在硅谷已经成为了一项巨大的产业。随着电子自动化的发展，我们现在拥有了电子医疗记录，如果我们能够将这些记录转变为医学知识，那我们就能对各种疾病了解的更深入，同时，计算生物学也在电子自动化的辅助下快速发展。生物学家收集了大量有关基因序列以及DNA序列的数据，通过对其应用机器学习的算法来帮助我们跟深入地理解人类基因组，及其对我们人类的意义，几乎工程界的所有领域，都在使用机器学习算法来分析日益增长的海量数据集。有些机器应用我们并不能够通过手工编程来实现，比如说，我个人对自动直升机有着许多年的研究，想要写出一个能让直升机自主飞行的程序几乎是不可能的任务。唯一可行的解决方案就是让一台计算机能够自主地学会如何让直升机飞行。再比如手写识别，如今将大量的邮件，按地址分类寄送到全美甚至全球的代价大大降低，其中重要的理由之一便是每当你写下这样一封信时 一个机器学习的算法已经学会如何读懂你的笔迹并自动地将你的信件发往它的目的地.所以邮寄跨越上万里的信件的费用也很低。你也许曾经接触过自然语言处理和计算机视觉，事实上，这些领域都是试图通过人工智能来理解人类的语言和图像，如今大多数的自然语言处理和计算机视觉都是对机器学习的一种应用。</p>
<p>机器学习算法也在用户自定制化程序(self-customizing program)中有着广泛的应用，每当你使用亚马逊、Netflix或iTunes Genius的服务时，都会收到它们为你量身推荐的电影或产品。这就是通过学习算法来实现的。可以相信，这些应用都有着上千万的用户，而针对这些海量的用户编写千万个不同的程序显然是不可能的。唯一有效的解决方案就是开发出能够自我学习，定制出符合你喜好的并据此进行推荐的软件，最后，机器学习算法已经被应用于探究人类的学习方式，并试图理解人类的大脑。我们也将会了解到研究者是如何运用机器学习的工具，来一步步实现人工智能的梦想。</p>
<p>就在几个月前我的一位学生给我看了一篇文章，文中列举了当今12个最主要的IT技能，这些技术可以让信息技术行业的招聘官无法拒绝你。虽然这是一篇略显老旧的文章，但所有技能中最重要的便是机器学习。在斯坦福，向我咨询有没有即将毕业的研究机器学习学生的雇主，远远多于我们这儿每年毕业的机器学习的学生。因而我觉得对机器学习这一技能的需求仍有着巨大的缺口，而现在正是学习它的绝佳机会。我希望你们能在这门课中收获良多。在接下来的视频中，我将更正式地定义什么是机器学习，也会讨论机器学习主要面对的几类问题和相关算法，你也会学习一些主要的机器学习术语，并对不同的算法和其适用的场景有初步的了解。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第一周 (2)监督学习</title>
    <url>/2016/07/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E5%91%A8%20(2)%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>在本视频中，我将介绍一种也许是最常见的机器学习问题。即监督学习。后面将给出监督学习更正式的定义，现在最好以示例来说明什么是监督学习。之后再给出正式的定义。</p>
<p>假设你想预测房价（无比需要啊！)，之前，某学生已经从某地收集了数据集（不是中国的，囧） 其中一个数据集是这样的。</p>
<p><img src="/img/16_07_19/001.png" alt=""></p>
<p> 这是横坐标，即不同房子的面积，单位平方脚（^-^） 纵轴上是房价，单位 千美元。 根据给定数据，假设你朋友有栋房子，750平尺（70平米） 想知道这房子能卖多少，好卖掉。 那么，学习算法怎么帮你呢？学习算法可以： 绘出一条直线，让直线尽可能匹配到所有数据。 </p>
<p><img src="/img/16_07_19/002.png" alt=""></p>
<p>基于此，看上去，那个房子应该、可能、也许、大概 卖到15万美元（一平米两千刀！）。但这不是唯一的学习算法。可能还有更好的。比如不用直线了，可能平方函数会更好，即二次多项式更符合数据集。如果你这样做，预测结果就应该是20万刀（一平三千刀，涨价好快）。</p>
<p><img src="/img/16_07_19/003.png" alt=""></p>
<p>后面我们会介绍到如何选择，是选择直线还是平方函数来拟合。没有明确的选择，就不知哪个能给你的朋友更好的卖房建议。只是这些每个都是很好的学习算法例子。也是监督学习的例子。术语监督学习，意指给出一个算法，需要部分数据集已经有正确答案。比如给定房价数据集， 对于里面每个数据，算法都知道对应的正确房价，即这房子实际卖出的价格。算法的结果就是算出更多的正确价格，比如那个新房子，你朋友想卖的那个。</p>
<p>用更术语的方式来定义，监督学习又叫回归问题，（应该是回归属于监督中的一种）意指要预测一个连续值的输出，比如房价。虽然从技术上，一般把房价记到美分单位。所以实际还是个离散值，但通常把它看作实际数字，是一个标量值，一个连续值的数，而术语回归，意味着要预测这类连续值属性的种类。另一个监督学习的例子，我和一些朋友 之前研究的领域。让我们来看医学记录，并预测胸部肿瘤是恶性良性。 如果某人发现有胸部肿瘤，恶性肿瘤有害又危险，良性肿瘤则是少害。 显然人们很关注这个。让我们看一个收集好的数据集，假设在数据集中，横轴表示肿瘤的大小，纵轴我打算圈上0或1，是或否，即肿瘤是恶性的还是良性的。</p>
<p><img src="/img/16_07_19/004.png" alt=""></p>
<p>所以如图所示，可以看到这个大小的肿瘤块 是良性的，还有这些大小的都是良性的。 不幸地是也看到一些恶性肿瘤，比如这些大小的肿瘤。 所以，有5个良性块，在这一块，还有5个恶性的，它们纵轴值为1。</p>
<p>现在假设某人杯具地得胸部肿瘤了，大小大概是这么大。</p>
<p><img src="/img/16_07_19/005.png" alt=""></p>
<p>对应的机器学习问题就是，你能否估算出一个概率，即肿瘤为恶或为良的概率？ 专业地说，这是个分类问题。分类是要预测一个离散值输出。这里是0或1，恶性或良性。</p>
<p>事实证明，在分类问题中，有时会有超过两个的值，输出的值可能超过两种。举个具体例子，胸部肿瘤可能有三种类型，所以要预测离散值0，1，2，3。假设总共有三种癌症。0就是良性肿瘤，没有癌症。1 表示1号癌症，2 是2号癌症，3 就是3号癌症。这同样是个分类问题，因为它的输出的离散值集合 分别对应于无癌，1号，2号，3号癌症。</p>
<p>我再露一小手，在分类问题中，还有另一种作图方式 来描述数据。我画你猜。要用到些许不同的符号集合 来描绘数据。如果肿瘤大小作为唯一属性，被用于预测恶性良性，可以把数据作图成这样。</p>
<p><img src="/img/16_07_19/006.png" alt=""></p>
<p>使用不同的符号来表示良性和恶性，即阴性和阳性。所以，不再统一画叉叉了，改用圈圈来代表良性肿瘤，就像这样。仍沿用X（叉叉）代表恶性肿瘤。希望你能明白。我所做的就是，把在上面的数据， 映射下来。再用不同的符号， 圈和叉来分别代表良性和恶性。</p>
<p>在上例中，只使用了一个特征属性，即肿瘤块大小，来预测肿瘤是恶性良性。在其它机器学习问题里，有着不只一个的特征和属性。</p>
<p>例子，现在不只是知道肿瘤大小，病人年龄和肿瘤大小都知道了。</p>
<p><img src="/img/16_07_19/007.png" alt=""></p>
<p>这种情况下，数据集如表图所示，有些病人，年龄、肿瘤已知，不同的病人，会有一点不一样，肿瘤恶性，则用叉来代表。所以，假设 有一朋友得了肿瘤。肿瘤大小和年龄落在此处。</p>
<p><img src="/img/16_07_19/008.png" alt=""></p>
<p>那么依据这个给定的数据集，学习算法所做的就是画一条直线，分开 恶性肿瘤和良性肿瘤，所以学习算法会画条直线，像这样，把两类肿瘤分开。</p>
<p><img src="/img/16_07_19/009.png" alt=""></p>
<p>然后你就能判断你朋友的肿瘤是…了。如果它在那边，学习算法就说 你朋友的肿瘤在良性一边，因此更可能是良性的。</p>
<p><img src="/img/16_07_19/010.png" alt=""></p>
<p>好，本例中，总共有两个特征，即病人年龄和肿瘤大小。在别的ML问题中， 经常会用到更多特征，我朋友研究这个问题时，通常使用这些特征：比如块的厚度，即胸部肿瘤的厚度、肿瘤细胞大小和形状的一致性，等等。它表明，最有趣的学习算法（本课中将学到） 能够处理，无穷多个特征。不是3到5个这么少。在这张幻灯片中，我已经列举了总共5个不同的特征。但对于一些学习问题，真要用到的不只是三五个特征，要用到无数多个特征，非常多的属性，所以，你的学习算法要使用很多的属性或特征、线索来进行预测。那么，你如何处理 无限多特征呢？甚至你如何存储无数的东西进电脑里，又要避免内存不足？</p>
<p>事实上，等我们介绍一种叫<strong>支持向量机（SVM）</strong>的算法时，就知道存在一个简洁的数学方法，能让电脑处理无限多的特征。想像下，我不是这边写两个特征，右边写三个特征。而是，写一个无限长的特征表，不停地写特征，似乎是个无限长的特征的表。但是，我们也有能力设计一个算法来处理这个问题。</p>
<p>所以再从头复述一遍。本课中，我们介绍监督学习。其基本思想是，监督学习中，对于数据集中的每个数据，都有相应的正确答案，（训练集）算法就是基于这些来做出预测。就像那个房价，或肿瘤的性质。后面介绍了回归问题。即通过回归来预测一个连续值输出。我们还谈到了分类问题，目标是预测离散值输出。</p>
<p>下面是个小测验题目：假设你有家公司，希望研究相应的学习算法去 解决两个问题。</p>
<p>第一个问题，你有一堆货物的清单。 假设一些货物有几千件可卖，你想预测出，你能在未来三个月卖出多少货物。 </p>
<p>第二个问题，你有很多用户， 你打算写程序来检查每个用户的帐目。 对每个用户的帐目，判断这个帐目是否被黑过（hacked or compromised）。</p>
<p>问题一是个回归问题 因为如果我有几千件货物， 可能只好把它当作一个实际的值，一个连续的值。也把卖出的数量当作连续值。</p>
<p>第二个问题，则是分类问题，因为可以把我想预测的一个值设为0，来表示账目没有被hacked另一个设为1，表示已经被hacked。 就像乳癌例子中，0表示良性，1表示恶性。 所以这个值为0或1，取决于是否被hacked，有算法能预测出是这两个离散值中的哪个。 因为只有少量的离散值，所以这个就是个分类问题。 这就是监督学习，下个视频将会介绍 无监督学习，学习算法的另一主要类型。 </p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第一周 (3)无监督学习</title>
    <url>/2016/07/20/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E5%91%A8%20(3)%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/olRZo/unsupervised-learning">视频地址</a></p>
<p>在这段视频中我们要讲第二种主要的机器学习问题，叫做无监督学习.</p>
<p>在上一节视频中，我们已经讲过了监督学习。回想起上次的数据集，每个样本，都已经被标明为正样本或者负样本，即良性或恶性肿瘤。</p>
<p><img src="/img/16_07_20/001.png" alt=""></p>
<p>因此，对于监督学习中的每一个样本，我们已经被清楚地告知了什么是所谓的正确答案，即它们是良性还是恶性。在无监督学习中，我们用的数据会和监督学习里的看起来有些不一样。在无监督学习中，没有属性或标签这一概念，也就是说所有的数据都是一样的，没有区别。</p>
<p><img src="/img/16_07_20/002.png" alt=""></p>
<p>所以在无监督学习中我们只有一个数据集，没人告诉我们该怎么做，我们也不知道，每个数据点究竟是什么意思。相反，它只告诉我们现在有一个数据集，你能在其中找到某种结构吗？对于给定的数据集，无监督学习算法可能判定该数据集包含两个不同的聚类。</p>
<p>你看，这是第一个聚类。</p>
<p><img src="/img/16_07_20/003.png" alt=""></p>
<p>然后这是另一个聚类。</p>
<p><img src="/img/16_07_20/004.png" alt=""></p>
<p>你猜对了，无监督学习算法会把这些数据分成两个不同的聚类。</p>
<p>所以这就是所谓的聚类算法，实际上它被用在许多地方。</p>
<p>我们来举一个聚类算法的栗子。Google新闻的例子，如果你还没见过这个页面的话，你可以到这个URL <a href="http://news.google.com">news.google.com</a>去看看。谷歌新闻每天都在干什么呢？他们每天会去收集成千上万的网络上的新闻，然后将他们分组，组成一个个新闻专题。</p>
<p><img src="/img/16_07_20/005.png" alt=""></p>
<p>比如让我们来看看这里：</p>
<p><img src="/img/16_07_20/006.png" alt=""></p>
<p>这里的URL链接连接着不同的有关BP油井事故的报道。所以让我们点击这些URL中的一个，然后我们会来到这样一个网页。</p>
<p><img src="/img/16_07_20/007.png" alt=""></p>
<p>这是一篇来自华尔街日报的，有关BP油井泄漏事故的报道，标题为《BP杀死了Macondo》。Macondo是个地名，就是那个漏油事故的地方。如果你从这个组里点击一个不同的URL，那么你可能会得到不同的新闻：这里是一则CNN的新闻，是一个有关BP石油泄漏的视频。</p>
<p><img src="/img/16_07_20/008.png" alt=""></p>
<p>如果你再点击第三个链接，又会出现不同的新闻。这边是英国卫报的报道，也是关于BP石油泄漏。</p>
<p><img src="/img/16_07_20/009.png" alt=""></p>
<p>所以，谷歌新闻所做的就是，去搜索成千上万条新闻，然后自动的将他们聚合在一起。因此，有关同一主题的新闻被显示在一起。</p>
<p>实际上聚类算法和无监督学习算法也可以被用于许多其他的问题。这里我们举个它在基因组学中的应用。</p>
<p>下面是一个关于基因芯片的例子，基本的思想是：给定一组不同的个体 对于每个个体，检测它们是否拥有某个特定的基因。也就是说，你要去分析有多少基因显现出来了。因此，这些颜色：红、绿、灰等等，它们 展示了这些不同的个体是否拥有一个特定基因的不同程度。</p>
<p><img src="/img/16_07_20/010.png" alt=""></p>
<p>然后你能做的就是，运行一个聚类算法，把不同的个体归入不同的类或归为不同类型的人。</p>
<p><img src="/img/16_07_20/011.png" alt=""></p>
<p>这就是无监督学习。我们没有提前告知这个算法：这些是第一类的人，这些是第二类的人，这些是第三类的人等等。相反我们只是告诉算法：你看！这儿有一堆数据，我不知道这个数据是什么东东，我不知道里面都有些什么类型，叫什么名字，我甚至不知道都有哪些类型。但是，请问你可以自动的找到这些数据中的类型吗？然后自动的按得到的类型把这些个体分类。虽然事先我并不知道哪些类型。因为对于这些数据样本来说，我们没有给算法一个正确答案，所以，这就是无监督学习。</p>
<p>无监督学习或聚类算法在其他领域也有着大量的应用，它被用来组织大型的计算机集群。</p>
<p>我有一些朋友在管理大型数据中心，也就是大型计算机集群，并试图找出哪些机器趋向于协同工作，如果你把这些机器放在一起，你就可以让你的数据中心更高效地工作。</p>
<p><img src="/img/16_07_20/012.png" alt=""></p>
<p>第二种应用是用于社交网络的分析 </p>
<p>如果可以得知哪些朋友你用email联系的最多，或者知道你的Facebook好友或者你Google+里的朋友，知道了这些之后，我们是否可以自动识别哪些是很要好的朋友组，哪些仅仅是互相认识的朋友组。</p>
<p><img src="/img/16_07_20/013.png" alt=""></p>
<p>还有在市场分割中的应用中，许多公司拥有庞大的客户信息数据库。那么，给你一个客户数据集，你能否自动找出不同的市场分割，并自动将你的客户分到不同的细分市场中，从而有助于我在不同的细分市场中进行更有效的销售。</p>
<p><img src="/img/16_07_20/014.png" alt=""></p>
<p>这也是无监督学习。我们现在有这些客户数据，但我们预先并不知道 有哪些细分市场。而且，对于我们数据集的某个客户，我们也不能预先知道谁属于细分市场一、谁又属于细分市场二等等。但我们必须让这个算法自己去从数据中发现这一切。</p>
<p>最后，事实上无监督学习也被用于天文数据分析。通过这些聚类算法我们发现了许多惊人的、有趣的，以及实用的，关于星系是如何诞生的理论。</p>
<p><img src="/img/16_07_20/015.png" alt=""></p>
<p>所有这些都是聚类算法的例子。而聚类只是无监督学习的一种，现在让我来告诉你另一种，我先来介绍一下鸡尾酒宴问题：</p>
<p>恩，我想你参加过鸡尾酒会的，是吧？嗯，想象一下，有一个宴会，有一屋子的人，大家都坐在一起，而且在同时说话，有许多声音混杂在一起。因为每个人都是在同一时间说话的，在这种情况下你很难听清楚你面前的人说的话。</p>
<p>因此，比如有这样一个场景：宴会上只有两个人，两个人同时说话。恩，这是个很小的鸡尾酒宴会，我们准备好了两个麦克风，把它们放在房间里，然后，因为这两个麦克风距离这两个人的距离是不同的，每个麦克风都记录下了来自两个人的声音的不同组合。也许A的声音在第一个麦克风里的声音会响一点，也许B的声音在第二个麦克风里会比较响一些。因为两个麦克风的位置相对于两个说话者的位置是不同的，但每个麦克风都会录到来自两个说话者的重叠部分的声音。</p>
<p><img src="/img/16_07_20/016.png" alt=""></p>
<p>这里有一个来自一个研究员录下的两个说话者的声音，让我先放给你听。第一个这是第一个麦克风录到的录音： </p>
<p><a href="/audio/16_07_20/001.mp3">Microphone #1</a><br>一 (UNO) 二 (DOS) 三 (TRES) 四 (CUATRO) 五 (CINCO) 六 (SEIS) 七 (SIETE) 八 (ocho) 九 (NUEVE) 十 (Y DIEZ) </p>
<p>好吧 这大概不是什么有趣的酒会…… ……在这个酒会上，有两个人，各自从1数到10。但用的是两种不同语言。你刚才听到的是第一个麦克风的录音，这里是第二个的： </p>
<p><a href="/audio/16_07_20/001.mp3">Microphone #2</a></p>
<p>一 (UNO) 二 (DOS) 三 (TRES) 四 (CUATRO) 五 (CINCO) 六 (SEIS) 七 (SIETE) 八 (ocho) 九 (NUEVE) 十 (Y DIEZ) </p>
<p>所以，我们能做的就是把这两个录音输入一种无监督学习算法中，称为“鸡尾酒会算法”，让这个算法帮你找出其中蕴含的分类，然后这个算法就会去听这些录音，并且你知道这听起​​来像两个音频录音被叠加在一起，所以我们才能听到这样的效果。此外这个算法还会分离出这两个被 叠加到一起的音频源。事实上，这是我们的鸡尾酒会算法的第一个输出：</p>
<p><a href="/audio/16_07_20/003.mp3">Output #1</a> </p>
<p>一 二 三 四 五 六 七 八 九 十 </p>
<p>所以我在一个录音中分离出了英文声音。这是第二个输出：</p>
<p><a href="/audio/16_07_20/002.mp3">Output #2</a></p>
<p>Uno dos tres quatro cinco seis siete ocho nueve y diez </p>
<p>听起来不错嘛。再举一个例子，这是另一个录音，也是在一个类似的场景下，这是第一个麦克风的录音：</p>
<p><a href="/audio/16_07_20/004.mp3">Microphone #1</a></p>
<p> 一 二 三 四 五 六 七 八 九 十 </p>
<p>OK，这个可怜的家伙从鸡尾酒会回家了，他现在独自一人坐在屋里对着录音机自言自语，这是第二个麦克风的录音：</p>
<p><a href="/audio/16_07_20/005.mp3">Microphone #2</a></p>
<p>一 二 三 四 五 六 七 八 九 十 </p>
<p>当你把这两个麦克风录音送给与刚刚相同的算法处理，它所做的还是 告诉你这听起来有两种音频源，并且算法说，这里是我找到的第一个音频源：</p>
<p><a href="/audio/16_07_20/006.mp3">Output #1</a></p>
<p>一 二 三 四 五 六 七 八 九 十 </p>
<p>恩，不是太完美，提取到了人声，但还有一点音乐没有剔除掉。这是算法的第二个输出：</p>
<p><a href="/audio/16_07_20/007.mp3">Output #2</a></p>
<p>还好，在第二个输出中，它设法剔除掉了整个人声，只是清理了下音乐剔除了从一到十的计数。</p>
<p>所以，你可以看到，像这样的无监督学习算法，也许你想问，要实现这样的算法很复杂吧？ 看起来为了构建这个应用程序做这个音频处理似乎需要写好多代码啊，或者需要链接到一堆处理音频的Java库，貌似需要一个非常复杂的程序分离出音频等。</p>
<p>实际上，要实现你刚刚听到的效果，只需要一行代码就可以了。写在这里呢。</p>
<p><img src="/img/16_07_20/017.png" alt=""></p>
<p>当然，研究人员花了很长时间才想出这行代码的^-^，我不是说这是一个简单的问题，但事实上，如果你使用正确的编程环境，许多学习算法是用很短的代码写出来的。所以这也是为什么在这门课中我们要使用Octave的编程环境。</p>
<p>Octave是一个免费的、开放源码的软件。使用Octave或Matlab这类的工具，许多学习算法都可以用几行代码就可以实现。在后续课程中，我会教你如何使用Octave。你会学到如何在Octave中实现这些算法，或者如果你有Matlab，你可以用它。</p>
<p>事实上，在硅谷，很多的机器学习算法，我们都是先用Octave写一个程序原型。因为在Octave中实现这些学习算法的速度快得让你无法想象。</p>
<p>在这里每一个函数，例如：SVD意思是奇异值分解，但这其实是解线性方程的一个惯例，它被内置在Octave软件中了。</p>
<p>如果你试图在C++或Java中做这个，将需要写N多代码，并且还要连接复杂的C++或Java库。所以，你可以在C++或Java或Python中实现这个算法，只是会更加复杂而已。</p>
<p>在教授机器学习将近10年后，我得出的一个经验就是，如果你使用Octave的话，会学的更快。并且如果你用Octave作为你的学习工具 和开发原型的工具，你的学习和开发过程会变得更快。而事实上在硅谷 很多人会这样做。他们会先用Octave来实现这样一个学习算法原型，只有在确定这个算法可以工作后，才开始迁移到C++、Java或其它编译环境。事实证明，这样做实现的算法，比你一开始就用C++实现的算法要快多了。</p>
<p>所以我知道，作为一个老师，我不能老是念叨：“在这个问题上相信我“ 但对于那些从来没有用过这种类似Octave的编程环境的童鞋，我还是要请你相信我这一次，我认为你的时间，研发时间，是你最宝贵的资源之一。</p>
<p>当见过很多的人这样做以后，我觉得如果你也这样做，作为一个机器学习的研究者和开发者，你会更有效率。如果你学会先用Octave开发原型，而不是先用其他的编程语言来开发。</p>
<p>最后，总结一下。这里有一个问题需要你来解答：</p>
<p>我们谈到了无监督学习，它是一种学习机制，你给算法大量的数据，要求它找出数据中蕴含的类型结构，以下的四个例子中，哪一个您认为是 无监督学习算法，而不是监督学习问题？</p>
<ul>
<li>通过标记邮件是否为垃圾邮件来实现的垃圾邮件过滤器。</li>
<li>从网络中爬取一些新闻，按照相同的类别进行自动分组。</li>
<li>通过一个市场数据库，来自动的发现市场细分类别。</li>
<li>通过一系列糖尿病患者的数据信息来学习，达到能分辨一个新的患者是否得了糖尿病。</li>
</ul>
<p>恩，没忘记垃圾邮件文件夹问题吧？如果你已经标记过数据，那么就有垃圾邮件和非垃圾邮件的区别，我们会将此视为一个监督学习问题。</p>
<p>新闻故事的例子正是我们在本课中讲到的谷歌新闻的例子。我们介绍了你可以如何使用聚类算法这些文章聚合在一起，所以这是无监督学习问题。</p>
<p>市场细分的例子，我之前有说过这也是一个无监督学习问题。因为我是要拿到数据，然后要求它自动发现细分市场。</p>
<p>最后一个例子，糖尿病。这实际上就像我们上节课讲到的乳腺癌的例子 只不过这里不是好的或坏的癌细胞，良性或恶性肿瘤。我们现在是有糖尿病或没有糖尿病。所以这是有监督的学习问题，像处理那个乳腺癌的问题一样。我们会把它作为一个有监督的学习问题来处理。</p>
<p>好了，关于无监督学习问题就讲这么多了，下一节课中我们会涉及到更具体的学习算法，并开始讨论这些算法是如何工作的，以及我们如何来实现它们。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第一周 (4)一元线性回归</title>
    <url>/2016/07/22/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E5%91%A8%20(4)%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<blockquote>
<p>线性回归预测一个输入值的一个真值输出。我们讨论了线性回归在住房价格预测中的应用，提出了成本函数的概念，并介绍了学习的梯度下降法。</p>
</blockquote>
<h2 id="模型与成本函数-Model-and-Cost-Function"><a href="#模型与成本函数-Model-and-Cost-Function" class="headerlink" title="模型与成本函数(Model and Cost Function)"></a>模型与成本函数(Model and Cost Function)</h2><h3 id="模型表示"><a href="#模型表示" class="headerlink" title="模型表示"></a>模型表示</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/db3jS/model-representation">视频地址</a></p>
<p>我们的第一个学习算法是<strong>线性回归算法</strong>，在这段视频中，你会看到这个算法的概况。更重要的是你将会了解监督学习过程完整的流程，让我们通过一个例子来开始。</p>
<p>这个例子是预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。</p>
<p><img src="/img/16_07_22/001.png" alt=""></p>
<p>在这里我要根据不同房屋尺寸所售出的价格 画出我的数据集，比方说，我们来看这个数据集，你有一个朋友正想出售自己的房子。如果你朋友的房子是1250平方尺大小，你要告诉他们这房子能卖多少钱，那么你可以做的一件事就是，构建一个模型，也许是条直线，从这个数据模型上来看。也许你可以告诉你的朋友，他能以大约220000(美元)左右的价格卖掉这个房子。</p>
<p><img src="/img/16_07_22/002.png" alt=""></p>
<p>那么这就是监督学习算法的一个例子，<strong>它被称作监督学习是因为对于每个数据来说，我们给出了“正确的答案”</strong>，即告诉我们根据我们的数据来说，房子实际的价格是多少，而且更具体来说，这是一个<strong>回归问题</strong>。回归一词指的是我们根据之前的数据预测出一个准确的输出值。对于这个例子就是价格。</p>
<p>同时，还有另一种最常见的监督学习方式，叫做<strong>分类问题</strong>。当我们想要预测离散的输出值，例如，如果我们正在寻找癌症肿瘤并想要确定肿瘤是良性的还是恶性的，这就是0/1离散输出的问题。</p>
<p>更进一步来说，在监督学习中我们有一个数据集，这个数据集被称训练集，因此对于房价的例子，我们有一个训练集，包含不同的房屋价格。我们的任务就是从这个数据中学习预测房屋价格。</p>
<p><img src="/img/16_07_22/003.png" alt=""></p>
<p>现在我们给出这门课中经常使用的一些符号定义，我们要定义颇多符号，不过没关系，现在你记不住所有的符号也没关系，随着课程的进展，你会发现记住这些符号会很有用。我将在整个课程中<strong>用小写的m来表示训练样本的数目</strong>。</p>
<p><img src="/img/16_07_22/004.png" alt=""></p>
<p>因此 在这个数据集中，如果表中有47行，那么我们就有47组训练样本，$m$就等于47。让我用小写字母$x$来表示输入变量，往往也被称为<strong>特征量</strong>，这就是用$x$表示输入的特征，并且我们将用$y$来表示输出变量或者目标变量，也就是我的预测结果。那么这就是第二列，在这里我要使用$(x,y)$来表示一个训练样本，所以在这个表格中的单独的一行对应于一个训​​练样本，为了表示某个训练样本，我将使用$x^{(i)}$与$y^{(i)}$来表示。并且用这个表示第$i$个训练样本，所以这个上标$i$不是求幂运算，这个$(x^{(i)},y^{(i)})$括号里的上标$i$只是一个索引，表示我的训练集里的第i行。这里不是x的i和y的i次方，仅仅是指$(x^{(i)},y^{(i)})$是在此表中的第$i$行。</p>
<p>举个例子$x^{(1)}$指的是第一个训练集里值为2104的输入值，这个就是第一行里的$x$，$x^{(2)}$ 等于1416吧?这是第二个$x$，$y^{(1)}$等于460，这是我第一个训练集样本的$y$值，这就是$^{(1)}$所代表的含义。</p>
<p><img src="/img/16_07_22/005.png" alt=""></p>
<p>像之前一样，我会问你一个问题，需要几秒的时间检查一下你的理解程度，在这个视频片段中，有时会有视频选择题弹出,当它弹出的时候,请使用鼠标来选择你认为正确的答案。这就是一个监督学习算法的工作方式。我们可以看到这里有我们的训练集里房屋价格，我们把它喂给我们的学习算法，这就是学习算法的工作了。然后输出一个函数，按照惯例，通常表示为小写h，<strong>$h$代表hypothesis(假设)</strong>，$h$表示一个函数，输入是房屋尺寸大小。就像你朋友想出售的房屋。因此 h 根据输入的$x$值来得出$y$值，$y$值对应房子的价格，因此，$h$是一个从$x$到$y$的函数映射。</p>
<p><img src="/img/16_07_22/006.png" alt=""></p>
<p>人们经常问我为什么这个函数被称作假设(hypothesis)，你们中有些人可能知道hypothesis的意思，从字典或者其它什么方式可以查到。其实在机器学习中这是一个在早期被用于机器学习的名称，它有点绕口。对这类函数来说，这可能不是一个很恰当的名字，对表示从房屋的大小到价格的函数映射，我认为这个词“hypothesis”可能不是最好的名称，但是这是人们在机器学习中使用的标准术语。所以不用太纠结人们为什么这么叫它。</p>
<p>当设计学习算法的时候，我们接下来需要去思考的是怎样得到这个假设$h$，对于这一点在接下来的几个视频中我将选择最初的使用规则，$h$代表hypothesis。我们将会这么写：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ_0 + θ_1 * x</script><p>为了方便有时非书面形式也可以这么写：$h_{θ}(x)$，我就写成$h(x)$，这是缩写方式。但一般来说我会保留这个下标$θ$。所以这就是数据集和函数的作用：用来预测。有时候我们会有更复杂的函数，也许是非线性函数，但是由于线性方程是简单的形式，我们将先从线性方程的例子入手。当然最终我们将会建立更复杂的模型，以及更复杂的学习算法。好吧，让我们也给这模型起一个名字，这个模型被称为线性回归<strong>(linear regression)</strong>模型。另外，这实际上是关于单个变量的线性回归，这个变量就是x。根据x来预测所有的价格函数，同时 对于这种模型有另外一个名称，称作<strong>单变量线性回归</strong>，单变量是对一个变量的一种特别的表述方式，总而言之这就是线性回归，在接下来的视频中我们将开始讨论如何去实现这种模型。</p>
<h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/rkTp3/cost-function">视频地址</a></p>
<p>在这段视频中我们将定义<strong>代价函数</strong>的概念，这有助于我们弄清楚如何把最有可能的直线与我们的数据相拟合。在线性回归中我们有一个像这样的训练集，记住，$M$代表了训练样本的数量。所以，比如$M = 47$。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式。</p>
<p><img src="/img/16_07_22/007.png" alt=""></p>
<p>接下来我们会引入一些术语，这些$θ_{0}$和$θ_{1}$，这些$θ_{i}$我把它们称为<strong>模型参数</strong>。在这个视频中，我们要做的就是谈谈如何选择这两个参数值$θ_{0}$和$θ_{1}$。选择不同的参数$θ_{0}$和$θ_{1}$，我们会得到不同的假设，不同的假设函数，我知道你们中的有些人可能已经知道我在这张幻灯片上要讲的，但我们还是用这几个例子来复习回顾一下。如果$θ_{0}=1.5$，$θ_{1}=0$ 那么假设函数会看起来是这样:</p>
<p><img src="/img/16_07_22/008.png" alt=""></p>
<p>因为你的假设函数是$h(x) = 1.5 + 0 * x$是这样一个常数函数 <code>恒等于1.5</code>。 </p>
<p>如果$θ_{0} = 0$并且$θ_{1} = 0.5$， 那么假设会看起来像这样:</p>
<p><img src="/img/16_07_22/009.png" alt=""></p>
<p>它会通过点$(2,1)$。这样你又得到了$h(x)$或者$h_{θ}(x)$。但是有时我们为了简洁会省略$θ$。因此$h(x)$将等于$0.5$倍的$x$。就像这样。</p>
<p>最后，如果$θ_{0} = 1$并且$θ_{1} = 0.5$。我们最后得到的假设会看起来像这样:</p>
<p><img src="/img/16_07_22/010.png" alt=""></p>
<p>让我们来看看它应该通过点$(2,2)$，这是我的新的$h(x)$或者写作$h_{θ}(x)$。你还记得之前我们提到过$h_{θ}(x)$的。但作为简写，我们通常只把它写作$h(x)$。</p>
<p>在线性回归中，我们有一个训练集，可能就像我在这里绘制的。我们要做的就是得出$θ_{0}$、$θ_{1}$这两个参数的值，来让假设函数表示的直线尽量地与这些数据点很好的拟合。也许就像这里的这条线一样：</p>
<p><img src="/img/16_07_22/011.png" alt=""></p>
<p>那么我们如何得出$θ_{0}$、$θ_{1}$的值来使它很好地拟合数据的呢？我们的想法是我们要选择能使$h(x)$，也就是输入$x$时我们预测的值，最接近该样本对应的$y$值的参数$θ_{0}$、$θ_{1}$。所以，在我们的训练集中我们会得到一定数量的样本。我们知道$x$表示卖出哪所房子,并且知道这所房子的实际价格。所以我们要尽量选择合适的参数值，使得在训练集中给出的$x$值，我们能合理准确地预测$y$的值。</p>
<blockquote>
<p>Idea: Choose $θ_{0}$、$θ_{1}$ so that $h_{θ}(x)$ is close to $y$ for our training examples $(x,y)$.</p>
</blockquote>
<p>让我们给出标准的定义:在线性回归中我们要解决的是一个最小化问题。所以我要写出关于$θ_{0}$、$θ_{1}$的最小化，而且我希望这个式子极其小，我想要$h(x)$和$y$之间的差异要小。我要做的事情是尽量减少假设的输出与房子真实价格之间的差的平方。</p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{0}θ\_{1}} 
(h_{θ}(x) - y)^{2}</script><p>接下来我会详细的阐述。</p>
<p>别忘了，我用符号$(x^{(i)},y^{(i)})$代表第i个样本，所以我想要做的是对所有训练样本进行一个求和，对$i = 1$到$i = m$的样本将对假设进行预测得到的结果，此时的$x^{i}$输入是第$i$号房子的面积。将第$i$号对应的预测结果减去第$i$号房子的实际价格，所得的差的平方相加得到总和而我希望尽量减小这个值，也就是预测值和实际值的差的平方误差和，或者说预测价格和实际卖出价格的差的平方。</p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{0}θ\_{1}} 
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p>我说了这里的$m$指的是训练集的样本容量。而为了让表达式的数学意义变得容易理解一点，我们实际上考虑的是这个数的$1/m$。因此我们要尝试尽量减少我们的平均误差，也就是尽量减少其$1/2m$。通常是这个数的一半。</p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{0}θ\_{1}} 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p>前面的这些只是为了使数学更直白一点，因此对这个求和值的二分之一求最小值应该得出相同的$θ_{0}$值和相同的$θ_{1}$值来，在这里</p>
<script type="math/tex; mode=display">h\_{θ}(x^{(i)})=θ\_{0} + θ\_{1} * x^{(i)}</script><p>而这个表达式</p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{0}θ\_{1}}</script><p>意味着我们要找到$θ_{0}$和$θ_{1}$的值来使这个表达式的值最小。这个表达式因$θ_{0}$和$θ_{1}$的变化而变化。</p>
<p>因此，简单地说，我们正在把这个问题变成：找到能使我的训练集中预测值和真实值的差的平方的和的$1/2m$最小的$θ_{0}$和$θ_{1}$的值。因此，这将是我的线性回归的整体目标函数。为了使它更明确一点，我们要改写这个函数。</p>
<p>按照惯例我要定义一个代价函数：</p>
<script type="math/tex; mode=display">
J(θ\_{0},θ\_{1}) = 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p>正如屏幕中所示，这里的这个公式我们想要做的就是关于$θ_{0}$和$θ_{1}$对函数$J(θ_{0}$,$θ_{1})$求最小值。这就是我的代价函数。代价函数也被称作<strong>平方误差函数</strong>，有时也被称为<strong>平方误差代价函数</strong>。事实上我们之所以要求出误差的平方和，是因为误差平方代价函数对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。</p>
<p>在后续课程中，我们还会谈论其他的代价函数。但我们刚刚讲的选择是对于大多数线性回归问题非常合理的。好吧，所以这是代价函数，到目前为止我们已经介绍了代价函数的数学定义，也许这个函数$J(θ_{0}$,$θ_{1})$有点抽象，可能你仍然不知道它的内涵，在接下来的几个视频里我们要更进一步解释代价函数$J$的工作原理，并尝试更直观地解释它在计算什么，以及我们使用它的目的。</p>
<h3 id="代价函数-实例1"><a href="#代价函数-实例1" class="headerlink" title="代价函数 实例1"></a>代价函数 实例1</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/N09c6/cost-function-intuition-i">视频地址</a></p>
<p>在上一个视频中我们给了代价函数一个数学上的定义，在这个视频里 让我们通过一些例子来获取一些直观的感受，看看代价函数到底是在干什么。</p>
<p>回顾一下，这是我们上次所讲过的内容：我们想找一条直线来拟合我们的数据，所以我们用θ0，θ1等参数得到了这个假设，而且通过选择不同的参数，我们会得到不同的直线拟合。然后我们还有一个代价函数，这就是我们的优化目标。</p>
<p><strong>假设(Hypothesis):</strong></p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ_0 + θ_1 * x</script><p><strong>参数(Parameters):</strong></p>
<script type="math/tex; mode=display">
θ_0 , θ_1</script><p><strong>代价函数(Cost Function):</strong></p>
<script type="math/tex; mode=display">
J(θ\_{0},θ\_{1}) = 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p><strong>目标(Goal):</strong></p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{0}θ\_{1}} 
J(θ\_{0},θ\_{1})</script><p>在这个视频里，为了更好地将代价函数可视化，我将使用一个简化表示方法来表示假设函数、参数、代价函数以及目标：</p>
<p><strong>简化的假设函数(Hypothesis):</strong></p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ_1 * x</script><p><strong>简化的参数(Parameters):</strong></p>
<script type="math/tex; mode=display">
θ_1</script><p><strong>简化的代价函数(Cost Function):</strong></p>
<script type="math/tex; mode=display">
J(θ\_{1}) = 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p><strong>简化的目标(Goal):</strong></p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{1}} 
J(θ\_{1})</script><p>我们可以将这个假设函数看成是把$θ_{0}$设为0，所以我只有一个参数，也就是$θ_{1}$。代价函数看起来与之前的很像，唯一的区别是现在$h(x) = θ_{1} * x$，只有一个参数$θ_{1}$，所以我的优化目标是将$J(θ_{1})$最小化。用图形来表示就是，如果$θ_{0}$等于零，也就意味这我们选择的假设函数会经过原点，也就是经过坐标$(0,0)$。通过利用简化的假设得到的代价函数 我们可以试着更好地理解代价函数这个概念。</p>
<p>我们要理解的是这两个重要的函数：第一个是假设函数，第二个是代价函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/012.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/013.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>注意这个假设函数$h_{θ}(x)$对于一个固定的$θ_{1}$是一个关于$x$的函数。所以这个假设函数就是一个关于$x$这个房子大小的函数。与此不同的是，代价函数$J$是一个关于参数$θ_{1}$的函数，而$θ_{1}$控制着这条直线的斜率。通过上图我们可以很好的理解，比如说这里是我的训练样本，它包含了三个点$(1,1)$，$(2,2)$和$(3,3)$。现在我们选择一个值$θ_{1}$，所以当$θ_{1} = 1$，如果这是我选择的$θ_{1}$，那么我的假设函数看起来就会像是这条直线。我将要指出的是，X轴是表示房子大小的量。现在暂时把$θ_{1}$定为1，我想要做的就是算出在$θ_{1} = 1$的时候$J(θ_{1})$等于多少。所以我们按照这个思路来计算代价函数的大小，和之前一样，代价函数定义如下:</p>
<script type="math/tex; mode=display">
\begin{align\*}
J(θ\_{1}) &= 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})^{2}\\\\
 &= 
\frac{1}{2m}
\sum\_{i=1}^{m}
(θ\_1x^{(i)} - y^{(i)})^{2}\\\\
 &= 
\frac{1}{2m}
(0^2 + 0^2 + 0^2)\\\\
 &= 0
\end{align*}</script><p>对这个误差平方项进行求和，这就等于这样一个形式，简化以后就等于三个0的平方和，当然还是0。现在，在代价函数里，我们发现所有这些值都等于0。因为对于我所选定的这三个训练样本$(1,1)$，$(2,2)$和$(3,3)$，如果$θ_{1} = 1$，那么$h_{θ}(x^{(i)})$就会正好等于$y^{(i)}$。所以$h(x) - y$所有的这些值都会等于零。这也就是为什么$J(1) = 0$。所以我们现在知道了$J(1) = 0$，如下图，要注意的是，因为我的代价函数是关于参数$θ_{1}$的函数，当我描绘我的代价函数时，$X$轴就是$θ_{1}$。</p>
<p><img src="/img/16_07_22/014.png" alt=""></p>
<p>现在我有$J(1) = 0$，让我们继续把函数画出来，结果我们会得到这样一个点。</p>
<p>现在我们来看其它一些样本$θ_{1}$可以被设定为某个范围内各种可能的取值，所以$θ_{1}$可以取负数、0或者正数。所以如果$θ_{1} = 0.5$会发生什么呢？继续把它画出来:</p>
<p><img src="/img/16_07_22/015.png" alt=""></p>
<p>这条线的斜率等于0.5，现在让我们计算$J(0.5)$。</p>
<script type="math/tex; mode=display">
\begin{align\*}
J(θ\_{1}) &= 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})^{2}\\\\
 &= 
\frac{1}{2m}
\sum\_{i=1}^{m}
(θ\_1x^{(i)} - y^{(i)})^{2}\\\\
 &= 
\frac{1}{2m}
((0.5 - 1)^2 + (1 - 2)^2 + (1.5 - 3)^2)\\\\
 &\approx 0.58
\end{align*}</script><p>让我们把点画出来：</p>
<p><img src="/img/16_07_22/016.png" alt=""></p>
<p>让我们试试$θ_{1}$等于0，$J(0)$会等于多少呢？如果$θ_{1} = 0$，那么$h(x)$就会等于一条水平的线。如下图：</p>
<p><img src="/img/16_07_22/017.png" alt=""></p>
<p>计算$J(0)$：</p>
<script type="math/tex; mode=display">
\begin{align\*}
J(θ\_{1}) &= 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})^{2}\\\\
 &= 
\frac{1}{2m}
\sum\_{i=1}^{m}
(θ\_1x^{(i)} - y^{(i)})^{2}\\\\
 &= 
\frac{1}{2m}
((0 - 1)^2 + (0 - 2)^2 + (0 - 3)^2)\\\\
 &\approx 2.33
\end{align*}</script><p>所以让我们接着把这个点也画出来，所以这个点最后是2.3：</p>
<p><img src="/img/16_07_22/018.png" alt=""></p>
<p>当然我们可以接着设定$θ_{1}$等于别的值进行计算，你也可以把$θ_{1}$设定成一个负数，所以如果$θ_{1}$是负数，那么h(x)将会等于，打个比方说－0.5乘以x然后$θ_{1}$就是-0.5，那么这将会对应着一个斜率为-0.5的假设函数，而且你可以 继续计算这些误差。结果你会发现对于0.5结果会是非常大的误差，最后会得到一个较大的数值，类似于5.25，等等。对于不同的$θ_{1}$，你可以计算出这些对应的值，结果你会发现，你算出来的这些值，你得到一条这样的曲线，通过计算这些值，你可以慢慢地得到这条线，这就是$J(θ)$的样子了。</p>
<p><img src="/img/16_07_22/019.png" alt=""></p>
<p>我们来回顾一下，任何一个$θ_{1}$的取值对应着一个不同的假设函数，或者说对应着左边一条不同的拟合直线。对于任意的$θ_{1}$你可以算出一个不同的$J(θ1)$的取值。举个例子，你知道的$θ_{1} = 1$时对应着穿过这些数据的那条直线，当$θ_{1} = 0.5$，对应着上面斜率为0.5的那条直线，然后$θ_{1} = 0$，对应着过原点的水平的线。所以对于任意一个$θ_{1}$的取值，我们会得到一个不同的$J(θ_{1})$，而且我们可以利用这些来描出上边的这条曲线。</p>
<p><img src="/img/16_07_22/013.png" alt=""></p>
<p>现在你还记得学习算法的优化目标，是我们想找到一个$θ_{1}$的值来将$J(θ_{1})$最小化，这是我们线性回归的目标函数。嗯，看这条曲线，让$J(θ_{1})$最小化的值 是$θ_{1} = 1$，然后你看，这个确实就对应着最佳的通过了数据点的拟合直线，这条直线就是由$θ_{1} = 1$的设定而得到的，然后，对于这个特定的训练样本，我们最后能够完美地拟合。这就是为什么最小化$J(θ_{1})$对应着寻找一个最佳拟合直线的目标。总结一下，在这个视频里我们看到了一些图形来理解代价函数，要做到这个，我们简化了算法，让这个函数只有一个参数$θ_{1}$，也就是说我们把$θ_{0}$设定为0，在下一个视频里我们将回到原来的问题的公式，然后看一些带有$θ_{0}$和$θ_{1}$的图形，也就是说不把$θ_{0}$设置为0了，希望这会让你更好地理解在原来的线性回归公式里代价函数$J$的意义。</p>
<h3 id="代价函数-实例2"><a href="#代价函数-实例2" class="headerlink" title="代价函数 实例2"></a>代价函数 实例2</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/nwpe2/cost-function-intuition-ii">视频地址</a></p>
<p>这节课中，我们将更深入地学习代价函数的作用。这段视频的内容假设你已经认识轮廓图，如果你对轮廓图不太熟悉的话，这段视频中的某些内容你可能会听不懂。但不要紧，如果你跳过这段视频的话，也没什么关系。不听这节课对后续课程理解影响不大。</p>
<p>和之前一样，这是我们的几个重要公式：</p>
<p><strong>假设(Hypothesis):</strong></p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ_0 + θ_1 * x</script><p><strong>参数(Parameters):</strong></p>
<script type="math/tex; mode=display">
θ_0 , θ_1</script><p><strong>代价函数(Cost Function):</strong></p>
<script type="math/tex; mode=display">
J(θ\_{0},θ\_{1}) = 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p><strong>目标(Goal):</strong></p>
<script type="math/tex; mode=display">
\mathop{minimze}\limits\_{θ\_{0}θ\_{1}} 
J(θ\_{0},θ\_{1})</script><p>跟前一节视频不同的是 我还是把$θ$写成$θ_{0}$、$θ_{1}$的形式，便于这里我们要对代价函数进行的可视化。和上次一样，首先来理解假设$h$和代价函数$J$。</p>
<p>这是房价数据组成的训练集数据:</p>
<p><img src="/img/16_07_22/020.png" alt=""></p>
<p>让我们来构建某种假设：如果我假设$θ_{0} = 50$，$θ_{1} = 0.06$的话，那么我将得到这样一个假设函数：</p>
<p><img src="/img/16_07_22/021.png" alt=""></p>
<p>那么现在的代价函数图像要怎么画呢？上一节我们只有一个$θ$，我们画出来的图形是一个倒过来的抛物线图，可是现在我们有了两个变量：$θ_{0}$和$θ_{1}$，我们的代价函数图就成了一个三维曲面图，水平方向的两个轴分别表示$θ_{0}$和$θ_{1}$，我们要在下面画出代价函数的图像：</p>
<p><img src="/img/16_07_22/022.png" alt=""></p>
<p>随着你改变$θ_{0}$和$θ_{1}$的大小，你会得到不同的代价函数 $J(θ_{0}$,$θ_{1})$对于某个特定的点$(θ_{0}$,$θ_{1})$这个曲面的高度，也就是竖直方向的高度，就表示代价函数$J(θ_{0}$,$θ_{1})$的值。</p>
<p>不难发现这是一个弓形曲面。我们来看看三维图，旋转一下这个图你就更能理解这个弓形曲面所表示的代价函数了：</p>
<p><img src="/img/16_07_22/023.gif" alt=""></p>
<p>在这段视频的后半部分，为了描述方便，我将不再像这样给你用三维曲面图的方式解释代价函数$J$，而是用<strong>轮廓图(contour plot)</strong>来表示，下边就是一个轮廓图</p>
<p><img src="/img/16_07_22/024.png" alt=""></p>
<p>两个轴分别表示$θ_{0}$和$θ_{1}$，而这些一圈一圈的椭圆形，每一个圈就表示$J(θ_{0}$,$θ_{1})$相同的所有点的集合。如果你之前没怎么接触轮廓图的话，你就这么想：一个弓形的函数从屏幕里冒出来，因此最小值也就是这个弓形的最低点就是这个点，也就是这一系列同心椭圆的中心点。因此轮廓图是一种很方便的方法 能够直观地观察代价函数$J$。</p>
<p>接下来让我们看几个例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{0}$,$θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{0}$,$θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/025.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/026.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>在代价函数的图上这一点表示$θ_{0} = 800$，$θ_{1} = -0.15$，坐标为$(800,-0.15)$。而这个点也对应于左边这样一条线，$θ_{0} = 800$也就是跟纵轴相交于大约800，斜率大概是-0.15。当然，这条线并不能很好地拟合数据。并且你也发现了，这个代价值，距离最小值点还很远。也就是说这个代价值还是算比较大的，因此不能很好拟合数据。</p>
<p>让我们再来看另一个假设：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{0}$,$θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{0}$,$θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/027.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/028.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>你不难发现，这依然不是一个好的拟合，但比刚才稍微好一点。这里$θ_{0} = 360$，$θ_{1} = 0$。因此这组$θ$值对应的假设是:$h(x) = 360 + 0 × x$，这个假设同样也有某个代价值，而这个代价值就对应于这个代价函数在这一点的高度。</p>
<p>让我们再来看另一个例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$h_{θ}(x)$ :假设函数</th>
<th style="text-align:center">$J(θ_{1})$ :代价函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(for fixed $θ_{0}$,$θ_{1}$,this is a function of x)</td>
<td style="text-align:center">(function of the parameter $θ_{0}$,$θ_{1}$)</td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/16_07_22/029.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_22/030.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>这个点其实不是最小值，但已经非常靠近最小值点了。这个点对数据的拟合就很不错。这个点虽然不在最小值点，但非常接近了。因此误差平方和，或者说训练样本和假设的距离的平方和，非常接近于最小值。尽管它还不是最小值。</p>
<p>通过这些图形我希望你能更好地理解这些代价函数$J$所表达的值，它们是什么样的，它们对应的假设是什么样的，以及什么样的假设对应的点更接近于代价函数$J$的最小值。当然我们真正需要的是一种有效的算法，能够自动地找出这些使代价函数$J$取最小值的参数$θ_{0}$和$θ_{1}$来。我想我们也不希望编个程序，把这些点画出来，然后人工的方法来读出这些点的数值。这很明显不是一个好办法。事实上我们后面就会学到，我们会遇到更复杂、更高维度、更多参数的情况，这在我们在后面的视频中很快就会遇到。而这些情况是很难画出图的，因此更无法将其可视化。因此我们真正需要的是编写程序来找出这些最小化代价函数的$θ_{0}$和$θ_{1}$的值。在下一节视频中 我们将介绍一种算法<strong>能够自动地找出能使代价函数$J$最小化的参数$θ_{0}$和$θ_{1}$的值</strong>。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第一周 (5)参数学习-梯度下降算法</title>
    <url>/2016/07/24/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E5%91%A8%20(5)%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/8SpIM/gradient-descent">视频地址</a></p>
<p>我们已经定义了代价函数$J$，而在这段视频中，我想向你们介绍梯度下降算法。这种算法可以将代价函数$J$最小化。梯度下降是很常用的算法，它不仅被用在线性回归上，它实际上被广泛的应用于机器学习领域中的众多领域。在后面课程中，为了解决其他线性回归问题，我们也将使用梯度下降法最小化其他函数，而不仅仅是只用在本节课的代价函数$J$。</p>
<p>下面是问题概述：</p>
<p><img src="/img/16_07_24/001.png" alt=""></p>
<p>在这里我们有一个函数$J(θ_{0}, θ_{1})$，也许这是一个线性回归的代价函数，也许是一些其他函数。我们需要用一个算法，来最小化函数$J(θ_{0}, θ_{1})$，就像刚才说的：事实证明，梯度下降算法可应用于多种多样的函数求解，所以想象一下如果你有一个函数$J(θ_{0}, θ_{1}, θ_{2}, …,θ_{n})$，你希望可以通过最小化$θ_{0}$到$θ_{n}$来最小化此代价函数$J(θ_{0}, θ_{1}, θ_{2}, …,θ_{n})$。用n个θ是为了证明梯度下降算法可以解决更一般的问题，但为了简洁起见，为了简化符号，在接下来的视频中我只用两个参数。</p>
<p>下面就是关于梯度下降的构想：</p>
<p><img src="/img/16_07_24/002.png" alt=""></p>
<p>我们要做的是我们要开始对$θ_{0}$和$θ_{0}$进行一些初步猜测。它们到底是什么其实并不重要，但通常的选择是将$θ_{0}$设为0将$θ_{1}$也设为0，将它们都初始化为0。我们在梯度下降算法中要做的就是不停地一点点地改变 $θ_{0}$和$θ_{1}$，试图通过这种改变使得$J(θ_{0}, θ_{1})$变小，直到我们找到$J$的最小值，或许是局部最小值。</p>
<p>让我们通过一些图片来看看梯度下降法是如何工作的：</p>
<p><img src="/img/16_07_24/003.png" alt=""></p>
<p>我在试图让这个函数值最小，注意坐标轴$θ_{0}$和$θ_{1}$在水平轴上，而函数$J$在垂直坐标轴上。图形表面高度则是$J$的值，我们希望最小化这个函数，所以我们从$θ_{0}$和$θ_{1}$的某个值出发，所以想象一下，对$θ_{0}$和$θ_{1}$赋以某个初值，也就是对应于从这个函数表面上的某个起始点出发。所以不管$θ_{0}$和$θ_{1}$的取值是多少，我将它们初始化为0，但有时你也可把它初始化为其他值。</p>
<p>现在我希望大家把这个图像想象为一座山，想像类似这样的景色：公园中有两座山，想象一下你正站立在山的这一点上，站立在你想象的公园这座红色山上。在梯度下降算法中我们要做的就是旋转360度，看看我们的周围，并问自己我要在某个方向上用小碎步尽快下山，如果我想要尽快走下山，这些小碎步需要朝什么方向? </p>
<p>如果我们站在山坡上的这一点，你看一下周围，你会发现最佳的下山方向大约是那个方向。好的现在你在山上的新起点上：</p>
<p><img src="/img/16_07_24/004.png" alt=""></p>
<p>你再看看周围，然后再一次想想我应该从什么方向迈着小碎步下山?然后你按照自己的判断又迈出一步，往那个方向走了一步，然后重复上面的步骤，从这个新的点，你环顾四周并决定从什么方向将会最快下山，然后又迈进了一小步，又是一小步，并依此类推……直到局部最低点的位置。</p>
<p><img src="/img/16_07_24/005.gif" alt=""></p>
<p>此外这种下降有一个有趣的特点，第一次我们是从这个点开始进行梯度下降算法的，在这一点上从这里开始。现在想象一下我们在刚才的右边一些的位置，开始使用梯度下降。如果你重复上述步骤停留在该点并环顾四周，往下降最快的方向迈出一小步，然后环顾四周，又迈出一步然后如此往复，如果你从右边不远处开始，梯度下降算法将会带你来到这个右边的第二个局部最优处：</p>
<p><img src="/img/16_07_24/006.png" alt=""></p>
<p>如果从刚才的第一个点出发，你会得到第一个局部最优解，但如果你的起始点偏移了一些，你会得到一个非常不同的局部最优解。这就是梯度下降算法的一个特点。我们会在之后继续探讨这个问题。</p>
<p>看看这个图，这是梯度下降算法的定义：</p>
<p><img src="/img/16_07_24/007.png" alt=""></p>
<p>我们将会反复做这些直到收敛。我们要更新参数$θ_{j}$，方法是反复执行$θ_{j} - α\frac{∂}{∂θ_{j}}J(θ_{0},θ_{1})$。</p>
<p>让我们来看看这个公式有很多细节问题，我来详细讲解一下。</p>
<p>首先，注意这个符号$:=$，我们使用$:=$表示<strong>赋值</strong>。这是一个赋值运算符。具体地说，如果我写$a:= b$在计算机专业内，这意味着不管$a$的值是什么，取$b$的值并将其赋给$a$这意味着我们让$a$等于$b$的值 这就是赋值。我也可以这样写 $a:= a+1$这意味着取出$a$值并将其增加1。与此不同的是如果我写$a=b$就是在断言$a$的值是等于$b$的值。</p>
<p>其次，这里的$α$是一个数字，被称为<strong>学习速率(learn )</strong>。什么是$α$呢?在<strong>梯度下降算法中它控制了我们下山时会迈出多大的步子</strong>。因此如果$α$值很大，那么相应的梯度下降过程中，我们会试图用大步子下山；如果$α$值很小，那么我们会迈着很小的小碎步下山。关于如何设置$α$的值等内容，在之后的课程中我会回到这里并且详细说明。</p>
<p>最后，是公式的这一部分：$\frac{∂}{∂θ_{j}}J(θ_{0},θ_{1})$这是一个微分项。我现在不想谈论它，但我会推导出这个微分项，并告诉你到底这要如何计算。你们中有人大概比较熟悉微积分，但即使你不熟悉微积分也不用担心，我会告诉你对这一项你最后需要做什么。</p>
<p>现在，在梯度下降算法中还有一个更微妙的问题：在梯度下降中，当$j=0$和$j=1$时，更新$θ_{0}$和$θ_{1}$的值，等式产生更新。实现梯度下降算法的微妙之处是，在这个表达式中如果你要更新这个等式，你需要同时更新$θ_{0}$和$θ_{1}$。我的意思是在这个等式中我们要这样更新</p>
<script type="math/tex; mode=display">
θ\_{0} := θ\_{0} - 一些东西</script><p>并更新 </p>
<script type="math/tex; mode=display">
θ\_{1} := θ\_{1} - 一些东西</script><p>实现方法是你应该计算公式右边的部分，通过那一部分计算出$θ_{0}$和$θ_{1}$的值，然后同时更新$θ_{0}$和$θ_{1}$。</p>
<p>让我进一步阐述这个过程。在梯度下降算法中，这是正确实现同时更新的方法：</p>
<p><img src="/img/16_07_24/008.png" alt=""></p>
<p>我要先设temp0和temp1变量，并且为它们付初值。然后同时更新$θ_{0}$和$θ_{1}$。这才是正确的实现方法。</p>
<p>与此相反，下面是不正确的实现方法：</p>
<p><img src="/img/16_07_24/009.png" alt=""></p>
<p>因为它没有做到同步更新。在这种不正确的实现方法中，我们计算 temp0然后更新$θ_{0}$，然后我们计算temp1，然后我们将 temp1赋给$θ_{1}$。这种方法和上面的方法的区别是，在计算temp1之前你已经更新了$θ_{0}$，那么你会使用$θ_{0}$的新的值来计算这个微分项，那么这会产生一个与上边不同的temp1的值。所以这并不是正确地实现梯度下降的做法。</p>
<p>同时更新是梯度下降中的一种常用方法。我们之后会讲到，实际上<strong>同步更新</strong>是更自然的实现方法。<strong>当人们谈到梯度下降时，他们的意思就是同步更新。</strong>如果用非同步更新去实现算法，代码可能也会正确工作，但是上边那种不正确的方法并不是人们所指的那个梯度下降算法，而是具有不同性质的其他算法。由于各种原因，这其中会表现出微小的差别。你应该做的是在梯度下降中真正实现同时更新，这些就是梯度下降算法的梗概。</p>
<p>在接下来的视频中，我们要进入这个微分项的细节之中。我已经写了出来但没有真正定义。如果你已经修过微积分课程，如果你熟悉偏导数和导数，这其实就是这个微分项。如果你不熟悉微积分，不用担心。即使你之前没有看过微积分，或者没有接触过偏导数，在接下来的视频中你会得到一切你需要知道的如何计算这个微分项的知识。下一个视频中希望我们能够给出实现梯度下降算法的所有知识。</p>
<h3 id="深入研究梯度下降算法"><a href="#深入研究梯度下降算法" class="headerlink" title="深入研究梯度下降算法"></a>深入研究梯度下降算法</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/GFFPB/gradient-descent-intuition">视频地址</a></p>
<blockquote>
<p>在之前的视频中，我们给出了一个数学上关于梯度下降的定义。本次视频我们更深入研究一下，更直观地感受一下这个算法是做什么的，以及梯度下降算法的更新过程有什么意义。</p>
</blockquote>
<p>这是我们上次视频中看到的梯度下降算法：</p>
<p><img src="/img/16_07_24/007.png" alt=""></p>
<p>提醒一下，这个参数$α$术语称为<strong>学习速率</strong>。它控制我们以多大的幅度更新这个参数$θ_{j}$。第二部分是导数项。而我在这个视频中要做的就是给你一个更直观的认识，这两部分有什么用，以及为什么当把这两部分放一起时，整个更新过程是有意义的。为了更好地让你明白我要做是用一个稍微简单的例子：比如我们想最小化的那个函数只有一个参数的情形，所以假如我们有一个代价函数$J$只有一个参数$θ_{1}$，那么我们可以画出一维的曲线：</p>
<p><img src="/img/16_07_24/010.png" alt=""></p>
<p>假如这是关于$θ_{1}$的函数$J$，其中$θ_{1}$是一个实数。现在我们已经对这个点上用于梯度下降法的$θ_{1}$进行了初始化。想象一下在我的函数图像上从这个点出发，那么梯度下降要做的事情是不断更新$θ_{j} - α\frac{∂}{∂θ_{j}}J(θ_{0},θ_{1})$这个项。我们要计算这个导数，我不确定之前你是否在微积分中学过导数，但对于这个问题，基本上可以说取这一点的切线，这条切线的斜率，其实这就是导数：</p>
<p><img src="/img/16_07_24/011.png" alt=""></p>
<p>现在这条线有一个正斜率，也就是说它有正导数。因此我得到的新的θ是：</p>
<script type="math/tex; mode=display">
θ\_{1} := θ\_{1} - α(positive num)</script><p>其中$positive num$就是一个为整数的斜率。$α$也就是学习速率也是一个正数，所以我要使$θ_{1}$减去一个东西，所以相当于我将$θ_{1}$向左移，使$θ_{1}$变小了。实际上我往这个方向移动，确实让我更接近那边的最低点：</p>
<p><img src="/img/16_07_24/012.png" alt=""></p>
<p>所以梯度下降到目前为止似乎是在做正确的事。</p>
<p>让我们来看看另一个例子。我们用同样的函数$J$，同样再画出函数$J(θ_{1})$的图像。而这次我们把参数初始化到左边这点：</p>
<p><img src="/img/16_07_24/013.png" alt=""></p>
<p>现在这一点切线的斜率，就是这个点的导数。但是这条线向下倾斜，所以这个点的导数是负数。因此，这个导数项小于等于零。所以当我更新$θ$时$θ$被更新为：</p>
<script type="math/tex; mode=display">
θ\_{1} := θ\_{1} - α(negative num)</script><p>这意味着我实际上是在增加$θ_{1}$，因为这是减去一个负数，意味着给$θ$加上一个正数。因此，我们将增加$θ_{1}$的值，这也让我更接近最小值了。</p>
<p>让我们接下来再看一看学习速率$α$：如果$α$太小或$α$太大，会出现什么情况。</p>
<p>这第一个例子:$α$太小会发生什么呢?</p>
<p><img src="/img/16_07_24/014.png" alt=""></p>
<p>如果α太小了，那么我要做的是要去用一个比较小的数乘以更新的值。 所以如果我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动，去努力接近最低点。所以如果$α$太小的话，可能会很慢。因为它需要很多步才能到达全局最低点。</p>
<p>那么如果$α$太大又会怎样呢?</p>
<p>如果$α$太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛。比如我们从一个已经接近最低点的点开始，由于导数是负数，因此指向右侧。但如果$α$太大的话，我会迈出很大一步。我的代价函数可能会离这个最低点越来越远。</p>
<p><img src="/img/16_07_24/015.png" alt=""></p>
<p>现在我的导数指向左侧，实际上在减小$θ$，但是你看如果我的学习速率过大，我会移动一大步，从这点一下子又到那点了。如果我的学习率太大，下一次迭代又移动了一大步，越过一次又越过一次，一次次越过最低点。直到你发现实际上离最低点越来越远，所以如果$α$太大，它会导致无法收敛，甚至发散。</p>
<p><img src="/img/16_07_24/016.png" alt=""></p>
<p>现在我还有一个问题，这问题挺狡猾的。当我第一次学习这个地方时 我花了很长一段时间才理解这个问题。如果我们预先把$θ_{1}$放在一个局部的最低点，你认为下一步梯度下降法会怎样工作？ </p>
<p><img src="/img/16_07_24/017.png" alt=""></p>
<p>其实，如果你将$θ_{1}$初始化在局部最优点，那么这一点的导数将等于0，因为那一点的切线是与x轴平行的，斜率为0。因此，在你的梯度下降更新过程中，所以$θ_{1}$的变化过程为：$θ_{1} := θ_{1} - α * 0$，所以这意味着你已经在局部最优点，它使得$θ_{1}$不再改变。因此，如果你的参数已经处于局部最低点，那么梯度下降法更新其实什么都没做。它不会改变参数的值。这也正是你想要的，因为它使你的解始终保持在局部最优点。</p>
<p>局部最优点也解释了为什么即使学习速率$α$保持不变时，梯度下降也可以收敛到局部最低点。我们来看一个例子：</p>
<p><img src="/img/16_07_24/018.png" alt=""></p>
<p>这是代价函数$J(θ)$，我想找到它的最小值。首先在那个品红色的点初始化我的梯度下降算法，如果我更新一步梯度下降，它会带我到这个绿色的点，因为这个点的导数是相当陡的。现在，在这个绿色的点，再更新一步，你会发现我的导数(即斜率)相对于在品红色点是没那么陡的，对吧？因为<strong>随着我接近最低点，我的导数越来越接近零</strong>。所以，梯度下降一步后，新的导数会变小一点点。然后我想再梯度下降一步，在这个绿点我会用一个更小的一步到达新的红色点，这时更接近全局最低点了。因此这点的导数会比在绿点时更小。所以我再进行一步梯度下降时，我的导数项是更小的，$θ_{1}$更新的幅度就会更小，所以你会移动更小的一步。<strong>随着梯度下降法的运行，你移动的幅度会自动变得越来越小，直到最终移动幅度非常小，你会发现已经收敛到局部极小值。</strong>所以回顾一下，在梯度下降法中，当我们接近局部最低点时 梯度下降法会自动采取更小的幅度，这是因为当我们接近局部最低点时，很显然在局部最低时导数等于零。所以当我们，接近局部最低时，导数值会自动变得越来越小，所以梯度下降将自动采取较小的幅度。<strong>所以实际上没有必要再另外减小α</strong>。</p>
<p>这就是梯度下降算法，你可以用它来最小化任何代价函数$J$。不只是线性回归中的代价函数$J$。在接下来的视频中，我们要用代价函数$J$回到它的本质：线性回归中的代价函数(也就是我们前面得出的平方误差函数)结合梯度下降法以及平方代价函数，我们会得出第一个机器学习算法即线性回归算法。</p>
<h3 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/kCvQc/gradient-descent-for-linear-regression">视频地址</a></p>
<blockquote>
<p>在以前的视频中我们谈到关于梯度下降算法。梯度下降是很常用的算法 它不仅被用在线性回归上和线性回归模型、平方误差代价函数。在这段视频中，我们要<strong>将梯度下降和代价函数结合</strong>，在后面的视频中我们将用到此算法，并将其应用于具体的拟合直线的线性回归算法里。</p>
</blockquote>
<p>这就是我们在之前的课程里所做的工作：</p>
<p><img src="/img/16_07_24/019.png" alt=""></p>
<p>左侧梯度下降法，这个算法你应该很熟悉。右侧是线性回归模型，还有线性假设和平方误差代价函数。我们将要做的就是：用梯度下降的方法 来最小化平方误差代价函数。为了达到梯度下降，我们需要的关键项 是这里这个微分项 ：</p>
<script type="math/tex; mode=display">
\frac{∂}{∂θ\_{j}}J(θ\_{0},θ\_{1})</script><p>通过之前学习的公式，带入之后，可以得出：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\frac{∂}{∂θ\_{j}}J(θ\_{0},θ\_{1})
&=
\frac{∂}{∂θ\_{j}}
\frac{1}{2m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})^{2}\\\\
&=
\frac{∂}{∂θ\_{j}}
\frac{1}{2m}
\sum\_{i=1}^{m}
(θ\_{0} + θ\_{1}(x^{(i)}) - y^{(i)})^{2}\\\\
\end{align\*}</script><p>实际上我们需要弄清楚这两个偏导数项是什么：</p>
<script type="math/tex; mode=display">
j = 0 时: \frac{∂}{∂θ\_{0}}J(θ\_{0},θ\_{1}) = ?
\\\\
j = 1 时: \frac{∂}{∂θ\_{1}}J(θ\_{0},θ\_{1}) = ?</script><p>其实根据上面的推导，我们很容易就能得出结果：</p>
<script type="math/tex; mode=display">
\begin{align\*}
j = 0 时: \frac{∂}{∂θ\_{0}}J(θ\_{0},θ\_{1}) 
&= 
\frac{∂}{∂θ\_{0}}
\frac{1}{2m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})^{2}\\\\
&=
\frac{1}{m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})
\\\\
j = 1 时: \frac{∂}{∂θ\_{1}}J(θ\_{0},θ\_{1})
&=
\frac{∂}{∂θ\_{1}}
\frac{1}{2m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})^{2}\\\\
&=
\frac{1}{m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})·x^{i}
\end{align\*}</script><blockquote>
<p>计算这些偏导数项需要一些多元微积分，如果你掌握了微积分你可以随便自己推导这些。但如果你不太熟悉微积分，别担心，你可以直接用这些已经算出来的结果。你不需要掌握微积分或者别的东西来完成作业，你只需要会用梯度下降就可以。</p>
</blockquote>
<p>在我们算出这些微分项以后 这些微分项实际上就是代价函数$J$的斜率。现在可以将它们放回我们的梯度下降算法中：</p>
<p><img src="/img/16_07_24/020.png" alt=""></p>
<p>所以这就是专用于线性回归的梯度下降。反复执行括号中的式子直到收敛。$θ_{0}$和$θ_{1}$不断被更新。</p>
<p><strong>提醒一下：执行梯度下降时有一个细节要注意，就是必须要同时更新$θ_{0}$和$θ_{1}$。</strong></p>
<p>所以让我们来看看梯度下降是如何工作的。我们用梯度下降解决问题的 一个原因是它更容易得到局部最优值。当我第一次解释梯度下降时，我展示过这幅图：</p>
<p><img src="/img/16_07_24/021.png" alt=""></p>
<p>我们知道根据你的初始化的不同，你会得到不同的局部最优解。但是 事实证明，用于线性回归的代价函数，总是这样一个弓形的样子：</p>
<p><img src="/img/16_07_24/022.png" alt=""></p>
<p>这个函数的专业术语是：<strong>凸函数(convex function)</strong>。</p>
<p>我不打算在这门课中给出凸函数的定义，但不正式的说法是它就是一个弓形的函数。<strong>因此这个函数，没有任何局部最优解，只有一个全局最优解。</strong>并且无论什么时候，你对这种代价函数使用线性回归，梯度下降法得到的结果，总是收敛到全局最优值。因为没有全局最优以外的其他局部最优点。</p>
<p>现在让我们来看看这个算法的执行过程：</p>
<p>像往常一样这是假设函数的图，还有代价函数$J$的图：</p>
<p><img src="/img/16_07_24/023.png" alt=""></p>
<p>为了展示需要，在这个梯度下降的实现中，我们把$θ_{0}$初始化为900，$θ_{1}$初始化为-0.1。这对应的假设就应该是这样$h(x)= 900 - 0.1x$。</p>
<p>现在如果我们进行梯度下降，在之前点的基础上向左下方移动了一小步，这就得到了第二个点。而且你注意到这条线改变了一点点，然后我再继续一步步进行梯度下降，左边这条线就会越来越拟合所有的点，直到它渐渐的收敛于全局最小值。这个全局最小值对应的假设函数给出了最拟合数据的解，这就是梯度下降法。</p>
<p><img src="/img/16_07_24/024.gif" alt=""></p>
<p>我们最终得到了房价数据的最好拟合结果，现在你可以用它来预测。假如你有个朋友，他有一套房子面积1250平方英尺(约116平米)。现在你可以通过这个数据，然后告诉他们，也许他的房子可以卖到35万美元。</p>
<p>实际上我们刚刚使用的算法，有时也称为<strong>批量梯度下降(Batch Gradient Descent)</strong>。”批量梯度下降”指的是在梯度下降的每一步中，我们都用到了所有的训​​练样本。在梯度下降中，在计算微分求导项时，我们需要进行求和运算。所以在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有$m$个训练样本求和。因此，“批量梯度下降法”这个名字说明了我们需要考虑所有这一”批”训练样本。事实上有时也有其他类型的“梯度下降法”不是这种”批量”型的，不考虑整个的训练集而是每次只关注训练集中的一些小的子集。在后面的课程中我们也将介绍这些方法。但就目前而言，应用刚刚学到的算法，你应该已经掌握了批量梯度算法并且能把它应用到线性回归中了。</p>
<p>这就是用于线性回归的梯度下降法。如果你之前学过线性代数，你应该知道有一种计算代价函数$J$最小值的数值解法，不需要梯度下降这种迭代算法。在后面的课程中，我们也会谈到这个方法。它可以在不需要 多步梯度下降的情况下也能解出代价函数$J$的最小值，这是另一种称为<strong>正规方程(normal equations)</strong>的方法。可能你之前已经听说过这种方法，但实际上在数据量较大的情况下，梯度下降法比正规方程要更适用一些。现在我们已经掌握了梯度下降，我们可以在不同的环境中使用梯度下降法。我们还将在不同的机器学习问题中大量地使用它。所以祝贺大家成功学会你的第一个机器学习算法！希望大家能让这些算法真正地为你工作。但在此之前，我还想先在下一组视频中告诉你<strong>“泛化的梯度下降算法”</strong>，这将使梯度下降更加强大。在下一段视频中我将介绍这一问题。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第一周 (6)线性代数复习</title>
    <url>/2016/07/25/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%80%E5%91%A8%20(6)%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="线性代数复习"><a href="#线性代数复习" class="headerlink" title="线性代数复习"></a>线性代数复习</h2><blockquote>
<p>这个可选模块提供了线性代数概念的复习。在接下来的课程中，对线性代数的基本理解是必要的，特别是当我们开始涵盖多个变量的模型时。</p>
</blockquote>
<h3 id="矩阵和向量"><a href="#矩阵和向量" class="headerlink" title="矩阵和向量"></a>矩阵和向量</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/38jIT/matrices-and-vectors">视频地址</a></p>
<p>我们先复习一下线性代数的知识。在这段视频中，我会向大家介绍<strong>矩阵</strong>和<strong>向量</strong>的概念。</p>
<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><blockquote>
<p><strong>Matrix</strong>:Rectangular array of numbers.</p>
<p><strong>矩阵</strong>是指由数字组成的矩形阵列并写在方括号中间。</p>
</blockquote>
<p>例如下面就是一个矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1902 & 191 \\\\
1371 & 821 \\\\
949 & 1437 \\\\
147 & 1448
\end{bmatrix}</script><p>这些数字可能是机器学习问题的特征值，也可能表示其他意思。</p>
<p>接下来看一下其他矩阵的例子：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 2 & 3 \\\\
4 & 5 & 6
\end{bmatrix}</script><p>这里我们还需要知道的是，矩阵的维度应该写作：矩阵的行数乘以列数。具体到第一个例子是一个$4 × 2$的矩阵(即行数乘以列数)。第二个例子中的矩阵是一个$2 × 3$的矩阵。所以我们说这个矩阵的维度是$2 × 3$维。</p>
<p>有时候大家会发现会使用字母$\Re$来表示一个矩阵的维度。例如第一个例子中可以写作一个$\Re^{4 × 2}$的矩阵，第二个例子中可以说是一个$\Re^{2 × 3}$的矩阵。</p>
<p>接下来让我们来谈谈如何表达矩阵的某个特定元素。这里我说矩阵元素(这里指矩阵内部的某个数)。</p>
<p>我们通常使用矩阵名加下标的方式来表达矩阵中的某个元素。例如:</p>
<script type="math/tex; mode=display">
A\_{ij}</script><p>表达的是矩阵A中第$i$行，第$j$列的元素。</p>
<p>在第一个例子的矩阵中，$A_{11}$就等于1402，$A_{11}$就等于191。</p>
<p>如果你写出了$A_{43}$，这应该表示的是第四行第三列。而你知道 这个矩阵没有第三列。因此这是未定义的。或者你可以认为这是一个错误。</p>
<p>因此，矩阵提供了一种很好的方式，让你快速整理索引和访问大量数据。所以，这就是矩阵的定义。</p>
<h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>接下来让我们来谈谈什么是向量。</p>
<blockquote>
<p><strong>Vector</strong>:An n × 1 matrix.<br><strong>向量</strong>是只有一列的矩阵。</p>
</blockquote>
<p>例如下面就是一个向量：</p>
<script type="math/tex; mode=display">
y =
\begin{bmatrix}
460 \\\\
232 \\\\
315 \\\\
178
\end{bmatrix}</script><p>另一个术语是:这是一个四维的向量。也就意味着这是一个含有4个元素的向量。而且前面我们讲矩阵的时候提到过，这个符号$\Re^{3 × 2}$表示的是一个3行2列的矩阵，而对于这个向量，我们也同样可以表示为集合$\Re^{4}$。</p>
<p>我们将使用符号$y_{i}$来代表向量$y$的第$i$个元素。例如这里$y_{1}$表示第一个元素460，$y_{2}$表示第二个元素232。只有$y_{1}$至$y_{4}$是有意义的，因为这定义的是一个四维向量。</p>
<p>此外事实上有两种方法来表达某个向量中某个索引：</p>
<p><img src="/img/16_07_25/001.png" alt=""></p>
<p>左边是<strong>1-索引向量</strong>，它的元素写作$y_{1}$，$y_{2}$，$y_{3}$，$y_{4}$。而右边的是<strong>0-索引向量</strong>，它的元素写作，$y_{0}$，$y_{1}$，$y_{2}$，$y_{3}$。这有点像一些初级语言中的数组。</p>
<p>事实上在数学中，1-索引的情况比较多。而对于很多机器学习的应用问题来说0-索引向量为我们提供了一个更方便的符号表达。</p>
<p>所以你应该默认我们使用的是1-索引法表示向量。在本课程的后面所有 关于线性代数的视频中，我都将使用1-索引法表示向量。</p>
<p>但你要明白，当我们谈论到机器学习的应用问题时，如果我们需要使用0-索引向量的话，我会明确地告诉你</p>
<p>最后，按照惯例，通常在书写矩阵和向量时大多数人会使用大写字母来表示矩阵。因此，我们要使用大写字母，如$A$、$B$、$C$、$X$来表示矩阵。而通常我们会使用小写字母，像$a$、$b$、$x$、$y$来表示数字或是原始的数字或标量或向量。这是实际的使用习惯，我们也经常看到使用小写字母$y$来表示向量，但我们平时是用大写字母来表示矩阵 。</p>
<h3 id="加减法与数乘运算"><a href="#加减法与数乘运算" class="headerlink" title="加减法与数乘运算"></a>加减法与数乘运算</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/R4hiJ/addition-and-scalar-multiplication">视频地址</a></p>
<p>在这段视频中，我们将要介绍矩阵的加减法以及数乘运算。</p>
<h4 id="矩阵的加减法运算"><a href="#矩阵的加减法运算" class="headerlink" title="矩阵的加减法运算"></a>矩阵的加减法运算</h4><p>让我们从下面这个例子开始：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 \\\\
2 & 5 \\\\
3 & 1
\end{bmatrix}
+
\begin{bmatrix}
4 & 0.5 \\\\
2 & 5 \\\\
0 & 1
\end{bmatrix}
= 
\begin{bmatrix}
5 & 0.5 \\\\
4 & 10 \\\\
3 & 2
\end{bmatrix}</script><p>假设有这样两个矩阵，如果想对它们做求和运算，应该怎么做呢？答案是：如果你想将两个矩阵相加，你只需要将这两个矩阵的每一个元素都逐个相加即可。</p>
<p>这里大家不难发现，<strong>只有相同维度的两个矩阵才能相加</strong>。对于这个例子而言，是两个3行2列的矩阵相加，这是一个3行2列的矩阵，因此这两个矩阵相加的结果也是一个3行2列的矩阵。所以你只能将相同维度的矩阵，进行相加运算，同时所得到的结果将会是一个新的矩阵，这个矩阵与相加的两个矩阵维度相同。</p>
<p>反过来，如果你想将下面这样两个维度不相同的矩阵相加，就会出现错误了。所以我们不能将它们相加，这两个矩阵的和是没有意义的。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 \\\\
2 & 5 \\\\
3 & 1
\end{bmatrix}
+
\begin{bmatrix}
4 & 0.5 \\\\
2 & 5 
\end{bmatrix}
= 
error</script><p>这就是矩阵的加法运算。</p>
<h4 id="矩阵的数乘运算"><a href="#矩阵的数乘运算" class="headerlink" title="矩阵的数乘运算"></a>矩阵的数乘运算</h4><p>矩阵的数乘运算指的是用标量去乘以矩阵中的每个元素，最终得到的结果就是数乘运算的结果矩阵。这里的标量指的是实数。</p>
<p>例如下面两个例子：</p>
<script type="math/tex; mode=display">
3 ×
\begin{bmatrix}
1 & 0 \\\\
2 & 5 \\\\
3 & 1
\end{bmatrix}
= 
\begin{bmatrix}
3 & 0 \\\\
6 & 15 \\\\
9 & 3
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
4 & 0 \\\\
6 & 3 
\end{bmatrix}
/ 4
= 
1/4
\begin{bmatrix}
4 & 0 \\\\
6 & 3 
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 \\\\
3/2 & 3/4 
\end{bmatrix}</script><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>见<a href="/2015/11/29/线性代数01-矩阵乘法/">矩阵乘法</a></p>
<h3 id="矩阵乘法性质"><a href="#矩阵乘法性质" class="headerlink" title="矩阵乘法性质"></a>矩阵乘法性质</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/W1LNU/matrix-multiplication-properties">视频地址</a></p>
<p>本节主要介绍矩阵乘法的性质。</p>
<h4 id="矩阵乘法不满足交换律"><a href="#矩阵乘法不满足交换律" class="headerlink" title="矩阵乘法不满足交换律"></a>矩阵乘法不满足交换律</h4><blockquote>
<p>Let A and B be matrices.Then in general, A × B ≠ B × A.(not commutative.)<br>如果A和B是矩阵，那么一般情况下，A × B ≠ B × A (不满足交换律)。</p>
</blockquote>
<p>例如：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 1 \\\\
0 & 0
\end{bmatrix}
\begin{bmatrix}
0 & 0 \\\\
2 & 0
\end{bmatrix}
= 
\begin{bmatrix}
2 & 0 \\\\
0 & 0
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
0 & 0 \\\\
2 & 0
\end{bmatrix}
\begin{bmatrix}
1 & 1 \\\\
0 & 0
\end{bmatrix}
= 
\begin{bmatrix}
0 & 0 \\\\
2 & 2
\end{bmatrix}</script><h4 id="矩阵乘法满足结合律"><a href="#矩阵乘法满足结合律" class="headerlink" title="矩阵乘法满足结合律"></a>矩阵乘法满足结合律</h4><script type="math/tex; mode=display">
A × B × C = (A × B) × C = A × (B × C)</script><h4 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h4><p>定义单位矩阵为$I$(或者$I_{n×n}$)。单位矩阵满足:</p>
<script type="math/tex; mode=display">
I × Z = Z × I = Z</script><p>其中$Z$是任意矩阵。</p>
<p>实际上单位矩阵就是对角线上元素为1，其他元素为0的方阵。例如下面几个都是单位矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 \\\\
0 & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0\\\\
0 & 1 & 0\\\\
0 & 0 & 1
\end{bmatrix}</script><h3 id="矩阵的逆和矩阵的转置"><a href="#矩阵的逆和矩阵的转置" class="headerlink" title="矩阵的逆和矩阵的转置"></a>矩阵的逆和矩阵的转置</h3><h4 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h4><p>矩阵的逆以及求解逆的方式，见<a href="/2015/11/29/线性代数02-矩阵的逆/">矩阵的逆</a></p>
<p>奇异矩阵的介绍，见<a href="/2015/11/30/线性代数04-奇异矩阵/">奇异矩阵</a></p>
<h4 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h4><p>如果用$A$表示一个矩阵，那么矩阵A的转置就是$A^{T}$。矩阵的转置就相当于将这个矩阵按照45度角求镜像，矩阵的行变为矩阵的列，矩阵的列变为矩阵的行。</p>
<blockquote>
<p>Let A be an $m × n$ matrix, and let $B = A^{T}$.Then $B$ is an $n × m$ matrix, and $B_{ij} = A_{ji}$.<br>如果A是一个$m × n$的矩阵，并且矩阵B是A的转置，那么B是一个$n × m$的矩阵，并且$B_{ij} = A_{ji}$。</p>
</blockquote>
<p>举个例子：</p>
<script type="math/tex; mode=display">
A = 
\begin{bmatrix}
1 & 2 & 0\\\\
3 & 5 & 9
\end{bmatrix}</script><script type="math/tex; mode=display">
A^{T} = 
\begin{bmatrix}
1 & 3\\\\
2 & 5\\\\
0 & 9
\end{bmatrix}</script><p>矩阵的转置就是第一个矩阵的第一行转变为转置的第一列，第二行转变为第二列。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第七周 (1)大间距分类</title>
    <url>/2017/02/06/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%83%E5%91%A8%20(1)%E5%A4%A7%E9%97%B4%E8%B7%9D%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/sHfVT/optimization-objective">视频地址</a></p>
<blockquote>
<p>到目前为止，你已经见过一系列不同的学习算法。在监督学习中许多学习算法的性能都非常类似，因此重要的不是你该选择使用学习算法A还是学习算法B，而更重要的是应用这些算法时所创建的大量数据。</p>
<p>在应用这些算法时，表现情况通常依赖于你的水平。比如你为学习算法所设计的 特征量的选择，以及如何选择正则化参数，诸如此类的事。还有一个更加强大的算法，广泛的应用于工业界和学术界，它被称为<strong>支持向量机(Support Vector Machine)</strong>。</p>
<p>与逻辑回归和神经网络相比，<strong>支持向量机</strong>或者简称<strong>SVM</strong>在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p>
<p>因此，在接下来的视频中我会探讨这一算法，在稍后的课程中，我也会对监督学习算法进行简要的总结。当然，仅仅是作简要描述。但对于<strong>支持向量机</strong>，鉴于该算法的强大和受欢迎度，在本课中我会花许多时间来讲解它，它也是我们所介绍的最后一个监督学习算法。</p>
</blockquote>
<h3 id="支持向量机引入"><a href="#支持向量机引入" class="headerlink" title="支持向量机引入"></a>支持向量机引入</h3><p>为了描述<strong>支持向量机</strong>，我将会从逻辑回归开始，展示我们如何一点一点修改，来得到本质上的支持向量机。</p>
<p>在逻辑回归中，我们已经熟悉了它的假设函数形式：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x)=\frac{1}{1+\mathrm{e}^{-\theta^{T}x}}</script><p>和S型激励函数：</p>
<p><img src="/img/17_02_06/001.png" width = "300" height = "200" align=center /></p>
<p>现在让我们一起来考虑下，我们想要逻辑回归做什么？</p>
<ul>
<li><p>如果有一个样本为$y=1$，那么我们希望假设函数$h(x)≈1$，即$\theta^{T}&gt;&gt;0$。你不难发现，此时逻辑回归的输出将趋近于1。</p>
</li>
<li><p>如果有另一个样本为$y=0$，那么我们希望假设函数$h(x)≈0$，即$\theta^{T}&lt;&lt;0$。此时逻辑回归的输出将趋近于0。</p>
</li>
</ul>
<hr>
<p>如果你进一步观察逻辑回归的代价函数，你会发现每个样本(x, y)都会为总代价函数增加这样的一项：</p>
<script type="math/tex; mode=display">
-(ylogh\_{\theta}(x) + (1-y)log(1-h\_{\theta}(x))) 
= -ylog\frac{1}{1+\mathrm{e}^{-\theta^{T}x}} - (1-y)log(1-\frac{1}{1+\mathrm{e}^{-\theta^{T}x}})</script><p>在逻辑回归中，这里的这一项就是表示一个训练样本所对应的表达式。</p>
<p>现在一起来考虑<strong>y=1</strong>和<strong>y=0</strong>的两种情况：</p>
<ul>
<li><strong>y=1的情况下（即$\theta^{T}x&gt;&gt;0$）</strong>：</li>
</ul>
<p>对于</p>
<script type="math/tex; mode=display">
-ylog\frac{1}{1+\mathrm{e}^{-\theta^{T}x}} - (1-y)log(1-\frac{1}{1+\mathrm{e}^{-\theta^{T}x}})</script><p>由于$(1-y)=0$，所以我们只需考虑前半部分：</p>
<script type="math/tex; mode=display">
-ylog\frac{1}{1+\mathrm{e}^{-\theta^{T}x}}</script><p>如果画出代价函数关于$z$的图，你会看到下图：</p>
<p><img src="/img/17_02_06/002.png" width = "300" height = "200" align=center /></p>
<p>我们可以看到，当$z$增大时(即$\theta^{T}x$增大时)，$z$对应的值会变得非常小，对整个代价函数而言，影响也非常小。</p>
<p>现在开始建立<strong>支持向量机</strong>，我们会从这个代价函数$-ylog\frac{1}{1+\mathrm{e}^{-\theta^{T}x}}$开始，一点点的修改：</p>
<p>我们画出一个非常接近于逻辑回归函数的折线，这个折线经由$z=1$的一点的两条线段组成：</p>
<p><img src="/img/17_02_06/003.png" width = "300" height = "200" align=center /></p>
<p>到这里已经非常接近逻辑回归中使用的代价函数了，只是这里是由两条线段组成。先不要考虑线段的斜率，这并不重要，重要的是我们将在$y=1$的前提下使用新的代价函数。</p>
<ul>
<li><strong>y=0的情况下（即$\theta^{T}x&lt;&lt;0$）</strong>：</li>
</ul>
<p>对于</p>
<script type="math/tex; mode=display">
-ylog\frac{1}{1+\mathrm{e}^{-\theta^{T}x}} - (1-y)log(1-\frac{1}{1+\mathrm{e}^{-\theta^{T}x}})</script><p>由于$y=0$，所以我们只需考虑后半部分：</p>
<script type="math/tex; mode=display">
(1-y)log(1-\frac{1}{1+\mathrm{e}^{-\theta^{T}x}})</script><p>如果画出代价函数关于$z$的图，你会看到下图：</p>
<p><img src="/img/17_02_06/004.png" width = "300" height = "200" align=center /></p>
<p>用相似的方法，我们开始建立<strong>支持向量机</strong>：</p>
<p><img src="/img/17_02_06/005.png" width = "300" height = "200" align=center /></p>
<p>我们将在$y=0$的前提下使用新的代价函数。</p>
<hr>
<p>那么现在我们来给这两个方程命名：</p>
<p>对于这个函数：</p>
<p><img src="/img/17_02_06/003.png" width = "300" height = "200" align=center /></p>
<p>我们命名为<strong>$cost_{1}(z)$</strong>。</p>
<p>对于第二个函数：</p>
<p><img src="/img/17_02_06/005.png" width = "300" height = "200" align=center /></p>
<p>我们命名为<strong>$cost_{0}(z)$</strong>。</p>
<p>这里的下标指的是在函数中对应的$y=1$和$y=0$的情况。</p>
<hr>
<h3 id="构建支持向量机"><a href="#构建支持向量机" class="headerlink" title="构建支持向量机"></a>构建支持向量机</h3><p>拥有了这些定义之后，现在我们就开始构建<strong>支持向量机</strong>。</p>
<h4 id="1-替换逻辑回归函数"><a href="#1-替换逻辑回归函数" class="headerlink" title="1.替换逻辑回归函数"></a>1.替换逻辑回归函数</h4><p>这就是我们在逻辑回归中使用的代价函数$J(\theta)$：</p>
<p><img src="/img/17_02_06/006.png" alt=""></p>
<p>对于支持向量机而言，实际上，我们要将</p>
<ul>
<li><p>上面式子中的这一项：$(-logh_{\theta}(x^{(i)}))$替换为：$cost_{1}(z)$，即:$cost_{1}(\theta^{T}x^{(i)})$</p>
</li>
<li><p>同样，这一项：$((-log(1-h_{\theta}(x^{(i)}))))$替换为：$cost_{0}(z)$，即:$cost_{0}(\theta^{T}x^{(i)})$</p>
</li>
</ul>
<p>这里替换之后的$cost_{1}(z)$和$cost_{0}(z)$就是上面提到的那两条靠近逻辑回归函数的折线。</p>
<p>所以对于<strong>支持向量机</strong>的最小化代价函数问题，代价函数的形式如下：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ} 
\frac{1}{m}[
\sum\_{i=1}^{m}
y^{(i)}
cost\_{1}(\theta^{T}x^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}x^{(i)})
]+
\frac{\lambda}{2m}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><h4 id="2-去除多余的常数项-frac-1-m"><a href="#2-去除多余的常数项-frac-1-m" class="headerlink" title="2.去除多余的常数项 $\frac{1}{m}$"></a>2.去除多余的常数项 $\frac{1}{m}$</h4><p>现在按照<strong>支持向量机</strong>的惯例，我们去除$\frac{1}{m}$这一项，因为这一项是个常数项，即使去掉我们也可以得出相同的$\theta$最优值：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ} 
\sum\_{i=1}^{m}
[
y^{(i)}
cost\_{1}(\theta^{T}x^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}x^{(i)})
]+
\frac{\lambda}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><h4 id="3-正则化项系数的处理"><a href="#3-正则化项系数的处理" class="headerlink" title="3.正则化项系数的处理"></a>3.正则化项系数的处理</h4><p>在逻辑回归的目标函数中，我们有两项表达式：</p>
<ul>
<li>来自于训练样本的代价函数:</li>
</ul>
<script type="math/tex; mode=display">
\frac{1}{m}[
\sum\_{i=1}^{m}
y^{(i)}
(-logh\_{\theta}(x^{(i)}))+
(1-y^{(i)})
((-log(1-h\_{\theta}(x^{(i)}))))
]</script><ul>
<li>正则化项：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\lambda}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><p>我们不得不使用正则化项来平衡我们的代价函数。这就相当于：</p>
<script type="math/tex; mode=display">
A + \lambda B</script><p>其中A相当于上面的第一项，B相当于第二项。</p>
<p>我们通过修改不同的正则化参数$\lambda$来达到优化目的，这样我们就能够使得训练样本拟合的更好。</p>
<p>但对于<strong>支持向量机</strong>，按照惯例我们将使用一个不同的参数来替换这里使用的$\lambda$来实现权衡这两项的目的。这个参数我们称为<strong>C</strong>。同时将优化目标改为:</p>
<script type="math/tex; mode=display">
CA + B</script><p>因此，在逻辑回归中，如果给$\lambda$一个很大的值，那么就意味着给与$B$了一个很大的权重，而在<strong>支持向量机</strong>中，就相当于对$C$设定了一个非常小的值，这样一来就相当于对$B$给了比$A$更大的权重。</p>
<p>因此，这只是一种来控制这种权衡关系的不同的方式。当然你也可以把这里的$C$当做$farc{1}{\lambda}$来使用。</p>
<p>因此，这样就得到了在<strong>支持向量机</strong>中的我们的整个优化目标函数：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
C
\sum\_{i=1}^{m}[
y^{(i)}
cost\_{1}(\theta^{T}x^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}x^{(i)})
]+
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><hr>
<p>最后有别于<strong>逻辑回归</strong>的一点，对于<strong>支持向量机</strong>假设函数的形式如下：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = 1 \ \ \ if \ \theta^Tx \ge 0</script><script type="math/tex; mode=display">
h\_{\theta}(x) = 0 \ \ \ if \ \theta^Tx \lt 0</script><p>而不是<strong>逻辑回归</strong>中的S型曲线：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x)=\frac{1}{1+e^{-x}}</script><h2 id="大间距的直觉"><a href="#大间距的直觉" class="headerlink" title="大间距的直觉"></a>大间距的直觉</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/wrjaS/large-margin-intuition">视频地址</a></p>
<blockquote>
<p>人们有时将<strong>支持向量机</strong>看做是<strong>大间距分类器</strong>。在这一部分，我将介绍其中的含义，这有助于我们直观地理解SVM模型的假设是什么样的。</p>
</blockquote>
<p>这是我的支持向量机模型的代价函数：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
C
\sum\_{i=1}^{m}[
y^{(i)}
cost\_{1}(\theta^{T}x^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}x^{(i)})
]+
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><ul>
<li>如果你有一个正样本，即$y=1$时，那么代价函数$cost_{1}(z)$的图像如下：</li>
</ul>
<p><img src="/img/17_02_06/007.png" width = "300" height = "200" align=center /></p>
<p>可以看出，<strong>只有在$z\ge1$(即$\theta^{T}x\ge1$)时(不仅仅是$\ge0$)，代价函数$cost_{1}(z)$的值才等于0</strong>。</p>
<ul>
<li>反之，如果你有一个负样本，即$y=0$时，那么代价函数$cost_{0}(z)$的图像如下：</li>
</ul>
<p><img src="/img/17_02_06/008.png" width = "300" height = "200" align=center /></p>
<p>可以看出，<strong>只有在$z\le-1$(即$\theta^{T}x\le-1$)时(不仅仅是$\lt0$)，代价函数$cost_{0}(z)$的值才等于0</strong>。</p>
<p>这是<strong>支持向量机</strong>的一个有趣的性质。</p>
<h3 id="安全距离因子"><a href="#安全距离因子" class="headerlink" title="安全距离因子"></a>安全距离因子</h3><p>事实上，在逻辑回归中：</p>
<ul>
<li><p>如果你有一个正样本，即$y=1$的情况下，我们仅仅需要$\theta^{T}x\ge0$；</p>
</li>
<li><p>如果你有一个负样本，即$y=0$的情况下，我们仅仅需要$\theta^{T}x\lt0$；</p>
</li>
</ul>
<p>就能将该样本恰当的分类了。</p>
<p>但是<strong>支持向量机</strong>的要求更高，不仅仅要求$\theta^{T}x\ge0$或$\theta^{T}x\lt0$，而且要求$\theta^{T}x$比0大很多，或小很多。比如这里要求$\theta^{T}x\ge1$以及$\theta^{T}x\le-1$。</p>
<p>这就相当于在<strong>支持向量机</strong>中嵌入了一个额外的安全因子（或者说是安全距离因子）。接下来让我们来看看这个因子会导致什么结果：</p>
<p>具体而言，我接下来会将代价函数中的常数项$C$设置成一个非常大的值，比如100000或者其他非常大的数，然后再来观察支持向量机会给出什么结果。</p>
<p>当代价函数中</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
C
\sum\_{i=1}^{m}[
y^{(i)}
cost\_{1}(\theta^{T}x^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}x^{(i)})
]+
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><p>$C$的值非常大时，则最小化代价函数的时候，我们会很希望找到一个使第一项：</p>
<script type="math/tex; mode=display">
\sum\_{i=1}^{m}[
y^{(i)}
cost\_{1}(\theta^{T}x^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}x^{(i)})
]</script><p>为0的最优解。</p>
<p>可以看到当输入一个正样本$y^{(i)}=1$时，我们想令上面这一项为0，从图中可以得出</p>
<p><img src="/img/17_02_06/007.png" width = "300" height = "200" align=center /></p>
<p>对于代价函数$cost_{1}(z)$我们需要使得$\theta^{T}x^{(i)}\ge1$。</p>
<p>类似地，对于一个负训练样本$y^{(i)}=0$时，我们想令上面这一项为0，从图中可以得出</p>
<p><img src="/img/17_02_06/008.png" width = "300" height = "200" align=center /></p>
<p>对于代价函数$cost_{0}(z)$我们需要使得$\theta^{T}x^{(i)}\le-1$。</p>
<hr>
<p>这样一来会产生下面这种优化问题：</p>
<p>因为我们将选择参数使第一项为0，因此这个函数的第一项为0，因此是：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
C0+
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><p>我们知道是$C0$的结果是0，因此可以删掉，所以最终得到的结果是：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><p>其中：</p>
<ul>
<li>若$y^{(i)}=1$时，则$\theta^{T}x^{(i)}\ge1$</li>
<li>若$y^{(i)}=0$时，则$\theta^{T}x^{(i)}\le-1$</li>
</ul>
<p>这样我们就得到了一个非常有趣的决策边界。</p>
<h3 id="SVM决策边界：线性分割案例"><a href="#SVM决策边界：线性分割案例" class="headerlink" title="SVM决策边界：线性分割案例"></a>SVM决策边界：线性分割案例</h3><p>具体而言，如果你仔细观察下面这个既有正样本又有负样本的数据集</p>
<p><img src="/img/17_02_06/009.png" width = "300" height = "200" align=center /></p>
<p>不难看出，这个数据集是线性可分的（即存在一条直线把正负样本分开）。可以看出有很多直线都可以把正负样本区分开，比如下面这两条看起来不太自然的直线：</p>
<p><img src="/img/17_02_06/010.png" width = "300" height = "200" align=center /></p>
<p>支持向量机会选择黑色的这一条直线：</p>
<p><img src="/img/17_02_06/011.png" width = "300" height = "200" align=center /></p>
<p>这条直线看起来好很多，因为它看起来更加稳健。在数学上来讲就是这条直线拥有相对于训练数据更大的最短距离，这个所谓的距离就是指<strong>间距(margin)</strong>：</p>
<p><img src="/img/17_02_06/012.png" width = "300" height = "200" align=center /></p>
<p>而之前两条粉线和蓝线距离训练样本非常近，在分离样本时就会表现的比黑线差。</p>
<p>这就是<strong>支持向量机</strong>拥有<a href="http://baike.baidu.com/link?url=My7Y1mL_9uj-XdR2DC2kyGLop-AaPdzSgdNmgRmaJVYV77puxNs-_A7ERwLv3uWih02JCu6esljRn90mc3EkMwKXBckm_6wSqU42EX06vC4ouxQhinIZco7crxr7HetC">鲁棒性</a>的原因。因为它一直努力用一个最大间距来分离样本。因此支持向量机分类器有时又被称为<strong>大间距分类器</strong>。</p>
<p>也许你想知道支持向量机是如何做到产生这个大间距分类器的，目前我还没解释这一点，在下一节中我会直观的来解释这一点。目前这个例子只是用于理解<strong>支持向量机模型</strong>的做法，即努力将正负样本用最大的间距区分开。</p>
<h3 id="大间距分类器中的异常值"><a href="#大间距分类器中的异常值" class="headerlink" title="大间距分类器中的异常值"></a>大间距分类器中的异常值</h3><p>最后要讲的一点是对于支持向量机中的异常数据的处理。在下面这组训练集中：</p>
<p><img src="/img/17_02_06/013.png" width = "300" height = "200" align=center /></p>
<p>我们通过使用支持向量机来进行分类，会得到这条黑色的决策边界，从而最大间距的区分这两种数据：</p>
<p><img src="/img/17_02_06/014.png" width = "300" height = "200" align=center /></p>
<p>当有一个异常值产生时：</p>
<p><img src="/img/17_02_06/015.png" width = "300" height = "200" align=center /></p>
<p>我们的算法会受到异常值的影响。这时我们将支持向量机中的正则化因子$C$设置的非常大，那么我们会得到类似这样一条粉色的决策边界：</p>
<p><img src="/img/17_02_06/016.png" width = "300" height = "200" align=center /></p>
<p>那么我们仅仅通过一个异常值，就将我们的决策边界旋转了这么大的角度，实在是不明智的。</p>
<p><img src="/img/17_02_06/017.png" width = "300" height = "200" align=center /></p>
<p>当我们的正则化因子$C$的值非常大时，支持向量机确实会如此处理，但如果我们适当的减小$C$的值，你最终还是会得到那条黑色的决策边界的。</p>
<p>如果数据是线性不可分的话，像这样：</p>
<p><img src="/img/17_02_06/018.png" width = "300" height = "200" align=center /></p>
<p>支持向量机也可以恰当的将它们分开。</p>
<p>值得提醒的是$C$的作用其实等同于$\frac{1}{\lambda}$，$\lambda$就是我们之前用到的正则化参数。在支持向量机中，$C$不是很大的时候，可以对包含异常数据、以及线性不可分的数据有比较好的处理效果。</p>
<p>稍后我们还会介绍支持向量机的偏差和方差，希望到那时候关于如何处理参数的这种平衡会变得更加清晰。</p>
<h2 id="大间距分类器背后的数学原理-选学"><a href="#大间距分类器背后的数学原理-选学" class="headerlink" title="大间距分类器背后的数学原理(选学)"></a>大间距分类器背后的数学原理(选学)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/3eNnh/mathematics-behind-large-margin-classification">视频地址</a></p>
<blockquote>
<p>这一节将介绍大间距分类背后的数学原理。</p>
<p>本节作为选学内容，你完全可以跳过，但是听听这节课可能让你对支持向量机中的优化问题，以及如何得到大间距分类器产生更好的直观理解。</p>
</blockquote>
<h3 id="向量内积"><a href="#向量内积" class="headerlink" title="向量内积"></a>向量内积</h3><p>首先，带大家复习一下<strong>向量内积</strong>的知识。</p>
<p>假设我们有两个二维向量：</p>
<script type="math/tex; mode=display">
u=
 \begin{bmatrix}
   u\_1 \\\
    u\_2
 \end{bmatrix}
 \\
 v=
 \begin{bmatrix}
   v\_1 \\\
   v\_2
 \end{bmatrix}</script><p>我们把</p>
<script type="math/tex; mode=display">
u^{T}v</script><p>的计算结果称作向量$u$和$v$之间的<strong>内积</strong>。</p>
<p>由于这里我们用的是二维向量，因此我们可以把这两个向量绘制在同一坐标系内，向量$u$和$v$如下：</p>
<p><img src="/img/17_02_06/019.png" width = "300" height = "200" align=center /></p>
<p>其中我们用$||u||$来表示$u$的<strong>范数</strong>（即$u$的长度），因此$||u||$的计算公式如下：</p>
<script type="math/tex; mode=display">
||u||=\sqrt{u\_1^2+u\_2^2}</script><p>下面我们来看看<strong>向量内积</strong>具体是如何计算的：</p>
<p>将向量$v$投影到向量$u$上，如下图我们对向量$v$做一个相对于向量$u$的直角投影：</p>
<p><img src="/img/17_02_06/020.png" width = "300" height = "200" align=center /></p>
<p>投影之后的长度就是图中红线$p$的长度：</p>
<script type="math/tex; mode=display">
p = 向量v投影到向量u上的长度</script><p>同时也有另外一种计算内积的方式：</p>
<script type="math/tex; mode=display">
u^Tv=p·||u||</script><p>通过这种方式计算出来的内积，答案和之前也是一样的。</p>
<p>事实上，如果你想要使用将$u$投影到$v$上来用这种方式来计算内积，得到的答案也是相同的。</p>
<p>要注意的一点是，这里的$p$是有符号的，如果两个向量的夹角大于90°，像下图中这种情形，如果将$v$投影到$u$上会得到这样一种投影：</p>
<p><img src="/img/17_02_06/021.png" width = "300" height = "200" align=center /></p>
<p>此时的$p$就是一个负数。</p>
<blockquote>
<p>在向量的内积问题中，如果两个向量的夹角小于90°，那么$p$的符号就是为正；如果两个向量的夹角大于90°，那么$p$的符号就为负。</p>
</blockquote>
<p>这就是<strong>向量内积</strong>的知识，接下来我们尝试使用它来理解支持向量机中的目标函数。</p>
<h3 id="SVM决策边界"><a href="#SVM决策边界" class="headerlink" title="SVM决策边界"></a>SVM决策边界</h3><p>下面是我们在支持向量机中的目标函数:</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><p>其中</p>
<ul>
<li>若$y^{(i)}=1$时，则$\theta^{T}x^{(i)}\ge1$</li>
<li>若$y^{(i)}=0$时，则$\theta^{T}x^{(i)}\le-1$</li>
</ul>
<p>接下来为了让目标函数更容易被分析，我们来忽略掉截距的影响，令$\theta_0=0$，这样更容易绘制示意图。并且我们将特征数$n$设置为2，因此我们仅有两个特征$x_1$和$x_2$：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\mathop{min}\limits\_{θ}
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2
&=
\frac{1}{2}
(\theta\_1^2+\theta\_2^2)
\\\\&=
\frac{1}{2}
(\sqrt{\theta\_1^2+\theta\_2^2})^2
\end{align\*}</script><p>其中</p>
<script type="math/tex; mode=display">
\sqrt{\theta\_1^2+\theta\_2^2} = ||\theta||</script><p>因此可以得出：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2
=
\frac{1}{2}||\theta||^2</script><p>可见，<strong>支持向量机所做的事情，其实就是在极小化参数向量$\theta$范数的平方（或者说是长度的平方）</strong>。</p>
<hr>
<p>现在让我们来看看这两行的含义：</p>
<ul>
<li>若$y^{(i)}=1$时，则$\theta^{T}x^{(i)}\ge1$</li>
<li>若$y^{(i)}=0$时，则$\theta^{T}x^{(i)}\le-1$</li>
</ul>
<p>想一想$\theta^{T}x^{(i)}$这一项等于什么呢？</p>
<p>在前面我们画出了$u^Tv$的示意图，这里$\theta^T$就相当于$u^T$、$x^{(i)}$就相当于$v$。让我们来看一下示意图：</p>
<p>我们考虑一个单一的样本$x^{(i)}$，其坐标为$(x^{(i)}_1,x^{(i)}_2)$</p>
<p><img src="/img/17_02_06/022.png" width = "300" height = "200" align=center /></p>
<p>这个训练样本点其实可以表示为一个训练样本向量：</p>
<p><img src="/img/17_02_06/023.png" width = "300" height = "200" align=center /></p>
<p>现在，我们有一个参数向量：</p>
<p><img src="/img/17_02_06/024.png" width = "300" height = "200" align=center /></p>
<p>那么我们向量内积的计算方式，通过使用之前的方法可以得出。训练样本向量投影到参数向量上的长度$p^{(i)}$，表示第i个训练样本在参数向量$\theta$上的投影：</p>
<p><img src="/img/17_02_06/025.png" width = "300" height = "200" align=center /></p>
<p>根据之前我们所学到的，我们可以知道：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\theta^Tx^{(i)}
&=p^{(i)}·||\theta||
\\\\
&=\theta\_1x\_1^{(i)}+\theta\_2x\_2^{(i)}
\end{align\*}</script><p>那么，这告诉我们了什么呢？这说明：</p>
<ul>
<li>若$y^{(i)}=1$时，则$\theta^{T}x^{(i)}\ge1$</li>
<li>若$y^{(i)}=0$时，则$\theta^{T}x^{(i)}\le-1$</li>
</ul>
<p>这里的约束项是可以用$p^{(i)}·||\theta||$来替代的：</p>
<ul>
<li>若$y^{(i)}=1$时，则$p^{(i)}·||\theta||\ge1$</li>
<li>若$y^{(i)}=0$时，则$p^{(i)}·||\theta||\le-1$</li>
</ul>
<p>因此，将其写入我们的优化目标后，<strong>完整的目标函数</strong>为：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2
=
\frac{1}{2}||\theta||^2</script><p>其中</p>
<ul>
<li>若$y^{(i)}=1$时，则$p^{(i)}·||\theta||\ge1$</li>
<li>若$y^{(i)}=0$时，则$p^{(i)}·||\theta||\le-1$</li>
</ul>
<hr>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>现在让我们考虑下面这里的训练样本：</p>
<p><img src="/img/17_02_06/026.png" width = "300" height = "200" align=center /></p>
<p>其中假设截距依然为0，即$\theta_0=0$，我们来看一下支持向量机会选择什么样的决策边界。</p>
<p>假设有这样一条决策边界：</p>
<p><img src="/img/17_02_06/027.png" width = "300" height = "200" align=center /></p>
<p>很明显，这不是一个好的决策边界，因为这个决策边界离训练样本很近，我们来看一下为什么支持向量机不会选择它。</p>
<p>由于<strong>决策边界和参数向量是正交的(斜率相乘结果为-1)</strong>(<a href="https://zhidao.baidu.com/question/1992397864989257747.html">为什么决策边界和参数向量是正交的</a>)，我们可以绘制出对应的参数向量$\theta$：</p>
<p><img src="/img/17_02_06/028.png" width = "300" height = "200" align=center /></p>
<blockquote>
<p>这里由于我们指定了$\theta_0=0$，也就意味着决策边界是过原点的。</p>
</blockquote>
<p>假设我们以这一点为第一个训练样本：</p>
<p><img src="/img/17_02_06/029.png" width = "300" height = "200" align=center /></p>
<p>我们可以画出这个样本向量到$\theta$的投影$p^{(1)}$：</p>
<p><img src="/img/17_02_06/030.png" width = "300" height = "200" align=center /></p>
<p>类似的，我们也可以画出第二个样本向量到$\theta$的投影$p^{(2)}$：</p>
<p><img src="/img/17_02_06/031.png" width = "300" height = "200" align=center /></p>
<p>我们会发现，这些$p^{(i)}$将会是一些非常小的数。因此当我们考察优化目标函数的时候：</p>
<ul>
<li><p>对于<strong>正样本($y^{(i)}=1$，即图中的”x”样本)</strong>而言，我们需要$p^{(i)}·||\theta||\ge1$，由于$p^{(i)}$非常小，也就意味着$||\theta||$需要非常大。</p>
</li>
<li><p>对于<strong>负样本($y^{(i)}=-1$，即图中的”o”样本)</strong>而言，我们需要$p^{(i)}·||\theta||\le-1$，由于$p^{(i)}$非常小，也就意味着$||\theta||$需要非常大。</p>
</li>
</ul>
<p>但我们的实际目标是希望找到一个参数$\theta$，使得它的范数$||\theta||$是尽可能小的，因此这并不是一个好的决策边界，因为我们的$||\theta||$比较大。</p>
<hr>
<p>对于下面这个决策边界来说，情况就会有很大的不同：</p>
<p><img src="/img/17_02_06/032.png" width = "300" height = "200" align=center /></p>
<p>这里，我们以纵坐标作为决策边界，那么我们的参数向量的方向就是垂直于它的方向：</p>
<p><img src="/img/17_02_06/033.png" width = "300" height = "200" align=center /></p>
<p>如果我们现在再来绘制出样本向量在参数向量上的投影$p^{(1)}$和$p^{(2)}$的话，你会发现这些投影的长度比之前长多了：</p>
<p><img src="/img/17_02_06/034.png" width = "300" height = "200" align=center /></p>
<p>因为投影$p$的长度变大了，随之$\theta$的范数$||\theta||$也相应的变小了。这就意味着通过选择第二种远离样本的决策边界，支持向量机可以使参数$\theta$的范数$||\theta||$变小很多。</p>
<p>这就是<strong>为什么支持向量机可以产生大间距分类的原因</strong>。</p>
<hr>
<p>最后一点，我们的推导自始至终都使用了<strong>截距为0（即$\theta_0=0$）</strong>这个简化假设。这样做的作用就是可以使得决策边界始终是通过原点的，如果你的决策边界不过原点，那么$\theta_0\ne0$，但支持向量机会产生大间距分类器的结论依然成立（具体推导过程不再叙述，和这里很类似）。但是可以说明的是，即便$\theta_0\ne0$，支持向量机仍然会找到正样本和负样本之间的大间距分隔。总之 我们解释了为什么支持向量机是一个大间距分类器。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第七周 (2)核函数</title>
    <url>/2017/02/09/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%83%E5%91%A8%20(2)%E6%A0%B8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="核函数-I"><a href="#核函数-I" class="headerlink" title="核函数 I"></a>核函数 I</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/YOMHn/kernels-i">视频地址</a></p>
<p>在本节，我将对支持向量机算法做一些改变，以构造复杂的非线性分类器。我们用<strong>“kernels(核函数)”</strong>来达到此目的。</p>
<p>我们来看看<strong>核函数</strong>是什么，以及如何使用。</p>
<p>如果你有一个像这个样的训练集：</p>
<p><img src="/img/17_02_09/001.png" alt=""></p>
<p>然后你希望拟合一个非线性的判别边界来区别正负样本，那么你的判别边界可能是这样的：</p>
<p><img src="/img/17_02_09/002.png" alt=""></p>
<p>当我们这么做的时候，其实这个决策边界是由类似于下面这种多项式构成的：</p>
<ul>
<li><p>如果$<br>\theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_1x_2+\theta_4x_1^2 + \theta_5x_2^2 + … \ge 0<br>$，则预测$h_{\theta}(x)=1$；</p>
</li>
<li><p>如果$<br>\theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_1x_2+\theta_4x_1^2 + \theta_5x_2^2 + … \lt 0<br>$，则预测$h_{\theta}(x)=0$；</p>
</li>
</ul>
<p>如果我们把假设函数改写成下面这种形式：</p>
<script type="math/tex; mode=display">
\theta\_0+\theta\_1f\_1+\theta\_2f\_2+\theta\_3f\_3+\theta\_4f\_4+\theta\_5f\_5+...</script><p>因此有：</p>
<script type="math/tex; mode=display">
f\_1=x\_1</script><script type="math/tex; mode=display">
f\_2=x\_2</script><script type="math/tex; mode=display">
f\_3=x\_1x\_2</script><script type="math/tex; mode=display">
f\_4=x\_1^2</script><script type="math/tex; mode=display">
f\_5=x\_2^2</script><script type="math/tex; mode=display">
...</script><p>以此类推，可以依次加入这些高阶项，但我们其实并不知道这些高阶项是不是我们真正需要的。我们之前谈到计算机视觉的时候，提到过在这里的输入是一个有很多像素的图像，我们看到如果用高阶项作为特征变量，运算量将是非常大的，因为有太多的高阶项需要被计算。</p>
<p>因此，我们是否有不同的选择，或者是更好的选择来构造特征变量，以用来嵌入到假设函数中呢？</p>
<h3 id="用核函数构造新特征"><a href="#用核函数构造新特征" class="headerlink" title="用核函数构造新特征"></a>用核函数构造新特征</h3><p>事实上，这里有一个可以构造新特征$f_1$、$f_2$、$f_3$的方法。</p>
<p>首先我们定义三个特征变量(但是对于实际问题而言，我们可以定义非常多的特征变量）：</p>
<p><img src="/img/17_02_09/003.png" width = "300" height = "200" align=center /></p>
<p>将这三个点标记为$l^{(1)}$、$l^{(2)}$、$l^{(3)}$，接下来我要做的是定义新的特征变量：</p>
<script type="math/tex; mode=display">
f\_1=similarity(x,l^{(1)})</script><p>这里$similarite(x,l^{(1)})$是一种相似度的度量，度量样本$x$与第一个标记$l^{(1)}$的相似度。</p>
<p>这个度量相似度的公司是这样的：</p>
<script type="math/tex; mode=display">
\begin{align\*}
f\_1&=similarity(x,l^{(1)})
\\\\
&=exp(-\frac{||x-l^{(1)}||^2}{2σ^2})
\end{align\*}</script><blockquote>
<p>$exp$是自然常数$e$为底的指数函数。</p>
</blockquote>
<p>不知道你之前是否看了上一个选修课程的视频，$||w||$是表示向量$w$的长度。因此这里的$||x-l^{(1)}||$的意思就是就是向量的欧式距离。</p>
<p>因此，我们可以依次写出$f_1$、$f_2$、$f_3$:</p>
<script type="math/tex; mode=display">
\begin{align\*}
f\_1&=similarity(x,l^{(1)})
=exp(-\frac{||x-l^{(1)}||^2}{2σ^2})
\end{align\*}</script><script type="math/tex; mode=display">
\begin{align\*}
f\_2&=similarity(x,l^{(2)})
=exp(-\frac{||x-l^{(2)}||^2}{2σ^2})
\end{align\*}</script><script type="math/tex; mode=display">
\begin{align\*}
f\_3&=similarity(x,l^{(3)})
=exp(-\frac{||x-l^{(3)}||^2}{2σ^2})
\end{align\*}</script><p>这里的$similarite(x,l)$函数，就被称为<strong>核函数(Kernels)</strong>。在这里，我们的例子中所说的<strong>核函数</strong>，实际上是<strong>高斯核函数</strong>，在后面我们还会见到不同的<strong>核函数</strong>。</p>
<p>核函数我们通常不写作$similarity(x,l^{(i)})$，而是写作：</p>
<script type="math/tex; mode=display">
k(x,l^{(i)})</script><h3 id="核函数可以做什么？"><a href="#核函数可以做什么？" class="headerlink" title="核函数可以做什么？"></a>核函数可以做什么？</h3><p>我们来看看核函数到底可以做什么？</p>
<p>首先让我们来看看第一个标记：</p>
<script type="math/tex; mode=display">
\begin{align\*}
f\_1&=similarity(x,l^{(1)})
=exp(-\frac{||x-l^{(1)}||^2}{2σ^2})
=exp(-\frac{\sum\_{j=1}^{n}(x\_j-l\_j^{(1)})^2}{2σ^2})
\end{align\*}</script><p>$l^{(1)}$是我之前在图中选取的几个点之中的一个，上面是$x$和$l^{(1)}$之间的核函数。</p>
<p>其中$||x-l^{(1)}||^2$这一项可以表示成各个$x$向量到$l$向量的距离求和的形式：$\sum_{j=1}^{n}(x_j-l_j^{(1)})^2$。（这里我们依然忽略了截距的影响，即令$x_0=1$）。</p>
<p>假设，如果$x\approx l^{(1)}$，即$x$与其中一个标记点非常接近，那么这个欧氏距离$||x-l^{(1)}||$就会接近0，因此：</p>
<script type="math/tex; mode=display">
f\_1
\approx
exp(-\frac{0^2}{2σ^2})
\approx1</script><p>相反的，如果$x$离$l^{(1)}$很远，那么会有：</p>
<script type="math/tex; mode=display">
f\_1
\approx
exp(-\frac{(large\ number)^2}{2σ^2})
\approx0</script><p><strong>这些特征变量的作用是度量$x$到标记$l^{(1)}$的相似度的，并且如果$x$离$l$非常接近，那么特征变量$f$就接近1；如果$x$离标记$l^{(1)}$非常远，那么特征变量$f$就接近于0。</strong></p>
<p>之前我绘制的三个标记点$l^{(1)}$、$l^{(2)}$、$l^{(3)}$每一个标记点会定义一个新的特征变量：</p>
<script type="math/tex; mode=display">
\begin{align\*}
f\_1&=k(x,l^{(1)})
=exp(-\frac{||x-l^{(1)}||^2}{2σ^2})
\end{align\*}</script><script type="math/tex; mode=display">
\begin{align\*}
f\_2&=k(x,l^{(2)})
=exp(-\frac{||x-l^{(2)}||^2}{2σ^2})
\end{align\*}</script><script type="math/tex; mode=display">
\begin{align\*}
f\_3&=k(x,l^{(3)})
=exp(-\frac{||x-l^{(3)}||^2}{2σ^2})
\end{align\*}</script><p><strong>也就是说，给出一个训练样本$x$，我们就能基于我们之前给出的标记点$l^{(1)}$、$l^{(2)}$、$l^{(3)}$来计算出三个新的特征变量$f_1$、$f_2$、$f_3$。</strong></p>
<h3 id="深入理解核函数"><a href="#深入理解核函数" class="headerlink" title="深入理解核函数"></a>深入理解核函数</h3><p>接下来让我们通过画一些图来更好地理解<strong>核函数</strong>是什么样的。</p>
<h4 id="x-对-f-的值的影响"><a href="#x-对-f-的值的影响" class="headerlink" title="$x$对$f$的值的影响"></a>$x$对$f$的值的影响</h4><p>看下面这个例子，假设我们有两个特征$x_1$和$x_2$，假设我们第一个标记点是$l^{(1)}$：</p>
<script type="math/tex; mode=display">
l^{(1)}=
\begin{bmatrix}
   3 \\\
    5
 \end{bmatrix}</script><p>假设:</p>
<script type="math/tex; mode=display">
σ^2=1</script><p>如果我画出:</p>
<script type="math/tex; mode=display">
\begin{align\*}
f\_1&=k(x,l^{(1)})
=exp(-\frac{||x-l^{(1)}||^2}{2σ^2})
\end{align\*}</script><p>结果就是这样的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">3D曲面图</th>
<th style="text-align:center">等高线图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_02_09/004.png" width = "300" height = "200" align=center /></td>
<td style="text-align:center"><img src="/img/17_02_09/005.png" width = "300" height = "200" align=center /></td>
</tr>
</tbody>
</table>
</div>
<p>其中左侧的图纵轴是$f_1$，水平方向的两个轴分别是$x_1$和$x_2$。右侧的图是左侧图的等高线图。</p>
<p>你会发现，当$x=(3,5)$的时候，$f_1=1$，因为它在最大值的位置上。所以如果$x$往旁边移动，离这个点越远，那么从图中可以看到$f_1$的值就越接近0。</p>
<h4 id="σ-2-对-f-的值的影响"><a href="#σ-2-对-f-的值的影响" class="headerlink" title="$σ^2$对$f$的值的影响"></a>$σ^2$对$f$的值的影响</h4><p>在这里，要提到的另一点就是$σ^2$对结果的影响。$σ^2$是<strong>高斯核函数</strong>的参数，改变它会得到略微不同的结果。</p>
<p>可以对比$σ^2=1$、$σ^2=0.5$、$σ^2=3$的情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$σ^2=1$</th>
<th style="text-align:center">$σ^2=0.5$</th>
<th style="text-align:center">$σ^2=3$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_02_09/004.png" width = "300" height = "200" align=center /></td>
<td style="text-align:center"><img src="/img/17_02_09/006.png" width = "300" height = "200" align=center /></td>
<td style="text-align:center"><img src="/img/17_02_09/008.png" width = "300" height = "200" align=center /></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/17_02_09/005.png" width = "300" height = "200" align=center /></td>
<td style="text-align:center"><img src="/img/17_02_09/007.png" width = "300" height = "200" align=center /></td>
<td style="text-align:center"><img src="/img/17_02_09/009.png" width = "300" height = "200" align=center /></td>
</tr>
</tbody>
</table>
</div>
<p>你会发现，函数的形状还是相似的，只是$σ^2=0.5$相较于$σ^2=1$凸起的宽度变窄了，等值线图也收缩了一些；$σ^2=3$相较于$σ^2=1$凸起的宽度变宽了，等值线也扩张了一些。</p>
<p>所以，如果我们将$σ^2$设为0.5时，特征变量$f_1$下降到0的速度也会相应变快；如果我们将$σ^2$设为3时，特征变量$f_1$下降到0的速度也会相应变慢。</p>
<h3 id="获取预测函数"><a href="#获取预测函数" class="headerlink" title="获取预测函数"></a>获取预测函数</h3><p>讲完了特征变量的定义，我们来看看我们能得到什么样的预测函数。</p>
<p>给定一个训练样本$x$，我们要计算出三个特征变量$f_1$ $f_2$ $f_3$</p>
<p><img src="/img/17_02_09/010.png" alt=""></p>
<p>并且如果$\theta_0 + \theta_1f_1 + \theta_2f_2 +  \theta_3f_3 \ge 0$，则预测函数的预测值为1，即$y=1$。</p>
<p>对于这个特定的例子而言，假设我们已经找到了一个学习算法，并且假设我已经得到了这些参数的值，比如如果：</p>
<script type="math/tex; mode=display">
\theta\_0=-0.5 \\\\
\theta\_1=1 \\\\
\theta\_2=1 \\\\
\theta\_3=0</script><p>如果我们现在有一个训练样本$x$：</p>
<p><img src="/img/17_02_09/011.png" alt=""></p>
<p>我想知道预测函数会给出什么结果。</p>
<p>看看这个公式：</p>
<script type="math/tex; mode=display">\theta\_0 + \theta\_1f\_1 + \theta\_2f\_2 +  \theta\_3f\_3 \ge 0</script><p>因为我的训练样本$x$接近于$l^{(1)}$，那么$f_1$就接近于1：</p>
<script type="math/tex; mode=display">
f\_1\approx1</script><p>又因为训练样本$x$离$l^{(2)}$ $l^{(3)}$都很远，所以$f_2$就接近于0，$f_3$也接近于0：</p>
<script type="math/tex; mode=display">
f\_2\approx0 \\\\
f\_3\approx0</script><p>所以带入上面的公式可以得到：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\theta\_0 + \theta\_1f\_1 + \theta\_2f\_2 +  \theta\_3f\_3
&=\theta\_0 + \theta\_1·1 + \theta\_2·0 +  \theta\_3·0
\\\\
&=-0.5+1
\\\\
&=0.5\\\\
\ge0
\end{align\*}</script><p>因此对于这一点，我们预测的结果是$y=1$。</p>
<hr>
<p>现在我们选择另一个不同的点，假设我选择了另一个点：</p>
<p><img src="/img/17_02_09/012.png" alt=""></p>
<p>如果将这个训练样本$x$带入之前相同的计算，你发现$f_1$ $f_2$ $f_3$都接近于0。</p>
<p>因此，我们得到$\theta_0 + \theta_1f_1 + \theta_2f_2 +  \theta_3f_3=-0.5$，因为$θ_0=-0.5$，并且$f_1$ $f_2$ $f_3$都为0，因此最后结果是-0.5，小于0。因此这个点，我们预测的y值是0。</p>
<hr>
<p>类似的，如果你自己来对大量的点进行这样相应的处理，你应该可以确定如果你有一个非常接近于$l^{(2)}$的训练样本，那么通过这个点预测的y值也是1。</p>
<p>实际上，你最后得到的结果是：<strong>对于接近$l^{(1)}$和$l^{(2)}$的点，我们的预测值是1，对于远离$l^{(1)}$和$l^{(2)}$的点，我们最后预测的结果是等于0的</strong>。</p>
<p>我们最后会得到这个预测函数的判别边界看起来是类似这样的结果：</p>
<p><img src="/img/17_02_09/013.png" width = "300" height = "200" align=center /></p>
<p>在这个红色的判别边界里面，预测的y值等于1；在这外面预测的y值等于0。</p>
<p>因此这就是一个我们如何通过标记点，以及核函数，来训练出非常复杂的非线性判别边界的方法。</p>
<p>这就是核函数这部分的概念，以及我们如何在支持向量机中使用它们。我们通过标记点和相似性函数来定义新的特征变量从而训练复杂的非线性分类器。</p>
<p>目前还有一些问题我们并没有做出回答，其中一个是<strong>我们如何得到这些标记点</strong>；另一个是<strong>其他的相似度方程（核函数）是什么样的</strong>，如果有其他的话，我们能够用其他的相似度方程来代替我们所讲的这个高斯核函数吗？在下一个视频中我们会回答这些问题，然后把所有东西都整合到一起来看看支持向量机如何通过核函数的定义 有效地学习复杂非线性函数。</p>
<h2 id="核函数-II"><a href="#核函数-II" class="headerlink" title="核函数 II"></a>核函数 II</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/hxdcH/kernels-ii">视频地址</a></p>
<blockquote>
<p>在上一节视频里，我们讨论了<strong>核函数</strong>这个想法以及怎样利用它去实现支持向量机的一些新特性。在这一节视频中我将补充一些缺失的细节，并简单的介绍一下怎么在实际中使用应用这些想法。例如，<strong>怎么处理支持向量机中的偏差方差折中</strong>。</p>
</blockquote>
<h3 id="如何选取标记点-landmark"><a href="#如何选取标记点-landmark" class="headerlink" title="如何选取标记点(landmark)"></a>如何选取标记点(landmark)</h3><p>在上一节课中，我谈到过选择标记点，例如$l^{(1)}$ $l^{(2)}$ $l^{(3)}$ 这些点使我们能够定义<strong>相似度函数</strong>，也称之为<strong>核函数</strong>。在这个例子里，我们的相似度函数为<strong>高斯核函数</strong>。</p>
<p><img src="/img/17_02_09/014.png" alt=""></p>
<p>但是，我们从哪里得到这些标记点呢？我们从哪里得到$l^{(1)}$ $l^{(2)}$ $l^{(3)}$？ 而且在一些复杂的学习问题中，也许我们需要更多的标记点，而不是我们手选的这三个。</p>
<p>因此，在实际应用时，怎么选取标记点，是机器学习中必须解决的问题。</p>
<p>这是我们的数据集：</p>
<p><img src="/img/17_02_09/015.png" alt=""></p>
<p>有一些正样本和一些负样本。我们的想法是：我们直接将训练样本作为标记点。</p>
<p><img src="/img/17_02_09/016.png" alt=""></p>
<p>如果我们有一个训练样本$x^{(1)}$，那么我将把第一个标记点就放在和第一个训练样本点完全重合的地方：</p>
<p><img src="/img/17_02_09/017.png" alt=""></p>
<p>同样，第二个标记点也是使用同样的方式来标注：</p>
<p><img src="/img/17_02_09/018.png" alt=""></p>
<p>在右边的这幅图上，我们使用红点和蓝点来阐述这幅图以及这些点的颜色，可能并不显眼，但是利用这个方法最终能得到m个标记点：</p>
<script type="math/tex; mode=display">
l^{(1)} ，l^{(2)}，...，l^{(m)}</script><p>即每一个标记点的位置，都与每一个样本点的位置精确对应。</p>
<p>这说明，特征函数基本上是在描述<strong>每一个样本距离样本集中其他样本的距离</strong>。</p>
<p>我们具体的列出这个过程的大纲：</p>
<p>给定m个训练样本：</p>
<script type="math/tex; mode=display">
(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),...,(x^{(m)},y^{(m)}),</script><p>我将选取与m个训练样本精确一致的位置作为我的标记点：</p>
<script type="math/tex; mode=display">
l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},...,l^{(m)}=x^{(m)}.</script><p>当输入样本$x$（样本$x$可以属于训练集，也可以属于交叉验证集，也可以属于测试集），我们可以计算这些特征，即：</p>
<script type="math/tex; mode=display">
f\_1=similarity(x,l^{(1)}) \\\\
f\_2=similarity(x,l^{(2)}) \\\\
...</script><blockquote>
<p>这里的$l^{(1)}=x^{(1)}$，$l^{(2)}=x^{(2)}$…。</p>
</blockquote>
<p>最终我们能得到一个特征向量，我们将特征向量记为$f$：</p>
<script type="math/tex; mode=display">
f=
\left[
\begin{matrix}
 f\_1  \\\
 f\_2  \\\
 ...    \\\
 f\_m
\end{matrix}
\right]</script><p>此外，按照惯例，如果我们需要的话，可以添加额外的特征$f_0$，$f_0$的值始终为1：</p>
<script type="math/tex; mode=display">
f=
\left[
\begin{matrix}
 f\_0  \\\
 f\_1  \\\
 f\_2  \\\
 ...    \\\
 f\_m
\end{matrix}
\right]</script><p>它与我们之前讨论过的截距$x^0$的作用相似。</p>
<hr>
<p>举个例子，假设我们有训练样本$(x^{(i)},y^{(i)})$，这个样本对应的特征向量可以这样计算：</p>
<p>给定$x^{(i)}$，我们可以通过相似度函数</p>
<script type="math/tex; mode=display">
f\_1^{(i)}=similarity(x^{(i)},l^{(1)}) \\\
f\_2^{(i)}=similarity(x^{(i)},l^{(2)}) \\\
... \\\
f\_m^{(i)}=similarity(x^{(i)},l^{(m)}) \\\</script><p>在这一列中的某个位置，即第$i$个元素，有一个特征：</p>
<script type="math/tex; mode=display">
f\_i^{(i)}=similarity(x^{(i)},l^{(i)})</script><blockquote>
<p>这里的$l^{(i)}$就等于$x^{(i)}$。</p>
</blockquote>
<p>所以$f_i^{(i)}$衡量的是$x^{(i)}$与其自身的相似度，如果你使用高斯核函数的话，这一项为：</p>
<script type="math/tex; mode=display">
f\_i^{(i)}=similarity(x^{(i)},l^{(i)})=exp(-\frac{0}{2σ^2})=1</script><p>所以，对于这个样本来说，其中的某一个特征等于1。接下来，类似于我们之前的过程，我将这m个特征合并为一个特征向量。于是，相比之前用$x^{(i)}$来描述样本，$x^{(i)}$为n维或者n+1维空间。我们现在可以使用这个特征向量$f^{(i)}$来描述我的特征向量：</p>
<script type="math/tex; mode=display">
f^{(i)}=
\left[
\begin{matrix}
 f\_0^{(i)}  \\\
 f\_1^{(i)}  \\\
 f\_2^{(i)}  \\\
 ...    \\\
 f\_m^{(i)}
\end{matrix}
\right]</script><p>其中 $f_0^{(i)}=1$。</p>
<p>那么这个向量就是我们用于描述训练样本的特征向量。</p>
<p>当给定核函数和相似度函数后，我们按照这个方法来使用<strong>支持向量机</strong>。</p>
<hr>
<p>如果你已经得到参数$\theta$并且想对样本x做出预测，我们先要计算特征向量$f$，$f$是$m+1$维的特征向量（这里有m是因为我们有m个训练样本，因此就有m个标记点）。</p>
<p>我们在$\theta^Tf\ge0$时，预测$y=1$</p>
<blockquote>
<p>这里$\theta^Tf=\theta_0f_0 + \theta_1f_1 + … + \theta_mf_m$</p>
</blockquote>
<p>以上就是<strong>当已知参数$\theta$时，怎么做出预测的过程</strong>。</p>
<p>那么，怎样得到参数$\theta$呢？</p>
<p>你在使用SVM学习算法的时候，具体来说就是要求解这个最小化问题：</p>
<script type="math/tex; mode=display">
\mathop{min}\limits\_{θ}
C
\sum\_{i=1}^{m}[
y^{(i)}
cost\_{1}(\theta^{T}f^{(i)})+
(1-y^{(i)})
cost\_{0}(\theta^{T}f^{(i)})
]+
\frac{1}{2}
\sum\_{j=1}^{n}
\theta\_{j}^2</script><p>你需要求出能使这个式子取最小值的参数$\theta$。注意，这里我们把之前的$x^{(i)}$换成了$f^{(i)}$。</p>
<p>通过解决这个最小化问题，我们就能得到支持向量机的参数。</p>
<p>最后一个对于这个优化问题的细节是：我们有$n=m$个特征。有效的特征数量应该等于$f$的维数，所以$n$其实就等于$m$。</p>
<p><img src="/img/17_02_09/019.png" alt=""></p>
<p>以上就是支持向量机的学习算法。</p>
<p>我在这里还要讲到一个数学细节，在支持向量机实现的过程中，最后一项与上面式子中的最后一项$\frac{1}{2}\sum_{j=1}^{n}\theta_{j}^2$有细微差别。其实在实现支持向量机时，你并不需要知道这个细节，事实上这个式子已经给你提供了全部需要的原理。但是在支持向量机实现的过程中，这一项$\sum_{j=1}^{n}\theta_{j}^2$可以被重写为$\theta^T\theta$(如果我们忽略$\theta_0$的话)，即：</p>
<script type="math/tex; mode=display">
\sum\_{j=1}^{n}
\theta\_{j}^2
=
\theta^T\theta</script><p>其中：</p>
<script type="math/tex; mode=display">
\theta=
\left[
\begin{matrix}
 \theta\_1  \\\
 \theta\_2  \\\
 ...    \\\
 \theta\_m  \\\
\end{matrix}
\right] \ \ (ignore \ \theta\_0)</script><p>大多数支持向量机在实现的时候其实是替换掉$\theta^T\theta$的，用$\theta^TM\theta$来代替，其中$M$是某矩阵，具体是什么矩阵取决于你采用的核函数。这其实是另一种略有区别的距离度量方法。我们用这种略有变化的度量距离的形式来取代对$||\theta||^2$（即$\theta^T\theta$，或者$\sum_{j=1}^{n}\theta_{j}^2$）进行最小化的形式，这是参数向量$\theta$的<strong>变尺度形式</strong>，这种变化和核函数相关。这个数学细节使得支持向量机能够更有效率的运行。</p>
<p>支持向量机做这种修改的理由是：这么做可以适应超大的训练集。</p>
<p>例如：当你的训练集有10000个样本时</p>
<script type="math/tex; mode=display">
M=10000</script><p>根据我们之前定义标记点的方法，我们最终有10000个标记点，$\theta$也随之是10000维的向量。或许这时这么做还可行，但是，当$m$变得非常非常大时，那么求解这么多参数时，此时利用支持向量机软件包来解决这里的最小化问题时，求解这些参数的成本会非常高。</p>
<p>这些都是数学细节，事实上你没有必要了解这些，这里$\theta^TM\theta$实际上细微的修改了最后一项，使得最终的优化目标与直接最小化$||\theta||^2$略有区别。</p>
<p>如果你愿意的话，你可以直接认为这个具体的实现细节尽管略微的改变了优化目标，但是它主要是为了计算效率，所以你不必要对此有太多担心。</p>
<p>顺便说一下，你可能会想，为什么我们不将核函数这个想法应用到其他算法，比如逻辑回归上。事实证明，如果你愿意的话，确实可以将核函数这个想法用于定义特征向量，将标记点之类的技术用于逻辑回归算法。但是用于支持向量机的计算技巧不能较好的推广到其他算法，诸如逻辑回归上。所以，将核函数用于逻辑回归上时，会变得非常的慢。相比之下，这些计算技巧，比如这一步：$\theta^TM\theta$，这些细节的修改，以及支持向量机软件的实现细节，使得支持向量机可以和核函数相得益彰，而逻辑回归和核函数则会运行的十分缓慢，更何况它们还不能使用那些高级优化技巧，因为这些技巧是人们专门为使用核函数的支持向量机开发的。但是这些问题只有在你亲自实现最小化函数时才会遇到。</p>
<p>我将在下一节视频中进一步讨论这些问题，但是你并不需要知道怎么去写一个软件，来最小化代价函数。你能找到很好的成熟的软件来做这些，就像我一直不建议自己写矩阵求逆函数，或者平方根函数的道理一样。这些软件包已经包含了那些数值优化技巧，所以你不必担心这些东西。</p>
<hr>
<h3 id="SVM参数："><a href="#SVM参数：" class="headerlink" title="SVM参数："></a>SVM参数：</h3><h4 id="C-frac-1-lambda"><a href="#C-frac-1-lambda" class="headerlink" title="$C(=\frac{1}{\lambda})$"></a>$C(=\frac{1}{\lambda})$</h4><p>但是另外一个值得说明的问题是，在你使用支持向量机时，怎么选择支持向量机中的参数？在本节视频的末尾，我想稍微说明一下，在使用支持向量机时的“偏差-方差折中”其中一个要选择的事情是，目标函数中的参数$C$。回忆一下，$C$的作用与$\frac{1}{\lambda}$相似。</p>
<p><img src="/img/17_02_09/020.png" alt=""></p>
<p>$\lambda$是逻辑回归算法中的正则化参数，所以$C$对应着我们之前在逻辑回归问题中的$\lambda$，这意味着:</p>
<ul>
<li>较小的$\lambda$对应较大的$C$，这就意味着有可能得到一个低偏差但高方差的模型。</li>
<li>较大的$\lambda$对应较小的$C$，这就意味着有可能得到一个高偏差但低方差的模型。</li>
</ul>
<p>所以使用较大的$C$值模型，为高方差，更倾向于过拟合；而使用较小的$C$值的模型，为高偏差，更倾向于欠拟合。</p>
<h4 id="σ-2"><a href="#σ-2" class="headerlink" title="$σ^2$"></a>$σ^2$</h4><p>另一个要处理的参数是<strong>高斯核函数</strong>中的$σ^2$。</p>
<p>当高斯核函数中的$σ^2$偏大时，那么对应的相似度函数为：</p>
<script type="math/tex; mode=display">
exp(-\frac{||x-l^\{(i)}||^2}{2σ^2})</script><p>在下面这个例子中，如果我们只有一个特征$x_1$，有一个标记点$l$：</p>
<p><img src="/img/17_02_09/021.png" alt=""></p>
<p><strong>如果$σ^2$越大</strong>，那么高斯核函数倾向于变得<strong>越平滑</strong>，由于函数平滑且变化的比较平缓，这会给你的模型带来<strong>较高的偏差和较低的方差</strong>，由于高斯核函数变得平缓，就更倾向于得到一个随着输入$x$变化得缓慢的模型：</p>
<p><img src="/img/17_02_09/022.png" alt=""></p>
<p>反之<strong>如果$σ^2$越小</strong>，那么高斯核函数会变化的<strong>很剧烈</strong>，在这种情况下，最终得到的模型会是<strong>低偏差和高方差</strong>：</p>
<p><img src="/img/17_02_09/023.png" alt=""></p>
<hr>
<p>这就是利用核函数的支持向量机算法。</p>
<p>希望这些关于方差和偏差的讨论能给你一些对于算法结果预期的直观印象。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第七周 (3)使用SVM</title>
    <url>/2017/04/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%83%E5%91%A8%20(3)%E4%BD%BF%E7%94%A8SVM/</url>
    <content><![CDATA[<h2 id="使用SVM"><a href="#使用SVM" class="headerlink" title="使用SVM"></a>使用SVM</h2><blockquote>
<p>这段视频中，我们将介绍使用SVM时，我们实际上需要做些什么。</p>
</blockquote>
<p><strong>支持向量机</strong>是一个特定的优化问题，但是我不建议你自己去手动实现这一算法来求解参数$\theta$。就像如今只有很少的人，或者说根本没有人会考虑自己写代码，来实现对矩阵求逆，或求一个数的平方根等。我们只需要调用库函数来实现这些功能即可。</p>
<p>同样，可以用于解决SVM优化问题的软件很复杂，而且已经有专门研究数值优化很多年的学者在做这个，因此你需要使用好的软件库来做这个。我强烈建议使用一个高度优化的软件库，而不是尝试自己去实现它。</p>
<p>这里推荐两个我最常用到的库：liblinear和libsvm。</p>
<p>尽管你不需要自己去实现SVM，但你也需要做以下几件事：</p>
<ul>
<li>选择参数$C$</li>
<li>选择<strong>核函数</strong>（相似度函数）</li>
</ul>
<h3 id="核函数的选择"><a href="#核函数的选择" class="headerlink" title="核函数的选择"></a>核函数的选择</h3><h4 id="线性核函数（无核函数）"><a href="#线性核函数（无核函数）" class="headerlink" title="线性核函数（无核函数）"></a>线性核函数（无核函数）</h4><p>关于<strong>核函数</strong>其中一个选择是<strong>不用任何核函数</strong>（不用任何核函数也叫作<strong>线性核函数</strong>）:</p>
<p>即对于预测结果$y=1$，满足$\theta^Tx\ge0$。</p>
<blockquote>
<p>例如这种情况下当$\theta_0 + \theta_1x_1 + … + \theta_nx_n \ge 0$时，预测$y=1$。</p>
</blockquote>
<p>对<strong>线性核函数</strong>这个术语，你可以把它理解为这个版本的SVM。它只是给你一个标准的线性分类器，因此对某些问题来说，它是一个合理的选择：</p>
<p>具体来说，当你的特征数量$n$很大，但数据量$m$很小时，由于数据量不足，在这种情况下如果使用其他核函数，你可能会<strong>过拟合</strong>，因此，此时<strong>线性核函数</strong>是一个合理的选择。</p>
<h4 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h4><script type="math/tex; mode=display">
f\_i=exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2}),</script><p>这是我们之前见过的高斯核函数。如果你选择这个核函数，那么你需要选择一个<script type="math/tex">\sigma^2</script>。</p>
<p>我们之前讨论如何权衡偏差、方差的时候谈论过：</p>
<ul>
<li>如果$\sigma^2$很大，那么你就有可能得到一个<strong>较高偏差较低方差</strong>的分类器。</li>
<li>如果$\sigma^2$很小，那么你就有可能得到一个<strong>较低偏差较高方差</strong>的分类器。</li>
</ul>
<p>那么，什么时候选择高斯核函数呢？</p>
<p>如果你原来的特征变量$x$是$n$维的，而且<strong>$n$很小，样本数量$m$很大时</strong>，高斯核函数会是一个不错的选择。</p>
<h5 id="如何使用高斯核函数"><a href="#如何使用高斯核函数" class="headerlink" title="如何使用高斯核函数"></a>如何使用高斯核函数</h5><p>在很多SVM的软件包中，如果你需要使用SVM时，你需要提供一个核函数。</p>
<p>具体地说，如果你决定使用高斯核函数，那么你需要做的就是根据你所用的SVM软件包，来提供一个用于计算核函数的特定特征的方法:</p>
<p><img src="/img/17_04_11/001.png" alt=""></p>
<p>然后它将自动地生成所有特征变量。</p>
<blockquote>
<p><strong>注意</strong>：如果你有大小很不一样的特征变量，在使用高斯核函数之前，对它们进行<strong>归一化</strong>是很重要的。</p>
</blockquote>
<p>假设你在计算$x$和$l$之间的范数(就是高斯核函数的分子项)：</p>
<p>$||x-l||^2$</p>
<p>这个式子所表达的含义如下：</p>
<script type="math/tex; mode=display">
v=x-l</script><script type="math/tex; mode=display">
\begin{align\*}
||v||^2 &= v\_1^2 + v\_2^2 + ... + v\_n^2 \\\\
&= (x\_1-l\_1)^2 + (x\_2-l\_2)^2 + ... + (x\_n-l\_n)^2
\end{align\*}</script><p>其中$v$、$x$、$l$都是向量，由于$x$是$n$维的，所以$v$也是$n$维的。</p>
<p>现在如果你的特征变量取值范围很不一样。例如房价预测中，$x_1$表示1000平方英尺，$x_2$表示卧室数量为2，那么$(x_1-l_1)$可能相较于$(x_2-l_2)$大很多。</p>
<p>因此，为了让SVM更好的工作，我们需要对特征变量进行<strong>归一化</strong>处理。这将会保证SVM能够同等地关注到所有不同的特征变量。</p>
<h4 id="选择其他核函数"><a href="#选择其他核函数" class="headerlink" title="选择其他核函数"></a>选择其他核函数</h4><p>当你尝试使用SVM时，目前你能用到的核函数就是<strong>线性核函数</strong>和<strong>高斯核函数</strong>，这里有一个警告：</p>
<p>不是所有你可能提出来的相似度函数都是有效的核函数。线性核函数，高斯核函数，以及其他人有时会用到的其他的核函数，他们全部需要满足一个技术条件，这个条件叫做<strong>摩赛尔定理(Mercer`s Theorem)</strong>。</p>
<p>因为支持向量机算法的实现有许多巧妙的数值优化技巧，为了有效地求解参数$\theta$，在最初的设想里，有一个这样的决定，将我们的注意力仅仅限制在可以满足<strong>摩赛尔定理</strong>的核函数上，这个定义做的是：确保所有的SVM包能够使用大量的优化方法，并且快速地得到参数$\theta$。所以，大多数人最后要么使用线性核函数、要么使用高斯核函数。也有一些其他的核函数是满足<strong>摩赛尔定理</strong>的，而我个人是很少很少使用其他核函数的。</p>
<p>所以，我只是简单提及一下你可能会遇到的其他核函数，他们有：</p>
<ul>
<li><p><strong>多项式核函数（Polynomial kernel）</strong>：</p>
<ul>
<li><p>将$x$和$l$之间的相似度，定义为$(x^Tl)^2$：</p>
<script type="math/tex; mode=display">
k(x,l)=(x^Tl)^2</script><p>这就是一个$x$和$l$相似度的估量，如果$x$和$l$每一项很接近，那么这个内积就会很大。</p>
<p>这是一个有些不寻常的核函数，它并不常用，但你可能会见到有人使用它的变体形式，比如：</p>
<script type="math/tex; mode=display">
k(x,l)=(x^Tl)^3</script><script type="math/tex; mode=display">
k(x,l)=(x^Tl + 1)^3</script><script type="math/tex; mode=display">
k(x,l)=(x^Tl + 5)^4</script><p>这些都是多项式核函数的变形形式。</p>
<p>多项式核函数实际上有两个参数，一个是加在后面的常数项，如上面最后式子中的5；另一个是多项式的次数，如上面最后式子中的4。</p>
<p>因此，多项式核函数的更一般的形式是：</p>
<script type="math/tex; mode=display">
k(x,l)=(x^Tl + constant)^{degree}</script><p>这种核函数并不像高斯核函数那样频繁的使用，通常他只用在当$x$和$l$都是严格的非负数时。这样以确保内积值永远不会是负数。</p>
<p>这捕捉到了这样一个直观感觉：如果$x$和$l$之间非常相似，也许它们之间的内积会很大。</p>
<p>它们也有其他的一些性质，但是人们通常用得不多。</p>
</li>
</ul>
</li>
</ul>
<p>你也有可能会碰到其他一些更难懂的核函数，比如：</p>
<ul>
<li><strong>字符串核函数（String kernel）</strong>:<ul>
<li>如果你的输入数据是文本字符串，或者其他类型的字符串，有时会用到这个核函数。</li>
</ul>
</li>
<li><strong>卡方核函数（chi-square kernel）</strong></li>
<li><strong>直方图交叉核函数（histogram intersection kernel）</strong></li>
<li>…</li>
</ul>
<p>你可以用它们来度量不同对象之间的相似性。</p>
<p>例如，你在做一些文本分类问题，在这个问题中，输入变量$x$是一个字符串，我们想要通过字符串核函数来找到两个字符串间的相似度（但是我个人很少用这些更加难懂的核函数，我想我平生可能用过一次卡方核函数，可能用过一次或两次直方图交叉核函数，我甚至没用过字符串核函数）。</p>
<hr>
<h3 id="两个细节"><a href="#两个细节" class="headerlink" title="两个细节"></a>两个细节</h3><p>我想要在这个视频里讨论最后两个细节。</p>
<h4 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h4><p>在多类分类中，你有K个类别：</p>
<script type="math/tex; mode=display">
y \in ｛1,2,3,...,K｝</script><p>对应下图：</p>
<p><img src="/img/17_04_11/002.png" alt=""></p>
<p>很明显，这里$K=4$。</p>
<p>那么怎样让SVM输出下面这种各个类别间合适的判定边界呢？</p>
<p><img src="/img/17_04_11/003.png" alt=""></p>
<p>大部分SVM软件包已经内置了多类分类的函数了，因此，如果你用的是这种软件包，你可以直接使用内置函数。</p>
<p>另一种方式就是使用<strong>一对多(one-vs-all)方法</strong>。这个我们在讲逻辑回归的时候讨论过，所以，你要做的就是要训练$K$个SVM，每一个SVM把一个类同其他类区分开。这种操作会给你$K$个参数向量：</p>
<script type="math/tex; mode=display">
\theta^{(1)},\theta^{(2)},...,\theta^{(K)}</script><p>最后，这就与我们在逻辑回归中用到的一对多方法一样，选取使得$(\theta^{(i)})^Tx$最大的类$i$即可。</p>
<blockquote>
<p>其实大多数软件包都已经内置了多类分类的函数，因此你不必重新造轮子。</p>
</blockquote>
<h4 id="逻辑回归-vs-SVM"><a href="#逻辑回归-vs-SVM" class="headerlink" title="逻辑回归 vs SVM"></a>逻辑回归 vs SVM</h4><p>关于<strong>逻辑回归</strong>和<strong>SVM</strong>，我想讨论的是，你什么时候应该用哪个呢？</p>
<p>假设$n$是特征变量的个数，$m$是训练样本数：</p>
<ul>
<li>如果$n$(相对于$m$)大很多时，使用<strong>逻辑回归</strong>，或者使用<strong>无核函数的SVM（线性核函数）</strong>。<br>  比如你有一个文本分类的问题，特征数量$n=10000$，而且如果你的训练集大小为$m=10$，在这个问题中，你有10000个特征变量，对应10000个词，但是你只有10个训练样本。这种情况下就比较适合使用逻辑回归或者线性核函数的SVM了。</li>
<li>如果$n$较小，$m$是中等大小，（例如$n$为1到1000之间的值，$m$为10到10000之间的值）那么使用<strong>高斯核函数的SVM</strong>效果好一些。</li>
<li>如果$n$很小，$m$很大时（例如$n=1000$,$m=100000+$），那么高斯核函数的SVM运行起来会很慢，这种情况下，需要<strong>尝试手动地创建更多的特征变量，然后使用逻辑回归或者无核函数的SVM（线性核函数）</strong>。</li>
</ul>
<p>逻辑回归和不带核函数的SVM它们都是非常相似的算法，他们会做相似的事情，并且表现也相似，但是根据你实现的具体情况，其中一个可能会比另一个更加有效。</p>
<p>但是SVM的威力会随着你用不同的核函数而发挥出来。</p>
<h4 id="什么时候使用神经网络？"><a href="#什么时候使用神经网络？" class="headerlink" title="什么时候使用神经网络？"></a>什么时候使用神经网络？</h4><p>最后，神经网络应该在什么时候使用呢？</p>
<p>对于上面所有的情况，一个设计得很好的神经网络也很可能会非常有效，它的一个缺点（或者说不使用神经网络的原因）是：神经网络训练起来可能会很慢。但是如果你有一个非常好的SVM实现包，它会运行得比较快，比神经网络快很多。</p>
<blockquote>
<p>SVM的优化问题，实际上是一个<strong>凸优化</strong>问题。因此好的SVM优化软件包总是会找到全局最小值，或者接近它的值。<br>对于SVM，你不需要担心局部最优。在实际应用中，局部最优对神经网络来说不是非常大，但是也不小。所以使用SVM，你不用考虑这部分问题。</p>
</blockquote>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，如果你觉得上面这些使用参考有一些模糊，在面临实际问题时，仍然不能完全确定具体使用哪个算法更好，这个其实很正常。</p>
<p>当我遇到机器学习问题时，有时确实不清楚具体使用哪个算法更好，但是正如你在之前的视频中看到的，算法确实很重要，但是通常更重要的是：<strong>你有多少数据</strong>，<strong>你有多熟练</strong>，<strong>是否擅长做误差分析和调试学习算法</strong>，<strong>想出如何设计新的特征变量</strong>，<strong>想出如何设计新的特征变量</strong>，以及<strong>找出应该输入给学习算法的其它特征变量</strong>等方面。通常这些方面会比你使用<strong>逻辑回归</strong>还是<strong>SVM</strong>更加重要。</p>
<p>但是<strong>SVM</strong>仍然被广泛认为是<strong>最强大的学习算法之一</strong>，最强大的学习算法之一，而且SVM在一个区间内是一个非常有效地学习复杂非线性函数的方法。因此，有了<strong>逻辑回归</strong>、<strong>神经网络</strong>、<strong>SVM</strong>这三个学习算法，我想你已经具备了在广泛的应用里构建最前沿的机器学习系统的能力。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第三周 (1)分类和表达式</title>
    <url>/2016/08/21/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E5%91%A8%20(1)%E5%88%86%E7%B1%BB%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/wlPeP/classification">视频地址</a></p>
<p>在接下来的几节课中，将介绍分类问题。我们将学习一种叫做<strong>逻辑回归(Logistic Regression)</strong>的算法，这也是目前最流行，使用最广泛的一种学习算法。</p>
<p>下面是几个使用分类算法的例子：</p>
<ul>
<li>Email的垃圾邮件分类问题：区分邮件是否为垃圾邮件</li>
<li>网上交易分类问题：是否为欺诈交易</li>
<li>肿瘤分类问题：区分肿瘤是恶性还是良性</li>
</ul>
<p>在所有的这些问题中，我们想要预测的变量是$y$，我们可以认为它可以取两个值：<code>0</code>或者<code>1</code>。</p>
<script type="math/tex; mode=display">
y\in {0, 1}</script><blockquote>
<p>0：“负类”（例如：良性肿瘤）<br>1：“正类”（例如：恶性肿瘤）</p>
</blockquote>
<p>现在我们要开始研究只有两类（0和1）的分类问题。之后我们也会讨论更多类别的问题：$y\in {0,1,2,3,…}$，这就是所谓的<strong>多类分类问题</strong>。但接下来，我们将开始介绍只有两种类别的分类问题，或者叫做<strong>二元分类</strong>问题。</p>
<h3 id="二元分类"><a href="#二元分类" class="headerlink" title="二元分类"></a>二元分类</h3><p>那么我们要怎样开发一个分类算法呢？下面是一个用来给肿瘤分类的训练集的例子(恶性或良性)。</p>
<p><img src="/img/16_08_22/001.png" alt=""></p>
<blockquote>
<p>注意这里的恶性值(Malignant)只取两个值：0也就是良性，1也就是恶性。</p>
</blockquote>
<p>所以拿到这样的数据，我们通常的做法是用线性回归算法尝试使用一条直线来拟合这些数据：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x)=\theta^{T}x</script><p>如果你试着用一条直线去拟合这些数据，你也许会得到这样一条直线：</p>
<p><img src="/img/16_08_22/002.png" alt=""></p>
<p>如果你想要尝试分类，可以试着将分类器的阈值设为0.5：</p>
<ul>
<li>当$h_{\theta}(x)\ge0.5$时，预测$y=1$。</li>
<li>当$h_{\theta}(x)\lt0.5$时，预测$y=0$。</li>
</ul>
<p>因此，如图这里就是阈值的所在点：</p>
<p><img src="/img/16_08_22/003.png" alt=""></p>
<p>这个点右侧的点，我们会将它们全部预测为正，因为它们的输出值在纵轴上都是大于0.5的。同理，在这一点的左侧的点，我们会将它们全部预测为负。</p>
<p>在这个例子中，看起来好像线性回归所做的实际上是合理的，现在让我们稍做一些改动，延长一下横轴，假设在很远的右侧有一个训练样本。</p>
<p><img src="/img/16_08_22/004.png" alt=""></p>
<p>此时，得到的拟合数据的直线就会是上图那样，而且阈值所在的位置也会向右侧偏移。此时我们预测阈值点右侧的值都为正，左侧都为负。这看起来线性回归的效果并不好。因为我们可以很明显的看出来，新增的这个点其实并没有给我们带来什么新的信息，这里的意思是说，按照原本的预测，这一个位置出现的点就应该是正。而且我们根据这个新增的点得到的阈值所在点并没有很好的把数据进行划分。</p>
<p>因此<strong>使用线性函数进行分类并不是一个好办法</strong>。在第一个例子中，线性函数能够正常的预测数据只不过是巧合罢了。</p>
<p>另外一个不使用线性函数进行分类的原因是：对于分类问题，我们通常只需要取得$y=0$或$y=1$。如果使用线性回归，那么假设输出函数很有可能远大于1或者远小于0。</p>
<p><img src="/img/16_08_22/005.png" alt=""></p>
<p>因此我们接下来的视频中将要介<strong>逻辑回归算法(Logistic Regression)</strong>，这个算法的性质就是适用于$y$值为离散值的情况，并且它的输出值保证在0到1之间:</p>
<script type="math/tex; mode=display">
0\le h\_{\theta}(x)\le1</script><blockquote>
<p>顺便提一句，<strong>逻辑回归算法</strong>是一个<strong>分类算法</strong>，即使它的名字里有<strong>回归</strong>，但我们也把它当成分类算法来使用。这里只是因为历史原因，才被这样称呼。</p>
</blockquote>
<h2 id="假设函数表达式"><a href="#假设函数表达式" class="headerlink" title="假设函数表达式"></a>假设函数表达式</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/RJXfB/hypothesis-representation">视频地址</a> </p>
<p>之前我们说过，我们希望分类器的输出值的范围能控制在0和1之间：</p>
<script type="math/tex; mode=display">
0\le h\_{\theta}(x)\le1</script><p>因此我们渴望找到一个满足这种预测值性质的函数。</p>
<p>当我们使用线性回归时，我们用下面的式子来作为假设函数表达式：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = \theta^{T}x</script><p>对于逻辑回归来说，我们需要稍微改动一下：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = g(\theta^{T}x)</script><p>其中$g$函数的表达式为：</p>
<script type="math/tex; mode=display">
g(z)=\frac{1}{1+e^{-z}}</script><p>这个函数被称为<strong>S型函数(Sigmoid function)</strong>，或者<strong>逻辑函数(Logistic function)</strong>。</p>
<blockquote>
<p><strong>S型函数(Sigmoid function)</strong>和<strong>逻辑函数(Logistic function)</strong>基本上是同义词。因此这两个术语是可以互换的。</p>
</blockquote>
<p><strong>S型函数(Sigmoid function)</strong>的图形是这样的，顶部是随着$z$的增大而逐渐趋近于1，底部随着$z$的减小而逐渐趋近于0：</p>
<p><img src="/img/16_08_22/006.png" alt=""></p>
<p>因此我们可以得到：</p>
<script type="math/tex; mode=display">
\begin{align\*}
h\_{\theta}(x) &= g(\theta^{T}x) \\\\
&= \frac{1}{1+e^{-\theta^{T}x}}
\end{align*}</script><p>接下来我们要做的就是用参数$\theta$来拟合我们的数据。</p>
<h3 id="对假设函数的进一步理解"><a href="#对假设函数的进一步理解" class="headerlink" title="对假设函数的进一步理解"></a>对假设函数的进一步理解</h3><p><strong>假设函数的解释</strong>：</p>
<p>$h_{\theta}(x)$是对于新注入样本$x$的满足$y=1$的概率估计。</p>
<p>举个肿瘤分类的例子来说：</p>
<p>如果：</p>
<script type="math/tex; mode=display">
x=
\begin{bmatrix}
x\_{0} \\\\
x\_{1}
\end{bmatrix}
=
\begin{bmatrix}
1 \\\\
tumorSizs
\end{bmatrix}</script><script type="math/tex; mode=display">
h\_{\theta}(x) = 0.7</script><p>和之前一样，特征向量$x_{0}=1$，特征向量$x_{1}=tumorSize$代表肿瘤大小。</p>
<p>假设有一个病人，我们已知他肿瘤的大小，将他的特征向量$x$带入到$h_{\theta}(x)$中，得到的结果是$0.7$，那么我的解释就是$y=1$的概率是$0.7$，即这个患者的肿瘤是恶性的概率是$70\%$。</p>
<p>用更加正式的式子来表示就是：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = P(y=1|x;\theta)</script><blockquote>
<p>熟悉概率的同学可能对这个式子不陌生，这个式子代表着<strong>在给定的特征$x$的情况下，$y=1$的概率，其中参数为$\theta$</strong>。<br>在这里给定的$x$就是代表我的病人的肿瘤大小的特征$x$。</p>
</blockquote>
<p>由于我们知道，$y$的取值不是0就是1，因此当我们得到了$y=1$的概率时，$y=0$的概率就很容易得出：</p>
<script type="math/tex; mode=display">
P(y=0|x;\theta) + P(y=1|x;\theta) = 1 \\\\
P(y=0|x;\theta) = 1 - P(y=1|x;\theta)</script><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><p><a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/3">视频地址</a></p>
<p>这一节向大家介绍一个<strong>决策边界(Decision Boundary)</strong>的概念，这个概念能更好的帮助大家理解逻辑回归中假设函数在计算什么。</p>
<p>在上一节中，我们说假设函数可以表示为如下形式：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = g(\theta^{T}x)</script><script type="math/tex; mode=display">
g(z)=\frac{1}{1+e^{-z}}</script><p>对应的图像是这样的：</p>
<p><img src="/img/16_08_22/007.png" alt=""></p>
<p>更进一步来理解：</p>
<ul>
<li>如果$h_{\theta}(x)\ge0.5$ 我们认为$y=1$</li>
<li>如果$h_{\theta}(x)\lt0.5$ 我们认为$y=0$</li>
</ul>
<p>根据图片，我们可以得出:</p>
<ul>
<li>当$z\ge0$时，$h_{\theta}(x)\ge0.5$，满足$y=1$；</li>
<li>当$z\lt0$时，$h_{\theta}(x)\lt0.5$，满足$y=0$。</li>
</ul>
<p>即：</p>
<ul>
<li>当$\theta^{T}x\ge0$时，$y=1$；</li>
<li>当$\theta^{T}x\lt0$时，$y=0$；</li>
</ul>
<p>通过上面这些，我们可以更好的理解如何利用逻辑回归的假设函数来进行预测。</p>
<p>接下来我们看一个例子：</p>
<p><img src="/img/16_08_22/008.png" alt=""></p>
<p>假设我们有一个训练集，我们的假设函数为：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x)=g(\theta\_{0} + \theta\_{1}x\_{1} + \theta\_{2}x\_{2})</script><blockquote>
<p>目前我们还没有讲解如何拟合此模型中的参数，这个知识点将在下一节中讲解。这里我们假设数据已经是拟合好的了。</p>
</blockquote>
<p>假设我们已经拟合好了数据，并且得到了$\theta_{0}=-3$、$\theta_{1}=1$、$\theta_{2}=1$。这意味着：</p>
<script type="math/tex; mode=display">
\theta=
\begin{bmatrix}
-3 \\\\
1 \\\\
1
\end{bmatrix}</script><p>根据上面我们的讨论，我们可以得到：</p>
<ul>
<li>当$-3 + x_{1} + x_{2} \ge 0$时，满足$y=1$；</li>
<li>当$-3 + x_{1} + x_{2} \lt 0$时，满足$y=0$。</li>
</ul>
<p>因此，当$x_{1} + x_{2} = 3$时，我们可以得到一条直线：</p>
<p><img src="/img/16_08_22/009.png" alt=""></p>
<p>在这条直线右上方的点，代表$y=1$的点，这片区域被称为$y=1$区域。于此相对的是，在这条直线左下方的点，代表$y=0$的点，这片区域被称为$y=0$区域。</p>
<p>上面我们绘制出来的$x_{1} + x_{2} = 3$这条直线被称为<strong>决策边界(decision boundary)</strong>。</p>
<blockquote>
<p>值得说明的是，决策边界其实是假设函数$h_{\theta}(x)$的属性，它取决于其参数$\theta$。目前我们还没有说明如何对这些参数$\theta$进行取值，后面我们会学习如何使用训练集来确定这些参数的取值。但是，我们一旦能确定$\theta$的值时，我们就能确定出决策边界了。</p>
</blockquote>
<p>接下来我们来看一个更复杂的例子：</p>
<p><img src="/img/16_08_22/010.png" alt=""></p>
<p>和之前一样，圆圈表示负样本，红色的叉号表示正样本。那么我们怎样使用逻辑回归来拟合这些数据呢？</p>
<p>之前我们讲过多项式回归时，我们谈论到可以通过添加额外的高阶多项式项，这里我们同样可以对逻辑回归使用相同的方法。</p>
<p>具体的说，假设我的假设函数如下：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = 
g(\theta\_{0}+\theta\_{1}x\_{1}+\theta\_{2}x\_{2}+\theta\_{3}x\_{1}^{2}+\theta\_{4}x\_{2}^{2})</script><p>之前我们说到，我们将在后面的学习讨论如何得到正确的$\theta$，这里假设我们已经得到了正确的$\theta$，值如下：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\theta\_{0} &= -1 \\\\
\theta\_{1} &= 0 \\\\
\theta\_{2} &= 0 \\\\
\theta\_{3} &= 1 \\\\
\theta\_{4} &= 1 
\end{align*}</script><p>在这个参数的选择下，我们的参数向量将是：</p>
<script type="math/tex; mode=display">
\theta=
\begin{bmatrix}
-1 \\\\
0 \\\\
0 \\\\
1 \\\\
1
\end{bmatrix}</script><p>这也说明，若我们期望$y$满足$y=1$，那么$x_{1}$,$x_{2}$需满足：</p>
<script type="math/tex; mode=display">
-1 + x\_{1}^{2} + x\_{2}^{2} \ge 0</script><p>对应的决策边界就是这样：</p>
<p><img src="/img/16_08_22/011.png" alt=""></p>
<hr>
<p>其实对于更复杂的假设函数：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = 
g(\theta\_{0}+\theta\_{1}x\_{1}+\theta\_{2}x\_{2}+\theta\_{3}x\_{1}^{2}+\theta\_{4}x\_{1}^{2}x\_{2}+\theta\_{5}x\_{1}^{2}x\_{2}^{2}+\theta\_{6}x\_{1}^{3}x\_{2}+...)</script><p>它的决策边界可能会是一些有趣的形状：</p>
<p><img src="/img/16_08_22/012.png" alt=""></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第三周 (2)Logistic回归模型</title>
    <url>/2016/08/25/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E5%91%A8%20(2)Logistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="逻辑回归的代价函数"><a href="#逻辑回归的代价函数" class="headerlink" title="逻辑回归的代价函数"></a>逻辑回归的代价函数</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/1XG8G/cost-function">视频地址</a></p>
<p>这节课将讲解逻辑回归中，如何定义用来拟合参数的<strong>代价函数</strong>。</p>
<p><img src="/img/16_08_25/001.png" alt=""></p>
<p>如上图所示，我们现在有一组训练集，其中有$m$个训练样本，由于是一个分类问题，我们的$y$取值范围就是0和1。并且我们给出了假设函数$h_{\theta}(x)$。现在的问题就是，我们如何确定我们的参数$\theta$的值呢？也就是说如何<strong>拟合参数$\theta$</strong>呢？</p>
<p><img src="/img/16_08_25/002.png" alt=""></p>
<p>上图是之前求线性回归问题时的代价函数，现在我将上图的公式进行改写：</p>
<script type="math/tex; mode=display">
Cost(h\_{\theta}(x^{(i)}),y^{(i)})=
\frac{1}{2}(h\_{θ}(x^{(i)})-y^{(i)})^{2}</script><p>为了简写方便，去掉上标之后的代价函数如下：</p>
<script type="math/tex; mode=display">
Cost(h\_{\theta}(x),y)=
\frac{1}{2}(h\_{θ}(x)-y)^{2}</script><p>在线性回归问题中，代价函数会被定义为以上这种形式，但在逻辑回归里，如果我们最小化代价函数后，使用这个最小代价的值也是可以正常工作的，但是我们的这个代价函数会变成参数$\theta$的非凸函数。</p>
<p>因为这里：</p>
<script type="math/tex; mode=display">
\begin{align\*}
h\_{\theta}(x)
= \frac{1}{1+e^{-\theta^{T}x}}
\end{align*}</script><p>$h_{\theta}(x)$是非线性的，如果将这个值带入Cost函数，然后在求代价函数$J(\theta)$，我们会得到如下的有多个局部最优的函数：</p>
<p><img src="/img/16_08_25/003.png" alt=""></p>
<p>这种函数的官方名称叫做：<strong>非凸函数</strong>。</p>
<p>你大概可以感觉到如果把梯度下降算法用在这样一个函数上，不能保证它会收敛到全局最小值。</p>
<p>相应的，我们期望我们的代价函数$J(\theta)$是一个凸函数：</p>
<p><img src="/img/16_08_25/004.png" alt=""></p>
<p>对于这样的函数，我们使用梯度下降算法，才能够保证顺利的收敛到最小值。</p>
<p>这里导致我们的代价函数是非凸函数的根本原因就在于使用逻辑回归的那一步：</p>
<script type="math/tex; mode=display">
\begin{align\*}
h\_{\theta}(x)
= \frac{1}{1+e^{-\theta^{T}x}}
\end{align*}</script><p>所以我们想做的就是，<strong>另找一个是凸函数的代价函数</strong>使得我们能够方便的找到代价函数的全局最小值。</p>
<p>因此对于<strong>逻辑回归的代价函数</strong>，形式如下：</p>
<p><img src="/img/16_08_25/005.png" alt=""></p>
<p>对应的函数的图形如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$y=1$时</th>
<th style="text-align:center">$y=0$时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/16_08_25/006.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_08_25/007.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>现在这种形式的代价函数，有着很多很有趣的性质：</p>
<ul>
<li>在$y=1$的情况下：<ul>
<li>如果假设函数$h_{\theta}(x) = 1$，那么代价函数为0:$Cost=0$。</li>
<li>如果假设函数$h_{\theta}(x) \rightarrow 0$，那么代价函数趋近于∞:$Cost \rightarrow ∞$</li>
</ul>
</li>
<li>在$y=0$的情况下：<ul>
<li>如果假设函数$h_{\theta}(x) \rightarrow 1$，那么代价函数为0:$Cost \rightarrow ∞ $。</li>
<li>如果假设函数$h_{\theta}(x) = 0$，那么代价函数等于0:$Cost = 0$</li>
</ul>
</li>
</ul>
<p>这就是我们所期望的效果：<strong>当假设函数和期望值越接近时，代价函数值越小，反之越大。</strong></p>
<h2 id="简化代价函数以及梯度下降"><a href="#简化代价函数以及梯度下降" class="headerlink" title="简化代价函数以及梯度下降"></a>简化代价函数以及梯度下降</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/MtEaZ/simplified-cost-function-and-gradient-descent">视频地址</a></p>
<p>这节课我们来讲解一种<strong>稍微简单一些的方式来写代价函数</strong>，来替代我们现有的方法。同时也要讲清楚，<strong>如何运用梯度下降法来拟合出逻辑回归的参数$\theta$</strong>。因此，听了这节课，你应该就能够实现一个完整的逻辑回归算法了。</p>
<h3 id="简化单个样本的代价函数-Cost-h-theta-x-y"><a href="#简化单个样本的代价函数-Cost-h-theta-x-y" class="headerlink" title="简化单个样本的代价函数$Cost(h_{\theta}(x),y)$"></a>简化单个样本的代价函数$Cost(h_{\theta}(x),y)$</h3><p>之前我们讲解了逻辑回归中的代价函数：</p>
<p><img src="/img/16_08_25/008.png" alt=""></p>
<p>上图中有：</p>
<ul>
<li>我们定义的逻辑回归的整体的代价函数$J(\theta)$</li>
<li>针对于单个样本的代价函数$Cost(h_{\theta}(x),y)$</li>
<li>并且我们知道，作为分类问题，我们的$y$的取值永远都是0或者1。</li>
</ul>
<p>其中对于单个样本的代价函数$Cost(h_{\theta}(x),y)$，我们可以把$y=0$和$y=1$的两种情况合二为一，写成一个统一的式子：</p>
<script type="math/tex; mode=display">
Cost(h\_{\theta}(x),y)=-ylog(h\_{\theta}(x))-(1-y)log(1-h\_{\theta}(x))</script><p>这个表达式和我们之前写的代价函数的表达式，效果是完全一样的，但后者更加紧凑。</p>
<blockquote>
<p>我们知道在上面的式子中，$y$的取值非0即1，如果$y=1$那么$Cost(h_{\theta}(x),y)=-log(h_{\theta}(x))$，如果$y=0$那么$Cost(h_{\theta}(x),y)=-log(1-h_{\theta}(x))$。效果和分开写是完全一样的。</p>
</blockquote>
<h3 id="拟合逻辑回归的参数-theta"><a href="#拟合逻辑回归的参数-theta" class="headerlink" title="拟合逻辑回归的参数$\theta$"></a>拟合逻辑回归的参数$\theta$</h3><p>这样一来，我们就可以写出完整的逻辑回归的代价函数了：</p>
<p><img src="/img/16_08_25/009.png" alt=""></p>
<blockquote>
<p>似乎我们有其他方式来表示单个样本的代价函数$Cost(h_{\theta}(x),y)$，但在这里不做详细的说明，但是我可以告诉你，现在我们使用的这种形式的代价函数的式子，是从统计学中的<strong>极大似然法</strong>得来的。不过如果你不理解什么是<strong>极大似然法</strong>，以及逻辑回归中的代价函数为什么是这种形式，也没关系，也不会影响你后面的学习。</p>
</blockquote>
<p>接下来的问题就是找到使得代价函数$j(\theta)$最小的参数$\theta$了：</p>
<p><img src="/img/16_08_25/010.png" alt=""></p>
<p>一旦我们得到了这个合适的$\theta$那么我们就可以对一个给定的样本进行预测了：</p>
<p><img src="/img/16_08_25/011.png" alt=""></p>
<blockquote>
<p>注意：$p(y=1|x;\theta)$就是指关于$x$以$\theta$为参数，$y=1$的概率。</p>
</blockquote>
<p>由此可见，我们问题的核心在于求解最小化代价函数：</p>
<p><img src="/img/16_08_25/012.png" alt=""></p>
<p>上图就是逻辑回归问题中最小化代价函数的方法，是通过梯度下降算法来实现。</p>
<p>对上图中的偏导数项展开后就是下面的形式：</p>
<p><img src="/img/16_08_25/013.png" alt=""></p>
<p>如果你把上面的式子放到线性回归问题中进行对比的话，<strong>你会发现这个式子正是用来做线性回归梯度下降的。</strong></p>
<p>那么我们不禁要问一下自己，线性回归算法和逻辑回归算法是一样的吗？</p>
<p>要回答这个问题，就要看从线性回归，到逻辑回归，到底发生了哪些变化。</p>
<p>实际上对于假设函数$h_{\theta}(x)$的定义发生了变化：</p>
<ul>
<li>线性回归中，假设函数定义为$h_{\theta}(x)=\theta^{T}x$</li>
<li>在逻辑回归中，假设函数的定义为$h_{\theta}(x)= \frac{1}{1+e^{-\theta^{T}x}}$</li>
</ul>
<p>由于假设函数的不同，实际上线性回归和逻辑回归的梯度下降是两个完全不同的东西。</p>
<p>当我们在讨论线性回归的梯度下降算法时，我们谈到了如何监控梯度下降法以确保其收敛。其实我们通常也把这种方法运用在逻辑回归中，来检测梯度下降，以确保其正常收敛。这里就不多做介绍，可以参考<strong>斯坦福机器学习课程 第一周 (5)参数学习-梯度下降算法</strong>来实现。</p>
<h2 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/licwf/advanced-optimization">视频地址</a></p>
<p>这节课中会介绍一些高级优化概念和技巧。利用这些技巧，我们就使通过梯度下降进行逻辑回归的速度大大提高，这也将使得算法更加适合解决大型的机器学习问题。</p>
<h3 id="优化算法概念引入"><a href="#优化算法概念引入" class="headerlink" title="优化算法概念引入"></a>优化算法概念引入</h3><p>现在我们换个角度来看看什么是梯度下降：</p>
<p>我们有个代价函数$J(\theta)$，并且我们希望最小化代价函数$min_{\theta}J(\theta)$。</p>
<p>为了得到最小化代价函数$min_{\theta}J(\theta)$，我们需要计算出$J(\theta)$关于每一项$\theta$的偏导：</p>
<p><img src="/img/16_08_25/014.png" alt=""></p>
<p>有了上面的$J(\theta)$关于每一项$\theta$的偏导，为了求得合适的$\theta$，我们就可以利用梯度下降算法来递减$\theta$，使其接近全局最小值了：</p>
<p><img src="/img/16_08_25/015.png" alt=""></p>
<p>但事实上，<strong>梯度下降并不是我们可以使用的唯一算法</strong>，下面是我们常用的几种算法：</p>
<ul>
<li><strong>梯度下降算法(Gradient descent)</strong></li>
<li><strong>共轭梯度法(Conjugate gradient)</strong></li>
<li><strong>变尺度法(BFGS)</strong></li>
<li><strong>限制变尺度法(L-BFGS)</strong></li>
</ul>
<p>除了我们常说的梯度下降算法外的其他三种算法，都有着更复杂的方式来求最小化代价函数。但是这三种算法的细节，超出了本门课程的范畴(实际上如果你想要研究这些算法，可能你需要花费几周的时间，你可以专门学一门课程来提高数值计算能力)。不过我会告诉你他们的一些特性。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>这三种算法有许多优点：</p>
<p><strong>优点</strong>：</p>
<ul>
<li>不需要手动选择学习率$a$<ul>
<li>所以对这些算法的一种思路是 给出计算导数项和代价函数$J(\theta)$的方法，你可以认为算法有一个智能的内部循环，这种智能的内部循环被称为<strong>线性搜索(line search)</strong>算法，它可以自动尝试不同的学习速率$a$，并自动选择一个好的学习速率$a$。因此它甚至可以在每次迭代时都选择不同的学习速率，那么你就不需要自己选择$a$了。</li>
</ul>
</li>
<li>通常情况下收敛速度比梯度下降算法更快<ul>
<li>这些算法实际上在做更复杂的事情，而不仅仅是选择一个好的学习速率$a$，所以他们往往最终收敛的远远快于梯度下降。不过关于它们是如何做到的细节，已经超过了本门课程的范畴。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实际上，我过去十年我都在相当频繁的使用这几种算法。但直到前几年，我才真正搞清楚共轭梯度法、BFGS和L-BFGS的细节。因此，实际上你完全可以在不了解这些算法的内环间在做什么的的情况下使用这些算法，并应用于许多不同的学习问题。</p>
</blockquote>
<p>如果说这些算法优缺点的话，那么它的缺点就是：</p>
<p><strong>缺点</strong></p>
<ul>
<li>比梯度下降法复杂多了<ul>
<li>如果你不是数值计算方面的专家，不建议你亲自去写共轭梯度法、BFGS和L-BFGS，而是去使用一些现成的库。实际上Octave和Matlab都有很理想的库来实现这些先进的优化算法。值得一提的是，这些算法在不同语言上的实现，是有差别的，有的语言上的库可能会表现的不太好。所以建议对比选择合适的实现。</li>
</ul>
</li>
</ul>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>接下来来举例说明如何使用这些算法。</p>
<p>比如你有一个包含两个参数的问题：</p>
<p><img src="/img/16_08_25/016.png" alt=""></p>
<p>对于上图中的代价函数，我们可以求得当$\theta_{1}=5$,$\theta_{2}=5$时，$J(\theta)$的值最小。</p>
<p>下面就看看怎么使用Octave程序来计算$\theta_{1}$和$\theta_{2}$吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function [jVal, gradient] &#x3D; costFunction(theta)</span><br><span class="line"></span><br><span class="line">jVal &#x3D; (theta(1)-5)^2 + (theta(2)-5)^2;</span><br><span class="line"></span><br><span class="line">gradient &#x3D; zeros(2,1);</span><br><span class="line">gradient(1) &#x3D; 2*(theta(1)-5);</span><br><span class="line">gradient(2) &#x3D; 2*(theta(2)-5);</span><br></pre></td></tr></table></figure>
<p>上面这段代码定义了一个函数<code>costFunction(theta)</code>，参数是一个<code>theta</code>向量，包含$\theta_{1}$和$\theta_{2}$，返回值是<code>jVal</code>和<code>gradient</code>。通过函数的定义，我们可以看出来<code>jVal</code>表示的是代价函数$J(\theta)$：</p>
<p><img src="/img/16_08_25/018.png" alt=""></p>
<p><code>gradient</code>是一个列量，其中两个值分别代表对$\theta_{1}$和$\theta_{2}$的偏导：</p>
<p><img src="/img/16_08_25/019.png" alt=""></p>
<p>接下来，调用高级优化函数<code>fminunc</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options &#x3D; optimset(&#39;GradObj&#39;, &#39;on&#39;, &#39;MaxIter&#39;, &#39;100&#39;);</span><br><span class="line">initialTheta &#x3D; zeros(2,1);</span><br><span class="line">[optTheta, functionVal, exitFlag] &#x3D; fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure>
<p><code>fminunc</code>表示Octave里无约束最小化函数，调用这个函数时，需要传入一个存有配置信息的变量<code>options</code>。上面的代码中，我们的设置项中<code>&#39;GradObj&#39;, &#39;on&#39;,</code>代表设置梯度目标参数为打开状态(on)，这也意味着你现在确实要给这个算法提供一个梯度。<code>&#39;MaxIter&#39;, &#39;100&#39;</code>代表设置最大迭代次数为100次。<code>initialTheta</code>代表我们给出的一个$\theta$的猜测初始值。</p>
<p>然后我们调用<code>fminunc</code>这个函数，传入三个参数，其中第一个参数<code>@costFunction</code>这里的<code>@</code>符号代表指向之前我们定义的<code>costFunction</code>函数的指针。后面两个参数分别是我们定义的$theta$初始值和配置信息<code>options</code>。</p>
<p>当我们调用这个<code>fminunc</code>函数时，它会自动的从众多高级优化算法中挑选一个来使用(你也可以把它当做一个可以自动选择合适的学习速率$a$的梯度下降算法)。</p>
<p>最终我们会得到三个返回值，分别是满足最小化代价函数$J(\theta)$的$\theta$值<code>optTheta</code>，<code>costFunction</code>中定义的<code>jVal</code>的值<code>functionVal</code>，以及标记是否已经收敛的状态值<code>exitFlag</code>，如果已收敛，标记为<code>1</code>，否则为<code>0</code>。</p>
<p>下面我们看看在Octave中具体怎么操作：</p>
<p>首先在当前工作目录下创建costFunction.m脚本，写入costFunction函数:</p>
<p><img src="/img/16_08_25/020.png" alt=""></p>
<p>然后在Octave终端下带入<code>fminunc</code>函数：</p>
<p><img src="/img/16_08_25/021.png" alt=""></p>
<h3 id="在逻辑回归中使用优化算法"><a href="#在逻辑回归中使用优化算法" class="headerlink" title="在逻辑回归中使用优化算法"></a>在逻辑回归中使用优化算法</h3><p>上面的例子是一个简单的二次函数中使用优化算法的例子，下面我们介绍一些在逻辑回归中使用这些算法：</p>
<p><img src="/img/16_08_25/022.png" alt=""></p>
<p>上图就是逻辑回归问题的代价函数的求解代码。可以看到大体流程和之前的例子是一致的，你只需要把相应的计算<code>jVal</code>以及各个<code>gradient</code>的代码，按照逻辑回归的规则填写完整即可。</p>
<blockquote>
<p>使用了这些复杂的优化算法之后，虽然它将使得调试变得更为困难，但是这些算法的速度远远大于普通的梯度下降算法的速度，因此可以用来处理很大的机器学习问题的时候，可以使用这些高级算法，而不是梯度下降算法。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第三周 (3)多类别分类问题：一对多</title>
    <url>/2016/09/04/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E5%91%A8%20(3)%E5%A4%9A%E7%B1%BB%E5%88%AB%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A/</url>
    <content><![CDATA[<h2 id="一对多分类问题"><a href="#一对多分类问题" class="headerlink" title="一对多分类问题"></a>一对多分类问题</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/68Pol/multiclass-classification-one-vs-all">视频地址</a></p>
<blockquote>
<p>在本节视频中，我们将谈到如何使用<strong>逻辑回归来解决多类别分类问题</strong>。具体来说，我想通过一个叫做<strong>“一对多”(one-vs-all)</strong>的分类算法，让你了解什么是多类别分类问题。</p>
</blockquote>
<p>先看这样一些例子：</p>
<ul>
<li>邮件分类器自动将邮件按照以下标签分类：工作，朋友，家庭，兴趣</li>
<li>医学根据病人的得病类型分类：没有病，感冒，流感</li>
<li>天气预报根据天气类型分类：晴天，多云，雨天，雪天</li>
</ul>
<p>我们可以分别对这些类别打上数值标签，比如天气分类中：晴天代表<code>y=1</code>，多云代表<code>y=2</code>，雨天代表<code>y=3</code>，雪天代表<code>y=4</code>。</p>
<p>以上这些例子都属于多类别分类问题。</p>
<hr>
<p>二元分类问题和多类别分类问题的比较：</p>
<p><img src="/img/16_09_04/001.png" alt=""></p>
<p>二元分类问题中，我们只有两个类别需要处理，而在多类别分类问题中，我们有多种类别需要处理。这里我们用三种不同的符号代表三种类别。</p>
<p>在二元分类中，我们知道我们可以使用逻辑回归来将两种类别的数据集一分为二：</p>
<p><img src="/img/16_09_04/002.png" alt=""></p>
<p>对于一对多的分类问题，我们也可以借鉴二元分类的思想。下面就来介绍一些如何进行一对多分类工作(有时也被称为“一对余”方法)。</p>
<p><img src="/img/16_09_04/003.png" alt=""></p>
<p>如图，我们现在有一组由三个类别元素组成的训练集。接下来我们要做的就是使用一个训练集将其分成三个二元分类问题。我们先从三角形开始，将其他两种类型视为同一种类型：</p>
<p><img src="/img/16_09_04/004.png" alt=""></p>
<p>实际上这是一个新的“伪类型集”，类型2和类型3被定义为负类(值为0)，类型1定义为正类(值为1)。我们要拟合出一个合适的分类器，来区分正类和负类。我们称这个分类器为$h_{\theta}^{(1)}(x)$</p>
<p><img src="/img/16_09_04/005.png" alt=""></p>
<p>同理，对类型2也做同样的处理，得到分类器$h_{\theta}^{(2)}(x)$：</p>
<p><img src="/img/16_09_04/006.png" alt=""></p>
<p>最后，对类型三也做同样处理，得到分类器$h_{\theta}^{(3)}(x)$：</p>
<p><img src="/img/16_09_04/007.png" alt=""></p>
<p>这样我们就得到了三个分类器，通过这些分类器来估算出给出$x$和先验$\theta$时，$y=i$的概率：</p>
<script type="math/tex; mode=display">
h\_{\theta}^{(i)}(x) = P(y=i|x;\theta)    \qquad  (i=1,2,3)</script><p>总之，现在我们要做的就是训练这个逻辑回归分类器$h_{\theta}^{(i)}(x)$，其中$i$对应每一个可能的$y=i$。</p>
<p>最后，为了做出预测，我们给定一个新的输入值$x$，用来做预测，我们要做的就是在我们的三个分类器里输入$x$，然后我们选择一个让$h_{\theta}^{(i)}(x)$最大的$i$，这就是预测出的类别。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第三周 (4)正则化：解决过拟合问题</title>
    <url>/2016/09/04/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B8%89%E5%91%A8%20(4)%E6%AD%A3%E5%88%99%E5%8C%96%EF%BC%9A%E8%A7%A3%E5%86%B3%E8%BF%87%E6%8B%9F%E5%90%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>机器学习模型需要拥有很好地泛化能力来适应训练集中没有出现过的新样本。</p>
<p>在这个节中，我们将介绍正则化方面的知识，这有助于预防过拟合的问题的产生。</p>
</blockquote>
<h2 id="解决过拟合问题"><a href="#解决过拟合问题" class="headerlink" title="解决过拟合问题"></a>解决过拟合问题</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/ACpTQ/the-problem-of-overfitting">视频地址</a></p>
<blockquote>
<p>到现在为止，你已经见识了几种不同的学习算法。包括线性回归和逻辑回归，它们能够有效地解决许多问题，但是当将它们应用到某些特定的机器学习应用时，会遇到<strong>过度拟合(over-fitting)</strong>的问题，可能会导致它们效果很差。</p>
<p>在这一节中，我将为你解释什么是过度拟合问题，并且在此之后接下来的几节中，我们将谈论一种称为<strong>正则化(regularization)</strong>的技术，它可以改善或者减少过度拟合问题，以使学习算法更好实现。</p>
</blockquote>
<h3 id="梯度下降中的过拟合问题"><a href="#梯度下降中的过拟合问题" class="headerlink" title="梯度下降中的过拟合问题"></a>梯度下降中的过拟合问题</h3><p>让我们继续使用那个线性回归来预测房价的例子。</p>
<h4 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h4><p>我们通过建立以住房面积为自变量的函数来预测房价，我们可以对该数据做线性回归：</p>
<p><img src="/img/16_09_04/028.png" width = "300" height = "200" align=center /></p>
<p>但是这不是一个很好的模型，我们来看看这些数据，很明显，随着房子面积增大，住房价格的变化趋势趋于稳定，或者往右越平缓。因此这个算法没有很好地拟合训练数据。</p>
<p>我们把这个问题称为<strong>欠拟合(under fitting)</strong>，这个问题的另一个术语叫做<strong>高偏差(High bias)</strong>。</p>
<p>这两种说法大致相似，意思是它只是没有很好地拟合训练数据。</p>
<blockquote>
<p><strong>bias</strong>这个词是过去传下来的一个专业名词，它的意思是如果拟合一条直线，到训练数据，就好像算法有一个很强的偏见，或者说非常大的偏差。</p>
<p>因为该算法认为房子价格与面积仅仅线性相关，尽管与该数据的事实相反，它还是接近于拟合一条直线，而此法最终导致拟合数据效果很差。</p>
</blockquote>
<h4 id="刚好合适"><a href="#刚好合适" class="headerlink" title="刚好合适"></a>刚好合适</h4><p>当我们加入一个二次项，在这组数据中，我们用二次函数来拟合它：</p>
<p><img src="/img/16_09_04/029.png" width = "300" height = "200" align=center /></p>
<p>事实证明这个拟合效果很好。</p>
<h4 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h4><p>另一个极端情况是，如果我们拟合一个四次多项式，因此在这里我们用五个参数来拟合这五个训练样本，你可以得到看上去像这样的一条曲线：</p>
<p><img src="/img/16_09_04/030.png" width = "300" height = "200" align=center /></p>
<p>一方面似乎对训练数据做了一个很好的拟合，因为这条曲线通过了所有的训练实例。但是，这任然是一条扭曲的曲线。它不停上下波动，因此事实上，我们并不认为它是一个预测房价的好模型。</p>
<p>这个问题我们把他叫做<strong>过度拟合(over fitting)</strong>，另一个描述该问题的术语是<strong>高方差(variance)</strong>。</p>
<p>介于<strong>高偏差</strong>和<strong>高方差</strong>这两者之间的情况叫做<strong>“刚好合适”</strong>。</p>
<p>概括地说，过拟合的问题将会在变量过多的时候发生，这种时候训练出的方程总能很好的拟合训练数据，所以你的代价函数实际上可能非常接近于0，甚至就是0。但是这会导致这种模型无法<strong>泛化</strong>到新的数据样本中，以至于无法预测新样本价格。</p>
<p>在这里术语<strong>“泛化(generalize)”</strong>指的是一个假设模型能够应用到新样本的能力。</p>
<h3 id="逻辑回归中的过拟合问题"><a href="#逻辑回归中的过拟合问题" class="headerlink" title="逻辑回归中的过拟合问题"></a>逻辑回归中的过拟合问题</h3><p>类似的方法同样可以应用到<strong>逻辑回归</strong>。</p>
<p>这里是一个以$x_{1}$，$x_{2}$为变量的逻辑回归。</p>
<p><img src="/img/16_09_04/031.png" width = "300" height = "200" align=center /></p>
<h4 id="欠拟合-1"><a href="#欠拟合-1" class="headerlink" title="欠拟合"></a>欠拟合</h4><p>我们先用下面这个假设函数来拟合：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = g(\theta\_{0} + \theta\_{1}x\_{1} + \theta\_{2}x\_{2})</script><script type="math/tex; mode=display">
(g=sigmoid\ function)</script><p>拟合的结果如下：</p>
<p><img src="/img/16_09_04/032.png" width = "300" height = "200" align=center /></p>
<p>它直接分开了正样本和负样本，但这个模型并不能够很好地拟合数据。因此这是一个<strong>欠拟合</strong>的例子。或者说假设模型具有高偏差。</p>
<h4 id="刚好适合"><a href="#刚好适合" class="headerlink" title="刚好适合"></a>刚好适合</h4><p>相比之下，如果我们再加入一些变量，改用这样一个多项式：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = g(\theta\_{0} + \theta\_{1}x\_{1} + \theta\_{2}x\_{2} + \theta\_{3}x\_{1}^{2} + \theta\_{4}x\_{2}^{2} + \theta\_{5}x\_{1}x\_{2})</script><p>那么你可以得到一个能比较好的拟合数据的判定边界：</p>
<p><img src="/img/16_09_04/033.png" width = "300" height = "200" align=center /></p>
<h4 id="过拟合-1"><a href="#过拟合-1" class="headerlink" title="过拟合"></a>过拟合</h4><p>在另一种极端情况下，如果你用高阶多项式来拟合数据：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = g(\theta\_{0} + \theta\_{1}x\_{1} + \theta\_{2}x\_{1}^{2} + \theta\_{3}x\_{1}^{2}x\_{2} + \theta\_{4}x\_{1}^{2}x\_{2}^{2} + \theta\_{5}x\_{1}^{2} x\_{2}^{3} + \theta\_{6}x\_{1}^{3}x\_{2} + ...)</script><p>那么逻辑回归可能发生自身扭曲：</p>
<p><img src="/img/16_09_04/034.png" width = "300" height = "200" align=center /></p>
<p>它会千方百计的来形成扭曲以至于成为一条能尽量拟合每一个样本的拟合曲线。</p>
<p>这是一个<strong>过拟合</strong>的例子，是一个高方差假设模型，它不能够很好泛化到新样本。</p>
<h4 id="解决过拟合问题-1"><a href="#解决过拟合问题-1" class="headerlink" title="解决过拟合问题"></a>解决过拟合问题</h4><p>当我们使用一维或二维数据时，我们可以通过绘制出假设模型的图像来研究问题所在，再选择合适的多项式来拟合数据。因此在以之前的房屋价格为例，我们可以绘制假设模型的图像就能看到模型的曲线非常扭曲，并通过所有的样本房价：</p>
<p><img src="/img/16_09_04/035.png" width = "300" height = "200" align=center /></p>
<p>我们可以通过绘制这样的图形来选择合适的多项式阶次，但当我们遇到有很多变量的假设模型时，我们就无法绘制出图像了：</p>
<p><img src="/img/16_09_04/036.png" width = "300" height = "200" align=center /></p>
<p>当我们有过多变量，同时只有非常少的训练数据时，就会出现过度拟合的问题。</p>
<p>为了解决过度拟合问题，有两种方法：</p>
<ul>
<li><p>1.要尽量减少选取的变量的数量。</p>
<ul>
<li>具体而言我们可以人工检测变量的条目，保留重要的特征，舍弃无用的特征</li>
<li>模型选择算法（后面的课程会提到）</li>
</ul>
</li>
<li><p>2.正则化</p>
<ul>
<li>保留所有的特征变量，但是通过减少参数$\theta_{j}$的数量级或值的大小。</li>
</ul>
</li>
</ul>
<p><strong>正则化</strong>相关的知识点将在接下来的内容中介绍。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/B1MnL/cost-function">视频地址</a></p>
<blockquote>
<p>在这一节中，我将传达给你一个关于正则化的直观的感受，并且我们还要写出使用正则化时需要使用的代价函数。</p>
</blockquote>
<p>在上一节中，我们看到了如果说我们要用一个二次函数来拟合这些数据，拟合的效果会很好。</p>
<p><img src="/img/16_09_04/037.png" width = "300" height = "200" align=center /></p>
<p>然而我们用一个更高次的多项式去拟合，我们最终可能得到一个曲线，能非常好的拟合训练集，但是这真的不是一个好的结果。</p>
<p><img src="/img/16_09_04/038.png" width = "300" height = "200" align=center /></p>
<p>它过度拟合了数据，因此泛化性并不是很好。</p>
<p>让我们考虑下面的假设：</p>
<p>我们想要加上惩罚项，从而使参数$\theta_{3}$和$\theta_{4}$足够的小。这里我的意思就是，尽量减少代价函数的均方误差。</p>
<p><img src="/img/16_09_04/039.png" width = "300" height = "200" align=center /></p>
<p>对于上面这个函数，我们对它添加一些项：</p>
<p><img src="/img/16_09_04/040.png" width = "300" height = "200" align=center /></p>
<p>现在，如果想最小化这个函数，我们需要尽量减少$\theta_{3}$和$\theta_{4}$的值。</p>
<p>如果我们减少了这两项的值，就像是在上面的式子中忽略了后面的两项：</p>
<p><img src="/img/16_09_04/041.png" width = "300" height = "200" align=center /></p>
<p>最终得到一个近似的二次函数，从而达到恰当地拟合数据的表达式。</p>
<hr>
<p>在这个具体的例子中，我们看到了，惩罚$\theta_{3}$和$\theta_{4}$这两个大的参数值的效果。</p>
<p>所以推广到更通用的情况下，这里给出了正规化背后的思路。这种思路就是如果我们的参数值对应一个较小的值的话，那么往往我们会得到一个形式更简单的假设函数。</p>
<blockquote>
<p>所以我们最后一个例子中我们惩罚的只是$\theta_{3}$和$\theta_{4}$，使这两个数值均接近于零。我们从而得到了一个更简单的假设。</p>
<p>通常情况下来讲，参数值减少的越多，函数越光滑，因此就不易发生过拟合的问题。</p>
</blockquote>
<hr>
<h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>来让我们看看具体的例子：</p>
<p>对于房屋价格预测，我们可能有上百种特征，我们谈到了一些可能的特征，比如说:</p>
<ul>
<li>$x_{1}$是房屋的尺寸</li>
<li>$x_{2}$是卧室的数目</li>
<li>$x_{3}$是房屋的层数</li>
<li>…</li>
</ul>
<p>我们可能有一百个特征。</p>
<p>跟前面的多项式例子不同，我们是不知道$\theta_{3}$,$\theta_{4}$是高阶多项式的项，即如果我们有一百个特征，我们是很难提前选出那些关联度更小的特征的。我们不知道如何选择参数来缩小参数的数目。</p>
<p>因此在正规化中，我们要做的事情，就是通过修改我们的代价函数（这里就是线性回归的代价函数）</p>
<p><img src="/img/16_09_04/042.png" width = "300" height = "200" align=center /></p>
<p>从而缩小我所有的参数值，修改方式就是在这后面添加一项：</p>
<p><img src="/img/16_09_04/043.png" width = "300" height = "200" align=center /></p>
<p>当我在最后添加一个额外的正则化项的时候，我们收缩了每个参数，并且因此 我们会使我们所有的参数$\theta_{1}.\theta_{2}.\theta_{3}.\theta_{4}…\theta_{100}$的值变小。</p>
<p>顺便说一下，按照惯例来讲，我们是从$\theta_{1}$开始的：</p>
<p><img src="/img/16_09_04/044.png" width = "300" height = "200" align=center /></p>
<p>所以我实际上没有去惩罚$\theta_{0}$，因此$\theta_{0}$的值是大的。</p>
<blockquote>
<p>在实际情况中，是否包含$\theta_{0}$只会有非常小的差异。</p>
</blockquote>
<h3 id="正规化优化的目标"><a href="#正规化优化的目标" class="headerlink" title="正规化优化的目标"></a>正规化优化的目标</h3><p>我们正规化之后的代价函数如下：</p>
<p><img src="/img/16_09_04/045.png" width = "300" height = "200" align=center /></p>
<p>在后面的正规化项中的$λ$我们称为<strong>正规化参数</strong>。</p>
<p>$λ$要做的就是控制在两个不同的目标中的一个平衡关系：</p>
<ul>
<li>第一个目标就是：我们想要训练使假设函数更好的拟合训练数据。</li>
<li>第二个目标就是：我们想要保持参数值较小。</li>
</ul>
<p>参数$λ$就是用来控制这两者之间的平衡，目标就是平衡<strong>拟合训练</strong>的目的和<strong>保持参数值较小</strong>的目的。（即欠拟合和过拟合的平衡）</p>
<p>对于我们房屋价格预测的例子来说，尽管我们之前已经用非常高的高阶多项式来拟合，我们将会得到一个非常弯曲和复杂的曲线函数，就像下面这样：</p>
<p><img src="/img/16_09_04/046.png" width = "300" height = "200" align=center /></p>
<p>但现在我们不这样了，你只需要确保使用了正规化目标的方法，那么你就可以得到一个类似于二次函数但并不是真正的二次函数的一条曲线：</p>
<p><img src="/img/16_09_04/047.png" width = "300" height = "200" align=center /></p>
<p>这样我们就得到了对于这个数据来说更好的假设函数。</p>
<hr>
<p>在正规化线性回归中，如果正规化参数值被设定为非常大，那么会发生什么呢？</p>
<p>我们将会非常大地惩罚我们的参数，会使得所有的参数接近于0。如果我们这么做，那么就相当于我们从假设函数中去掉了这些项，并且使得我们只是留下了一个简单的假设：</p>
<p><img src="/img/16_09_04/048.png" width = "300" height = "200" align=center /></p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = \theta\_{0}</script><p>那就是类似于拟合了一条水平直线：</p>
<p><img src="/img/16_09_04/049.png" width = "300" height = "200" align=center /></p>
<p>对于数据来说这就是<strong>欠拟合(underfitting)</strong>。</p>
<p>换句话说，就是这种假设有过于强烈的“偏见”或者过高的偏差（bais），认为预测的价格只是等于$\theta_{0}$。</p>
<p>因此为了使正则化运作的良好，我们应该去选择一个不错的正则化参数$λ$，并且当我们讲到多重选择时，我们将会介绍一种方法来<strong>自动选择正则化参数$λ$</strong>。这就是高度正则化的思路。</p>
<h2 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/QrMXd/regularized-linear-regression">视频地址</a></p>
<p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降、一种基于正规方程。</p>
<p>在这段视频中，我们将继续学习这两个算法，并把它们推广到正则化线性回归中去。</p>
<h3 id="基于梯度下降"><a href="#基于梯度下降" class="headerlink" title="基于梯度下降"></a>基于梯度下降</h3><p>这是我们上节课推导出的正则化线性回归的优化目标：</p>
<p><img src="/img/16_09_04/050.png" width = "300" height = "200" align=center /></p>
<p>前面第一部分是一般线性回归的目标函数，后半部分是正则化项。其中$\lambda$是正则化参数。我们想找到能最小化代价函数的参数$\theta$。</p>
<p>之前，我们使用梯度下降求解原来没有正则项的代价函数：</p>
<p><img src="/img/16_09_04/051.png" width = "300" height = "200" align=center /></p>
<p>我们会反复更新参数$\theta_{j}$，其中$j=0,1,2,3,…,n$。</p>
<p>让我们把$j=0$的情况单独写出来：</p>
<p><img src="/img/16_09_04/052.png" width = "300" height = "200" align=center /></p>
<blockquote>
<p>我只是把$\theta_{0}$的更新分离出来，剩下的这些参数($\theta_{j}$其中$j=1,2,3,…,n$)更新作为另一部分，所以这样做其实没有什么变化。仅仅是把$\theta_{0}$的更新从其他参数中分离出来。</p>
<p>我这样做的原因是因为上节课提到的，对于正则化的线性回归，我们惩罚参数从$\theta_{1}$开始，我们不惩罚$\theta_{0}$。所以当我们修改这个正则化线性回归的算法时，我们将对$\theta_{0}$有所不同。</p>
</blockquote>
<p>具体地说，如果我们要对这个算法进行修改，并用它求解正则化的目标函数，我们需要做的是把下面的这一项加上正则化项：</p>
<p><img src="/img/16_09_04/053.png" width = "500" height = "200" align=center /></p>
<p>如果这样做的话，那么你就有了用于最小化正则化代价函数$J(\theta)$的梯度下降算法。</p>
<p>对于上面式子中第二项：</p>
<p><img src="/img/16_09_04/054.png" width = "500" height = "200" align=center /></p>
<p>可以改写为这种形式：</p>
<p><img src="/img/16_09_04/055.png" width = "500" height = "200" align=center /></p>
<p>具体来讲，这一项的值:</p>
<p><img src="/img/16_09_04/056.png" width = "100" height = "200" align=center /></p>
<p>通常是一个<strong>小于1的具体的实数</strong>（通常情况下是一个比1小一点点的值），所以我们可以把它想成一个像$0.99$一样的数字。</p>
<p>所以对$\theta_{j}$更新的结果我们可以看作是被替换为$\theta_{j}$的0.99倍（把$\theta_{j}$向0压缩了一点点）。</p>
<p>另外后面的这一项：</p>
<p><img src="/img/16_09_04/057.png" width = "300" height = "200" align=center /></p>
<p>实际上与我们原来的梯度下降更新完全一样。</p>
<hr>
<p>当我们使用正则化线性回归时，我们需要做的就是在每一个被正则化的参数$\theta_{j}$上乘以了一个比1小一点点的数字，然后，我们执行跟以前一样的更新。</p>
<h3 id="基于正规方程"><a href="#基于正规方程" class="headerlink" title="基于正规方程"></a>基于正规方程</h3><p>梯度下降只是拟合线性回归模型的两种算法之一，另一种算法是基于正规方程。</p>
<p>我们的做法是建立这个设计矩阵X:</p>
<p><img src="/img/16_09_04/058.png" width = "300" height = "200" align=center /></p>
<p>其中每一行对应于一个单独的训练样本。</p>
<p>然后创建一个m维度的向量y，包含了所有训练集里的标签：</p>
<p><img src="/img/16_09_04/059.png" width = "300" height = "200" align=center /></p>
<p>所以X是一个$m \times (n+1)$维矩阵。</p>
<p>为了最小化代价函数$J$:</p>
<p><img src="/img/16_09_04/060.png" width = "150" height = "200" align=center /></p>
<p>我们发现一个办法就是让$\theta$等于这个式子：</p>
<script type="math/tex; mode=display">
\theta=(X^{T}X)^{-1}X^{T}y</script><p>这是没有使用正则化的表达式。</p>
<p>如果我们使用了正则化，我们想要得到最小值，那么我们的推导方式如下：</p>
<p>取$J$关于各个参数的偏导数，并令他们等于0：</p>
<p><img src="/img/16_09_04/061.png" width = "150" height = "200" align=center /></p>
<p>然后通过一些数学推导，你可以得到这样的式子：</p>
<script type="math/tex; mode=display">
\theta=(X^{T}X + \lambda
\begin{bmatrix}
     0 & 0 & ... & 0 \\\\
     0 & 1 \\\\
     ... & ... & ... \\\\
     0 & 0 & ... & 1 \\\\
\end{bmatrix}
 )^{-1}X^{T}y</script><p>其中正则化矩阵左上角的元素是0，其余对角线元素都是1，剩下的元素也都是0。矩阵的维度是$(n+1)\times(n+1)$。</p>
<h4 id="举个具体的例子来说明："><a href="#举个具体的例子来说明：" class="headerlink" title="举个具体的例子来说明："></a>举个具体的例子来说明：</h4><p>假设$n=2$，那么这里我们的矩阵是一个$3\times3$维的矩阵。这个矩阵看起来就是下面这种形式：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
     0 & 0 & 0 \\\\
     0 & 1 & 0 \\\\
     0 & 0 & 1 \\\\
\end{bmatrix}</script><p>如果你采用新定义包含正则项的$J(\theta)$，那么这个计算$\theta$的式子，能使你的$J(\theta)$达到全局最小值。</p>
<h3 id="不可逆问题-选学"><a href="#不可逆问题-选学" class="headerlink" title="不可逆问题(*选学)"></a>不可逆问题(*选学)</h3><p>最后，我想快速地谈一下不可逆性的问题，这部分是比较高阶的内容，所以这一部分还是作为选学。</p>
<p>之前当我讲正规方程的时候，我们也有一段讲不可逆问题的选学视频，这节视频是作为那一节的补充。</p>
<p>现在考虑m（即样本总数）小于等于特征数量n：</p>
<script type="math/tex; mode=display">
m \le n</script><p>如果你的样本数量比特征数量小的话，那么这个矩阵$X^{T}X$将是<strong>不可逆</strong>的或<strong>奇异(singluar)</strong>的。</p>
<p>幸运的是，正规化也为我们解决了这个问题，具体地说，只要正则参数是严格大于0的：</p>
<script type="math/tex; mode=display">
\lambda \gt 0</script><p>实际上是可以证明：</p>
<script type="math/tex; mode=display">
\theta=(X^{T}X + \lambda
\begin{bmatrix}
     0 & 0 & ... & 0 \\\\
     0 & 1 \\\\
     ... & ... & ... \\\\
     0 & 0 & ... & 1 \\\\
\end{bmatrix}
 )^{-1}X^{T}y</script><p>中</p>
<script type="math/tex; mode=display">
X^{T}X + \lambda
\begin{bmatrix}
     0 & 0 & ... & 0 \\\\
     0 & 1 \\\\
     ... & ... & ... \\\\
     0 & 0 & ... & 1 \\\\
\end{bmatrix}</script><p>这个矩阵是可逆的。</p>
<p>因此，使用正则化还可以照顾一些$X^{T}X$不可逆的问题</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第九周 (1)密度估计</title>
    <url>/2017/05/23/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B9%9D%E5%91%A8%20(1)%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="动机-异常检测"><a href="#动机-异常检测" class="headerlink" title="动机:异常检测"></a>动机:异常检测</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/V9MNG/problem-motivation">视频地址</a></p>
<blockquote>
<p>在接下来的一系列课程中，我将向大家介绍<strong>异常检测(Anomaly detection)问题</strong>。这是机器学习算法的一个常见应用。这种算法的一个有趣之处在于它虽然主要用于非监督学习问题，但从某些角度看，它又类似于一些监督学习问题。</p>
</blockquote>
<p>首先，我们举一个例子来解释什么是异常检测。</p>
<p>假想你是一个飞机引擎制造商，当你生产的飞机引擎从生产线上流出时，你需要进行QA(质量控制测试)。而作为这个测试的一部分，你测量了飞机引擎的一些特征变量，比如你可能测量了引擎运转时产生的热量，或者引擎的振动等等（我有一些朋友很早之前就开始进行这类工作，在实际工作中他们确实会从真实的飞机引擎采集这些特征变量）：</p>
<script type="math/tex; mode=display">
x\_1 = 产生的热量 \\\\
x\_2 = 振动的强度 \\\\
...</script><p>这样一来，如果你生产了m个引擎的话，你就有了一个从$x^{(1)}$到$x^{(m)}$的数据集：</p>
<script type="math/tex; mode=display">
｛x^{(1)}，x^{(2)}，...，x^{(m)}｝</script><p>也许你会将这些数据绘制成图表，看起来就是这个样子：</p>
<p><img src="/img/17_05_23/001.png" alt=""></p>
<p>图中每个叉都是你的无标签数据。</p>
<p>假设有一天，你有一个新的飞机引擎从生产线上流出，这个引擎的数据为$x_{test}$。那么所谓的<strong>异常检测问题</strong>就是检查这个新的飞机引擎是否存在某种异常。</p>
<p>比如说，如果你的新引擎对应的点落在这里：</p>
<p><img src="/img/17_05_23/002.png" alt=""></p>
<p>从数据上来看，它看起来像我们之前见过的引擎，因此我们可以直接认为它是正常的。然而如果你的新飞机引擎的$x_{test}$对应的点在这外面：</p>
<p><img src="/img/17_05_23/003.png" alt=""></p>
<p>那么我们可以认为这是一个异常的引擎。</p>
<h3 id="异常检测问题更正式的定义"><a href="#异常检测问题更正式的定义" class="headerlink" title="异常检测问题更正式的定义"></a>异常检测问题更正式的定义</h3><p><strong>异常检测问题</strong>更正式一些的定义如下：</p>
<p>假设我们有$m$个<strong>正常的</strong>样本数据$｛x^{(1)}，x^{(2)}，…，x^{(m)}｝$，我们需要一个算法来告诉我们一个新的样本数据$x_{test}$是否异常。</p>
<p>我们要采取的方法是：给定无标签的训练集，对数据集$x$建立一个概率分布模型$p(x)$。当我们建立了$x$的概率模型之后，我们就会说，对于新的飞机引擎$x_{test}$，如果概率$p$低于阈值$ε$：</p>
<script type="math/tex; mode=display">
p(x\_{test}) \lt ε</script><p>那么就将其标记为异常。</p>
<p>因此当我们看到一个新的引擎在我们根据训练数据得到的$p(x_{test})$模型中概率非常低时，我们就将其标记为异常；反之如果$p(x_{test})$大于给定的阈值$ε$，我们就认为它是正常的。</p>
<hr>
<p>因此在上面的飞机引擎的例子中，对于给定的训练集，对于图中的中心区域的$p(x)$会很大；而稍微远离中心区域的点概率会小一些；更远的地方的点，它们的概率将更小；在外面的点将成为异常点：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">中心区域$p(x)$很大</th>
<th style="text-align:center">$p(x)$略小</th>
<th style="text-align:center">$p(x)$很小</th>
<th style="text-align:center">异常点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_23/004.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/005.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/006.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/007.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<h3 id="异常检测的应用场景"><a href="#异常检测的应用场景" class="headerlink" title="异常检测的应用场景"></a>异常检测的应用场景</h3><h4 id="欺诈检测"><a href="#欺诈检测" class="headerlink" title="欺诈检测"></a>欺诈检测</h4><p>异常检测最常见的应用就是欺诈检测了。</p>
<p>假设你有很多用户，你的每个用户都在从事不同的活动。你可以对不同的用户活动计算特征变量，然后建立一个用来表示用户行为对应的特征向量出现的概率的模型（用来表示用户表现出各种行为的可能性的模型）。</p>
<p>因此假设你看到某个用户在网站上行为的特征变量是这样的：</p>
<script type="math/tex; mode=display">
\begin{align\*}
x\_1&:是用户登录的频率 \\\\
x\_2&:是用户访问某个页面的次数 \\\\
x\_3&:是用户在论坛上发帖的次数 \\\\
x\_4&:是用户的打字速度（有些网站是可以记录的）
\end{align\*}</script><p>因此你可以根据这些数据建一个模型$p(x)$，然后你可以通过这个模型来发现你网站上的行为奇怪的用户。你只需要看哪些用户的$p(x)\ltε$即可，接下来你就可以对这些用户的档案做进一步筛选，或者要求这些用户 验证他们的身份，从而让你的网站防御异常行为或者欺诈行为。</p>
<p>这种技术将会找到行为不正常的用户，而不仅仅是有欺诈行为的用户。然而这就是许多许多在线购物网站常常用来识别异常用户的技术。</p>
<h4 id="工业领域查找异常产品"><a href="#工业领域查找异常产品" class="headerlink" title="工业领域查找异常产品"></a>工业领域查找异常产品</h4><p>异常检测的另一个例子是在工业生产领域，事实上我们上面已经谈到过飞机引擎的问题，你可以通过异常检测找到异常的飞机引擎，然后要求进一步细查这些引擎的质量。</p>
<h4 id="计算机监控"><a href="#计算机监控" class="headerlink" title="计算机监控"></a>计算机监控</h4><p>第三个应用是数据中心的计算机监控。实际上我有些朋友正在从事这类工作。</p>
<p>如果你正在管理一个计算机集群或者一个数据中心，其中有许多计算机。那么我们可以为每台计算机计算特征变量，例如计算机的内存消耗、硬盘访问量、CPU负载或者一些更加复杂的特征（例如一台计算机的CPU负载与网络流量的比值）。</p>
<p>那么给定正常情况下数据中心中计算机的特征变量，你可以建立$p(x)$模型，通过它来找到运行不正常的计算机。</p>
<p>目前这种技术正在被各大数据中心使用，用来监测大量计算机可能发生的异常。</p>
<h2 id="高斯分布-正态分布"><a href="#高斯分布-正态分布" class="headerlink" title="高斯分布(正态分布)"></a>高斯分布(正态分布)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/ZYAyC/gaussian-distribution">视频地址</a></p>
<blockquote>
<p>在本节我将介绍<strong>高斯分布</strong>（也称为<strong>正态分布</strong>）。</p>
<p>如果你已经对高斯分布非常熟悉了，那么也许你可以直接跳过这一节。但是如果你不确定或者你已经有段时间没有接触高斯分布了，那么请从头到尾看完这一节。在下一节中，我们将应用高斯分布来推导一套异常检测算法。</p>
</blockquote>
<h3 id="高斯分布的定义"><a href="#高斯分布的定义" class="headerlink" title="高斯分布的定义"></a>高斯分布的定义</h3><p>假设$x$是一个实数随机变量（即：$x \in R$），如果x的概率分布服从高斯分布：其中均值为$μ$，方差为$σ^2$，那么将它记作：</p>
<script type="math/tex; mode=display">
x \sim N(μ,σ^2)</script><blockquote>
<p>这里的$\sim$符号读作：”服从…分布”。大写字母$N$表示Normal (正态)，有两个参数，其中$μ$表示均值，$σ^2$表示方差。</p>
</blockquote>
<p>如果我们将高斯分布的概率密度函数绘制出来，它看起来将是这样一个钟形的曲线：</p>
<p><img src="/img/17_05_23/008.png" alt=""></p>
<p>这个钟形曲线有两个参数，分别是$μ$和$σ$。其中$μ$控制这个钟形曲线的中心位置，$σ$控制这个钟形曲线的宽度。</p>
<p>从图中可以看出来，$x$取中心区域的值的概率相当大，因为高斯分布的概率密度在这里很大；而$x$取远处和更远处数值的概率将逐渐降低，直至消失。</p>
<p>高斯分布的数学公式如下：</p>
<script type="math/tex; mode=display">
p(x;μ,σ^2)=
\frac{1}{\sqrt{2π}σ}exp(-\frac{(x-μ)^2}{2σ^2})</script><p>其实我们并不需要记住这个公式，当我们真的需要用到它时，我们总可以查资料找到它。</p>
<h3 id="高斯分布中，-μ-和-σ-的关系"><a href="#高斯分布中，-μ-和-σ-的关系" class="headerlink" title="高斯分布中，$μ$和$σ$的关系"></a>高斯分布中，$μ$和$σ$的关系</h3><p>我们举例来说明一下高斯分布中$μ$和$σ$这两个参数之间的关系：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$μ=0$，$σ=1$</th>
<th style="text-align:center">$μ=0$，$σ=0.5$</th>
<th style="text-align:center">$μ=0$，$σ=2$</th>
<th style="text-align:center">$μ=3$，$σ=0.5$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_23/009.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/010.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/011.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/012.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>值得提醒的是，在高斯分布的图像中，不管曲线的形状如何，曲线围城的总面积都是1。所以如果$σ$很大，就意味着数据的离散化程度越大，中间区域就会变宽，但由于总概率为1，所以高度会降低；反之如果$σ$很小，就意味着数据的离散化程度越小，中间区域就会变窄，但由于总概率为1，所以高度会升高。</p>
<h3 id="参数估计问题"><a href="#参数估计问题" class="headerlink" title="参数估计问题"></a>参数估计问题</h3><p>接下来让我们来看参数估计问题。</p>
<p>假设我们有以下数据集：</p>
<script type="math/tex; mode=display">
｛x^{(1)},x^{(2)},...,x^{(m)}｝ \ \ \ \ \ \ \  x^{(i)} \in R</script><p>其对应的数据在图像中如下：</p>
<p><img src="/img/17_05_23/013.png" alt=""></p>
<p>如果这些数据是服从正态分布的：</p>
<script type="math/tex; mode=display">
x \sim N(μ,σ^2)</script><p>但我们只有数据，并不知道参数$μ$和$σ$的具体值。那么参数估计问题，就是在寻找这些参数具体值的问题。</p>
<h4 id="高斯分布的参数估计公式"><a href="#高斯分布的参数估计公式" class="headerlink" title="高斯分布的参数估计公式"></a>高斯分布的参数估计公式</h4><p>具体来说，高斯分布中的参数估计公式如下：</p>
<script type="math/tex; mode=display">
μ=\frac{1}{m}\sum\_{i=1}^mx^{(i)}</script><script type="math/tex; mode=display">
σ^2=\frac{1}{m}\sum\_{i=1}^m(x^{(i)}-μ)^2</script><p>可以看出来，$μ$是在对所有m个样本求均值，$σ^2$实际上是对所有样本与均值做差再取平方后得到的平均大小。</p>
<blockquote>
<p>再提一下，如果你精通统计学，你可能听过<strong>极大似然估计</strong>，那么这里的估计实际就是对$μ$和$σ^2$的极大似然估计。如果你不知道，也无所谓。</p>
<p>还有一点，如果你在学习统计学时，可能会见到这个式子：$σ^2=\frac{1}{m-1}\sum_{i=1}^m(x^{(i)}-μ)^2$，但在机器学习领域，大家习惯使用$σ^2=\frac{1}{m}\sum_{i=1}^m(x^{(i)}-μ)^2$，其实在实际情况中，具体使用$\frac{1}{m}$还是$\frac{1}{m-1}$其实区别很小，只要你有一个稍大的数据集。这两个版本的公式在理论特性和数学特性上稍有不同，但在实际应用中，他们的区别甚小，几乎可以忽略不计。</p>
</blockquote>
<h2 id="异常检测的具体算法"><a href="#异常检测的具体算法" class="headerlink" title="异常检测的具体算法"></a>异常检测的具体算法</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/C8IJp/algorithm">视频地址</a></p>
<blockquote>
<p>在上节课中，我们谈到了高斯分布。在本节我将应用高斯分布开发异常检测算法。</p>
</blockquote>
<p>假如说我们有一个无标签的训练集，其中共有$m$个训练样本，并且这里的训练集里的每一个样本都是$n$维的特征，因此你的训练集应该是$m$个$n$维的特征构成的样本矩阵：</p>
<script type="math/tex; mode=display">
｛x^{(1)},...,x^{(m)}｝   \\\\ 
x \in R^n</script><p>对于我们的异常检测算法，我们要从数据中建立一个$p(x)$概率模型。由于$x$是一个向量，因此：</p>
<script type="math/tex; mode=display">
p(x)=p(x\_1)p(x\_2)p(x\_3)...p(x\_n)</script><p>我们假定特征$x_1$服从高斯正态分布:</p>
<script type="math/tex; mode=display">
x\_1 \sim N(μ\_1,σ^2\_1)</script><p>根据上节学到的知识，你可以得出对应的$μ_1$和$σ_1$:</p>
<script type="math/tex; mode=display">
μ\_1=\frac{1}{m}\sum\_{i=1}^mx^{(i)}\_1</script><script type="math/tex; mode=display">
σ^2\_1=\frac{1}{m}\sum\_{i=1}^m(x^{(i)}\_1-μ\_1)^2</script><p>这样$p(x_1)$就可以写成这样一个高斯分布:</p>
<script type="math/tex; mode=display">
p(x\_1)=p(x\_1;μ\_1,σ^2\_1)</script><p>同样地，我假设$x_2$也服从高斯分布，可以得出：</p>
<script type="math/tex; mode=display">
p(x\_2)=p(x\_2;μ\_2,σ^2\_2)</script><p>与此类似$x_3$服从另外一个高斯分布:</p>
<script type="math/tex; mode=display">
p(x\_3)=p(x\_3;μ\_3,σ^2\_3)</script><p>直到$x_n$:</p>
<script type="math/tex; mode=display">
p(x\_n)=p(x\_n;μ\_n,σ^2\_n)</script><p>因此可以得出:</p>
<script type="math/tex; mode=display">
\begin{align\*}
p(x) 
&= p(x\_1;μ\_1,σ^2\_1)p(x\_2;μ\_2,σ^2\_2)p(x\_3;μ\_3,σ^2\_3)...p(x\_n;μ\_n,σ^2\_n) \\\\
&= Π\_{j=1}^np(x\_j;μ\_j,σ^2\_j)
\end{align\*}</script><p>其中$Π$（读作pai，是$π$的大写形式）类似$∑$符号，只不过这里将连加换成了连乘。顺便要说的是，估计$p(x)$的分布问题，通常被称为<strong>密度估计</strong>问题。</p>
<blockquote>
<p>注意：对于熟悉统计学的同学来说，上面的式子实际上就对应于一个从$x_1$到$x_n$的独立的假设。但实际应用中，无论这些特征是否相互独立，这些算法的效果都还不错。</p>
</blockquote>
<h3 id="异常检测算法步骤总结"><a href="#异常检测算法步骤总结" class="headerlink" title="异常检测算法步骤总结"></a>异常检测算法步骤总结</h3><p>让我们来总结一下<strong>异常检测</strong>算法的具体步骤：</p>
<ul>
<li>1.从样本中选择一些能体现出异常行为的特征$x_i$。</li>
</ul>
<blockquote>
<p>我们可以尝试找出一些特征，比如在你的系统里，那些能看出用户异常行为或者欺诈行为的特征。</p>
</blockquote>
<ul>
<li>2.分别计算出每个特征的参数$μ_1,…,μ_n,σ^2_1,…,σ^2_n$。</li>
</ul>
<script type="math/tex; mode=display">
μ=
\begin{equation} 
\left[
\begin{matrix}
     μ\_1 \\\\
     μ\_2 \\\\
     ┋     \\\\
     μ\_n
\end{matrix}
\right]
\end{equation}
=
\frac{1}{m}\sum\_{i=1}^mx^{(i)}</script><script type="math/tex; mode=display">
σ^2=
\begin{equation} 
\left[
\begin{matrix}
     σ^2\_1 \\\\
     σ^2\_2 \\\\
     ┋     \\\\
     σ^2\_n
\end{matrix}
\right]
\end{equation}
=
\frac{1}{m}\sum\_{i=1}^m(x^{(i)}-μ)^2</script><p>其中：</p>
<script type="math/tex; mode=display">
μ\_j=\frac{1}{m}\sum\_{i=1}^mx^{(i)}\_j</script><script type="math/tex; mode=display">
σ^2\_j=\frac{1}{m}\sum\_{i=1}^m(x^{(i)}\_j-μ\_j)^2</script><blockquote>
<p>对$m$个无标签数据分别计算出他们每个特征的期望$μ$和方差$σ^2$。<strong>注意，这里$μ$和$σ$都是m维度的向量</strong>，而$μ_j$和$σ_j$都是其中对应的第$j$个元素。</p>
</blockquote>
<ul>
<li>3.给定一个新的样本$x$，计算出它对应的$p(x)$:</li>
</ul>
<script type="math/tex; mode=display">
p(x)=Π\_{j=1}^np(x\_j;μ\_j,σ^2\_j)=Π\_{j=1}^n\frac{1}{\sqrt{2π}σ\_j}exp(-\frac{(x\_j-μ\_j)^2}{2σ^2\_j})</script><p>通过判断$p(x)&lt;ε$，来判断是否有异常发生。</p>
<blockquote>
<p>给定一个用户行为的样本，如何知道用户行为是否异常呢？我们将用户行为数据带入到$p(x)$的计算中来，如果这个结果非常小，那么我们就将这个行为标注为异常行为。</p>
</blockquote>
<h3 id="异常分析例子"><a href="#异常分析例子" class="headerlink" title="异常分析例子"></a>异常分析例子</h3><p>假如说我们有下面这样的数据集：</p>
<p><img src="/img/17_05_23/014.png" alt=""></p>
<p>从图中我们可以看出，数据集有两个特征$x_1$和$x_2$。</p>
<p>其中特征$x_1$对应的是水平方向的数据，它的均值是5，标准差是2；$x_2$对应的是竖直方向上的数据，它的均值是3，标准差是1：</p>
<script type="math/tex; mode=display">
μ\_1=5,σ\_1=2</script><script type="math/tex; mode=display">
μ\_2=3,σ\_2=1</script><p>这两个特征对应的分布如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$p(x_1;μ_1,σ^2_1)$</th>
<th style="text-align:center">$p(x_2;μ_2,σ^2_2)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_23/015.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_23/016.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>如果绘制出$p(x)$的图像，那么这个图像如下：</p>
<p><img src="/img/17_05_23/017.png" alt=""></p>
<p>通过图像，我们可以得出具体的某一点对应的高度值。</p>
<p>假如$x_1=2$，$x_2=2$那么就是这个点:</p>
<p><img src="/img/17_05_23/018.png" alt=""></p>
<p>在3-D表面图上的高度就代表$p(x)$的值。而这个$p(x)$完整的写出来就是下面的形式：</p>
<script type="math/tex; mode=display">
p(x)=p(x\_1;μ\_1,σ^2\_1)p(x\_2;μ\_2,σ^2\_2)</script><p>那么有了这个表达式，我们如何鉴定新的样本是否异常呢？</p>
<p>要回答这个问题，我们可以先给计算机设某个无穷小的数值$ε$，假如我设置$ε=0.02$(我会在后面讲到如何选取$ε$的值)。</p>
<p>现在我们有两个样本，分别为$x_{test}^{(1)}$和$x_{test}^{(2)}$：</p>
<p><img src="/img/17_05_23/019.png" alt=""></p>
<p>我们用上面的式子来计算出$p(x_{test}^{(1)})$，可以发现这是一个比较大的数，具体大小是大于等于$ε$的，所以对于$x_{test}^{(1)}$的检测结果是不属于异常。同样对于$p(x_{test}^{(2)})$，我们发现这是一个很小的数，具体值是小于$ε$的，所以我们说$x_{test}^{(2)}$属于异常数据。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第九周 (2)构建一个异常检测系统</title>
    <url>/2017/05/25/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B9%9D%E5%91%A8%20(2)%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="异常检测系统的开发与评估"><a href="#异常检测系统的开发与评估" class="headerlink" title="异常检测系统的开发与评估"></a>异常检测系统的开发与评估</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Mwrni/developing-and-evaluating-an-anomaly-detection-system">视频地址</a></p>
<blockquote>
<p>在上一节中，我们推导了异常检测算法。在本节，我想介绍一下如何开发一个异常检测的应用来解决一个实际问题。</p>
</blockquote>
<p>在之前，我们已经提到了使用实数评估法的重要性。这样做的想法是，当你在用某个学习算法来开发一个具体的机器学习应用时，你常常需要做出很多决定，比如说选择用什么样的特征等等。而如果你找到某种评估算法的方式，比如直接返回一个数字，来告诉你算法的好坏，那么你做这些决定就显得更容易了。有了这样的数字，你就可以更好的确定某些特征是否需要在构建算法的时候考虑进来了，因为你可以通过对比算法在有这个特征和没这个特征的情况下，算法的具体表现，来决定是否要加入这个特征。</p>
<p>所以对于异常检测系统的评价方式很重要。</p>
<p>为了做到能评价一个异常检测系统，我们先假定已有了一些带标签的数据。</p>
<blockquote>
<p>我们要考虑的异常检测问题是一个非监督问题，使用的是无标签数据。但如果你有一些带标签的数据，能够指明哪些是异常样本，哪些是非异常样本，那么这就是我们要找的能够评价异常检测算法的标准方法。</p>
</blockquote>
<p>还是以飞机发动机的为例，现在假如你有了一些带标签数据，我们用$y=0$表示完全正常的样本，用$y=1$表示有异常的样本。</p>
<p>那么异常检测算法的推导和评价方法如下所示：</p>
<h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><ul>
<li>我们先考虑训练样本。对于训练集，我们还是需要把数据看成是无标签的，通常来讲我们把这些样本都看成<strong>正常</strong>的，但可能有一些异常的也被分到你的训练集里，这也没关系（毕竟异常的是少数）：</li>
</ul>
<script type="math/tex; mode=display">
x^{(1)},x^{(2)},...,x^{(m)}</script><ul>
<li>接下来我们要定义交叉验证集和测试集。通过这两个集合我们将得到异常检测算法。</li>
</ul>
<script type="math/tex; mode=display">
交叉验证集：(x^{(1)}\_{cv},y^{(1)}\_{cv}),...,(x^{(m)}\_{cv},y^{(m)}\_{cv})</script><script type="math/tex; mode=display">
测试集：(x^{(1)}\_{test},y^{(1)}\_{test}),...,(x^{(m)}\_{test},y^{(m)}\_{test})</script><p>继续回到我们的例子中：</p>
<p>假如说我们有10000制造的引擎作为样本。就我们所知，这些样本都是正常没有问题的飞机引擎。同样地，如果有一小部分有问题的引擎也被混入了这10000个样本，别担心，没有关系，我们假设这10000个样本中大多数都是没有问题的引擎。而且实际上从过去的经验来看，无论是制造了多少年引擎的工厂，在10000个引擎中都会得到大概20个有问题的引擎。对于异常检测的典型应用来说，异常样本的个数(也就是$y=1$的样本)，基本上很多都是20到50个，并且通常我们的正常样本的数量要大得多。</p>
<p>有了这组数据，把数据分为训练集、交叉验证集和测试集的一种典型的分法如下：</p>
<p>我们把这10000个正常的引擎放6000个到无标签的<strong>训练集</strong>中，我叫它“无标签训练集”，但其实所有这些样本都对应$y=0$的情况。</p>
<p>我们要用这6000个训练样本来拟合$p(x)$。</p>
<script type="math/tex; mode=display">
p(x)=p(x\_1;μ\_1, σ\_1^2)...p(x\_n;μ\_n, σ\_n^2)</script><p>因此我们就是要用这6000个样本来计算参数$μ_1,σ_1^2…μ_n,σ_n^2$。</p>
<p>然后我们将剩余的4000个样本一半放入<strong>交叉验证集</strong>，另一半放入<strong>测试集</strong>中。同时我们还有20个异常的发动机样本，同样也把它们进行一个分割：放10个到验证集中，剩下10个放入测试集中。</p>
<blockquote>
<p>注意：不要把交叉验证集和测试集混在一起使用，这样效果并不好。</p>
</blockquote>
<h3 id="异常检测算法的推导和评估方法"><a href="#异常检测算法的推导和评估方法" class="headerlink" title="异常检测算法的推导和评估方法"></a>异常检测算法的推导和评估方法</h3><p>有了训练集、交叉验证集和测试集，异常检测算法的推导和评估方法如下：</p>
<p>首先我们使用训练样本来拟合模型$p(x)$。</p>
<p>然后我们预设一个比较小的$ε$，对于$p(x)&lt;ε$的样本视为异常样本，然后分别在测试集合交叉验证集上进行测试和验证。我们知道在测试集合交叉验证集上是存在$y=1$的异常样本的，只不过量比较少而已。</p>
<p>这里其实我们可以把异常检测算法想象成是对交叉验证集和测试集中的$y$进行预测，这与监督学习有些类似，因为我们在对有标签的数据进行预测。所以我们可以通过对标签预测正确的次数来评价算法的好坏。</p>
<p>当然这些标签会比较偏斜，因为$y=0$(也就是正常的样本)肯定是比出现$y=1$(也就是异常样本)的情况更多。这跟我们在监督学习中用到的评价度量方法非常接近。</p>
<p>那么用什么评价度量好呢？</p>
<p>因为数据是非常偏斜的，所以通过分类准确度来衡量算法并不是一个好的度量法。我们<strong><a href="http://t.cn/RSh83NE">之前的课程</a></strong>中也有提到过，如果你有一个比较偏斜的数据集，那么总是预测$y=0$它的分类准确度自然会很高。</p>
<p>因此我们应该算出以下数据来更科学的衡量算法的好坏：</p>
<ul>
<li>我们应该算出<strong>真阳性</strong>、<strong>假阳性</strong>、<strong>假阴性</strong>和<strong>真阴性</strong>的比率来作为评价度量值</li>
<li>我们也可以算出<strong>查准率</strong>和<strong>召回率</strong></li>
<li>计算出$F_1-score$，通过一个很简单的数字来总结出查准和召回的大小。</li>
</ul>
<p>通过这些方法，你就可以评价你的异常检测算法在交叉验证和测试集样本中的表现。</p>
<h4 id="ε是怎么得到的呢？"><a href="#ε是怎么得到的呢？" class="headerlink" title="ε是怎么得到的呢？"></a>ε是怎么得到的呢？</h4><p>现在还有一个问题没有说明，那就是参数$p(x)&lt;ε$中的$ε$是如何求得的？</p>
<p>如果你有一组交叉验证集样本，一种选择参数$ε$的方法就是通过尝试多个不同的$ε$，然后选出一个使得$F_1-score$最大的$ε$，这个$ε$就是在交叉验证集上表现最好的。</p>
<p>更一般来说,我们使用训练集、测试集和交叉验证集的方法是当我们需要作出决定时，比如要包括哪些特征或者说要确定参数$ε$取多大合适，我们就可以不断地用交叉验证集来评价这个算法，然后决定我们应该用哪些特征，以及选择哪一个$ε$。</p>
<p>所以就是在交叉验证集中评价算法，然后选出一组特征，或者找到能符合我们要求的ε的值后，我们就能用测试集来最终评价算法的表现了。</p>
<h2 id="异常检测-VS-监督学习"><a href="#异常检测-VS-监督学习" class="headerlink" title="异常检测 VS 监督学习"></a>异常检测 VS 监督学习</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Rkc5x/anomaly-detection-vs-supervised-learning">视频地址</a></p>
<blockquote>
<p>在上一节，我们谈到如何评价一个异常检测算法。我们先是用了一些带标签的数据，以及一些我们知道是异常或者正常的样本(用$y=1$或$y=0$来表示)。</p>
<p>这就引出了这样一个问题：既然我们有了带标签的数据，那么为什么我们不直接用监督学习的方法（比如逻辑回归或者神经网络）呢？</p>
<p>这一节，就来介绍一下什么时候应该用异常检测算法，什么时候用监督学习算法是更有成效的。</p>
</blockquote>
<p>下面这张表格对比了什么时候应该用什么算法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">异常检测</th>
<th style="text-align:center">监督学习</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">负样本量很少(通常是在0到20个之间),正样本很多的时候</td>
<td style="text-align:center">正负样本都很多的时候</td>
</tr>
<tr>
<td style="text-align:center">有多种不同的异常类型时（因为对任何算法来说，从大量正样本中去学习到异常具体是什么，都是困难的）；未知的异常与我们已知的异常完全不一样时。</td>
<td style="text-align:center">有足够多的正样本来让你的算法学习到对应的特征，并且在未知的正样本中，也和已知的样本是类似的。</td>
</tr>
</tbody>
</table>
</div>
<p>这就是在遇到具体情况时，要选择异常检查还是监督学习的方式。</p>
<p>其实关键区别就是<strong>在异常检测算法中我们只有一小撮正样本</strong>，因此监督学习算法不能从这些样本中学到太多东西。</p>
<hr>
<p>关于上面表格中，有关<strong>异常检测</strong>中的不同类型的异常情况，我们用之前的垃圾邮件的例子来说明。</p>
<p>在那个例子中，垃圾邮件的类型其实也有很多种。有的是想卖东西给你、有的是想钓出你的密码(这种就叫钓鱼邮件)、还有其他一些类型的垃圾邮件…但对于垃圾邮件的问题，我们能得到绝大多数不同类型的垃圾邮件，因为我们有大量的垃圾邮件样本的集合。因此这也是为什么我们通常把垃圾邮件问题看作是监督学习问题的原因，虽然垃圾邮件的种类通常有太多太多 。</p>
<p>因此，我们可以看看一些异常检测的应用和监督学习应用的比较，我们不难发现对于欺诈检测(fraud detection)，如果你掌握了许多种不同类型的诈骗方法，并且只有相对较小的训练集（只有很少一部分用户有异常行为）那我会使用异常检测算法。当然，有时候欺诈检测的方法也可能会偏向于使用监督学习算法，但是如果你并没有看到许多在你网站上进行异常行为的用户样本，那么欺诈检测通常还是被当做是一个异常检测算法，而不是一个监督学习算法。</p>
<h2 id="选择使用什么特征"><a href="#选择使用什么特征" class="headerlink" title="选择使用什么特征"></a>选择使用什么特征</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/LSpXm/choosing-what-features-to-use">视频地址</a></p>
<blockquote>
<p>前面我们讲到了异常检测算法，并且我们也讨论了如何评估一个异常检测算法。</p>
<p>事实上当你应用异常检测时，对它的效率影响最大的因素之一，是你使用什么特征变量。那么在本节，我将给出一些关于如何设计或选择异常检测算法的特征变量建议。</p>
</blockquote>
<h3 id="对不服从高斯分布的数据进行转换"><a href="#对不服从高斯分布的数据进行转换" class="headerlink" title="对不服从高斯分布的数据进行转换"></a>对不服从高斯分布的数据进行转换</h3><p>在我们的异常检测算法中，我们做的事情之一就是使用正态(高斯)分布来对特征向量建模。通常情况下，我们都需要用直方图来可视化这些数据，如下图：</p>
<p><img src="/img/17_05_25/001.png" alt=""></p>
<p>这么做的原因是为了在使用算法之前，确保我们的数据看起来是服从高斯分布的（当然即使你的数据并不是高斯分布，它也基本上可以良好地运行，但最好转换成高斯分布的样式之后在带入计算）。</p>
<p>如果你的样本的某个特征展示效果完全不像一个正态分布的形状：</p>
<p><img src="/img/17_05_25/002.png" alt=""></p>
<p>那么我们就需要对数据进行一些转换，来确保这些数据能看起来更像高斯分布。这样你的算法才能效果更好。</p>
<p>一般情况下，我们都会对原始数据尝试求对数或者开根号操作进行转换，下图是通过对数来转换的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x$</th>
<th style="text-align:center">$log(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_25/002.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_25/003.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>你也可以尝试使用以下的方式来带入：</p>
<script type="math/tex; mode=display">
x←log(x)  \\\\
x←log(x + c) \\\\
x←\sqrt x</script><p>选择哪一个都可以，唯一的原则就是保证转换后的分布看起来更像高斯分布(正态分布)一些。</p>
<hr>
<p>下面是对于一个不服从高斯分布的数据进行转换的过程：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原始数据</th>
<th style="text-align:center">$x^{0.5}$</th>
<th style="text-align:center">$x^{0.2}$</th>
<th style="text-align:center">$x^{0.1}$</th>
<th style="text-align:center">$x^{0.05}$</th>
<th style="text-align:center">$log(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_25/004.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_25/005.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_25/006.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_25/007.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_25/008.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_25/009.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>我们对原始数据尝试了不同的转换之后，图像最终趋于了正太分布的样式。在Octive中实现的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hist(x,50)</span><br><span class="line">hist(x.^0.5,50)</span><br><span class="line">hist(x.^0.2,50)</span><br><span class="line">hist(x.^0.1,50)</span><br><span class="line">hist(x.^0.05,50)</span><br><span class="line">hist(log(x),50)</span><br><span class="line">xNew &#x3D; log(x);</span><br></pre></td></tr></table></figure>
<p>最终我们选择了$log(x)$来代替原来的$x$。</p>
<h3 id="异常检测算法的特征变量的获取"><a href="#异常检测算法的特征变量的获取" class="headerlink" title="异常检测算法的特征变量的获取"></a>异常检测算法的特征变量的获取</h3><p>对于异常检测算法的特征变量的获取的方法，其实和之前学习的误差分析步骤是类似的。</p>
<ul>
<li>首先我们先训练处一个异常检测学习算法。</li>
<li>然后在一组交叉验证集上运行算法。</li>
<li>然后找出那些异常样本。</li>
<li>然后我们尝试其他的特征变量，看是否能让我们的算法变得更好。</li>
</ul>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>我们用一个具体的例子来说明上面的过程：</p>
<p>在异常检测中，我们希望$p(x)$的值对正常样本来说是比较大的，而对异常样本来说，值是很小的。但一个很常见的问题是$p(x)$是具有可比性的（即对于两者都很大）。</p>
<p>这是我的一组无标签数据：</p>
<p><img src="/img/17_05_25/010.png" alt=""></p>
<p>这里我只有一个特征变量$x_1$，我要用高斯分布来拟合它。</p>
<p>假设我们绘制出它的高斯分布，如下图所示：</p>
<p><img src="/img/17_05_25/011.png" alt=""></p>
<p>假设我们遇到了一个有异常的样本：</p>
<p><img src="/img/17_05_25/012.png" alt=""></p>
<p>但是，从图中我们能看出这个样本在这一特征下的$p(x_1)$并不低，我们无法从这一特征下区分出这一异常样本。</p>
<p>如果我们引入另一个特征$x_2$，图像如下：</p>
<p><img src="/img/17_05_25/013.png" alt=""></p>
<p>再来看看我们的异常样本，出现在了这两个特征所分布的区域的外侧：</p>
<p><img src="/img/17_05_25/014.png" alt=""></p>
<p>这个时候，我们的异常检测算法就会给出很小的值来验证这一点代表的样本属于异常样本。</p>
<blockquote>
<p><strong>总结</strong>:选择异常检测需要考虑的特征时，先找出异常样本，然后尝试通过引入新的特征来验证对异常样本的识别的准确性。如果有所提高，就可以考虑引入这个特征。</p>
</blockquote>
<h4 id="关于特征选择的思考"><a href="#关于特征选择的思考" class="headerlink" title="关于特征选择的思考"></a>关于特征选择的思考</h4><p>最后我想与你分享一些我平时在为异常检查算法选择特征变量时的一些思考。</p>
<p>通常，我会选择那些既不是特别大也不是特别小的特征变量。以数据中心异常计算机的监测的例子为例，我们有以下四个特征：</p>
<script type="math/tex; mode=display">
x\_1=机器内存使用  \\\\
x\_2=硬盘资源使用  \\\\
x\_3=CPU使用  \\\\
x\_4=网络情况</script><p>我假设CPU使用情况和网络情况呈线性关系，正常情况下如果其中一个服务器正在运行时，CPU负载和流量都很大。</p>
<p>现在，假设有一种异常情况，就是流量消耗很小，但CPU负载却很高，因为可能是机器遇到了某个死循环导致CPU负载飙升，因此我们可以定义一个新的特征变量来更好的说明这一情况：</p>
<script type="math/tex; mode=display">
x\_5=\frac{CPU 负载}{流量消耗}</script><p>同样，你也可以尝试使用下面这种特征变量：</p>
<script type="math/tex; mode=display">
x\_6=\frac{(CPU 负载)^2}{流量消耗}</script><p>其实，解决这类问题的思路就是尝试组合新的特征，从而能更好的检测异常情况。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第九周 (3)多元高斯分布（选学）</title>
    <url>/2017/05/26/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B9%9D%E5%91%A8%20(3)%E5%A4%9A%E5%85%83%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%EF%BC%88%E9%80%89%E5%AD%A6%EF%BC%89/</url>
    <content><![CDATA[<h2 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Cf8DF/multivariate-gaussian-distribution">视频地址</a></p>
<blockquote>
<p>接下来我将介绍<strong>多元高斯分布 (multivariate Gaussian distribution)</strong>。它是我们目前所学的异常检测算法的延伸，它有一些优势也有一些劣势，它能捕捉到一些之前的算法检测不出来的异常。</p>
</blockquote>
<h3 id="异常检测算法无法解决的问题"><a href="#异常检测算法无法解决的问题" class="headerlink" title="异常检测算法无法解决的问题"></a>异常检测算法无法解决的问题</h3><p>还是现以一个例子来解释：</p>
<p>假设在数据中心监控机器的例子中，我们有如下的内存和CPU使用数据：</p>
<p><img src="/img/17_05_26/001.png" alt=""></p>
<p>其中对于这两个维度的数据，都服从正态分布：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_1$</th>
<th style="text-align:center">$x_2$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/002.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/003.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>如果现在在我们的测试集中，有一个异常数据点出现在下图的位置中：</p>
<p><img src="/img/17_05_26/004.png" alt=""></p>
<p>那么在这种情况下我们会发现，这一点对应的两个维度下的概率其实都不低，从$p(x)$的结果上，我们无法准确预测这个样本是否属于异常。</p>
<p>产生这个问题的实际原因其实是这样的，从$x_1$和$x_2$这两个维度来看，我们的正常数据及时大多数集中分布在这样一个范围内：</p>
<p><img src="/img/17_05_26/005.png" alt=""></p>
<p>但我们使用之前的异常检测算法，其实是以中心区域向外以正圆的形式扩散的。也就是说距离中心区域距离相等的点，对应的$p(x)$都是一样的，所以我们可能无法检测到这一个异常样本，因为它也处在一个$p(x)$比较大的范围内：</p>
<p><img src="/img/17_05_26/006.png" alt=""></p>
<p>所以，为了解决异常检测算法的这一问题，接下来我解释改良版的异常检测算法，要用到叫做<strong>多元高斯分布（多元正态分布）</strong>的东西。</p>
<h3 id="通过多元高斯分布改良异常检测算法"><a href="#通过多元高斯分布改良异常检测算法" class="headerlink" title="通过多元高斯分布改良异常检测算法"></a>通过多元高斯分布改良异常检测算法</h3><p>在多元高斯分布中，对于n维特征$x \in R^n$，不要把模型$p(x_1)$,$p(x_2)$,…,$p(x_n)$分开，而要建立$p(x)$整体的模型。</p>
<p>多元高斯分布的参数包括向量$µ$和一个$n×n$的矩阵$Σ$。</p>
<script type="math/tex; mode=display">
µ \in R^n  \\\\
Σ \in R^{n×n}</script><p>$Σ$被称为<strong>协方差矩阵</strong>，它类似于我们之前学习PCA的时候所见到的协方差矩阵。</p>
<p>带入之后计算$p(x)$：</p>
<script type="math/tex; mode=display">
p(x;µ,Σ)=
\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}
exp(-\frac{1}{2}(x-µ)^TΣ^{-1}(x-µ))</script><blockquote>
<p>这个公式不用背，用的时候再去查。</p>
</blockquote>
<p>注意，公式中的$|Σ|$这一项，代表矩阵$Σ$的<strong>行列式</strong>。在Octave中可以用下面的代码来计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">det(Sigma)</span><br></pre></td></tr></table></figure>
<p>其实这个公式是什么样并不重要，更重要的是$p(x)$到底是什么样。</p>
<h3 id="多元高斯分布的样子"><a href="#多元高斯分布的样子" class="headerlink" title="多元高斯分布的样子"></a>多元高斯分布的样子</h3><p>我们来对比一下不同的$µ$和不同的$Σ$组合后，对应的$p(x)$的形状。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}0.6&amp;0\\0&amp;0.6\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}2&amp;0\\0&amp;2\end{matrix}\right]\end{equation}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/007.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/009.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/011.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/008.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/010.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/012.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>表格从上到下依次是三种情况对应的参数、三维图像以及俯视图。</p>
<p>$µ$作为均值，象征着中心区域对应的坐标点。$Σ$是协方差矩阵，它衡量的是特征$x_1$和$x_2$的方差。</p>
<p>从图中可以看出来，当缩小协方差$Σ$时，中心区域的凸起就会变得更细长；当扩大协方差$Σ$时，中心区域的凸起就会变得更扁平。因为概率分布的积分必须等于1，所以如果你缩小方差，就会变得细长，反之就会变得扁平。</p>
<p>接下来我们尝试对协方差中使用不同的数值，来观测$p(x)$形状的变化：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}0.6&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}2&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/007.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/013.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/015.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/008.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/014.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/016.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>在协方差$Σ$中，左上角元素对应的是$x_1$特征，右下角元素对应的是$x_2$特征。</p>
<p>在第二组图中，我们可以看到，当我们缩小$x_1$到原先的0.6倍而$x_2$保持原先的大小时，由于相当于是对特征$x_1$的方差进行了缩小，所以图像在$x_1$的方向上，会显得更细长。</p>
<p>在第三组图中，我们可以看到，当我们放大$x_1$到原先的2倍而$x_2$保持原先的大小时，由于相当于是对特征$x_1$的方差进行了放大，所以图像在$x_1$的方向上，会显得更扁平。</p>
<p>对于多元高斯分布来说，一个很棒的事情就是我们可以用它来<strong>对数据的相关性建模</strong>。也就是说，我们可以用它来给$x_1$和$x_2$高度相关的情况建立模型。具体来说，我们可以通过改变协方差$Σ$非对角线上的元素来得到不同的高斯分布：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0.5\\0.5&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0.8\\0.8&amp;1\end{matrix}\right]\end{equation}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/007.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/017.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/019.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/008.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/018.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/020.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>可以看出来，当我改变了非对角线上元素的值时，$p(x)$的图像也变得倾斜了；当我增大了这些元素时，这个倾斜的分布图像变得更细长了。</p>
<p>上面是我们把这些非对角线上元素设置为正数时的样子，那么如果我们把它们设置为负数时，会是什么样呢？</p>
<p>它们的倾斜方向会发生改变：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;-0.5\\-0.5&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;-0.8\\-0.8&amp;1\end{matrix}\right]\end{equation}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/007.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/021.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/023.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/008.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/022.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/024.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>如果我们改变$µ$，会对图像$p(x)$产生什么影响呢？</p>
<p>它们会发生平移：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}0\\0.5\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
<th style="text-align:center">$\begin{equation}µ=\left[\begin{matrix}1.5\\-0.5\end{matrix}\right]Σ=\left[\begin{matrix}1&amp;0\\0&amp;1\end{matrix}\right]\end{equation}$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/007.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/025.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/027.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="/img/17_05_26/008.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/026.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_05_26/028.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>$µ$有两个元素，第一个元素对应的是图像在$x_1$方向上的位移，第二个元素对应的是图像在$x_2$方向上的位移。当为正数时，是沿着增大的方向平移，反之是沿着缩小的方向平移。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不同的图片，能够帮助你了解<strong>多元高斯分布</strong>所能描述的概率分布是什么样。它最重要的优势就是能够描述当两个特征变量之间可能存在正相关或者是负相关关系的情况。</p>
<h2 id="通过多元高斯分布来处理异常检测问题"><a href="#通过多元高斯分布来处理异常检测问题" class="headerlink" title="通过多元高斯分布来处理异常检测问题"></a>通过多元高斯分布来处理异常检测问题</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/DnNr9/anomaly-detection-using-the-multivariate-gaussian-distribution">视频地址</a></p>
<blockquote>
<p>在上一节中，我们谈到了多元高斯分布，而且也看到了一些例子通过改变参数$µ$和$Σ$来给不同的概率分布建模。</p>
<p>在这节中，我们使用它们来开发另一种异常检测算法。</p>
</blockquote>
<h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p>再回顾一下<strong>多元高斯分布（或者叫多元正态分布）</strong>：</p>
<p>有两个参数：$µ$和$Σ$。</p>
<p>$µ$是一个n维向量，协方差矩阵$Σ$是一个$n×n$的矩阵。</p>
<p>其对应的概率分布公式如下：</p>
<script type="math/tex; mode=display">
p(x;µ,Σ)=
\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}
exp(-\frac{1}{2}(x-µ)^TΣ^{-1}(x-µ))</script><p>随着你改变$µ$和$Σ$，你可以得到一系列不同的概率分布：</p>
<p><img src="/img/17_05_26/029.png" alt=""></p>
<h4 id="参数拟合"><a href="#参数拟合" class="headerlink" title="参数拟合"></a>参数拟合</h4><p>接下来让我们谈一下<strong>参数拟合问题（参数估计问题）</strong>。</p>
<p>如果我有一组符合高斯分布的样本：</p>
<script type="math/tex; mode=display">
｛x^{(1)},x^{(2)},...,x^{(m)}｝</script><p>我们可以通过公式来得到参数$µ$和$Σ$：</p>
<script type="math/tex; mode=display">
µ=\frac{1}{m}\sum^m\_{i=1}x^{(i)}</script><script type="math/tex; mode=display">
Σ=\frac{1}{m}\sum^m\_{i=1}(x^{(i)}-µ)(x^{(i)}-µ)^T</script><h4 id="具体应用步骤"><a href="#具体应用步骤" class="headerlink" title="具体应用步骤"></a>具体应用步骤</h4><p>有了这两个参数值，我们就可以把他们应用到具体的异常检测算法中了。具体步骤是这样的：</p>
<p>假设我们有如下的训练样本：</p>
<p><img src="/img/17_05_26/030.png" alt=""></p>
<ul>
<li>首先，用我们的训练集来拟合模型$p(x)$，得到参数$µ$和$Σ$：</li>
</ul>
<script type="math/tex; mode=display">
µ=\frac{1}{m}\sum^m\_{i=1}x^{(i)}</script><script type="math/tex; mode=display">
Σ=\frac{1}{m}\sum^m\_{i=1}(x^{(i)}-µ)(x^{(i)}-µ)^T</script><ul>
<li>然后，当你得到一个新的测试样本时，我们用下面的公式来计算其$p(x)$：</li>
</ul>
<script type="math/tex; mode=display">
p(x;µ,Σ)=
\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}
exp(-\frac{1}{2}(x-µ)^TΣ^{-1}(x-µ))</script><ul>
<li>最后，如果$p(x)&lt;ε$时，就把它标记为是一个异常样本，反之，如果$p(x)&gt;=ε$则不标记为异常样本。</li>
</ul>
<p>所以，如果使用多元高斯分布来解决异常检测问题，你可能会得到这样一个高斯分布的概率模型：</p>
<p><img src="/img/17_05_26/031.png" alt=""></p>
<p>所以，他可以正常的识别出之前用普通的异常检测算法无法正确检测的那个异常样本。</p>
<h3 id="多元高斯模型和原始模型的关系"><a href="#多元高斯模型和原始模型的关系" class="headerlink" title="多元高斯模型和原始模型的关系"></a>多元高斯模型和原始模型的关系</h3><p>最后说一下<strong>多元高斯分布模型</strong>和原来的模型它们之间的关系。</p>
<p>原先的模型是这样的：</p>
<script type="math/tex; mode=display">
p(x)=p(x\_1;µ\_1,σ\_1^2)×p(x\_2;µ\_2,σ\_2^2)×...×p(x\_n;µ\_n,σ\_n^2)</script><p>事实上，你可以证明我们原先的这种模型，是多元高斯模型的一种。它其实是一种等高线都沿着坐标轴方向的多元高斯分布，但这里我不给出证明过程：</p>
<p><img src="/img/17_05_26/032.png" alt=""></p>
<p>所以这三个图像，全都是你可以用原来的模型来拟合的高斯分布的例子。</p>
<p>其实这个模型对应于一种多元高斯分布的特例，具体来说这个特例被定义为约束$p(x)$的分布(也就是多元高斯分布$p(x)$)，使得它的概率密度函数的等高线是沿着轴向的。也就是要求<strong>协方差矩阵$Σ$的非对角线元素都为0</strong>。</p>
<p>所以你可以得到多元高斯分布$p(x)$看起来是上图中这三种样式的。你会发现，在这3个例子中，它们的轴都是沿着$x_1$，$x_2$的轴的。</p>
<p>因此，在<strong>协方差矩阵$Σ$的非对角线元素都为0</strong>的情况下，这两者是相同的：</p>
<script type="math/tex; mode=display">
p(x)=p(x\_1;µ\_1,σ\_1^2)×p(x\_2;µ\_2,σ\_2^2)×...×p(x\_n;µ\_n,σ\_n^2)</script><script type="math/tex; mode=display">
p(x;µ,Σ)=
\frac{1}{(2π)^{\frac{n}{2}}|Σ|^{\frac{1}{2}}}
exp(-\frac{1}{2}(x-µ)^TΣ^{-1}(x-µ))</script><h3 id="何时使用多元高斯模型？何时使用原始模型？"><a href="#何时使用多元高斯模型？何时使用原始模型？" class="headerlink" title="何时使用多元高斯模型？何时使用原始模型？"></a>何时使用多元高斯模型？何时使用原始模型？</h3><p>既然我们知道了原始的模型是多元高斯模型的一个特例，那么应该在什么时候用哪个模型呢？</p>
<p>事实情况是，原始模型比较常用，而多元高斯模型比较少用。</p>
<p>假设在你的样本中，$x_1$和$x_2$是线性相关的特征组合，下面是这两种算法在处理不正常的特征组合时的具体方式对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原始模型</th>
<th style="text-align:center">多元高斯模型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">捕捉到这两个特征，建立一个新的特征$x_3$(比如$x_3=\frac{x_1}{x_2}$)，去尝试手工组合并改变这个新的特征变量，从而使得算法能很好的工作。</td>
<td style="text-align:center">自动捕捉不同特征变量之间的相关性。</td>
</tr>
<tr>
<td style="text-align:center">运算量小(更适用于特征变量个数$n$很大的情况)</td>
<td style="text-align:center">计算更复杂（Σ是$n×n$的矩阵，这里会涉及两个$n×n$的矩阵相乘的逻辑，计算量很大）</td>
</tr>
<tr>
<td style="text-align:center">即使训练样本数$m$很小的情况下，也能工作的很好</td>
<td style="text-align:center">必须满足$m&gt;n$，或者$Σ$不可逆（奇异矩阵）。这种情况下，还可以帮助你省去为了捕捉特征值组合而手动建立额外特征变量所花费的时间。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="一种异常情况的应对"><a href="#一种异常情况的应对" class="headerlink" title="一种异常情况的应对"></a>一种异常情况的应对</h4><p>当你在拟合多元高斯模型时，如果你发现协方差矩阵$Σ$是<strong>奇异的（不可逆的）</strong>，一般只有两种情况：</p>
<ul>
<li>第一种是它没有满足$m&gt;n$的条件</li>
<li>第二种情况是，你有冗余特征变量 <ul>
<li>冗余特征变量的意思是出现了以下两种情况的任意一种：<ul>
<li>出现了两个完全一样的特征变量（你可能不小心把同一个特征变量复制了两份）</li>
<li>如果你有$x_3=x_4+x_5$，这里$x_3$其实并没有包含额外的信息，相对于$x_4$和$x_5$来说，它就是冗余特征变量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这是你调试算法时的一个小知识，可能很少会遇到，但是一旦你发现$Σ$不可逆，那么首先需要从这两个方面来考虑解决方案。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第九周 (4)预测电影评分</title>
    <url>/2017/05/28/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%B9%9D%E5%91%A8%20(4)%E9%A2%84%E6%B5%8B%E7%94%B5%E5%BD%B1%E8%AF%84%E5%88%86/</url>
    <content><![CDATA[<h1 id="预测电影评分"><a href="#预测电影评分" class="headerlink" title="预测电影评分"></a>预测电影评分</h1><p>Simple inline $a = b + c$.</p>
<h2 id="问题制定"><a href="#问题制定" class="headerlink" title="问题制定"></a>问题制定</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Rhg6r/problem-formulation">视频地址</a></p>
<p>在接下来的内容中，我想介绍给你们有关<strong>推荐系统(recommender systems)</strong>的内容。</p>
<p>我想讨论推荐系统有两个原因：</p>
<ul>
<li><p><strong>原因一：对工业界有至关重要的作用</strong></p>
<p>  在过去的几年中，我有时会去参观硅谷的各种科技类公司。我经常在那些公司里与开发机器学习应用的人交流。然后我问他们什么才是机器学习最重要的应用？或者什么样的机器学习的应用是你最想让它的表现得到改进的？我最常听到的回答其中之一就是 现在硅谷有好多个团队正试图建立更好的推荐系统。</p>
<p>  亚马逊、Netflix、eBay又或者苹果公司的iTunes Genius等，很多网站或者很多系统，试图向用户推荐新产品。比如说亚马逊向你推荐新书，Netflix 向你推荐新电影…。而这些推荐系统可能会看看你以前购买过什么书，或者以前你给哪些电影进行过评分。</p>
<p>  这些系统贡献了现今亚马逊收入的相当大一部分。而对像Netflix这样的公司，他们向用户推荐的电影占了用户观看的电影的相当大一部分。于是一个推荐系统其表现的一些改进，就能带来显著且即刻产生的影响。这种影响关系到许多公司的最终业绩。</p>
<p>  推荐系统在机器学习学术界是个很有意思的问题。如果我们去参加一个学术类的机器学习会议，<br>推荐系统的问题几乎得不到什么关注至少它是学术界当前动向里较小的一部分。但如果你看看正在发生的事对很多科技类公司而言，建立这些推荐系统似乎是优先要办的事。这就是我想在这门课中谈论推荐系统的原因之一。</p>
</li>
<li><p><strong>原因二：自动学习到优良特征</strong></p>
<p>  对于机器学习来说，特征量是重要的。你选择的特征对你学习算法的表现有很大影响。</p>
<p>  在机器学习领域有这么一个宏大的想法，就是对于一些问题而言（可能不是所有问题），存在一些算法能<strong>试图自动地替你学习到一组优良的特征量</strong>。这样与其手动设计或者手动编写特征，你或许能够采用一种算法来自动学习到使用什么特征量。而推荐系统就是这种情形的一个例子。</p>
</li>
</ul>
<h3 id="推荐系统-问题表述"><a href="#推荐系统-问题表述" class="headerlink" title="推荐系统 问题表述"></a>推荐系统 问题表述</h3><p>以预测电影评分这个时兴的问题为例，假想你是一个销售或出租电影的网站，你让用户使用1至5颗星 给不同的电影评分：</p>
<p><img src="/img/17_05_28/001.png" alt=""></p>
<p>假设下面的表格是几个用户针对五部电影给出的评分。其中”?”代表用户没有给出评分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电影</th>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《爱到最后》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《浪漫永远》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《小爱犬》</td>
<td style="text-align:center">?</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">《无尽狂飙》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">《剑与空手道》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
</tr>
</tbody>
</table>
</div>
<p>引入以下几个变量：</p>
<script type="math/tex; mode=display">
n\_u=用户数量 \\\\
n\_m=电影数量 \\\\
r(i,j)=如果用户j对电影i投过票，则记为1 \\\\
y^{(i,j)}=用户j对电影i投票的分值（只有在r(i,j)=1时，才有这个值）</script><p>推荐系统问题就是：</p>
<p>在给定上面的这些数据（即$r(i,j)$和$y^{(i,j)}$）时，然后视图去预测上面表格中那些”?”的值。这样我们就可以向用户推荐他们可能还没看过的新电影了。</p>
<h2 id="基于内容的推荐"><a href="#基于内容的推荐" class="headerlink" title="基于内容的推荐"></a>基于内容的推荐</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/uG59z/content-based-recommendations">视频地址</a></p>
<blockquote>
<p>上一节，我们引出了<strong>推荐系统</strong>的问题，这一节，我将介绍一种<strong>基于内容的推荐</strong>方法。</p>
</blockquote>
<p>这是上一节中的数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电影</th>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
<th style="text-align:center">$x_1$(爱情片)</th>
<th style="text-align:center">$x_2$(动作片)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《爱到最后》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.9</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《浪漫永远》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">0.01</td>
</tr>
<tr>
<td style="text-align:center">《小爱犬》</td>
<td style="text-align:center">?</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0.99</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《无尽狂飙》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">1.0</td>
</tr>
<tr>
<td style="text-align:center">《剑与空手道》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.9</td>
</tr>
</tbody>
</table>
</div>
<p>重申一下之前的定义：</p>
<script type="math/tex; mode=display">
n\_u=用户数量 \\\\
n\_m=电影数量 \\\\
r(i,j)=如果用户j对电影i投过票，则记为1 \\\\
y^{(i,j)}=用户j对电影i投票的分值（只有在r(i,j)=1时，才有这个值）</script><p>在这里的数据中：</p>
<script type="math/tex; mode=display">
n\_u=4 \\\\
n\_m=5</script><p>并且我们又追加了两列特征$x_1$和$x_2$，分别表示当前电影属于<strong>爱情片</strong>和<strong>动作片</strong>的程度。我们用$n=2$来代表特征数（这里不包括$x_0$）。</p>
<p>有了每部电影的类型特征数据，我们就可以用一个特征矩阵表示某一部电影了。假设上面五部电影，从上到下我们依次使用数字$1、2、3、4、5$来代替。那么对于第一部电影《爱到最后》的特征向量表示为：</p>
<script type="math/tex; mode=display">
\begin{equation}
x^{(1)}=\left[
\begin{matrix}
1\\\\
0.9\\\\
0
\end{matrix}
\right]
\end{equation}</script><blockquote>
<p>这三个数分别代表三个特征的值:$x_0$、$x_1$和$x_2$。其中$x_0$是截距特征变量，值为1。</p>
</blockquote>
<h3 id="使用一个已经训练好的模型进行预测"><a href="#使用一个已经训练好的模型进行预测" class="headerlink" title="使用一个已经训练好的模型进行预测"></a>使用一个已经训练好的模型进行预测</h3><p>为了进行预测，我们可以把对每个观众打分的预测当成一个独立的线性回归问题。</p>
<p>具体来说，比如每一个用户$j$，都学习出一个参数$\theta^{(j)}$（一般情况下，$\theta^{(j)}$的维度都是$n+1$，$n$是特征数，不包括截距项$x_0$）。</p>
<p>然后我们要根据参数向量$\theta^{(j)}$与特征$x^{(i)}$的内积来预测用户对电影$i$的评分：</p>
<script type="math/tex; mode=display">
(\theta^{(j)})^Tx^{(i)}</script><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们以用户1 Alice为例，Alice对应的特征向量应该是$\theta^{(1)}$，我们要预测Alice对于电影《小爱犬》的评分，这部电影的特征向量为：</p>
<script type="math/tex; mode=display">
\begin{equation}
x^{(3)}=\left[
\begin{matrix}
1\\\\
0.99\\\\
0
\end{matrix}
\right]
\end{equation}</script><p>假如你已经得到了Alice的特征参数向量$\theta^{(1)}$的值（后面我们会具体讲如何得到这个值）：</p>
<script type="math/tex; mode=display">
\begin{equation}
\theta^{(1)}=\left[
\begin{matrix}
0\\\\
5\\\\
0
\end{matrix}
\right]
\end{equation}</script><p>那么对于Alice关于《小爱犬》的平分预测如下：</p>
<script type="math/tex; mode=display">
(\theta^{(1)})^Tx^{(3)}=5×0.99=4.95</script><p>这里我们实际在做的事情就是：<strong>对每个用户应用不同的线性回归模型</strong>。</p>
<h3 id="更正式的描述"><a href="#更正式的描述" class="headerlink" title="更正式的描述"></a>更正式的描述</h3><p>关于这个计算过程，更正式的描述如下：</p>
<p>已知：</p>
<script type="math/tex; mode=display">
r(i,j)=如果用户j对电影i投过票，则记为1 \\\\
y^{(i,j)}=用户j对电影i投票的分值（只有在r(i,j)=1时，才有这个值）\\\\
\theta^{(j)} = 用户j的参数向量 \\\\
x^{(i)} = 电影i的特征向量</script><p>对于用户$j$关于电影$i$的预测评分为：</p>
<script type="math/tex; mode=display">
(\theta^{(j)})^Tx^{(i)}</script><h3 id="训练预测模型：计算参数向量-theta"><a href="#训练预测模型：计算参数向量-theta" class="headerlink" title="训练预测模型：计算参数向量$\theta$"></a>训练预测模型：计算参数向量$\theta$</h3><p>通过以下运算，可以学习到参数$\theta^{(j)}$：</p>
<p><img src="/img/17_05_28/002.gif" alt=""></p>
<blockquote>
<p><strong>公式解读：</strong></p>
<p>其中$\sum_{i:r(i,j)=1}$代表对所有满足$r(i,j)=1$的元素进行求和。</p>
<p>$(\theta^{(j)})^T(x^{(i)})-y^{(i,j)}$代表预测用户$j$对电影$i$的平分减去用户对这部电影的实际评分。</p>
<p>$\frac{\lambda}{2m^{(j)}}\sum_{k=1}^n((\theta_k^{(j)}))^2$是正则化项。</p>
</blockquote>
<p>对上面的式子通过求最小化，我们最终可以得到一个表现良好的$\theta^{(j)}$。</p>
<p>为了让公式变得更简单一些，我们可以去除掉常数项$\frac{1}{m^{(j)}}$，对最终结果无影响：</p>
<p><img src="/img/17_05_28/003.gif" alt=""></p>
<h4 id="完整的描述"><a href="#完整的描述" class="headerlink" title="完整的描述"></a>完整的描述</h4><p>接下来对训练过程进行完整的描述一遍：</p>
<h5 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h5><p>为了学习第$j$个用户的参数$\theta^{(j)}$，我们执行以下运算：</p>
<p><img src="/img/17_05_28/003.gif" alt=""></p>
<p>为了学习全部用户的参数$\theta^{(1)},\theta^{(2)},…,\theta^{(n_u)}$，我们执行以下运算：</p>
<p><img src="/img/17_05_28/004.gif" alt=""></p>
<p>通过这一运算，我们就能得出所有用户的参数向量$\theta^{(1)},\theta^{(2)},…,\theta^{(n_u)}$，从而对所有用户作出预测了。</p>
<h5 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h5><p><img src="/img/17_05_28/004.gif" alt=""></p>
<p>是我们最优化目标，记为$J(\theta^{(1)},\theta^{(2)},…,\theta^{(n_u)})$。</p>
<p>为了最小化这个目标函数$J(\theta^{(1)},\theta^{(2)},…,\theta^{(n_u)})$，我们需要使用梯度下降算法来计算：</p>
<ul>
<li><strong>k=0时</strong></li>
</ul>
<p><img src="/img/17_05_28/005.gif" alt=""></p>
<ul>
<li><strong>k≠0时</strong></li>
</ul>
<p><img src="/img/17_05_28/006.gif" alt=""></p>
<blockquote>
<p><strong>注意：</strong>其中$\alpha$是学习率。</p>
</blockquote>
<p>上面的过程实际上是在对优化目标函数$J(\theta^{(1)},\theta^{(2)},…,\theta^{(n_u)})$求偏微分的过程：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial\theta\_k^{j}}
J(\theta^{(1)},\theta^{(2)},...,\theta^{(n\_u)})</script><p>以上就是通过梯度下降来最小化代价函数$J$的全过程，当然，如果你愿意的话，你可以尝试使用更高级的优化算比如<strong>聚类下降</strong>或者<em>L-BFGS(Limited-memory Broyden–Fletcher–Goldfarb–Shanno Algorithm)*</em>或者别的方法来最小化代价函数J。</p>
<blockquote>
<p>以上内容，我们介绍了使用一种线性回归的变体来预测不同用户对不同电影评分的算法，这种算法被称作<strong>“基于内容的推荐”</strong>，因为我们已知了不同电影的特征（比如电影是爱情片的程度，是动作片的程度等），从而来进行预测。但事实上，对于很多电影，我们并没有这些特征，或者很难得到这些特征。所以，在下一节中，我们将介绍一种<strong>“不基于内容的推荐系统”</strong>。</p>
</blockquote>
<h1 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h1><h2 id="协同过滤-1"><a href="#协同过滤-1" class="headerlink" title="协同过滤"></a>协同过滤</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/2WoBV/collaborative-filtering">视频地址</a></p>
<blockquote>
<p>这一节，我们将介绍一种叫做<strong>协同过滤(collaborative filtering)</strong>的推荐算法。</p>
<p>关于这个算法值得一提的一个特点，那就是它能实现<strong>对特征的学习</strong>。就是说这个算法可以实现自动学习要使用的特征值。</p>
</blockquote>
<p>在之前的电影评分的例子中，我们有下面的这组数据：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电影</th>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
<th style="text-align:center">$x_1$(爱情片)</th>
<th style="text-align:center">$x_2$(动作片)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《爱到最后》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.9</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《浪漫永远》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">0.01</td>
</tr>
<tr>
<td style="text-align:center">《小爱犬》</td>
<td style="text-align:center">?</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0.99</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《无尽狂飙》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">1.0</td>
</tr>
<tr>
<td style="text-align:center">《剑与空手道》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0.9</td>
</tr>
</tbody>
</table>
</div>
<p>我们除了有每个用户对不同电影的评分之外，同时也有每个电影属于不同类别特征的程度值$x_1$和$x_2$。</p>
<p>但是，在实际情况中，这样做的难度很大，因为我们很难对所有的电影给出相关特征的评分。而且通常情况，我们还希望能得到除了这两个特征之外的其他特征。</p>
<p>为了能做到这一点，我们换一种形式，假设我们并不知道每部电影具体的特征值是多少：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电影</th>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
<th style="text-align:center">$x_1$(爱情片)</th>
<th style="text-align:center">$x_2$(动作片)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《爱到最后》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">《浪漫永远》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">《小爱犬》</td>
<td style="text-align:center">?</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">《无尽狂飙》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">《剑与空手道》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
</tr>
</tbody>
</table>
</div>
<p>假设我们采访了每一位用户，而且每一位用户都告诉我们他们是否喜欢爱情电影；以及他们是否喜欢动作电影，这样Alice、Bob、Carol以及Dave就有了他们对应的参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\begin{equation}\theta^{(1)}=\left[\begin{matrix}0\\5\\0\end{matrix}\right]\end{equation}$</td>
<td style="text-align:center">$\begin{equation}\theta^{(2)}=\left[\begin{matrix}0\\5\\0\end{matrix}\right]\end{equation}$</td>
<td style="text-align:center">$\begin{equation}\theta^{(3)}=\left[\begin{matrix}0\\0\\5\end{matrix}\right]\end{equation}$</td>
<td style="text-align:center">$\begin{equation}\theta^{(4)}=\left[\begin{matrix}0\\0\\5\end{matrix}\right]\end{equation}$</td>
</tr>
</tbody>
</table>
</div>
<p>每个特征向量的第二个元素表示对爱情片的喜欢程度，第三个元素表示对动作片的喜欢程度。可以看出来Alice和Bob更喜欢爱情片，而Carol和Dave更喜欢动作片。</p>
<p>有了这些数据，我们就可以着眼于用户，看看任意用户$j$对应的不同题材电影的喜欢程度$\theta^{(j)}$。有了这些参数值，理论上我们就能推测出每部电影的特征变量$x_1$和$x_2$的值。</p>
<p>举个例子：</p>
<p>我们看第一个电影，假设我们不知道这部电影的主要内容，我们只知道Alice和Bob喜欢这部电影，而Carol和Dave不喜欢它。从他们四个人的特征向量就可以看出，Alice和Bob给出了5分，而Carol和Dave给出了0分。因此我们可以推断，这部电影可能是一部爱情片，而不太可也能是动作片。所以可能$x_1=1.0$而$x_2=0.0$。</p>
<p>其实这说明了我们在寻找能使得以下式子成立的$x^{(1)}$：</p>
<script type="math/tex; mode=display">
(\theta^{(1)})^Tx^{(1)}≈5 \\\\
(\theta^{(2)})^Tx^{(1)}≈5 \\\\
(\theta^{(3)})^Tx^{(1)}≈0 \\\\
(\theta^{(4)})^Tx^{(1)}≈0</script><p>因此，我们可以得出$x^{(1)}$的值为：</p>
<script type="math/tex; mode=display">
\begin{equation}
x^{(1)}
=\left[
\begin{matrix}
1\\\\
1.0\\\\
0.0
\end{matrix}
\right]
\end{equation}</script><blockquote>
<p>第一个元素$x^{(1)}_0$是截距。</p>
</blockquote>
<p>我们可以按照这种方式把其他电影的特征预测出来。</p>
<h3 id="协同过滤算法的正式描述"><a href="#协同过滤算法的正式描述" class="headerlink" title="协同过滤算法的正式描述"></a>协同过滤算法的正式描述</h3><p><strong>优化算法：</strong></p>
<p>在已知给定参数$\theta^{(1)},…,\theta^{(n_u)}$的情况下，对下面函数最小化，得到特征值$x^{(i)}$：</p>
<p><img src="/img/17_05_28/007.gif" alt=""></p>
<p>这就是我们如何从一部特定的电影中学习到特征的方法。</p>
<p>那么对于所有的电影，计算所有的特征，我们通过最小化下面的函数可以得到：</p>
<p><img src="/img/17_05_28/008.gif" alt=""></p>
<p>这里我们对所有$n_m$个电影的特征代价函数求和，然后最小化这个整体的代价函数，这样就能得到针对所有电影的合理的特征值了。</p>
<h3 id="鸡生蛋？蛋生鸡？"><a href="#鸡生蛋？蛋生鸡？" class="headerlink" title="鸡生蛋？蛋生鸡？"></a>鸡生蛋？蛋生鸡？</h3><p>在上一节中，我们提到了如果给定了一系列的特征值$x^{(1)},…,x^{(n_m)}$，以及用户对电影的评分，我们就可以得到不同用户对应的参数向量$\theta^{(1)},…,\theta^{(n_u)}$。</p>
<p>在本节内容中，我们又讲到了在给定参数$\theta^{(1)},…,\theta^{(n_u)}$的情况下，我们可以预测每个电影的特征向量$x^{(1)},…,x^{(n_m)}$。</p>
<p>这有点类似<strong>先有鸡还是先有蛋</strong>的问题。我们知道了$x$就能预测出$\theta$，反之，如果我们知道了$\theta$，我们就能预测出$x$。</p>
<p>这样一来，我们能做到的就是首先随机初始化参数向量$\theta$，然后根据这些初始化得到的$\theta$来得到不同电影的特征值$x$:</p>
<script type="math/tex; mode=display">
Guess \ \ \ \ \theta → x</script><p>有了这些特征值$x$，我们就可以得到对参数$\theta$更好的估计：</p>
<script type="math/tex; mode=display">
x → \theta</script><p>同样，我们可以根据这个更好的$\theta$来得到更好的特征集$x$：</p>
<script type="math/tex; mode=display">
\theta → x</script><p>如此循环往复。</p>
<p>如果你一直重复上述的计算过程，你的算法将会收敛到一组合理的特征值$x$，以及一组合理的对不同用户参数的估计值$\theta$。</p>
<p>这就是基本的<strong>协同过滤算法</strong>，但这实际上不是我们最终使用的算法。在下一节中，我们将改进这个算法，让其在计算时更为高效。但这节课希望能让你基本了解这个算法的基本原理。</p>
<blockquote>
<p>总结一下，在本节，我们了解了最基本的协同过滤算法。</p>
<p>协同过滤算法指的是当你针对一大批用户数据执行这个算法时，这些用户实际上在高效地进行了协同合作来得到每个人对电影的评分值。只要用户对某几部电影进行评分，每个用户就都在帮助算法更好的学习出特征。这样以来，通过自己对几部电影评分之后，我就能帮助系统更好的学习到特征。这些特征可以被系统运用，为其他人做出更准确的电影预测。</p>
<p>协同的另一层意思是说每位用户都在为了大家的利益，而学习出更好的特征。这就是协同过滤。</p>
</blockquote>
<h2 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/f26nH/collaborative-filtering-algorithm">视频地址</a></p>
<blockquote>
<p>在前几节中，我们谈到几个概念。</p>
<p>首先，如果给你几个特征表示电影，我们可以使用这些资料去获得用户的参数数据。</p>
<p>第二，如果给你用户的参数数据，你可以使用这些资料去获得电影的特征。</p>
<p>本节中，我们将会使用这些概念，并且将它们合并成<strong>协同过滤算法 (Collaborative Filtering Algorithm)</strong>。</p>
</blockquote>
<p>在之前的内容中，我们介绍了通过最小化以下目标函数，来在已知电影特征向量$x^{(1)},…,x^{(n_m)}$的情况下，预测每个用户对应的参数向量$\theta^{(1)},…,\theta^{(n_u)}$：</p>
<p><img src="/img/17_05_28/004.gif" alt=""></p>
<p>也介绍了通过最小化以下目标函数，来在已知每个用户参数向量$\theta^{(1)},…,\theta^{(n_u)}$的情况下，来预测每个电影的特征向量$x^{(1)},…,x^{(n_m)}$：</p>
<p><img src="/img/17_05_28/008.gif" alt=""></p>
<p>我们首先通过随机初始化一组参数$\theta$，然后来推导特征向量$x$；有了特征向量$x$，我们再去反推更好的参数向量$\theta$，然后如此循环往复，直到收敛。</p>
<p>而实际上，我们有一个更有效率的算法，让我们不必再这样不停地来回计算，而是能同时把$x$和$\theta$同时计算出来。</p>
<p>我们做的就是把上面两个式子合而为一：</p>
<p>同时最小化$x^{(1)},…,x^{(n_m)}$和$\theta^{(1)},…,\theta^{(n_u)}$：</p>
<p><img src="/img/17_05_28/009.gif" alt=""></p>
<p>优化目标函数：</p>
<p><img src="/img/17_05_28/010.gif" alt=""></p>
<h3 id="公式解读"><a href="#公式解读" class="headerlink" title="公式解读"></a>公式解读</h3><p>接下来，我们对上面这个式子的推导过程进行详细的解读。</p>
<h4 id="求和部分"><a href="#求和部分" class="headerlink" title="求和部分"></a>求和部分</h4><p>首先需要说明的是，在之前的这两个式子中：</p>
<p><img src="/img/17_05_28/004.gif" alt=""></p>
<p><img src="/img/17_05_28/008.gif" alt=""></p>
<p>仔细观察这两部分，其实是一样的：</p>
<p><img src="/img/17_05_28/011.gif" alt=""></p>
<p><img src="/img/17_05_28/012.gif" alt=""></p>
<p>第一个是：所有的用户的评过分的电影中，预测评分和真实评分的差值平方总和。</p>
<p>第二个是：所有的电影中对它评过分的用户，预测的评分和真实评分的差值平方总和。</p>
<p>这两者的计算结果其实是一样的，只不过条件先后不同导致计算顺序不同而已。</p>
<p>因此，在最终的代价函数中：</p>
<p><img src="/img/17_05_28/009.gif" alt=""></p>
<p>这一部分：</p>
<p><img src="/img/17_05_28/013.gif" alt=""></p>
<p>其实这个表达式就是上面那两种表达式的整体的表示形式。计算结果与上面那两个式子也是相同的。</p>
<h4 id="正则化部分"><a href="#正则化部分" class="headerlink" title="正则化部分"></a>正则化部分</h4><p>最终的代价函数</p>
<p><img src="/img/17_05_28/009.gif" alt=""></p>
<p>的后半段：</p>
<p><img src="/img/17_05_28/014.gif" alt=""></p>
<p>其实就是把这两个式子中的正则化部分求和得出的：</p>
<p><img src="/img/17_05_28/004.gif" alt=""></p>
<p><img src="/img/17_05_28/008.gif" alt=""></p>
<p>如果你把</p>
<p><img src="/img/17_05_28/009.gif" alt=""></p>
<p>中$x^{(1)},…,x^{(n_m)}$部分看做是常数，然后关于$\theta$做优化，那么这个式子其实就相当于：</p>
<p><img src="/img/17_05_28/004.gif" alt=""></p>
<p>反之，如果你把$\theta^{(1)},…,\theta^{(n_u)}$部分看做常数，然后关于$x$做优化，那么这个式子其实就相当于是：</p>
<p><img src="/img/17_05_28/008.gif" alt=""></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最终，我们通过合并之前的两个式子，得到了同时关于$x$和$\theta$的代价函数表达式：</p>
<p><img src="/img/17_05_28/009.gif" alt=""><br><img src="/img/17_05_28/010.gif" alt=""></p>
<p>这和之前的算法之间唯一的不同就是<strong>不需要反复计算</strong>（就是前面提到的先关于$\theta$最小化，然后再关于$x$最小化，然后再次关于$\theta$最小化，反复直到收敛）。在新版本里头 不需要不断地在$x$和$θ$这两个参数之间不停折腾，我们所要做的是将这两组参数同时化简。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>最后值得提醒的一件事，当我们以这样的方法学习特征量时，我们必须要保证去掉$x_0$项，这样来保证我们学习到的特征量$x$是$n$维的，而不是$n+1$维的。</p>
<p>同样地，因为参数$θ$与特征向量$x$是在同一个维度上，所以$θ$也是$n$维的。因为如果没有$x_0$，那么$θ_0$也不再需要。</p>
<h3 id="协同过滤算法的正式描述-1"><a href="#协同过滤算法的正式描述-1" class="headerlink" title="协同过滤算法的正式描述"></a>协同过滤算法的正式描述</h3><p>把上面所有的过程总结下来，就是所谓的<strong>协同过滤算法</strong>。下面是对这一算法的具体步骤描述：</p>
<ul>
<li>1.首先用较小的初始值来随机初始化参数$x^{(1)},…,x^{(n_m)},\theta^{(1)},…,\theta^{(n_u)}$。<blockquote>
<p>这一步有点像训练神经网络，在神经网络中的训练中，我们也是用小的随机数来初始化权值。</p>
</blockquote>
</li>
<li>2.通过使用梯度下降算法（或者其他更高级的优化算法）来最小化代价函数$J(x^{(1)},…,x^{(n_m)},\theta^{(1)},…,\theta^{(n_u)})$。<ul>
<li>例如循环每一个$j=1,…,n_u,i=1,…,n_m$ 来执行对应的梯度下降：</li>
</ul>
</li>
</ul>
<p><img src="/img/17_05_28/015.png" alt=""></p>
<p>其中这一部分：</p>
<p><img src="/img/17_05_28/016.png" alt=""></p>
<p>就是对代价函数的偏微分项：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial x_k^{(i)}}
J(x^{(1)},...,x^{(n_m)})</script><p>这一部分：</p>
<p><img src="/img/17_05_28/017.png" alt=""></p>
<p>对应也是下面这个代价函数的偏微分项：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial \theta_k^{(j)}}
J(\theta^{(1)},...,\theta^{(n_u)})</script><blockquote>
<p>值得提醒的是，在这个公式中，我们不再用到$x_0=1$这一项，因此$x$是$n$维的（$x\in R^n$）而不是$n+1$维；$\theta$也是$n$维（$\theta\in R^n$）。</p>
<p>所以我们在做正则化的时候，也是对这$n$维的参数进行正则化，并不包括$x_0$和$\theta_0$。</p>
</blockquote>
<ul>
<li>3.最终，通过用户对应的参数向量$\theta$和训练得出的特征向量$x$，来预测用户给出的评分$\theta^Tx$。</li>
</ul>
<h1 id="低秩矩阵分解"><a href="#低秩矩阵分解" class="headerlink" title="低秩矩阵分解"></a>低秩矩阵分解</h1><h2 id="矢量化：低秩矩阵分解"><a href="#矢量化：低秩矩阵分解" class="headerlink" title="矢量化：低秩矩阵分解"></a>矢量化：低秩矩阵分解</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/CEXN0/vectorization-low-rank-matrix-factorization">视频地址</a></p>
<blockquote>
<p>在上几节中，我们谈到了<strong>协同过滤算法</strong>，本节视频中我将会讲到有关该算法的向量化实现，以及说说有关该算法你可以做的其他事情。</p>
<p>比如说，你可以做到<strong>相似产品推荐</strong>的功能。</p>
</blockquote>
<p>还是以之前的电影评分为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电影</th>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《爱到最后》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《浪漫永远》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">《小爱犬》</td>
<td style="text-align:center">?</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">《无尽狂飙》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">《剑与空手道》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
</tr>
</tbody>
</table>
</div>
<p>我们将这些数据存储到矩阵$Y$中：</p>
<script type="math/tex; mode=display">
\begin{equation}
Y=\left[
\begin{matrix}
5&5&0&0\\\\
5&?&?&0\\\\
?&4&0&?\\\\
0&0&5&4\\\\
0&0&5&0
\end{matrix}
\right]
\end{equation}</script><p>$Y^{(i,j)}$代表第i行第j列的数据，即第i部电影的第j个用户的评分。</p>
<p>同时，我们也可以得出下面这个预测评分矩阵：</p>
<script type="math/tex; mode=display">
\begin{equation}
\left[
\begin{matrix}
(\theta^{(1)})^T(x^{(1)})&(\theta^{(2)})^T(x^{(1)})&...&(\theta^{(n_u)})^T(x^{(1)})\\\\
(\theta^{(1)})^T(x^{(2)})&(\theta^{(2)})^T(x^{(2)})&...&(\theta^{(n_u)})^T(x^{(2)})\\\\
┋&┋&┋&┋\\\\
(\theta^{(1)})^T(x^{(n_m)})&(\theta^{(2)})^T(x^{(n_m)})&...&(\theta^{(n_u)})^T(x^{(n_m)})
\end{matrix}
\right]
\end{equation}</script><p>其中$(\theta^{(j)})^T(x^{(i)})$代表第i个电影中第j个用户，预计给出的评分。</p>
<p>这个预测矩阵可以看做是<strong>电影的特征矩阵</strong>和<strong>用户的参数矩阵的转置</strong>的乘积。</p>
<p>电影特征矩阵如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
X=\left[
\begin{matrix}
(x^{(1)})^T\\\\
(x^{(2)})^T\\\\
┋\\\\
(x^{(n_m)})^T
\end{matrix}
\right]
\end{equation}</script><p>其中每一个元素都是一部电影的特征向量。</p>
<p>用户的参数矩阵如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
\Theta=\left[
\begin{matrix}
(\theta^{(1)})^T\\\\
(\theta^{(2)})^T\\\\
┋\\\\
(\theta^{(n_u)})^T
\end{matrix}
\right]
\end{equation}</script><p>其中每个元素都是一个用户的参数向量。</p>
<p>有了所有电影的特征矩阵$X$和所有用户的参数矩阵$\Theta$后，我们就可以得到上面的预测矩阵了：</p>
<script type="math/tex; mode=display">
\begin{equation}
X\Theta^T=\left[
\begin{matrix}
(\theta^{(1)})^T(x^{(1)})&(\theta^{(2)})^T(x^{(1)})&...&(\theta^{(n_u)})^T(x^{(1)})\\\\
(\theta^{(1)})^T(x^{(2)})&(\theta^{(2)})^T(x^{(2)})&...&(\theta^{(n_u)})^T(x^{(2)})\\\\
┋&┋&┋&┋\\\\
(\theta^{(1)})^T(x^{(n_m)})&(\theta^{(2)})^T(x^{(n_m)})&...&(\theta^{(n_u)})^T(x^{(n_m)})
\end{matrix}
\right]
\end{equation}</script><blockquote>
<p>我们的协同过滤算法还有另外一个名字：<strong>低秩矩阵分解（Low Rank Matrix Factorization）</strong>。</p>
</blockquote>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>最后，我们还可以通过使用协同过滤算法产生的结果做一些额外的事情。比如说<strong>找到相关的电影</strong>。</p>
<p>如何做到针对用户喜欢的某一部电影，然后推荐给他另一部类似的电影呢？</p>
<p>对于每一部电影，我们都可以学习到他的特征向量$x^{(i)} \in R^n$。</p>
<p>假设我们想找到和电影$i$最类似的一部电影，有一种方式就是求出所有电影的特征向量，然后和电影$i$的特征向量求欧氏距离，距离最小的那个就是最类似的：</p>
<script type="math/tex; mode=display">
Small ||x^{(i)}-x^{(j)}||  → 电影i和电影j最类似</script><p>类似的，如果你想找到与电影$i$最类似的5部电影，你只需求与特征向量$x^{(i)}$欧式距离最小的五部电影即可。</p>
<h2 id="实现细节：均值归一化"><a href="#实现细节：均值归一化" class="headerlink" title="实现细节：均值归一化"></a>实现细节：均值归一化</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Adk8G/implementational-detail-mean-normalization">视频地址</a></p>
<blockquote>
<p>到目前为止，你已经了解到了推荐系统算法或者 协同过滤算法的所有要点。</p>
<p>在本节中，我想分享最后一点实现过程中的细节，这一点就是<strong>均值归一化</strong>。有时它可以让算法运行得更好。</p>
</blockquote>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>为了了解均值归一化这个想法的动机，我们考虑这样一个例子。</p>
<p>有一个用户Eve没有给任何电影评分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">电影</th>
<th style="text-align:center">Alice(1)</th>
<th style="text-align:center">Bob(2)</th>
<th style="text-align:center">Carol(3)</th>
<th style="text-align:center">Dave(4)</th>
<th style="text-align:center">Eve(5)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">《爱到最后》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>?</strong></td>
</tr>
<tr>
<td style="text-align:center">《浪漫永远》</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center">?</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>?</strong></td>
</tr>
<tr>
<td style="text-align:center">《小爱犬》</td>
<td style="text-align:center">?</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">?</td>
<td style="text-align:center"><strong>?</strong></td>
</tr>
<tr>
<td style="text-align:center">《无尽狂飙》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><strong>?</strong></td>
</tr>
<tr>
<td style="text-align:center">《剑与空手道》</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">?</td>
<td style="text-align:center"><strong>?</strong></td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\begin{equation}
Y=\left[
\begin{matrix}
5&5&0&0&?\\\\
5&?&?&0&?\\\\
?&4&0&?&?\\\\
0&0&5&4&?\\\\
0&0&5&0&?
\end{matrix}
\right]
\end{equation}</script><p>我们来看看协同过滤算法会对这个用户做什么。</p>
<p>假设我们的电影只有两个特征$n=2$，用户的参数向量也是2维的：$\theta^{(5)} \in R^2$。</p>
<p><img src="/img/17_05_28/009.gif" alt=""></p>
<p>由于用户没有给任何电影评分，因此代价函数的前半部分没有任何电影满足$r(i,j)=1$的条件，所以可以忽略。所以，真正影响代价函数值变化的只有这一项：</p>
<script type="math/tex; mode=display">
\frac{\lambda}{2}
\sum\_{j=1}^{n\_u}
\sum\_{k=1}^{n}
(\theta\_k^{(j)})^2</script><p>对应到我们的具体的两个特征上之后，就是如下的形式：</p>
<script type="math/tex; mode=display">
\frac{\lambda}{2}
[
(\theta_1^{(5)})^2+(\theta_2^{(5)})^2
]</script><p>因此，为了最小化这一项，我们得到的结果就是：</p>
<script type="math/tex; mode=display">
\begin{equation}
\theta^{(5)}=\left[
\begin{matrix}
0\\\\
0
\end{matrix}
\right]
\end{equation}</script><p>所以，我们可以得出用户对电影评分的预测结果：</p>
<script type="math/tex; mode=display">
(\theta^{(5)})^Tx^{(1)}=0</script><p>都是0颗星。</p>
<p>这个结果看起来并没有什么用，因为其实有的电影是对于某些人来说是有较高的评分的，所以某些电影是值得被推荐的。但是我们得到的预测结果都是0颗星，这个结果在暗示我们不要推荐电影给他，这其实也不够好。</p>
<p>所以，我们需要引入<strong>均值归一化</strong>来解决我们这个问题。</p>
<h3 id="均值归一化处理数据"><a href="#均值归一化处理数据" class="headerlink" title="均值归一化处理数据"></a>均值归一化处理数据</h3><p>对于已知的电影评分数据：</p>
<script type="math/tex; mode=display">
\begin{equation}
Y=\left[
\begin{matrix}
5&5&0&0&?\\\\
5&?&?&0&?\\\\
?&4&0&?&?\\\\
0&0&5&4&?\\\\
0&0&5&0&?
\end{matrix}
\right]
\end{equation}</script><p>我们要做的就是计算每个电影所得评分的均值，用向量$μ$表示：</p>
<script type="math/tex; mode=display">
\begin{equation}
μ=\left[
\begin{matrix}
2.5\\\\
2.5\\\\
2\\\\
2.25\\\\
1.25
\end{matrix}
\right]
\end{equation}</script><p>然后将所有评分减去平均评分，得到新的$Y$：</p>
<script type="math/tex; mode=display">
\begin{equation}
Y=\left[
\begin{matrix}
2.5&2.5&-2.5&-2.5&?\\\\
2.5&?&?&-2.5&?\\\\
?&2&-2&?&?\\\\
-2.25&-2.25&2.75&1.75&?\\\\
-1.25&-1.25&3.75&-1.25&?
\end{matrix}
\right]
\end{equation}</script><p>这样做的目的，<strong>就是把每部电影的评分的平均数都调整为0</strong>。</p>
<p>然后我们对经过归一化处理之后的矩阵使用协同过滤算法，即使用户没有对电影做出过评分，那么我们得到的参数向量是：</p>
<script type="math/tex; mode=display">
\begin{equation}
\theta^{(5)}=\left[
\begin{matrix}
0\\\\
0
\end{matrix}
\right]
\end{equation}</script><p>我们最终预测用户给出的分值是：</p>
<script type="math/tex; mode=display">
(\theta^{(5)})^Tx^{(1)} + μ\_i</script><p>在这个例子中，我们预测Eva对五部电影初始化的评分分别为：2.5，2.5，2，2.25，1.25。</p>
<p>因为：</p>
<script type="math/tex; mode=display">
\begin{equation}
μ=\left[
\begin{matrix}
2.5\\\\
2.5\\\\
2\\\\
2.25\\\\
1.25
\end{matrix}
\right]
\end{equation}</script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第二周 (1)编程环境设置-Octave/MATLAB</title>
    <url>/2016/07/26/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E5%91%A8%20(1)%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE-Octave:MATLAB/</url>
    <content><![CDATA[<h2 id="设置你的编程环境"><a href="#设置你的编程环境" class="headerlink" title="设置你的编程环境"></a>设置你的编程环境</h2><p>这个机器学习的课程包括几个你需要完成的编程任务。这些任务需要Octave或MATLAB科学计算语言。</p>
<ul>
<li>Octave是一个免费、开源的应用。它拥有一个文本接口以及一个实验图形化接口。</li>
<li>MATLAB是一个专有软件。但是针对本套课程有一个免费的受限制的版本可以使用。</li>
</ul>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>这些需要花钱吗？</p>
<p>针对你当前正在学习的课程，这两个软件都是免费的。Octave是在GNU协议下被开放的，这意味着它一直是可以免费下载的。MATLAB只能用于完成本课程中的编程任务。对于其他的使用目的（例如你在完成课程之后去做的你自己的工作），MATLAB可以从Mathworks直接授权给个人或者公司。</p>
<p>这两者（Octave和MATLAB）质量有不同吗？</p>
<p>这两个软件有一些微妙的区别。MATLAB会提供一个更平滑的体验（尤其在Mac下），包含更多的函数，以及能够更稳健的处理失败。然而，这套课程中使用到的函数在两个软件里都有的，并且不管是哪个应用，都有很多学生用它完成了课程内容。</p>
<h2 id="在Windows下安装Octave-MATLAB"><a href="#在Windows下安装Octave-MATLAB" class="headerlink" title="在Windows下安装Octave/MATLAB"></a>在Windows下安装Octave/MATLAB</h2><h3 id="在Windows下安装Octave"><a href="#在Windows下安装Octave" class="headerlink" title="在Windows下安装Octave"></a>在Windows下安装Octave</h3><p><strong>使用这个链接来在Windows安装Octave</strong>:</p>
<p><a href="http://wiki.octave.org/Octave_for_Microsoft_Windows">http://wiki.octave.org/Octave_for_Microsoft_Windows</a></p>
<p>在Windows下Octave能用来提交本课程的编程任务，但是需要安装一个在论坛区中的补丁。查看更多你当前版本的补丁信息，参见<a href="https://www.coursera.org/learn/machine-learning/discussions/vgCyrQoMEeWv5yIAC00Eog?page=2">https://www.coursera.org/learn/machine-learning/discussions/vgCyrQoMEeWv5yIAC00Eog?page=2</a>。</p>
<h3 id="在Windows下安装MATLAB。"><a href="#在Windows下安装MATLAB。" class="headerlink" title="在Windows下安装MATLAB。"></a>在Windows下安装MATLAB。</h3><p>在course中MathWorks提供了一个MATLAB的入口。不过要注意的是请在课程的有效时间内使用(12周之内)。</p>
<p>第一步：如果你没有MathWork，请<a href="https://www.mathworks.com/licensecenter/classroom/machine_learning_od/">创建一个MathWork账号</a>。</p>
<p>第二步：再次使用<a href="https://www.mathworks.com/licensecenter/classroom/machine_learning_od/">这个连接</a>去下载并安装。你需要登录在第一步中创建的账号，然后开始安装。</p>
<h2 id="在Mac-OS-X-10-10-Yosemite-以及-10-9-Mavericks-上安装Octave-MATLAB"><a href="#在Mac-OS-X-10-10-Yosemite-以及-10-9-Mavericks-上安装Octave-MATLAB" class="headerlink" title="在Mac OS X (10.10 Yosemite 以及 10.9 Mavericks)上安装Octave/MATLAB"></a>在Mac OS X (10.10 Yosemite 以及 10.9 Mavericks)上安装Octave/MATLAB</h2><h3 id="在Mac-OS-X上安装Octave"><a href="#在Mac-OS-X上安装Octave" class="headerlink" title="在Mac OS X上安装Octave"></a>在Mac OS X上安装Octave</h3><p>Mac OS X上有一个被称为<a href="http://support.apple.com/en-us/HT202491">Gatekeeper</a>的功能，这个功能只允许你安装来自App store的程序。你需要设置它来允许安装Octave。打开你的系统偏好，点击安全性与隐私，然后勾选设置允许下载的应用位置为“任何来源”。你需要输入密码来解锁设置页面。</p>
<p><img src="/img/16_07_25/002.png" alt=""><br><img src="/img/16_07_25/003.png" alt=""></p>
<p>2.下载<a href="http://sourceforge.net/projects/octave/files/Octave%20MacOSX%20Binary/2013-12-30%20binary%20installer%20of%20Octave%203.8.0%20for%20OSX%2010.9.1%20%28beta%29/GNU_Octave_3.8.0-6.dmg/download">Octave3.8.0安装包</a>，文件有点大，可能需要花费一些时间。</p>
<p>3.打开下载好的文件，可能在你的电脑上文件名为”GNU_Octave_3.8.0-6.dmg”，然后打开里面的”Octave-3.8.0-6.mpkg”。</p>
<p>4.根据安装程序的说明。你也许需要输入你电脑的管理员密码。</p>
<p>5.安装成功后，你会在应用中看到<strong>Octave-cli</strong>。这是一个Octave的文本界面入口，通过它，我们可以完成机器学习的编程任务。</p>
<p>Octave也拥有一个叫做”Octave-gui”的处于实验阶段的图形界面入口，但我们任然建议你使用Octave-cli，因为它更稳定。</p>
<blockquote>
<p>提示：如果你在使用一个包管理器（例如MacPorts或者Homebrew），我们建议你使用<a href="http://wiki.octave.org/Octave_for_MacOS_X#Package_Managers">通过包管理器的安装方式</a>。</p>
</blockquote>
<h3 id="在Mac-OS-X上安装MATLAB"><a href="#在Mac-OS-X上安装MATLAB" class="headerlink" title="在Mac OS X上安装MATLAB"></a>在Mac OS X上安装MATLAB</h3><p>在course中MathWorks提供了一个MATLAB的入口。不过要注意的是请在课程的有效时间内使用(12周之内)。</p>
<p>第一步：如果你没有MathWork，请<a href="https://www.mathworks.com/licensecenter/classroom/machine_learning_od/">创建一个MathWork账号</a>。</p>
<p>第二步：再次使用<a href="https://www.mathworks.com/licensecenter/classroom/machine_learning_od/">这个连接</a>去下载并安装。你需要登录在第一步中创建的账号，然后开始安装。</p>
<h2 id="在GNU-Linux上安装Octave-MATLAB"><a href="#在GNU-Linux上安装Octave-MATLAB" class="headerlink" title="在GNU/Linux上安装Octave/MATLAB"></a>在GNU/Linux上安装Octave/MATLAB</h2><h3 id="在GNU-Linux上安装Octave"><a href="#在GNU-Linux上安装Octave" class="headerlink" title="在GNU/Linux上安装Octave"></a>在GNU/Linux上安装Octave</h3><p>我们建议你<a href="http://wiki.octave.org/Octave_for_GNU/Linux">使用系统包管理器来安装Octave</a></p>
<p>在Ubuntu上，你可以使用：</p>
<ul>
<li><code>sudo apt-get update &amp;&amp; sudo apt-get install octave</code></li>
</ul>
<p>在Fedora上，你可以使用：</p>
<ul>
<li><code>sudo yum install octave-forge</code></li>
</ul>
<p>其他GNU/Linux系统，请参见<a href="http://wiki.octave.org/Octave_for_GNU/Linux">这里</a></p>
<h3 id="在GNU-Linux上安装MATLAB"><a href="#在GNU-Linux上安装MATLAB" class="headerlink" title="在GNU/Linux上安装MATLAB"></a>在GNU/Linux上安装MATLAB</h3><p>第一步：如果你没有MathWork，请<a href="https://www.mathworks.com/licensecenter/classroom/machine_learning_od/">创建一个MathWork账号</a>。</p>
<p>第二步：再次使用<a href="https://www.mathworks.com/licensecenter/classroom/machine_learning_od/">这个连接</a>去下载并安装。你需要登录在第一步中创建的账号，然后开始安装。</p>
<h2 id="更多Octave-MATLAB的资源"><a href="#更多Octave-MATLAB的资源" class="headerlink" title="更多Octave/MATLAB的资源"></a>更多Octave/MATLAB的资源</h2><h3 id="Octave资源"><a href="#Octave资源" class="headerlink" title="Octave资源"></a>Octave资源</h3><p>在Octave命令行下，输入<strong>help</strong>跟上一个函数名来展示这个函数的说明文档。例如:<strong>help plot</strong>将呼起一个有关测绘(plotting)的帮助信息。更多的信息，请见<a href="http://www.gnu.org/software/octave/doc/interpreter/">文档页</a>。</p>
<h3 id="MATLAB资源"><a href="#MATLAB资源" class="headerlink" title="MATLAB资源"></a>MATLAB资源</h3><p>在MATLAB命令行下，输入<strong>help</strong>跟上一个函数名来展示这个函数的说明文档。例如:<strong>help plot</strong>将呼起一个有关测绘(plotting)的帮助信息。更多的信息，请见<a href="http://cn.mathworks.com/help/matlab/?requestedDomain=www.mathworks.com">文档页</a>。</p>
<p>MathWorks也有一系列有关MATLAB功能的视频：</p>
<p>MATLAB的介绍：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学习模块</th>
<th style="text-align:left">学习目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://youtu.be/rXwTiKGlilE">什么是MATLAB?</a></td>
<td style="text-align:left">介绍MATLAB</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/iYTzJXXI9vI">MATLAB的环境</a></td>
<td style="text-align:left">命令行，工作空间，目录和编辑器介绍</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/jURDBsIPt5I">MATLAB变量</a></td>
<td style="text-align:left">使用赋值操作符来定义标量变量</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/E7KllorEWkA">MATLAB作为一个计算器</a></td>
<td style="text-align:left">通过MATLAB的语法的方法和标量以及操作顺序来执行算数运算。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/R-kBvJ3kVVk">数学函数</a></td>
<td style="text-align:left">对方法的输入输出来使用MATLAB的变量，例如：COS，SIN，EXP，NTHROOT。</td>
</tr>
</tbody>
</table>
</div>
<p>向量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学习模块</th>
<th style="text-align:left">学习目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://youtu.be/2VNFqxmVqw8">通过级联创建向量</a></td>
<td style="text-align:left">通过输入单个元素创建向量</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/GihLWwp8sBw">访问向量的元素</a></td>
<td style="text-align:left">访问向量的特定元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/t9Kla_YFdfs">向量运算</a></td>
<td style="text-align:left">通过包含智能元素操作的向量来执行计算</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/USehPX2iEa4">向量的转置</a></td>
<td style="text-align:left">使用向量的转置来实现向量的行列交换</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/L7cERR5J9XY">创建均匀分布的向量(冒号运算符)</a></td>
<td style="text-align:left">使用冒号运算符来创建指定起始值、终止值以及间隔大小的向量</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/3QM3LRnb4Tw">创建均匀分布的向量(LINSPACE 函数)</a></td>
<td style="text-align:left">使用LINSPAC函数来创建一个向量</td>
</tr>
</tbody>
</table>
</div>
<p>可视化：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学习模块</th>
<th style="text-align:left">学习目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://youtu.be/00k9A9W0cl8">线图</a></td>
<td style="text-align:left">创建一个向量的折线图并且自定义的绘图标记和颜色</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/ab3XIDdloNI">图形注释</a></td>
<td style="text-align:left">标签轴，添加一个标题，或者对于一个图添加一个描述</td>
</tr>
</tbody>
</table>
</div>
<p>矩阵和数组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学习模块</th>
<th style="text-align:left">学习目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://youtu.be/5tm6PKaJdI8">创建一个矩阵</a></td>
<td style="text-align:left">通过直接输入标量创建矩阵</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/DDnm7vek6KY">数组创建函数</a></td>
<td style="text-align:left">通过使用MATLAB的方法，例如<code>ZEROS</code>和<code>EYE</code>，来创建一个更大的矩阵</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/qqQnFp5aiuM">访问和数组元素</a></td>
<td style="text-align:left">通过行和列的索引来访问一个数组的元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/SqvtT_VspKU">数组的大小和长度</a></td>
<td style="text-align:left">使用内置函数来确定数组的尺寸</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/TgopxS-_zl8">串联阵列</a></td>
<td style="text-align:left">从一个较小的数组创建一个更大的数组</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/-jgXqAYBhxI">矩阵乘法</a></td>
<td style="text-align:left">执行矩阵乘法并列出关于尺寸不匹配的错误信息</td>
</tr>
</tbody>
</table>
</div>
<p>编程：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">学习模块</th>
<th style="text-align:left">学习目标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://youtu.be/TZr6GyxnI_w">使用MATLAB编辑器</a></td>
<td style="text-align:left">在MATLAB编辑器下写一个脚本，并且分块执行这些代码，并且查找方法的帮助</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/5gVKJVVmbrM">逻辑运算符</a></td>
<td style="text-align:left">通过使用关系运算符以及逻辑运算符来创建程序控制的逻辑变量</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/8wxh4LtT--g">有条件的数据选择</a></td>
<td style="text-align:left">允许更改一个满足指定标准的向量元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/oaK2-ZT9dls">if-else控制语句</a></td>
<td style="text-align:left">通过使用if-else条件判断语句来控制哪一行代码将被执行</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/1u3RahlWEZA">for循环</a></td>
<td style="text-align:left">重复执行一个指定次数的命令序列</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://youtu.be/dofj51Ovdl4">while循环</a></td>
<td style="text-align:left">当条件判断语句为true时，重复执行一个序列的命令</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第二周 (2)多元线性回归分析</title>
    <url>/2016/07/29/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E5%91%A8%20(2)%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="多特征量"><a href="#多特征量" class="headerlink" title="多特征量"></a>多特征量</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/6Nj1q/multiple-features">视频地址</a></p>
<p>在这段视频中，我们将开始介绍一种新的更为有效的线性回归形式，这种形式适用于多个变量，或者多特征量的情况。</p>
<p>比如说：在之前我们学习过的线性回归中，我们只有一个单一特征量：‘房屋面积x’，我们希望用这个特征量来预测房子的价格，这就是我们的假设 。</p>
<p><img src="/img/16_07_29/001.png" alt=""></p>
<p>但是想象一下，如果我们不仅有房屋面积作为预测房屋价格的特征量或者变量，我们还知道卧室的数量楼层的数量以及房子的使用年限，这样就给了我们更多可以用来预测房屋价格的信息:</p>
<p><img src="/img/16_07_29/002.png" alt=""></p>
<h3 id="多特征量的表示"><a href="#多特征量的表示" class="headerlink" title="多特征量的表示"></a>多特征量的表示</h3><p>先简单介绍一下记法：</p>
<ul>
<li>$n$ = 来表示特征量的数目</li>
</ul>
<p>这个例子中有4个特征量，因此，这里n=4</p>
<ul>
<li>$x^{(i)}$ = 第$i$个训练样本的输入特征值</li>
</ul>
<p>这个例子中$x^{(2)}$就是表示第二个训练样本的特征向量：</p>
<script type="math/tex; mode=display">
x^{(2)}
=
\begin{bmatrix}
1416 \\\\
3 \\\\
2 \\\\
40
\end{bmatrix}</script><ul>
<li>$x_j^{(i)}$ = 第$i$个训练样本的第$j$个特征量 </li>
</ul>
<p>这个例子中，$x_3^{(2)}$代表着第2个训练样本里的第3个特征量。这里值是2。</p>
<h3 id="多特征量的假设函数"><a href="#多特征量的假设函数" class="headerlink" title="多特征量的假设函数"></a>多特征量的假设函数</h3><p>这是我们之前使用的假设形式：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ_0 + θ_1 * x</script><p>其中$x$就是我们唯一的特征量，但现在我们有了多个特征量我们就不能再 使用这种简单的表示方式了。取而代之的，我们将把线性回归的假设改成这样：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ\_{0} + θ\_{1} x\_{1} + θ\_{2} x\_{2} + ... + θ\_{n} x\_{n}</script><p>接下来，我要来介绍简化这个等式的表示方式：</p>
<p><strong>为了表示方便,我要将$x_{0}$的值设为1。</strong>具体而言这意味着对于第$i$个样本，都有一个向量$x^{(i)}$，并且$x^{(i)}_{0} = 1$。你可以认为我们定义了一个额外的第0个特征量。因此，我过去有$n$个特征量 因为我们有$x_{1},x_{2}…x_{n}$，由于我另外定义了第0个特征向量$x_{0}$，并且它的取值总是1，所以我现在的特征向量$x$是一个从0开始标记的$n+1$维的向量：</p>
<script type="math/tex; mode=display">
x 
=
\begin{bmatrix}
x\_{0} \\\\
x\_{1} \\\\
x\_{2} \\\\
... \\\\
x\_{n} 
\end{bmatrix}
\in
\mathbb{R}^{n+1}</script><p>但我要从0开始标记，同时我也想把我的参数都看做一个向量，所以我们的参数就是：</p>
<script type="math/tex; mode=display">
θ 
=
\begin{bmatrix}
θ\_{0} \\\\
θ\_{1} \\\\
θ\_{2} \\\\
... \\\\
θ\_{n} 
\end{bmatrix}
\in
\mathbb{R}^{n+1}</script><p>所以我的假设，现在可以写成：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ\_{0} x\_{0} + θ\_{1} x\_{1} + θ\_{2} x\_{2} + ... + θ\_{n} x\_{n}</script><blockquote>
<p>请注意，这里$x_{0} = 1$</p>
</blockquote>
<p>下面我要把这种形式假设等式写成:</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ^{T} x</script><p>其中$θ^{T}$是$θ$向量的转置，是一个$(n+1)×1$维的矩阵，也被称为行向量：</p>
<script type="math/tex; mode=display">
\underbrace{
\begin{bmatrix}
θ\_{0} θ\_{1} θ\_{2} ... θ\_{n} 
\end{bmatrix}
}\_{θ^{T}}</script><p>因此这个假设函数的完整推导过程如下:</p>
<script type="math/tex; mode=display">
\begin{align\*}
h\_{θ}(x) 
&=
θ\_{0} x\_{0} + θ\_{1} x\_{1} + θ\_{2} x\_{2} + ... + θ\_{n} x\_{n}\\\\
&=
\begin{bmatrix}
θ\_{0} θ\_{1} θ\_{2} ... θ\_{n} 
\end{bmatrix}
\begin{bmatrix}
x\_{0} \\\\
x\_{1} \\\\
x\_{2} \\\\
... \\\\
x\_{n} 
\end{bmatrix}\\\\
&=
θ^{T} x
\end{align\*}</script><p>这就为我们表示假设的更加便利的形式：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ^{T} x</script><p>即用参数向量$θ$以及特征向量$X$的内积来表示。</p>
<p>这样的表示方法让我们可以以这种紧凑的形式写出假设，这就是多特征量情况下的假设形式。起另一个名字：就是<strong>所谓的多元线性回归</strong>。</p>
<h2 id="多特征的梯度下降"><a href="#多特征的梯度下降" class="headerlink" title="多特征的梯度下降"></a>多特征的梯度下降</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Z9DKX/gradient-descent-for-multiple-variables">视频地址</a></p>
<p>在之前的视频中，我们谈到了一种线性回归的假设形式，这是一种有多特征或者是多变量的形式。在本节视频中我们将会谈到如何找到满足这一假设的参数，尤其是如何使用梯度下降法来解决多特征的线性回归问题。</p>
<p>为尽快让你理解，假设现有多元线性回归并约定$x_{0}=1$。</p>
<p><strong>假设函数(Hypothesis)</strong>如下：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ^{T}x = θ\_{0} x\_{0} + θ\_{1} x\_{1} + θ\_{2} x\_{2} + ... + θ\_{n} x\_{n}</script><p>该模型的参数是从$θ_{0}$到$θ_{n}$，不要认为这是$n+1$个单独的参数。你可以把这$n+1$个$θ$参数想象成一个$n+1$维的向量$θ$。</p>
<p><strong>参数(Parameters)</strong>如下：</p>
<script type="math/tex; mode=display">
θ\_{0} θ\_{1} θ\_{2} ... θ\_{n}</script><p>我们的代价函数是从$θ_{0}$到$θ_{n}$的函数$J$并给出了误差项平方的和。但同样地，不要把函数$J$想成是一个关于$n+1$个自变量的函数而是看成带有一个$n+1$维向量的函数:</p>
<p><strong>代价函数(Cost function)</strong>如下：</p>
<script type="math/tex; mode=display">
J(θ\_{0},θ\_{1},...,θ\_{n}) = 
\frac{1}{2m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})^{2}</script><p><strong>梯度下降法(Gradient descent)</strong>：</p>
<p><img src="/img/16_07_29/003.png" alt=""></p>
<p>我们将会不停地用$θ_{j}$减去$α$倍的导数项来替代$θ_{j}$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">当特征$n=1$时，梯度下降的情况：</th>
<th style="text-align:center">当特征$n&gt;=1$时，梯度下降的情况：</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/16_07_29/004.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_07_29/005.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>下图中，为了更好的理解这个梯度下降更新规则，蓝圈圈起来的部分其实是等价的：</p>
<p><img src="/img/16_07_29/006.png" alt=""></p>
<p>最后，我想让你明白为什么新旧两种算法实际上是一回事儿。</p>
<p>考虑这样一个情况：有两个或以上个数的特征，同时我们有对$θ_{1}$、$θ_{2}$、$θ_{3}$的三条更新规则(当然可能还有其它参数)。如果你观察$θ_{0}$的更新规则，你会发现这跟之前$n=1$的情况相同。它们之所以是等价的，是因为在我们的标记约定里有$x^{i}_{0}=1$。</p>
<p><img src="/img/16_07_29/007.png" alt=""></p>
<p><img src="/img/16_07_29/008.png" alt=""></p>
<p>从上图可以看出，对于$n &gt;= 1$的梯度下降规则，其实是一个通用规则。请务必看懂上图，确保理解之后再继续学习！</p>
<h2 id="梯度下降实用技巧-1：特征缩放-Feature-Scaling-以及均值归一化-mean-normalization"><a href="#梯度下降实用技巧-1：特征缩放-Feature-Scaling-以及均值归一化-mean-normalization" class="headerlink" title="梯度下降实用技巧 1：特征缩放(Feature Scaling)以及均值归一化(mean normalization)"></a>梯度下降实用技巧 1：特征缩放(Feature Scaling)以及均值归一化(mean normalization)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/xx3Da/gradient-descent-in-practice-i-feature-scaling">视频地址</a></p>
<p>在这段视频以及下一段视频中，我想告诉你一些关于梯度下降运算中的实用技巧。</p>
<p>在这段视频中我会告诉你两个称为<strong>特征缩放(feature scaling)</strong>以及<strong>均值归一化(mean normalization)</strong>的方法。</p>
<p>这两个方法都是为了<strong>保证特征的取值在合适的范围内</strong>的。</p>
<h3 id="特征缩放-feature-scaling"><a href="#特征缩放-feature-scaling" class="headerlink" title="特征缩放(feature scaling)"></a><strong>特征缩放(feature scaling)</strong></h3><p>其中，<strong>特征缩放(feature scaling)</strong>大致的思路是这样的：<strong>梯度下降算法中，在有多个特征的情况下，如果你能确保这些不同的特征都处在一个相近的范围，这样梯度下降法就能更快地收敛。</strong></p>
<p>举个例子来说明：</p>
<script type="math/tex; mode=display">
x\_{1} = size(0-2000 feet^{2})\\\\
x\_{2} = 卧室的数量(1-5)</script><p>假如你有一个具有两个特征的问题，其中$x_{1}$是房屋面积大小，它的取值在0到2000之间；$x_{2}$是卧室的数量，可能这个值的取值范围在1到5之间。其代价函数$J(θ)$是一个关于参数$θ_{0}$，$θ_{1}$和$θ_{2}$的函数。但这里我们暂时不考虑$θ_{0}$并假想一个函数的变量只有$θ_{1}$和$θ_{2}$。</p>
<p>如果$x_{1}$的取值范围远远大于$x_{2}$的取值范围的话，那么最终画出来的代价函数$J(θ)$的轮廓图就会呈现出这样一种非常偏斜并且椭圆的形状:</p>
<p><img src="/img/16_07_29/009.png" alt=""></p>
<p>如果你用这个代价函数来运行梯度下降的话，你要得到梯度值最终可能需要花很长一段时间，并且可能会来回波动，然后会经过很长时间最终才收敛到全局最小值。</p>
<p><img src="/img/16_07_29/010.gif" alt=""></p>
<p>事实上如果这些轮廓再被放大一些的话，如果你画的再夸张一些把它画的更细更长，那么可能情况会更糟糕，梯度下降的过程可能更加缓慢，需要花更长的时间反复来回振荡，最终才找到一条正确通往全局最小值的路。</p>
<p>在这样的情况下一种有效的方法是<strong>进行特征缩放(feature scaling)</strong>。</p>
<p>具体来说把特征$x$定义为：</p>
<script type="math/tex; mode=display">
x\_{1} = \frac{size(feet^2)}{2000}</script><script type="math/tex; mode=display">
x\_{2} = \frac{卧室的数量}{5}</script><p>通过这样的变化，表示代价函数$J(θ)$的轮廓图的形状就会变得偏移没那么严重，可能看起来更圆一些了。</p>
<p><img src="/img/16_07_29/011.png" alt=""></p>
<p>如果你用这样的代价函数来执行梯度下降的话，那么可以从数学上来证明梯度下降算法将会找到一条更捷径的路径通向全局最小，而不是像刚才那样  沿着一条让人摸不着头脑的路径，来找到全局最小值。</p>
<p>因此在这个例子中，通过特征缩放，我们最终得到的两个特征$x_{1}$和 $x_{2}$都在0和1之间，这样你得到的梯度下降算法就会更快地收敛。</p>
<p>更一般地，<strong>我们执行特征缩放时，我们通常的目的是将特征的取值约束到$-1$到$+1$的范围内</strong>。其中，特征$x_{0}$总是等于1，因此这已经是在这个范围内了，但对于其他的特征，你可能需要通过除以不同的数来让它们处于同一范围内。</p>
<p>$-1$和$+1$这两个数字并不是太重要，所以如果你有一个特征$x_{1}$它的取值在<code>0 ~ 3</code>之间，这没问题 如果你有另外一个特征取值在<code>-2 ~ +0.5</code>之间，这也没什么关系，因为这也非常接近<code>-1 ~ +1</code>的范围。</p>
<p>但如果你有另一个特征$x_{3}$，假如它的范围在<code>-100 ~ +100</code>之间，那么这个范围跟<code>-1 ~ +1</code>就有很大不同了。所以这可能是一个不那么好的特征。类似地，如果你的特征在一个非常非常小的范围内，比如另外一个特征$x_{4}$，它的范围在<code>-0.0001 ~ +0.0001</code>之间,那么这同样是一个比<code>-1 ~ +1</code>小得多的范围，因此我同样会认为这个特征也不太好。所以可能你认可的范围，也许可以大于或者小于<code>-1 ~ +1</code>，但是也别太大或太小，只要与<code>-1 ~ +1</code>范围偏差不多就可以接受。</p>
<p>因此，总的来说不用过于担心你的特征是否在完全相同的范围或区间内，但是只要它们足够接近的话，梯度下降法就会正常地工作。</p>
<h3 id="均值归一化-mean-normalization"><a href="#均值归一化-mean-normalization" class="headerlink" title="均值归一化(mean normalization)"></a><strong>均值归一化(mean normalization)</strong></h3><p>除了在特征缩放中将特征除以最大值以外，有时候我们也会进行一个称为<strong>均值归一化(mean normalization)</strong>的工作。</p>
<p>具体做法就是：如果你有一个特征$x_{i}$你就用$x_{i} - μ_{i}$来替换。这样做的目的是为了<strong>让你的特征值具有为0的平均值</strong>。很明显 我们不需要把这一步应用到$x_{0}$中，因为$x_{0}$总是等于1的，所以它不可能有为0的的平均值。</p>
<p>但是对其他的特征来说，比如房子的大小取值介于<code>0 ~ 2000</code>，并且假如房子面积的平均值是等于1000的，那么你可以用这个公式 </p>
<script type="math/tex; mode=display">
x\_{1} = \frac{size - 1000}{2000}</script><p>类似地，如果你的房子有五间卧室，并且平均一套房子有两间卧室，那么你可以使用这个公式来归一化你的第二个特征$x_{2}$：</p>
<script type="math/tex; mode=display">
x\_{2} = \frac{卧室数 - 2}{5}</script><p>在这两种情况下你可以算出新的特征$x_{1}$和$x_{2}$，它们的范围可以在<code>-0.5 ~ +0.5</code>之间，当然这肯定不对，$x_{2}$的值实际上肯定会大于0.5。更一般的规律是用:</p>
<script type="math/tex; mode=display">
\frac{x\_{n} - μ\_{n}}{S\_{n}}</script><p>来替换原来的特征$x_{n}$。其中定义$μ_{n}$的意思是在训练集中特征$x_{n}$的平均值。而$S_{n}$是该特征值的范围（最大值减去最小值）。</p>
<blockquote>
<p>最后直的一提的是：特征缩放其实并不需要太精确，其目的只是为了让梯度下降能够运行得更快一点，让梯度下降收敛所需的循环次数更少一些而已。</p>
</blockquote>
<h2 id="梯度下降实用技巧-2：学习速率-Learning-Rate"><a href="#梯度下降实用技巧-2：学习速率-Learning-Rate" class="headerlink" title="梯度下降实用技巧 2：学习速率(Learning Rate)"></a>梯度下降实用技巧 2：学习速率(Learning Rate)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/3iawu/gradient-descent-in-practice-ii-learning-rate">视频地址</a></p>
<p>在本段视频中，我将集中讨论<strong>学习率$α$</strong>。具体来说这是梯度下降算法的更新规则。</p>
<script type="math/tex; mode=display">
θ\_{j} := θ\_{j} -α \frac{∂}{∂θ\_{0}} J(θ)</script><p>这里我想要告诉大家两点： </p>
<ul>
<li>如何调试(Debugging) : 也就是我认为应该如何确定梯度下降是正常工作的。</li>
<li>如何选择学习率$α$ : 如何选择这个参数才能保证梯度下降正常工作。</li>
</ul>
<h3 id="收敛的判断"><a href="#收敛的判断" class="headerlink" title="收敛的判断"></a>收敛的判断</h3><p>梯度下降算法所做的事情就是为你找到一个$θ$值，并希望它能够最小化代价函数$J(θ)$。</p>
<p>我通常会在梯度下降算法运行时，绘出代价函数$J(θ)$的值。这里的$x$轴是表示梯度下降算法的迭代步数：</p>
<p><img src="/img/16_07_29/012.png" alt=""></p>
<blockquote>
<p><strong>注意:</strong>这里的$x$轴是迭代步数，在我们以前看到的$J(θ)$曲线中$x$轴，曾经用来表示参数$θ$但这里不是。</p>
</blockquote>
<p>具体来说，这一点的含义是这样的：比如，当我运行完100步的梯度下降迭代之后，我将得到一个$θ$值，根据这个$θ$值，我将算出代价函数$J(θ)$的值。而这个点的垂直高度就代表梯度下降算法100步迭代之后得到的$θ$算出的$J(θ)$值：</p>
<p><img src="/img/16_07_29/013.png" alt=""></p>
<p>而这个点则是梯度下降算法迭代200次之后得到的$θ$算出的$J(θ)$值：</p>
<p><img src="/img/16_07_29/014.png" alt=""></p>
<p>所以这条曲线显示的是梯度下降算法迭代过程中代价函数$J(θ)$的值。</p>
<p><strong>如果梯度下降算法正常工作，那么每一步迭代之后$J(θ)$都应该下降。</strong></p>
<p>这条曲线中，当迭代达到300步到400步之间时（如下图所示），看起来$J(θ)$并没有下降多少。也就是说在400步迭代的时候，梯度下降算法基本上已经收敛了，因为代价函数并没有继续下降：</p>
<p><img src="/img/16_07_29/015.png" alt=""></p>
<p>所以说，看这条曲线可以帮助你判断梯度下降算法是否已经收敛。</p>
<blockquote>
<p>对于每一个特定的问题，梯度下降算法所需的迭代次数可以相差很大。也许对于某一个问题，梯度下降算法只需要30步迭代就可以收敛，然而换一个问题，也许梯度下降算法就需要3000步迭代，对于另一个机器学习问题则可能需要三百万步迭代。</p>
</blockquote>
<p>实际上，我们很难提前判断梯度下降算法需要多少步迭代才能收敛。通常我们需要画出这类<strong>代价函数随迭代步数数增加的变化曲线</strong>，通常我会通过看这种曲线来试着判断梯度下降算法是否已经收敛。另外也可以进行一些自动的<strong>收敛测试</strong>（也就是说用一种算法来告诉你梯度下降算法是否已经收敛）。</p>
<p>自动收敛测试一个非常典型的例子是：如果代价函数$J(θ)$的下降小于一个很小的值$ε$那么就认为已经收敛。比如可以选择$10^{-3}$作为阈值$ε$。但通常要选择一个合适的阈值$ε$是相当困难的。</p>
<p><strong>因此，为了检查梯度下降算法是否收敛,我实际上还是通过看上边的这条曲线图，而不是依靠自动收敛测试。</strong></p>
<h3 id="判断梯度下降算法是否正常工作"><a href="#判断梯度下降算法是否正常工作" class="headerlink" title="判断梯度下降算法是否正常工作"></a>判断梯度下降算法是否正常工作</h3><p>此外这种曲线图也可以在算法没有正常工作时提前警告你。具体地说如果代价函数$J(θ)$随迭代步数的变化曲线是这个样子:</p>
<p><img src="/img/16_07_29/016.png" alt=""></p>
<p>很明确的表示梯度下降算法没有正常工作，而这样的曲线图通常意味着你应该使用较小的学习率$α$。如果$J(θ)$在上升，那么最常见的原因是你在最小化一个函数时，如果你的学习率太大，梯度下降算法可能将冲过最小值达到最小值另一侧的更大的一个点。下次迭代时，也可能再次冲过最小值，达到更大的一个点，然后一直这样下去。</p>
<p><img src="/img/16_07_29/017.png" alt=""></p>
<p>所以，如果你看到这样一个曲线图，通常的解决方法是使用较小的$α$值，当然也要确保，你的代码中没有错误。</p>
<p>同样的，有时你可能看到这种形状的$J(θ)$曲线:</p>
<p><img src="/img/16_07_29/018.png" alt=""></p>
<p>它先下降，然后上升，接着又下降，然后又上升，然后再次下降，再次上升，如此往复。而解决这种情况的方法通常同样是选择较小$α$值。</p>
<p>我不打算证明这一点，但对于我们讨论的线性回归可以很容易从数学上证明：只要学习率足够小，那么每次迭代之后，代价函数$J(θ)$都会下降。因此如果代价函数没有下降，那可能意味着学习率过大，这时你就应该尝试一个较小的学习率。当然，你也不希望学习度太小，因为如果这样，那么梯度下降算法可能收敛得很慢，你需要迭代很多次才能到达最低点。因此如果学习率$α$太小，梯度下降算法的收敛将会很缓慢。</p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>如果学习率$α$太小，你会遇到收敛速度慢的问题。</strong></li>
<li><strong>如果学习率$α$太大，代价函数$J(θ)$可能不会在每次迭代都下降，甚至可能不收敛。</strong></li>
</ul>
<blockquote>
<p>在某些情况下，如果学习率$α$过大，也可能出现收敛缓慢的问题。</p>
</blockquote>
<h3 id="如何选择-α"><a href="#如何选择-α" class="headerlink" title="如何选择$α$"></a>如何选择$α$</h3><p>为了调试，当我运行梯度下降算法时，我通常会尝试一系列$α$值，比如0.001， 0.01， 0.1， 1 … 这里每隔10倍取一个值，然后对于这些不同的$α$值绘制$J(θ)$随迭代步数变化的曲线，然后选择看上去使得$J(θ)$快速下降的一个$α$值。</p>
<p>事实上在为梯度下降算法选择合适的学习率时，我大致是按3的倍数来取值的。例如：0.001， 0.003， 0、01，0.03，0.1，0.3，1…</p>
<p>所以我会尝试一系列$α$值，直到我找到不能再小了的值，同时找到另一个不能再大的值，然后我尽量挑选其中最大的那个$α$值，或者一个比最大值略小一些的合理的值。当我做了以上工作时，我通常就可以得到一个不错的学习率。</p>
<h2 id="特征的选择和多项式回归"><a href="#特征的选择和多项式回归" class="headerlink" title="特征的选择和多项式回归"></a>特征的选择和多项式回归</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Rqgfz/features-and-polynomial-regression">视频地址</a></p>
<p>你现在了解了多变量的线性回归，在本节中我想告诉你一些用来选择特征的方法，以及如何得到不同的学习算法。当选择了合适的特征后，这些算法往往是非常有效的。另外，我也想给你们讲一讲多项式回归，它使得你们能够使用，线性回归的方法来拟合非常复杂的函数，甚至是非线性函数。</p>
<h3 id="特征的选择"><a href="#特征的选择" class="headerlink" title="特征的选择"></a>特征的选择</h3><p>以预测房价为例，假设你有两个特征，分别是房子临街的宽度和垂直宽度。这就是我们想要卖出的房子的图片：</p>
<p><img src="/img/16_07_29/019.png" alt=""></p>
<p>临街宽度其实就是拥有的土地的宽度，而纵向深度就是你的房子的深度。你可能会建立一个像这样的线性回归模型：</p>
<p><strong>Housing prices prediction</strong></p>
<script type="math/tex; mode=display">
h\_{θ}(x) = Θ\_{0} + Θ\_{1} × frontage + Θ\_{2} × depth</script><p>其中临街宽度是你的第一个特征$frontage$，纵深是你的第二个特征$depth$。但当我们在运用线性回归时，你不一定非要直接用给出的$frontage$和$depth$作为特征，其实你可以自己创造新的特征。因此，如果我要预测房子的价格，我真正要需做的也许是确定真正能够决定我房子大小，或者说我土地大小的因素是什么。因此，我可能会创造一个新的特征，我称之为$x$。它是临街宽度与纵深的乘积：</p>
<script type="math/tex; mode=display">
x = frontage × depth</script><script type="math/tex; mode=display">
h\_{θ}(x) = Θ\_{0} + Θ\_{1}x</script><p>这得到的就是我拥有的土地的面积。然后我可以把假设选择为使其只使用一个特征，也就是我的土地的面积。</p>
<p>由于矩形面积的计算方法是矩形长和宽相乘，因此这取决于你从什么样的角度去审视一个特定的问题，而不是直接去使用临街宽度和纵深，这两个我们只是碰巧在开始时使用的特征。有时通过定义新的特征，你确实会得到一个更好的模型。</p>
<h3 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h3><p>与选择特征的想法密切相关的一个概念，被称为<strong>多项式回归(polynomial regression)</strong>。</p>
<p>比方说你有这样一个住房价格的数据集：</p>
<p><img src="/img/16_07_29/020.png" alt=""></p>
<p>为了拟合它，可能会有多个不同的模型供选择。其中一个你可以选择的是像这样的二次模型：</p>
<script type="math/tex; mode=display">
θ\_{0} + θ\_{1}x + θ\_{2}x^{2}</script><p>因为直线似乎并不能很好地拟合这些数据，因此也许你会想到用这样的二次模型去拟合数据。</p>
<p>但是你可能会觉得二次函数的模型并不好用，因为一个二次函数最终会降回来。而我们并不认为房子的价格在高到一定程度后会下降回来：</p>
<p><img src="/img/16_07_29/021.png" alt=""></p>
<p>因此也许我们会选择一个不同的多项式模型，并转而选择使用一个三次函数：</p>
<script type="math/tex; mode=display">
θ\_{0} + θ\_{1}x + θ\_{2}x^{2} + θ\_{3}x^{3}</script><p>我们用这个三次函数进行拟合，我们可能得到这样的模型（绿线部分）：</p>
<p><img src="/img/16_07_29/022.png" alt=""></p>
<p>也许这条绿色的线对这个数据集拟合得更好，因为它不会在最后下降回来。</p>
<p>那么，我们到底应该如何将模型与我们的数据进行拟合呢？使用多元线性回归的方法，我们可以通过将我们的算法做一个非常简单的修改来实现它：</p>
<script type="math/tex; mode=display">
\begin{align\*} 
h\_{θ}(x) &= θ\_{0} + θ\_{1}x\_{1} + θ\_{2}x\_{2} + θ\_{3}x\_{3}
\\\\&=
θ\_{0} + θ\_{1}(size) + θ\_{2}(size)^{2} + θ\_{3}(size)^{3}
\end{align\*}</script><script type="math/tex; mode=display">
x\_{1} = (size) \\\\
x\_{2} = (size)^{2} \\\\
x\_{3} = (size)^{3} \\\\</script><p>我还想再说一件事，如果你像这样选择特征，那么特征的归一化就变得更重要了。因此，如果房子的大小范围在<code>1</code>到<code>1000</code>之间，那么房子面积的平方的范围就是<code>1</code>到<code>10000000</code>（也就是$1000^{2}$），而你的第三个特征$x_{3}$ 它是房子面积的立方,范围会扩大到1到$10^{9}$。这三个特征的范围有很大的不同，因此，如果你使用梯度下降法，应用特征值的归一化是非常重要的，这样才能将他们的值的范围变得具有可比性。</p>
<p>最后一个例子，除了建立一个三次模型以外，你也许有其他的选择特征的方法。这里有很多可能的选项，但是给你另外一个合理的选择的例子：</p>
<script type="math/tex; mode=display">
h\_{θ}(x) = θ\_{0} + θ\_{1}(size) + θ\_{2}\sqrt{(size)}</script><p>这样的一种函数曲线看起来趋势是上升的，但慢慢变得平缓一些，而且永远不会下降回来：</p>
<p><img src="/img/16_07_29/023.png" alt=""></p>
<p>在这段视频中，我们探讨了多项式回归。也就是如何将一个多项式如一个二次函数或一个三次函数拟合到你的数据上。除了这个方面我们还讨论了：在使用特征时的选择性。例如：我们不使用房屋的临街宽度和纵深，也许你可以把它们乘在一起从而得到房子的土地面积这个特征。实际上这似乎有点难以抉择，这里有这么多不同的特征选择，我该如何决定使用什么特征呢？</p>
<p>在之后的课程中我们将探讨一些算法，它们能够<strong>自动选择要使用什么特征</strong>。因此你可以使用一个算法观察给出的数据，并自动为你选择到底应该选择一个二次函数，或者一个三次函数，还是别的函数。但是，在我们学到那种算法之前，现在我希望你知道，你需要选择使用什么特征并且通过设计不同的特征，你能够用更复杂的函数去拟合你的数据，而不是只用一条直线去拟合。特别是你也可以使用多项式函数，有时候通过采取适当的角度来观察 特征就可以得到一个更符合你的数据的模型。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第二周 (3)参数的计算分析</title>
    <url>/2016/08/12/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E5%91%A8%20(3)%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="正规方程-Normal-Equation"><a href="#正规方程-Normal-Equation" class="headerlink" title="正规方程(Normal Equation)"></a>正规方程(Normal Equation)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/2DKxQ/normal-equation">视频地址</a></p>
<p>这一节我们要讲<strong>正规方程(Normal Equation)</strong>。对于某些线性回归问题，用正规方程法求解参数$θ$的最优值更好。具体而言，到目前为止，我们一直在使用的线性回归的算法是<strong>梯度下降法</strong>，就是说，为了最小化代价函数$J(θ)$，我们通过多次迭代来计算梯度下降，来收敛到全局最小值。相反地，<strong>正规方程法提供了一种可以直接一次性求解$θ$的最优值的解法</strong>。</p>
<p>首先让我们先对这个算法有一个直观的理解，我们举一个例子来解释这个问题：</p>
<p><img src="/img/16_08_12/001.png" alt=""></p>
<p>我们假设有一个非常简单的代价函数$J(θ)$，它就是一个实数$θ$的函数，所以现在假设$θ$只是一个标量($θ$只有一行，它是一个数字，不是向量)。假设我们的代价函数$J$是这个实参数$θ$的二次函数，所以$J(θ)$看起来是这样的:</p>
<p><img src="/img/16_08_12/002.png" alt=""></p>
<p>那么如何最小化一个二次函数呢? 对于那些了解一点微积分的同学来说，你可能知道最小化的一个函数的方法是对它求导，并且将导数置零。这样你就可以求得使得$J(θ)$最小的$θ$值。</p>
<p>在实际情况中，我们感兴趣的是$θ$为$n+1$维参数向量的情况，如下：</p>
<p><img src="/img/16_08_12/003.png" alt=""></p>
<p>我们如何最小化这个代价函数$J$?实际上微积分告诉我们一种方法: 对每个参数$θ$求$J$的偏导数，然后把它们全部置零。如果你这样做 并且求出$θ_{0}$，$θ_{1}$，一直到$θ_{n}$的值，这样就能得到能够最小化代价函数$J$的$θ$值。</p>
<p><img src="/img/16_08_12/004.png" alt=""></p>
<h3 id="正规方程法-实例"><a href="#正规方程法-实例" class="headerlink" title="正规方程法 实例"></a>正规方程法 实例</h3><p>举个实现正规方程法的例子：</p>
<p>假如说我有$m=4$个训练样本，训练集如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Size($feet^{2}$)</strong></th>
<th style="text-align:center"><strong>Number of bedrooms</strong></th>
<th style="text-align:center"><strong>Number of floors</strong></th>
<th style="text-align:center"><strong>Age of home(years)</strong></th>
<th style="text-align:center"><strong>Price($1000)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x_{1}$</td>
<td style="text-align:center">$x_{2}$</td>
<td style="text-align:center">$x_{3}$</td>
<td style="text-align:center">$x_{4}$</td>
<td style="text-align:center">$y$</td>
</tr>
<tr>
<td style="text-align:center">2104</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">45</td>
<td style="text-align:center">460</td>
</tr>
<tr>
<td style="text-align:center">1416</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">40</td>
<td style="text-align:center">232</td>
</tr>
<tr>
<td style="text-align:center">1534</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">30</td>
<td style="text-align:center">315</td>
</tr>
<tr>
<td style="text-align:center">852</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">36</td>
<td style="text-align:center">178</td>
</tr>
</tbody>
</table>
</div>
<p>我们假设这4个训练样本就是我的所有数据，另外我所要做的是在我的训练集中加上一列对应额外特征变量的$x_{0}$(就是那个取值永远是1的)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>Size($feet^{2}$)</strong></th>
<th style="text-align:center"><strong>Number of bedrooms</strong></th>
<th style="text-align:center"><strong>Number of floors</strong></th>
<th style="text-align:center"><strong>Age of home(years)</strong></th>
<th style="text-align:center"><strong>Price($1000)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$x_{0}$</td>
<td style="text-align:center">$x_{1}$</td>
<td style="text-align:center">$x_{2}$</td>
<td style="text-align:center">$x_{3}$</td>
<td style="text-align:center">$x_{4}$</td>
<td style="text-align:center">$y$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2104</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">45</td>
<td style="text-align:center">460</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1416</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">40</td>
<td style="text-align:center">232</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1534</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">30</td>
<td style="text-align:center">315</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">852</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">36</td>
<td style="text-align:center">178</td>
</tr>
</tbody>
</table>
</div>
<p>接下来我要做的是构建一个矩阵$X$，这个矩阵基本包含了训练样本的所有特征变量：</p>
<script type="math/tex; mode=display">
X = 
\begin{bmatrix}
1 & 2104 & 5 & 1 & 45 \\\\
1 & 1416 & 3 & 2 & 40 \\\\
1 & 1534 & 3 & 2 & 30 \\\\
1 & 852 & 2 & 1 & 36 
\end{bmatrix}</script><p>我要对$y$做类似的事情:</p>
<script type="math/tex; mode=display">
y = 
\begin{bmatrix}
460 \\\\
232 \\\\
315 \\\\
178 
\end{bmatrix}</script><p>最后，你可以通过下面这个方程来计算使得代价函数最小化的$θ$:</p>
<script type="math/tex; mode=display">
θ = (X^{T}X)^{-1}X^{T}y</script><p>这样就得到能够使得代价函数最小化的$θ$。</p>
<p>让我把这个写成更加通用的形式，在之后的视频中我会仔细介绍这个方程，以防你不完全清楚要如何做。</p>
<p>在一般情况下，假如我们有$m$个训练样本:</p>
<script type="math/tex; mode=display">
(x^{(1)},y^{(1)}),...,(x^{(m)},y^{(m)})</script><p>$n$个特征变量:</p>
<script type="math/tex; mode=display">
x^{(i)} = 
\begin{bmatrix}
x\_{0}^{(i)} \\\\
x\_{1}^{(i)} \\\\
x\_{2}^{(i)} \\\\
... \\\\
x\_{n}^{(i)} 
\end{bmatrix}
\in
\mathbb{R}^{n+1}</script><p>每一个训练样本$x^{(i)}$看起来像一个$n+1$维的特征向量。</p>
<p>我要构建矩阵$X$，也被称为<strong>设计矩阵(design matrix)</strong>。如下所示：</p>
<script type="math/tex; mode=display">
X = 
\begin{bmatrix}
(x^{(1)})^{T} \\\\
(x^{(2)})^{T} \\\\
(x^{(3)})^{T} \\\\
... \\\\
(x^{(m)})^{T} \\\\
\end{bmatrix}
=
\begin{bmatrix}
x\_{0}^{(1)} & x\_{1}^{(1)} & x\_{2}^{(1)} & ... &x\_{n}^{(1)} \\\\
x\_{0}^{(2)} & x\_{1}^{(2)} & x\_{2}^{(2)} & ... &x\_{n}^{(2)} \\\\
x\_{0}^{(3)} & x\_{1}^{(3)} & x\_{2}^{(3)} & ... &x\_{n}^{(3)} \\\\
... \\\\
x\_{0}^{(m)} & x\_{1}^{(m)} & x\_{2}^{(m)} & ... &x\_{n}^{(m)} \\\\
\end{bmatrix}</script><p>矩阵$X$是一个$m * (n+1)$维矩阵。</p>
<p>举个具体的例子：假如我只有一个特征变量(就是说除了$x_{0}$之外只有一个特征变量，而$x_{0}$始终为1)，比如说房屋的大小：</p>
<script type="math/tex; mode=display">
x^{(i)} = 
\begin{bmatrix}
1 \\\\
x^{(i)}\_{1} 
\end{bmatrix}</script><p>那么我的设计矩阵$X$会是这样：</p>
<script type="math/tex; mode=display">
X = 
\begin{bmatrix}
1 & x^{(1)}\_{1}\\\\
1 & x^{(1)}\_{2}\\\\
...
1 & x^{(1)}\_{mysql}\\\\
\end{bmatrix}</script><p>向量$y$代表所有训练集中正确的房屋价格，是这样的：</p>
<script type="math/tex; mode=display">
y = 
\begin{bmatrix}
y^{1} \\\\
y^{2} \\\\
...
y^{m} \\\\
\end{bmatrix}</script><p>最后，构建完矩阵$X$和向量$y$，我们就可以通过计算：</p>
<script type="math/tex; mode=display">
θ = (X^{T}X)^{-1}X^{T}y</script><p>来得到$θ$。</p>
<blockquote>
<p>这就是通过正规方程来求解最优的$θ$值的过程，在数学上可以证明这个式子会给出最优的$θ$值，可以最小化代价函数$J(θ)$，但在这里我并不打算给出证明过程。</p>
</blockquote>
<h3 id="使用Octave来执行正规方程"><a href="#使用Octave来执行正规方程" class="headerlink" title="使用Octave来执行正规方程"></a>使用Octave来执行正规方程</h3><script type="math/tex; mode=display">
θ = (X^{T}X)^{-1}X^{T}y</script><p>这个方程在Octave中的表达方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pinv(X&#96;*X)*X&#96;*y</span><br></pre></td></tr></table></figure>
<p>其中X`代表X的转置，pinv是用来计算矩阵的逆的函数。</p>
<h3 id="正规方程不需要对特征变量归一化"><a href="#正规方程不需要对特征变量归一化" class="headerlink" title="正规方程不需要对特征变量归一化"></a>正规方程不需要对特征变量归一化</h3><p>在之前视频中我提到<strong>特征变量归一化</strong>和让特征变量在相似的范围内的想法将所有的值归一化在类似范围内。<strong>如果你使用正规方程法 那么就不需要归一化特征变量，实际上这是没问题的</strong>。</p>
<p>例如：$x_{1}$在0到1的区间，$x_{2}$在0到1000的区间，$x_{3}$在0到$10^{-5}$的区间，如果使用正规方程法，不需要做特征变量归一化也是没有问题的，<strong>但如果你使用梯度下降法，特征变量归一化就很重要</strong>。</p>
<h3 id="梯度下降法VS正规方程"><a href="#梯度下降法VS正规方程" class="headerlink" title="梯度下降法VS正规方程"></a>梯度下降法VS正规方程</h3><p>最后你何时应该使用梯度下降法，而何时应该使用正规方程法呢？这里列举了一些它们的优点和缺点：</p>
<p>假如你有$m$个训练样本和$n$个特征变量 :</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">梯度下降算法</th>
<th style="text-align:center">正规方程法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">需要选择一个学习速率$α$</td>
<td style="text-align:center">不需要选择一个学习速率$α$</td>
</tr>
<tr>
<td style="text-align:center">需要多次迭代</td>
<td style="text-align:center">不需要多次迭代</td>
</tr>
<tr>
<td style="text-align:center">当$n$很大时也能良好运行</td>
<td style="text-align:center">需要计算$(X^{T}X)^{-1}$</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">当$n$很大时，运行会很慢(因为复杂度为:$O(n^3)$)</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>那么在什么情况下会考虑使用梯度下降算法呢？ 通常$n<10000$的情况下，建议使用正规方程法，当$n>10000$时，建议使用梯度下降法。</p>
</blockquote>
<p>随着我们要讲的学习算法越来越复杂，例如当我们讲到分类算法：像逻辑回归算法，我们会看到实际上对于那些问题，并不能使用正规方程法。对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题，因为标准方程法不适合用在它们上。但对于特征变量比较少的情况下，正规方程法是一个比梯度下降法更快的替代算法。所以这两算法都是值得学习的。</p>
<h2 id="正规方程法的不可逆性"><a href="#正规方程法的不可逆性" class="headerlink" title="*正规方程法的不可逆性"></a>*正规方程法的不可逆性</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/zSiE6/normal-equation-noninvertibility">视频地址</a></p>
<p>在这段视频中我想谈谈正规方程(normal equation)以及它们的不可逆性。由于这是一种较为深入的概念，并且总有人问我有关这方面的问题，因此我想在这里来讨论它。由于概念较为深入，所以对这段可选材料大家放轻松吧，也许你可能会深入地探索下去并且会觉得理解以后会非常有用，但即使你没有理解正规方程和线性回归的关系也没有关系。</p>
<p>首先，我们知道，并不是所有的矩阵都是可逆的，不可逆的矩阵被称为<strong>奇异矩阵</strong>或<strong>退化矩阵</strong></p>
<p>那么当计算</p>
<script type="math/tex; mode=display">
θ = (X^{T}X)^{-1}X^{T}y</script><p>时，当$X^{T}X$不可逆时，怎么办呢？</p>
<p>问题的关键在于实际上$X^{T}X$不可逆的情况很少发生。</p>
<p>在Octave里，如果你用它来实现θ的计算 你将会得到一个正常的解 </p>
<blockquote>
<p>在Octave里有两个函数可以求解矩阵的逆，一个是pinv()另一个是inv()。这两者之间的差异是些许计算过程上的，一个是所谓的伪逆，另一个被称为逆。使用pinv()函数可以展现数学上的过程，它可以在即便矩阵$X^{T}X$是不可逆的的情况下，计算出$θ$的值。另外在计算法方面，inv()引入了先进的数值计算的概念。</p>
</blockquote>
<p>下面来看看$X^{T}X$不可逆的情况的处理：</p>
<p>关于矩阵$X^{T}X$的不可逆的问题，如果你懂一点线性代数或许你会感兴趣。我不会从数学的角度来证明它，但如果矩阵$X^{T}X$结果是不可逆的通常有两种最常见的原因：</p>
<ul>
<li><p>第一个原因是，多余的特征（线性依赖）：</p>
<p>  例如：</p>
<script type="math/tex; mode=display">
  x\_{1} = size\ in\ feet^{2}</script><script type="math/tex; mode=display">
  x\_{2} = size\ in\ m^{2}</script><p>  在预测住房价格时,如果$x_{1}$是以英尺为尺寸规格计算的房子，$x_{2}$是以平方米为尺寸规格计算的房子，同时你也知道1米等于3.28英尺(四舍五入到两位小数)。这样你的这两个特征值将始终满足约束$x_{1}=(3.28)^{2}$x_{2}$，这种矩阵$X^{T}X$是不可逆的。</p>
</li>
</ul>
<ul>
<li><p>第二个原因是，过多的特征($m\leq{n}$)：</p>
<p>  在你想用大量的特征值尝试实践你的学习算法的时候，可能会导致矩阵$X^{T}X$的结果是不可逆的。具体地说，在$m\leq{n}$的时候不可逆。</p>
<p>  例如有$m=10$的训练样本，也有$n=100$的特征数量，仅仅通过10各训练样本来适应这100个特征向量，数据还是有些少。稍后我们将看到，如何使用小数据样本以得到这100或101个参数。通常我们会使用一种叫做<strong>正则化</strong>的线性代数方法通过删除某些特征，或者是使用某些技术来解决当$m\leq{n}$小的时候的问题，这也是在本节课后面要讲到的内容。即使你有一个相对较小的训练集，也可使用很多的特征来找到很多合适的参数。</p>
<p>  有关正规化的内容将是本节之后课程的话题，总之当你发现的矩阵$X^{T}X$的结果是奇异矩阵(不可逆)，建议你：</p>
<ul>
<li>首先看特征值里是否有一些多余的特征，例如$x_{1}$和$x_{2}$是否线性相关，同时当有一些多余的特征时，可以删除这两个重复特征里的其中一个，无须两个特征同时保留,直到他们不再是多余的为止。</li>
<li><p>其次如果特征里没有多余的，我会检查是否有过多的特征，如果特征数量实在太多，我会删除些用较少的特征来反映尽可能多内容</p>
<p>否则我会考虑使用正规化方法，这也是我们将要谈论的话题。</p>
</li>
</ul>
</li>
</ul>
<p>总之出现不可逆矩阵的情况极少发生，所以在大多数实现线性回归中，出现不可逆的问题不应该过多的关注。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第二周 (4)Octave/Matlab 使用说明</title>
    <url>/2016/08/13/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%8C%E5%91%A8%20(4)Octave:Matlab%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>你现在已经掌握不少机器学习知识了，在这段视频中我将教你一种编程语言：Octave语言。你能够用它来非常迅速地实现这门课中我们已经学过或者将要学的机器学习算法。</p>
<p>过去我一直尝试用不同的编程语言来教授机器学习，包括C++、Java、 Python、Numpy 和 Octave。我发现当使用像Octave这样的高级语言时，学生能够更快、更好地学习并掌握这些算法。事实上，在硅谷我经常看到的情况是进行大规模的机器学习项目的人通常会使用的程序语言就是Octave。</p>
<p>Octave是一种很好的原始语言(prototyping language)。使用Octave你能快速地实现你的算法，剩下的事情你只需要进行大规模的资源配置，你只用再花时间用C++或Java这些语言把算法重新实现就行了。因为我们知道，开发项目的时间或者说你的时间是很宝贵的，机器学习的时间也是很宝贵的。所以如果你能让你的学习算法在Octave上快速的实现，再用C++或者Java去改写，这样你就能节省出大量的时间。</p>
<p>据我所见人们使用最多的用于机器学习的原始语言是Octave、MATLAB、Python、NumPy和R。Octave很好因为它是开源的，当然 MATLAB也很好，但它不是每个人都买得起的。如果你能够使用MATLAB，Python、NumPy 或者R语言，你也可以在这门课里面使用。我也见过有人用R的，但是据我所知，这些人不得不中途放弃了，因为这些语言在开发上比较慢。而且因为Python、NumPy这些语言的语法相较于Octave来说还是更麻烦一点，正因为这样我强烈建议你不要用NumPy或者R来完整这门课的作业，我建议你在这门课中用Octave来写程序。</p>
</blockquote>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/9fHfl/basic-operations">视频地址</a></p>
<p>这是Octave的命令行界面：</p>
<p><img src="/img/16_08_13/001.png" alt=""></p>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>首先示范一下基本的加、减、乘、除、指数运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">octave:1&gt; 5+6</span><br><span class="line">ans &#x3D;  11</span><br><span class="line">octave:2&gt; 3-2</span><br><span class="line">ans &#x3D;  1</span><br><span class="line">octave:3&gt; 5*8</span><br><span class="line">ans &#x3D;  40</span><br><span class="line">octave:4&gt; 1&#x2F;2</span><br><span class="line">ans &#x3D;  0.50000</span><br><span class="line">octave:5&gt; 2^6</span><br><span class="line">ans &#x3D;  64</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算："><a href="#逻辑运算：" class="headerlink" title="逻辑运算："></a>逻辑运算：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">octave:6&gt; 1 &#x3D;&#x3D; 2  % false</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">octave:7&gt; 1 ~&#x3D; 2</span><br><span class="line">ans &#x3D;  1</span><br><span class="line">octave:8&gt; 1 &amp;&amp; 0  % AND</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">octave:9&gt; 1 || 0  % OR</span><br><span class="line">ans &#x3D;  1</span><br><span class="line">octave:10&gt; xor(1,0)</span><br><span class="line">ans &#x3D;  1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得说明的是，其中<code>%</code>代表注释符号，<code>~=</code>代表不等于，<code>xor()</code>是异或符号。</p>
</blockquote>
<h3 id="修改等待命令的快捷提示"><a href="#修改等待命令的快捷提示" class="headerlink" title="修改等待命令的快捷提示"></a>修改等待命令的快捷提示</h3><p>通过<code>PS1()</code>命令来设置等待命令的快捷提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">octave:11&gt; PS1(&quot;&gt;&gt; &quot;)</span><br><span class="line">&gt;&gt; </span><br><span class="line">&gt;&gt; </span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>
<h3 id="赋值运算："><a href="#赋值运算：" class="headerlink" title="赋值运算："></a>赋值运算：</h3><p>赋值运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; 3</span><br><span class="line">a &#x3D;  3</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>如果不希望在屏幕上显示结果，只需要结尾加<code>;</code>即可抑制打印输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; 3;  % semicolon supressing output</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>
<h3 id="变量的打印输出"><a href="#变量的打印输出" class="headerlink" title="变量的打印输出"></a>变量的打印输出</h3><p>变量的赋值与打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; b &#x3D; &quot;hi&quot;;</span><br><span class="line">&gt;&gt; b</span><br><span class="line">b &#x3D; hi</span><br><span class="line">&gt;&gt; c &#x3D; (3&gt;&#x3D;1);</span><br><span class="line">&gt;&gt; c</span><br><span class="line">c &#x3D;  1</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>对于一些复杂的输出，可以使用<code>disp</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; pi;</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.1416</span><br><span class="line">&gt;&gt; disp(a)</span><br><span class="line"> 3.1416</span><br><span class="line">&gt;&gt; disp(sprintf(&#39;2 decimals: %0.2f&#39;, a))</span><br><span class="line">2 decimals: 3.14</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>控制输出长短：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.1416</span><br><span class="line">&gt;&gt; format long</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.14159265358979</span><br><span class="line">&gt;&gt; format short</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  3.1416</span><br><span class="line">&gt;&gt; </span><br></pre></td></tr></table></figure>
<h3 id="矩阵的表示"><a href="#矩阵的表示" class="headerlink" title="矩阵的表示"></a>矩阵的表示</h3><p>表示一个三行两列的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外一种表示矩阵的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2;</span><br><span class="line">&gt; 3 4;</span><br><span class="line">&gt; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分配一个一行三列的行向量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; [1 2 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>分配一个三行一列的列向量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; [1; 2; 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表示一个行向量，其中第一个值是起始值，中间的值是步长，最后一个值是终止值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; 1:0.1:2</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line"> Columns 1 through 8:</span><br><span class="line"></span><br><span class="line">    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000</span><br><span class="line"></span><br><span class="line"> Columns 9 through 11:</span><br><span class="line"></span><br><span class="line">    1.8000    1.9000    2.000</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>也可以不写步长，这样默认步长是1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; 1:6</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3   4   5   6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生成元素为1的矩阵"><a href="#生成元素为1的矩阵" class="headerlink" title="生成元素为1的矩阵"></a>生成元素为1的矩阵</h3><p>生成一个2行3列，所有元素都为1的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ones(2,3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1</span><br><span class="line">   1   1   1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成一个2行3列，所有元素都为2的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 2*ones(2,3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2</span><br><span class="line">   2   2   2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生成0矩阵"><a href="#生成0矩阵" class="headerlink" title="生成0矩阵"></a>生成0矩阵</h3><p>生成一个1行3列的0矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; w &#x3D; zeros(1,3)</span><br><span class="line">w &#x3D;</span><br><span class="line"></span><br><span class="line">   0   0   0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="生成随机数矩阵"><a href="#生成随机数矩阵" class="headerlink" title="生成随机数矩阵"></a>生成随机数矩阵</h3><p>生成一个元素为介于0到1之间随机数的1行3列的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; w &#x3D; rand(1,3)</span><br><span class="line">w &#x3D;</span><br><span class="line"></span><br><span class="line">   0.65555   0.77468   0.85729</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>均值为0的高斯分布：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; w &#x3D; randn(1,3)</span><br><span class="line">w &#x3D;</span><br><span class="line"></span><br><span class="line">   0.61607   0.53219   1.48783</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-6加上根号10乘以一个一行10000列的正太分布的随机向量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; w &#x3D; -6 + sqrt(10)*(randn(1,10000));</span><br></pre></td></tr></table></figure>
<h3 id="绘制函数"><a href="#绘制函数" class="headerlink" title="绘制函数"></a>绘制函数</h3><p>绘制这个直方图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; hist(w)</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/002.png" alt=""></p>
<p>绘制有50条的直方图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; hist(w,50)</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/003.png" alt=""></p>
<h3 id="生成单位矩阵"><a href="#生成单位矩阵" class="headerlink" title="生成单位矩阵"></a>生成单位矩阵</h3><p>生成矩阵的特殊命令：<code>eye</code>，可用来生成单位矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; eye(5)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0   0   0</span><br><span class="line">   0   1   0   0   0</span><br><span class="line">   0   0   1   0   0</span><br><span class="line">   0   0   0   1   0</span><br><span class="line">   0   0   0   0   1</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>help</code>命令，后面跟任何其他指令，都可以查看该指令的说明文档，包括help自身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; help eye</span><br></pre></td></tr></table></figure>
<h2 id="移动数据"><a href="#移动数据" class="headerlink" title="移动数据"></a>移动数据</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/SZJIc/moving-data-around">视频地址</a></p>
<p>这一节将介绍，如何加载外部数据到Octave中，以及存储Octave的数据到文件中的一些操作。</p>
<p>首先，创建一个3行2列的矩阵A：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查看矩阵尺寸"><a href="#查看矩阵尺寸" class="headerlink" title="查看矩阵尺寸"></a>查看矩阵尺寸</h3><p>通过<code>size</code>命令，我们能看到这个矩阵的尺寸：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; size(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上<code>size</code>的这个输出结果自身也是一个矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; sz &#x3D; size(A)</span><br><span class="line">sz &#x3D;</span><br><span class="line"></span><br><span class="line">   3   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(sz)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>分别查看A向量的size的输出结果中的两个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; size(A,1)</span><br><span class="line">ans &#x3D;  3</span><br><span class="line">&gt;&gt; size(A,2)</span><br><span class="line">ans &#x3D;  2</span><br></pre></td></tr></table></figure>
<h3 id="查看矩阵最大维度"><a href="#查看矩阵最大维度" class="headerlink" title="查看矩阵最大维度"></a>查看矩阵最大维度</h3><p><code>length</code>指令，来获取矩阵的最大维度，这个命令其实通常只对向量使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; [1 2 3 4]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3   4</span><br><span class="line"></span><br><span class="line">&gt;&gt; length(v)</span><br><span class="line">ans &#x3D;  4</span><br><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; length(A)</span><br><span class="line">ans &#x3D;  3</span><br></pre></td></tr></table></figure>
<h3 id="设置Octave当前路径"><a href="#设置Octave当前路径" class="headerlink" title="设置Octave当前路径"></a>设置Octave当前路径</h3><p>当我们打开Octave的时候，其实我们已经处在了一个默认路径下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; pwd</span><br><span class="line">ans &#x3D; &#x2F;Users&#x2F;lijianan</span><br></pre></td></tr></table></figure>
<p>这个路径是Octave的安装位置。我们可以改变当前目录到桌面目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; cd &#x2F;Users&#x2F;lijianan&#x2F;Desktop</span><br><span class="line">&gt;&gt; pwd</span><br><span class="line">ans &#x3D; &#x2F;Users&#x2F;lijianan&#x2F;Desktop</span><br></pre></td></tr></table></figure>
<h3 id="加载外部文件"><a href="#加载外部文件" class="headerlink" title="加载外部文件"></a>加载外部文件</h3><p>目前我的桌面目录下有两个存有数据的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ls</span><br><span class="line">FeaturesX.dat 	PriceY.dat</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/004.gif" alt=""></p>
<p>通过<code>load</code>命令，加载外部文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; load featuresX.dat</span><br><span class="line">&gt;&gt; load priceY.dat</span><br></pre></td></tr></table></figure>
<p>你也可以使用<code>load()</code>的方式来加载，效果相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; load(&#39;featuresX.dat&#39;)</span><br><span class="line">&gt;&gt; load(&#39;priceY.dat&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="查看存储变量"><a href="#查看存储变量" class="headerlink" title="查看存储变量"></a>查看存储变量</h3><p>我们可以使用<code>who</code>命令来查看当前Octave中存储的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; who</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">A          ans        c          priceY     v</span><br><span class="line">a          b          featuresX  sz         w</span><br></pre></td></tr></table></figure>
<p><code>whos</code>命令可以查看更详细的信息，包括尺寸，内存占用，以及类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; whos</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">   Attr Name           Size                     Bytes  Class</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;           &#x3D;&#x3D;&#x3D;&#x3D;                     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">        A              3x2                         48  double</span><br><span class="line">        a              1x1                          8  double</span><br><span class="line">        ans            1x2                         16  double</span><br><span class="line">        b              1x2                          2  char</span><br><span class="line">        c              1x1                          1  logical</span><br><span class="line">        featuresX     47x2                        752  double</span><br><span class="line">        priceY        47x1                        376  double</span><br><span class="line">        sz             1x2                         16  double</span><br><span class="line">        v              1x4                         32  double</span><br><span class="line">        w              1x10000                  80000  double</span><br><span class="line"></span><br><span class="line">Total is 10159 elements using 81251 bytes</span><br></pre></td></tr></table></figure>
<p>可以看到<code>featuresX</code>和<code>priceY</code>已经被成功的被作为一个变量加载进来了，我们可以直接输入<code>featuresX</code>来查看这个变量的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; featuresX</span><br><span class="line"></span><br><span class="line">featuresX &#x3D;</span><br><span class="line"></span><br><span class="line">   2104      3</span><br><span class="line">   1600      3</span><br><span class="line">   2400      3</span><br><span class="line">   1416      2</span><br><span class="line">   3000      4</span><br><span class="line">   1985      4</span><br><span class="line">   1534      3</span><br><span class="line">   1427      3</span><br><span class="line">   1380      3</span><br><span class="line">   1494      3</span><br><span class="line">   1940      4</span><br><span class="line">   2000      3</span><br><span class="line">   1890      3</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>通过<code>size()</code>函数，我们可以看到<code>featuresX</code>是一个47行2列的矩阵，<code>priceY</code>是一个47行1列的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; size(featuresX)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   47    2</span><br><span class="line"></span><br><span class="line">&gt;&gt; size(priceY)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   47    1</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>可以使用<code>clear</code>命令来删除某个变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; who</span><br><span class="line">Variables in the current scope:</span><br><span class="line"></span><br><span class="line">A       a       ans     b       c       priceY  sz      v       w</span><br></pre></td></tr></table></figure>
<h3 id="截取矩阵部分元素"><a href="#截取矩阵部分元素" class="headerlink" title="截取矩阵部分元素"></a>截取矩阵部分元素</h3><p>将<code>priceY</code>的前10个元素存入变量<code>V</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; V &#x3D; priceY(1:10)</span><br><span class="line">V &#x3D;</span><br><span class="line"></span><br><span class="line">   3999</span><br><span class="line">   3299</span><br><span class="line">   3690</span><br><span class="line">   2320</span><br><span class="line">   5399</span><br><span class="line">   2999</span><br><span class="line">   3149</span><br><span class="line">   1989</span><br><span class="line">   2120</span><br><span class="line">   2425</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="变量的存储"><a href="#变量的存储" class="headerlink" title="变量的存储"></a>变量的存储</h3><p>将变量<code>V</code>存入<code>hello.mat</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; save hello.mat V</span><br><span class="line">&gt;&gt; ls</span><br><span class="line">FeaturesX.dat 	PriceY.dat	hello.mat</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里其实是把<code>V</code>按照压缩的二进制的形式进行存储，如果说<code>V</code>的数据很大，那么压缩的幅度也很大。</p>
<p>如果想按照一个我们可以看得懂的格式进行存储的话，可以这样输入：<code>save hello.txt V -ascii</code></p>
</blockquote>
<h3 id="清空所有变量"><a href="#清空所有变量" class="headerlink" title="清空所有变量"></a>清空所有变量</h3><p>直接输入<code>clear</code>命令，会清空所有的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; clear</span><br><span class="line">&gt;&gt; whos</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="用索引来查询"><a href="#用索引来查询" class="headerlink" title="用索引来查询"></a>用索引来查询</h4><p>首先创建矩阵<code>A</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>你可以通过<code>A(3,2)</code>来访问矩阵的第三行第二列的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A(3,2)</span><br><span class="line">ans &#x3D;  6</span><br></pre></td></tr></table></figure>
<p>你也可以通过<code>A(2,:)</code>来访问第二行的所有元素，其中<code>:</code>代表该行/列的所有元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A(2,:)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以通过<code>A([1 3], :)</code>来取矩阵第1行以及第3行的所有元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A([1 3], :)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   5   6</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>通过<code>A(:)</code>来将所有的元素以一个列向量的形式展示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A(:)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">     3</span><br><span class="line">     5</span><br><span class="line">    10</span><br><span class="line">    11</span><br><span class="line">    12</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="用索引来赋值"><a href="#用索引来赋值" class="headerlink" title="用索引来赋值"></a>用索引来赋值</h4><p>你也可以通过索引来进行复制操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:,2) &#x3D; [10; 11; 12]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">    1   10</span><br><span class="line">    3   11</span><br><span class="line">    5   12</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在矩阵的右侧新增一列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">    1   10</span><br><span class="line">    3   11</span><br><span class="line">    5   12</span><br><span class="line"></span><br><span class="line">&gt;&gt; A &#x3D; [A,[100; 101; 102]]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">     1    10   100</span><br><span class="line">     3    11   101</span><br><span class="line">     5    12   102</span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>将两个行相等的向量按照从左到右的顺序连在一起：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2;3 4;5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B &#x3D; [11 12;13 14;15 16]</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   11   12</span><br><span class="line">   13   14</span><br><span class="line">   15   16</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; [A B]</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">    1    2   11   12</span><br><span class="line">    3    4   13   14</span><br><span class="line">    5    6   15   16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将两个列数相等的向量按照从上到下的顺序连在一起：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   11   12</span><br><span class="line">   13   14</span><br><span class="line">   15   16</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; [A;B]</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">    1    2</span><br><span class="line">    3    4</span><br><span class="line">    5    6</span><br><span class="line">   11   12</span><br><span class="line">   13   14</span><br><span class="line">   15   16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="对数据进行运算"><a href="#对数据进行运算" class="headerlink" title="对数据进行运算"></a>对数据进行运算</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Y6uuC/computing-on-data">视频地址</a></p>
<p>本节将介绍如何对数据进行运算。</p>
<h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>矩阵的乘法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; [1 1; 2 2]</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   2   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; A*C</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    5    5</span><br><span class="line">   11   11</span><br><span class="line">   17   17</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="点乘操作"><a href="#点乘操作" class="headerlink" title="点乘操作"></a>点乘操作</h3><p>让两个矩阵中的每个对应位置的元素相乘(点乘操作)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B &#x3D; [11 12; 13 14; 15 16]</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   11   12</span><br><span class="line">   13   14</span><br><span class="line">   15   16</span><br><span class="line">   </span><br><span class="line">&gt;&gt; A.*B</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   11   24</span><br><span class="line">   39   56</span><br><span class="line">   75   96</span><br></pre></td></tr></table></figure>
<h3 id="对每个元素求平方"><a href="#对每个元素求平方" class="headerlink" title="对每个元素求平方"></a>对每个元素求平方</h3><p>对矩阵$A$中的每个元素求平方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A .^ 2</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1    4</span><br><span class="line">    9   16</span><br><span class="line">   25   36</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="对每个元素求倒数"><a href="#对每个元素求倒数" class="headerlink" title="对每个元素求倒数"></a>对每个元素求倒数</h3><p>对矩阵中每个元素求倒数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; [1; 2; 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; 1 .&#x2F; v</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.00000</span><br><span class="line">   0.50000</span><br><span class="line">   0.33333</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的<code>.</code>符号，表示对每个元素分别进行运算</p>
</blockquote>
<h3 id="对每个元素求对数"><a href="#对每个元素求对数" class="headerlink" title="对每个元素求对数"></a>对每个元素求对数</h3><p>对每个元素求对数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; log(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.00000</span><br><span class="line">   0.69315</span><br><span class="line">   1.09861</span><br></pre></td></tr></table></figure>
<h3 id="自然数e的幂次运算"><a href="#自然数e的幂次运算" class="headerlink" title="自然数e的幂次运算"></a>自然数e的幂次运算</h3><p>以$e$为低，以每个元素为幂的运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; exp(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    2.7183</span><br><span class="line">    7.3891</span><br><span class="line">   20.0855</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="对每个元素求绝对值"><a href="#对每个元素求绝对值" class="headerlink" title="对每个元素求绝对值"></a>对每个元素求绝对值</h3><p>对所有元素求绝对值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; abs([-1; 2; -3])</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="求相反数运算"><a href="#求相反数运算" class="headerlink" title="求相反数运算"></a>求相反数运算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; -v</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  -1</span><br><span class="line">  -2</span><br><span class="line">  -3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实就相当于<code>-1 * v</code></p>
</blockquote>
<h3 id="对向量每个元素自增1"><a href="#对向量每个元素自增1" class="headerlink" title="对向量每个元素自增1"></a>对向量每个元素自增1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v + 1</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line">   4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A&#39;</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   3   5</span><br><span class="line">   2   4   6</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="获取向量中最大的元素"><a href="#获取向量中最大的元素" class="headerlink" title="获取向量中最大的元素"></a>获取向量中最大的元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a &#x3D; [1 15 2 0.5]</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; val &#x3D; max(a)</span><br><span class="line">val &#x3D;  15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以获取最大元素的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; [val, ind] &#x3D; max(a)</span><br><span class="line">val &#x3D;  15</span><br><span class="line">ind &#x3D;  2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，如果这里不是向量，而是矩阵，那么将得到每一列的最大值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; D &#x3D; [1 5;2 4; 3 3]</span><br><span class="line">D &#x3D;</span><br><span class="line"></span><br><span class="line">   1   5</span><br><span class="line">   2   4</span><br><span class="line">   3   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(D)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   5</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="判断矩阵中每个元素是否满足某条件"><a href="#判断矩阵中每个元素是否满足某条件" class="headerlink" title="判断矩阵中每个元素是否满足某条件"></a>判断矩阵中每个元素是否满足某条件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; a &lt; 3</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   0   1   1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里1代表真，0代表假</p>
</blockquote>
<h3 id="获取魔幻方阵-magic-squares"><a href="#获取魔幻方阵-magic-squares" class="headerlink" title="获取魔幻方阵(magic squares)"></a>获取魔幻方阵(magic squares)</h3><p>魔幻方阵，指的是矩阵的<strong>所有的行、列、以及对角线元素的和，都相等</strong>的矩阵。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(3)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实这个神奇的矩阵，在机器学习中基本用不上</p>
</blockquote>
<h3 id="找出矩阵中满足某条件元素的索引"><a href="#找出矩阵中满足某条件元素的索引" class="headerlink" title="找出矩阵中满足某条件元素的索引"></a>找出矩阵中满足某条件元素的索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; [r,c] &#x3D; find(A &gt;&#x3D; 7)</span><br><span class="line">r &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   3</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">c &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中r是所在行的索引，c是所在列的索引。</p>
<p>比如：元素<code>(1,1)</code>，<code>(3,2)</code>，<code>(2,3)</code>。</p>
<h3 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h3><p>将矩阵中所有元素求和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(a)</span><br><span class="line">ans &#x3D;  18.500</span><br></pre></td></tr></table></figure>
<h3 id="求积函数"><a href="#求积函数" class="headerlink" title="求积函数"></a>求积函数</h3><p>将矩阵中所有元素求积：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; prod(a)</span><br><span class="line">ans &#x3D;  15</span><br></pre></td></tr></table></figure>
<h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h3><p>向下四舍五入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.00000   15.00000    2.00000    0.50000</span><br><span class="line"></span><br><span class="line">&gt;&gt; floor(a)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   15    2    0</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>向上四舍五入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceil(a)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   15    2    1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h3><p>获得一个3×3的方阵，元素为在0到1之间的随机数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; rand(3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.315556   0.669565   0.192329</span><br><span class="line">   0.449421   0.010167   0.389329</span><br><span class="line">   0.282657   0.761167   0.600949</span><br></pre></td></tr></table></figure>
<p>分别取两个矩阵中对应位置较大的一个元素，组成新矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; max(rand(3),rand(3))</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.53967   0.79306   0.62026</span><br><span class="line">   0.90069   0.70636   0.55156</span><br><span class="line">   0.98940   0.68021   0.85094</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取一个矩阵中每一列最大的元素组成的向量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A,[],1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   8   9   7</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>获取矩阵每一行的最大值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; max(A,[],2)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   8</span><br><span class="line">   7</span><br><span class="line">   9</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>找出矩阵$A$中最大元素的两种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; max(max(A))</span><br><span class="line">ans &#x3D;  9</span><br><span class="line">&gt;&gt; max(A(:))</span><br><span class="line">ans &#x3D;  9</span><br></pre></td></tr></table></figure>
<h3 id="对矩阵的每一行-列-求和"><a href="#对矩阵的每一行-列-求和" class="headerlink" title="对矩阵的每一行(列)求和"></a>对矩阵的每一行(列)求和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(9)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   47   58   69   80    1   12   23   34   45</span><br><span class="line">   57   68   79    9   11   22   33   44   46</span><br><span class="line">   67   78    8   10   21   32   43   54   56</span><br><span class="line">   77    7   18   20   31   42   53   55   66</span><br><span class="line">    6   17   19   30   41   52   63   65   76</span><br><span class="line">   16   27   29   40   51   62   64   75    5</span><br><span class="line">   26   28   39   50   61   72   74    4   15</span><br><span class="line">   36   38   49   60   71   73    3   14   25</span><br><span class="line">   37   48   59   70   81    2   13   24   35</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A,1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   369   369   369   369   369   369   369   369   369</span><br><span class="line">   </span><br><span class="line">&gt;&gt; sum(A,2)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br></pre></td></tr></table></figure>
<p>求$A$的对角线元素的和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   47   58   69   80    1   12   23   34   45</span><br><span class="line">   57   68   79    9   11   22   33   44   46</span><br><span class="line">   67   78    8   10   21   32   43   54   56</span><br><span class="line">   77    7   18   20   31   42   53   55   66</span><br><span class="line">    6   17   19   30   41   52   63   65   76</span><br><span class="line">   16   27   29   40   51   62   64   75    5</span><br><span class="line">   26   28   39   50   61   72   74    4   15</span><br><span class="line">   36   38   49   60   71   73    3   14   25</span><br><span class="line">   37   48   59   70   81    2   13   24   35</span><br><span class="line"></span><br><span class="line">&gt;&gt; eye(9)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0   0   0   0   0   0   0</span><br><span class="line">   0   1   0   0   0   0   0   0   0</span><br><span class="line">   0   0   1   0   0   0   0   0   0</span><br><span class="line">   0   0   0   1   0   0   0   0   0</span><br><span class="line">   0   0   0   0   1   0   0   0   0</span><br><span class="line">   0   0   0   0   0   1   0   0   0</span><br><span class="line">   0   0   0   0   0   0   1   0   0</span><br><span class="line">   0   0   0   0   0   0   0   1   0</span><br><span class="line">   0   0   0   0   0   0   0   0   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; A.*eye(9)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   47    0    0    0    0    0    0    0    0</span><br><span class="line">    0   68    0    0    0    0    0    0    0</span><br><span class="line">    0    0    8    0    0    0    0    0    0</span><br><span class="line">    0    0    0   20    0    0    0    0    0</span><br><span class="line">    0    0    0    0   41    0    0    0    0</span><br><span class="line">    0    0    0    0    0   62    0    0    0</span><br><span class="line">    0    0    0    0    0    0   74    0    0</span><br><span class="line">    0    0    0    0    0    0    0   14    0</span><br><span class="line">    0    0    0    0    0    0    0    0   35</span><br><span class="line">    </span><br><span class="line">&gt;&gt; sum(sum(A.*eye(9)))</span><br><span class="line">ans &#x3D;  369</span><br></pre></td></tr></table></figure>
<h3 id="将矩阵上下翻转"><a href="#将矩阵上下翻转" class="headerlink" title="将矩阵上下翻转"></a>将矩阵上下翻转</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; magic(3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line">   </span><br><span class="line">&gt;&gt; flipud(magic(3))</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   4   9   2</span><br><span class="line">   3   5   7</span><br><span class="line">   8   1   6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="求逆矩阵"><a href="#求逆矩阵" class="headerlink" title="求逆矩阵"></a>求逆矩阵</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(3)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; temp &#x3D; pinv(A)</span><br><span class="line">temp &#x3D;</span><br><span class="line"></span><br><span class="line">   0.147222  -0.144444   0.063889</span><br><span class="line">  -0.061111   0.022222   0.105556</span><br><span class="line">  -0.019444   0.188889  -0.102778</span><br><span class="line"></span><br><span class="line">&gt;&gt; temp * A</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.00000   0.00000  -0.00000</span><br><span class="line">  -0.00000   1.00000   0.00000</span><br><span class="line">   0.00000   0.00000   1.00000</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，这里的<code>pinv()</code>函数求得的是伪逆矩阵。</p>
</blockquote>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/I7gx3/plotting-data">视频地址</a></p>
<p>这段视频中，将介绍通过Octave来绘制数据。</p>
<h3 id="绘制正弦余弦函数"><a href="#绘制正弦余弦函数" class="headerlink" title="绘制正弦余弦函数"></a>绘制正弦余弦函数</h3><p>绘制一个正弦函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; t&#x3D;[0:0.01:0.98];	% 生成一个0到0.98的等差数列，差值为0.01</span><br><span class="line">&gt;&gt; y1 &#x3D; sin(8*pi*t)</span><br><span class="line">&gt;&gt; plot(t,y1);</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/005.png" alt=""></p>
<p>同理，可以绘制余弦图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; y2 &#x3D; cos(8*pi*t);</span><br><span class="line">&gt;&gt; plot(t,y2)</span><br></pre></td></tr></table></figure>
<p>这样会覆盖掉之前的图，得到新的图：</p>
<p><img src="/img/16_08_13/006.png" alt=""></p>
<p>如果我们想将两个图重叠在一起绘制，可以使用<code>hold on</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; plot(t,y1);</span><br><span class="line">&gt;&gt; hold on</span><br><span class="line">&gt;&gt; plot(t,y2,&#39;r&#39;);	%  这里第三个参数&#39;r&#39;代表颜色为红色</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/007.png" alt=""></p>
<h3 id="图的标记"><a href="#图的标记" class="headerlink" title="图的标记"></a>图的标记</h3><p>可以用以下命令来对图进行标记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; xlabel(&#39;time&#39;)	%	标记x坐标</span><br><span class="line">&gt;&gt; ylabel(&#39;value&#39;)	%	标记y坐标</span><br><span class="line">&gt;&gt; legend(&#39;sin&#39;,&#39;cos&#39;)	%	标记图例</span><br><span class="line">&gt;&gt; title(&#39;my plot&#39;)	%	标记标题</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/008.png" alt=""></p>
<h3 id="图片的保存与删除"><a href="#图片的保存与删除" class="headerlink" title="图片的保存与删除"></a>图片的保存与删除</h3><p>将图片保存在Octave所在目录。可能会花费一些时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; print -dpng &#39;myPlot.png&#39;</span><br><span class="line">warning: print.m: fig2dev binary is not available.</span><br><span class="line">Some output formats are not available.</span><br></pre></td></tr></table></figure>
<p>这里其实可以保存多种格式，可以查看<code>help</code>来了解。</p>
<p>如果想删除这个文件，直接输入<code>close</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; close</span><br></pre></td></tr></table></figure>
<p>这样就会关闭视图窗口，并且删除刚才生成的文件。</p>
<h3 id="为图像标号"><a href="#为图像标号" class="headerlink" title="为图像标号"></a>为图像标号</h3><p>可以通过<code>figure</code>函数对图像进行标号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; figure(1);plot(t,y1);</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/009.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; figure(2);plot(t,y2);</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/010.png" alt=""></p>
<p>这个时候界面上其实可以看到有两个图片：</p>
<p><img src="/img/16_08_13/011.png" alt=""></p>
<h3 id="使用subplot将图像分割显示"><a href="#使用subplot将图像分割显示" class="headerlink" title="使用subplot将图像分割显示"></a>使用subplot将图像分割显示</h3><p><code>subplot</code>函数接受三个参数，前两个参数代表获取一个a × b格子，第三个参数代表当前使用的格子的索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; subplot(1,2,1); % 将图像划分成1×2的格子，并且使用第一个格子</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/012.png" alt=""></p>
<p>如果这个时候输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; plot(t,y1);</span><br></pre></td></tr></table></figure>
<p>那么将会绘制在第一个格子里：</p>
<p><img src="/img/16_08_13/013.png" alt=""></p>
<p>同理，我们可以通过以下命令，将<code>y2</code>绘制在第二个格子里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; subplot(1,2,2);</span><br><span class="line">&gt;&gt; plot(t,y2);</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/014.png" alt=""></p>
<p>另外，你可以使用<code>axis</code>函数，来改变当前图像的刻度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; axis([0.5 1 -1 1])	% 将x轴的范围调整到0.5到1之间，y轴的范围调整到-1到1之间</span><br></pre></td></tr></table></figure>
<p>可以看到<code>y2</code>对应的图刻度发生了改变：</p>
<p><img src="/img/16_08_13/015.png" alt=""></p>
<p>如果想清空图像，可以使用<code>clf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; clf;</span><br></pre></td></tr></table></figure>
<p>可以看到图像被清空了：</p>
<p><img src="/img/16_08_13/016.png" alt=""></p>
<h3 id="矩阵的可视化"><a href="#矩阵的可视化" class="headerlink" title="矩阵的可视化"></a>矩阵的可视化</h3><p>通过<code>imagesc</code>函数，将矩阵绘制出来，其中一种颜色代表一种数值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; magic(5)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   17   24    1    8   15</span><br><span class="line">   23    5    7   14   16</span><br><span class="line">    4    6   13   20   22</span><br><span class="line">   10   12   19   21    3</span><br><span class="line">   11   18   25    2    9</span><br><span class="line"></span><br><span class="line">&gt;&gt; imagesc(A)</span><br></pre></td></tr></table></figure>
<p><img src="/img/16_08_13/017.png" alt=""></p>
<p>设置用来显示的颜色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; imagesc(A), colorbar, colormap gray;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里其实相当于连续输入了三条命令。</p>
</blockquote>
<p>可以看到，颜色变为了灰色，并且颜色对应的数值范围也在右侧列出：</p>
<p><img src="/img/16_08_13/018.png" alt=""></p>
<h2 id="控制语句：for-while-if符号的使用"><a href="#控制语句：for-while-if符号的使用" class="headerlink" title="控制语句：for, while, if符号的使用"></a>控制语句：for, while, if符号的使用</h2><h3 id="for语句的使用"><a href="#for语句的使用" class="headerlink" title="for语句的使用"></a>for语句的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; zeros(10,1)</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line">   0</span><br><span class="line"></span><br><span class="line">&gt;&gt; for i&#x3D;1:10,</span><br><span class="line">&gt;    v(i) &#x3D; 2^i;</span><br><span class="line">&gt;  end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">      2</span><br><span class="line">      4</span><br><span class="line">      8</span><br><span class="line">     16</span><br><span class="line">     32</span><br><span class="line">     64</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以通过<code>for</code>来访问一个索引序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; indices&#x3D;1:10;</span><br><span class="line">&gt;&gt; indices</span><br><span class="line">indices &#x3D;</span><br><span class="line"></span><br><span class="line">    1    2    3    4    5    6    7    8    9   10</span><br><span class="line"></span><br><span class="line">&gt;&gt; for i&#x3D;indices,</span><br><span class="line">&gt;    disp(i);</span><br><span class="line">&gt;  end;</span><br><span class="line"> 1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"> 4</span><br><span class="line"> 5</span><br><span class="line"> 6</span><br><span class="line"> 7</span><br><span class="line"> 8</span><br><span class="line"> 9</span><br><span class="line"> 10</span><br></pre></td></tr></table></figure>
<h3 id="while的使用："><a href="#while的使用：" class="headerlink" title="while的使用："></a>while的使用：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">      2</span><br><span class="line">      4</span><br><span class="line">      8</span><br><span class="line">     16</span><br><span class="line">     32</span><br><span class="line">     64</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br><span class="line">&gt;&gt; i &#x3D; 1;</span><br><span class="line">&gt;&gt; while i &lt;&#x3D; 5,</span><br><span class="line">&gt;    v(i) &#x3D; 100;</span><br><span class="line">&gt;    i &#x3D; i+1;</span><br><span class="line">&gt;  end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">     64</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="if-以及-break-的使用"><a href="#if-以及-break-的使用" class="headerlink" title="if 以及 break 的使用"></a>if 以及 break 的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">    100</span><br><span class="line">     64</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br><span class="line">&gt;&gt; i&#x3D;1;</span><br><span class="line">&gt;&gt; while true,</span><br><span class="line">&gt;    v(i) &#x3D; 999;</span><br><span class="line">&gt;    i &#x3D; i+1;</span><br><span class="line">&gt;    if i &#x3D;&#x3D; 6,</span><br><span class="line">&gt;      break;</span><br><span class="line">&gt;    end;</span><br><span class="line">&gt;  end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">     64</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="else-的使用"><a href="#else-的使用" class="headerlink" title="else 的使用"></a>else 的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v(1)</span><br><span class="line">ans &#x3D;  2</span><br><span class="line">&gt;&gt; v(1)&#x3D;2;</span><br><span class="line">&gt;&gt; if v(1)&#x3D;&#x3D;1,</span><br><span class="line">&gt;    disp(&#39;The value is one&#39;);</span><br><span class="line">&gt;  elseif v(1) &#x3D;&#x3D; 2,</span><br><span class="line">&gt;    disp(&#39;The value is two&#39;);</span><br><span class="line">&gt;  else</span><br><span class="line">&gt;    disp(&#39;The value is not one or two.&#39;);</span><br><span class="line">&gt;  end;</span><br><span class="line">The value is two</span><br></pre></td></tr></table></figure>
<h3 id="退出Octave"><a href="#退出Octave" class="headerlink" title="退出Octave"></a>退出Octave</h3><p>退出Octave只需输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; exit</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; quit</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的定义以及调用"><a href="#函数的定义以及调用" class="headerlink" title="函数的定义以及调用"></a>函数的定义以及调用</h4><p>在当前Octave的目录下创建一个文件<code>squareThisNumber.m</code></p>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function y &#x3D; squareThisNumber(x)</span><br><span class="line">y &#x3D; x^2;</span><br></pre></td></tr></table></figure>
<p>在当前目录下就可以直接使用这个函数了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; squareThisNumber(5)</span><br><span class="line">ans &#x3D;  25</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里<code>y</code>是函数<code>squareThisNumber</code>的返回值，函数体是<code>y = x^2;</code>，参数是<code>x</code>。<br>如果想要正常使用这个函数，必须把这个函数所在的文件放到当前目录下。</p>
</blockquote>
<h4 id="添加搜索路径"><a href="#添加搜索路径" class="headerlink" title="添加搜索路径"></a>添加搜索路径</h4><p>如果你想在其他目录下也正常的使用这个函数，那么你需要将这个文件路径添加到Octave的搜索路径下(<code>addpath</code>)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; addpath(&#39;&#x2F;Users&#x2F;lijianan&#x2F;Desktop&#39;)</span><br><span class="line">&gt;&gt; cd ~</span><br><span class="line">&gt;&gt; pwd</span><br><span class="line">ans &#x3D; &#x2F;Users&#x2F;lijianan</span><br><span class="line">&gt;&gt; squareThisNumber(5)</span><br><span class="line">ans &#x3D;  25</span><br></pre></td></tr></table></figure>
<h4 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h4><p>Octave的函数有一个其他大多数语言不具备的一个特性，就是允许返回多个参数。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function [y1,y2] &#x3D; squareAndCubeThisNumber(x)</span><br><span class="line"></span><br><span class="line">y1 &#x3D; x^2;</span><br><span class="line">y2 &#x3D; x^3;</span><br></pre></td></tr></table></figure>
<p>可以看到函数<code>squareAndCubeThisNumber</code>返回两个值，分别为<code>y1</code>和<code>y2</code>。</p>
<p>使用这个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; [a,b] &#x3D; squareAndCubeThisNumber(5);</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;  25</span><br><span class="line">&gt;&gt; b</span><br><span class="line">b &#x3D;  125</span><br></pre></td></tr></table></figure>
<h3 id="使用函数求解代价函数值："><a href="#使用函数求解代价函数值：" class="headerlink" title="使用函数求解代价函数值："></a>使用函数求解代价函数值：</h3><p><img src="/img/16_08_13/019.png" alt=""></p>
<p>定义函数<code>costFunctionJ.m</code>，入参分别为<code>X</code>,<code>y</code>以及$\theta$：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function J &#x3D; costFunctionJ(X, y, theta)</span><br><span class="line"></span><br><span class="line">% X is the &quot;design matrix&quot; containing our training examples.</span><br><span class="line">% y is the class labels</span><br><span class="line"></span><br><span class="line">m &#x3D; size(X,1); 		% number of training examples</span><br><span class="line">predictions &#x3D; X*theta; 	% predictions of hypothesis on all m examples</span><br><span class="line">sqrErrors &#x3D; (predictions-y).^2;	% squaed errors</span><br><span class="line"></span><br><span class="line">J &#x3D; 1&#x2F;(2*m) * sum(sqrErrors);</span><br></pre></td></tr></table></figure>
<p>使用这个方法求解代价函数$J(\theta)$值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; X &#x3D; [1 1; 1 2; 1 3]</span><br><span class="line">X &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   1   2</span><br><span class="line">   1   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; y &#x3D; [1; 2; 3]</span><br><span class="line">y &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; theta &#x3D; [0; 1];</span><br><span class="line">&gt;&gt;  j &#x3D; costFunctionJ(X,y,theta)</span><br><span class="line">j &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>其中<code>X</code>矩阵第一列代表$x_{0}$项，第二列代表$x_{1}$项。<br><code>y</code>矩阵代表$y$的值。<code>theta</code>的两个值分别代表$\theta_{0}$和$\theta_{1}$。</p>
<p>可以看到<code>X</code>和<code>y</code>对应的值能够被所给的$\theta$值完全拟合，所以得到$J(\theta)=0$</p>
<p>如果我们换一组$\theta$值，就会得到不一样的结果了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; theta &#x3D; [0;0];</span><br><span class="line">&gt;&gt;  j &#x3D; costFunctionJ(X,y,theta)</span><br><span class="line">j &#x3D;  2.3333</span><br></pre></td></tr></table></figure>
<p>我们也可以算一下来验证这个结果是否正确：</p>
<script type="math/tex; mode=display">
((1 - 0)^{2} + (2 - 0)^{2} + (3 - 0)^{2}) / (2*3) = 2.3333</script><p>结果正确。</p>
<h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/WnQWH/vectorization">视频地址</a></p>
<blockquote>
<p>无论你使用Octave还是别的语言，比如matlab或者你正在使用python Numpy或者Java、C 、C++所有这些语言都具有线性代数的库。这些库已经经过高度优化，通常是数值计算方面的博士或者专业人士开发的，而当你实现机器学习算法时，如果你能好好利用这些线性代数库，并联合调用它们，而不是自己去实现这些库可以实现的功能，那么通常情况下，运行速度会更快一些。出错的概率也更小一些。</p>
</blockquote>
<p>为了能使用库函数提供的矩阵乘法之类的API，我们通常情况下解决问题的思路应该是向着把参数<strong>向量化</strong>的方向努力。这样你就会有一个简单得多，也有效得多的代码。</p>
<p>例如：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = \sum\_{j=0}^{n}\theta\_{j}x\_{j}</script><p>这个式子如果我们自己来计算，可能会从0到n去遍历$\theta x$的和。但如果向量化处理之后，我们可以得到$h_{\theta}(x)$的另外一种表示方式：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = \theta^{T}x</script><p>我们可以看一下向量化处理前后的Octave代码对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">非向量化的实现</th>
<th style="text-align:center">向量化的实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/16_08_13/020.png" alt=""></td>
<td style="text-align:center"><img src="/img/16_08_13/021.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>接下来看一个更为复杂的例子：</p>
<p>下面是线性回归算法梯度下降的更新规则：</p>
<p><img src="/img/16_08_13/022.png" alt=""></p>
<p>当我们更新对象有$\theta_{0}$、$\theta_{1}$、$\theta_{2}$时：</p>
<p><img src="/img/16_08_13/023.png" alt=""></p>
<blockquote>
<p>这里你可能已经忘了 在之前提到的<strong>同步更新</strong>，就是我们需要同时更新$\theta_{0}$、$\theta_{1}$、$\theta_{2}$。</p>
</blockquote>
<p>这里我们可以通过向量化的代码实现<strong>同步更新</strong>:</p>
<p>首先，上面的三行式子可以压缩为下面这种形式：</p>
<script type="math/tex; mode=display">
\theta := \theta - αδ</script><p>其中：</p>
<script type="math/tex; mode=display">
δ = 
\frac{1}{m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})x^{(i)}</script><p>好了，接下来我们来解释一下上面的这两个式子：</p>
<p>我们把$\theta$看做一个$n+1$维的向量，$α$是一个常量，$δ$也是一个$n+1$维的向量。所以$\theta := \theta - αδ$这个式子，其实是一个向量减法的运算。</p>
<p>$δ$向量其实是这样的：</p>
<script type="math/tex; mode=display">
δ = 
\begin{bmatrix}
δ\_{0} \\\\
δ\_{1} \\\\
δ\_{2} 
\end{bmatrix}</script><p>其中$δ_{0}$代表着：</p>
<script type="math/tex; mode=display">
δ\_{0} = 
\frac{1}{m}
\sum\_{i=1}^{m}
(h\_{θ}(x^{(i)}) - y^{(i)})x^{(i)}\_{0}</script><p>因此在这个式子中：</p>
<script type="math/tex; mode=display">
δ = 
\frac{1}{m}
\sum\_{i=1}^{m}
(h_{θ}(x^{(i)}) - y^{(i)})x^{(i)}</script><p>其实$(h_{θ}(x^{(i)}) - y^{(i)})$部分可以看做是常量，而$x^{(i)}$则代表着下面的向量:</p>
<script type="math/tex; mode=display">
x^{(i)} = 
\begin{bmatrix}
x^{(i)}\_{0} \\\\
x^{(i)}\_{1} \\\\
x^{(i)}\_{2} 
\end{bmatrix}</script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第五周 (1)训练神经网络</title>
    <url>/2016/09/14/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%94%E5%91%A8%20(1)%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/na28E/cost-function">视频地址</a></p>
<blockquote>
<p>在本节课中和后面的几节课中，我将开始讲述一种在给定训练集下为神经网络拟合参数的学习算法。正如我们讨论大多数学习算法一样，我们准备从拟合神经网络参数的代价函数开始讲起。</p>
</blockquote>
<p>以神经网络在分类问题中的应用为例：</p>
<p><img src="/img/16_09_18/001.png" alt=""> </p>
<p>假设我们有一个如上图所示的神经网络结构，然后假设我们有一个这样的训练集：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),...,(x^{(m)},y^{(m)})
\end{aligned}</script><p>一共有m个训练样本$(x^{(i)},y^{(i)})$。</p>
<p>用大写字母$L$表示这个神经网络结构的总层数：</p>
<script type="math/tex; mode=display">
L = total\ no.\ of\ layers\ in\ network(神经网络总层数)</script><p>所以，对于左边的网络结构，我们得到$L=4$。</p>
<p>然后，我们准备用$S_{l}$表示第$l$层的神经元的数量，<strong>这其中不包括L层的偏置单元</strong>：</p>
<script type="math/tex; mode=display">
S\_{l}= no.\ of\ units(not\ counting\ bias\ unit)\ in\ layer\ l</script><p>比如说：</p>
<ul>
<li>$S_{1}=3$(也就是输入层)</li>
<li>$S_{2}=5$</li>
<li>$S_{3}=5$</li>
<li>$S_{4}=S_{L}=4$ (因为$L=4$)</li>
</ul>
<p>我们接下来讨论两种分类问题，分别是<strong>二元分类</strong>和<strong>多类别分类</strong>。</p>
<h3 id="二元分类-Binary-classification"><a href="#二元分类-Binary-classification" class="headerlink" title="二元分类(Binary classification)"></a>二元分类(Binary classification)</h3><p>在二元分类中$y$只能是0或者1：</p>
<script type="math/tex; mode=display">
y= 0\ or\ 1</script><p>在这个例子中，我们有一个输出单元（不同于上面的神经网络有4个输出单元）。神经网络的输出会是一个实数：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\in \mathbb{R}</script><p>输出单元的个数:</p>
<script type="math/tex; mode=display">
S\_{L} = 1</script><blockquote>
<p>在这类问题里，为了简化记法，我会把$K$设为1，这样<strong>你可以把$K$看作输出层的单元数目</strong>。</p>
</blockquote>
<h3 id="多类别分类（Multi-class-classification）"><a href="#多类别分类（Multi-class-classification）" class="headerlink" title="多类别分类（Multi-class classification）"></a>多类别分类（Multi-class classification）</h3><p>在多类别分类问题中，会有$K$个不同的类，比如说如果我们有四类的话，我们就用下面这种表达形式来代表$y$。在这类问题里，我们就会有$K$个输出单元。</p>
<p><img src="/img/16_09_18/002.png" alt=""> </p>
<p>我们的输出假设就是一个$K$维向量：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\in \mathbb{R}^{K}</script><p>输出单元的个数就是$K$：</p>
<script type="math/tex; mode=display">
S\_{L} = K</script><blockquote>
<p>通常这类问题中，我们都有$K\ge3$，因为如果我们只有两类的话，我们直接使用二元分类法就可以了。因此只有在$K\ge3$的情况下，我们才会使用这种<strong>多类别分类</strong>。</p>
</blockquote>
<h3 id="定义代价函数"><a href="#定义代价函数" class="headerlink" title="定义代价函数"></a>定义代价函数</h3><p>我们在神经网络里，使用的代价函数，应该是逻辑回归里使用的代价函数的一般形式。</p>
<p><strong>逻辑回归的代价函数:</strong></p>
<script type="math/tex; mode=display">
\begin{equation\*}
J(\theta)=-\frac{1}{m}
[
\sum\_{i=1}^m
y^{(i)}logh\_{\theta}(x^{(i)})
+(1-y^{(i)})log(1-h\_{\theta}(x^{(i)}))
]+
\frac{\lambda}{2m}
\sum\_{j=1}^n
\theta^{2}\_{j}
\end{equation*}</script><p>其中$\begin{equation*}<br>\frac{\lambda}{2m}<br>\sum_{j=1}^n<br>\theta^{2}_{j}<br>\end{equation*}$这一项是个额外的正则化项，是一个$j$从1到$n$的求和形式。因为我们并没有把偏置项0正则化。</p>
<p>对于神经网络，我们使用的代价函数是这个式子的一般化形式。</p>
<script type="math/tex; mode=display">
\begin{equation\*}
J(Θ)=-\frac{1}{m}
[
\sum\_{i=1}^m
\sum\_{k=1}^K
y^{(i)}\_{k}log(h\_{Θ}(x^{(i)}))\_{k}
+(1-y^{(i)})\_{k})log(1-(h\_{Θ}(x^{(i)}))\_{k})
]+
\frac{\lambda}{2m}
\sum\_{l=1}^{L-1}
\sum\_{i=1}^{S\_{l}}
\sum\_{j=1}^{S\_{l+1}}
(Θ^{(l)}\_{ji})^{2}
\end{equation*}</script><p>神经网络现在输出了在$K$维的向量$h_{Θ}(x)$：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\in \mathbb{R}^{K}</script><p>用$(h_{Θ}(x))_{i}$来表示第$i$个输出。</p>
<p>其中$\begin{equation*}\sum_{k=1}^K\end{equation*}$这个求和项是$K$个输出单元的求和，比如你有4个输出单元在神经网络的最后一层，那么这个求和项就是$k$从1到4所对应的每一个逻辑回归算法的代价函数之和。</p>
<p>最后式子中的这一项$\begin{equation*}<br>\frac{\lambda}{2m}<br>\sum_{l=1}^{L-1}<br>\sum_{i=1}^{S_{l}}<br>\sum_{j=1}^{S_{l+1}}<br>(Θ^{(l)}_{ji})^{2}<br>\end{equation*}$类似于我们在逻辑回归里所用的正则化项，这个求和项看起来确实非常复杂，它所做的就是把这些项全部加起来，也就是对所有的$Θ_{ji}^{(l)}$的值都相加。正如我们在逻辑回归里的一样，这里要除去那些对应于偏差值的项。具体来说，我们不把$Θ_{j0}^{(l)}$这些项加进去，这是因为当我们计算神经元的激励值时，我们会有这些项。这些带0的项，类似于偏置单元的项。类比于我们在做逻辑回归的时候，我们就不应该把这些项加入到正规化项里去，因为我们并不想正规化这些项，并把这些项设定为0。 （这里我表示没看懂）</p>
<p>即使我们真的把他们加进去了，也就是说$i$从0加到$S_{l}$依然成立，并且不会有大的差异，但是这个“不把偏差项正规化”的规定可能只是会更常见一些。</p>
<h2 id="反向传播-B-P"><a href="#反向传播-B-P" class="headerlink" title="反向传播(B-P)"></a>反向传播(B-P)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/1z9WW/backpropagation-algorithm">视频地址</a></p>
<blockquote>
<p>这个视频中，我们来讨论一下让代价函数最小化的算法，具体来说，我们将主要讲解<strong>反向传播算法（BP算法）</strong></p>
</blockquote>
<p>下面是我们上一节写好的代价函数：</p>
<p><img src="/img/16_09_18/003.png" alt=""> </p>
<p>我们要做的就是试图找到使得代价函数$J(Θ)$最小的$Θ$值：</p>
<p><img src="/img/16_09_18/004.png" alt=""> </p>
<p>为了使用梯度下降法，我们需要做的就是写好一个通过输入参数$Θ$，然后计算：</p>
<p><img src="/img/16_09_18/005.png" alt=""> </p>
<p>这一节的大部分内容也都是在讲解如何计算真两项的。</p>
<hr>
<p><strong>梯度下降计算</strong></p>
<p><img src="/img/16_09_18/006.png" alt=""> </p>
<p>首先，我们从只有一个训练样本的情况说起，假设我们整个训练集只包含一个训练样本：</p>
<script type="math/tex; mode=display">
(x,y)</script><p>让我们粗看一下，使用这样一个训练样本来计算的顺序。</p>
<p>首先我们用向前传播方法来计算一下在给定输入的时候，假设函数的输出结果：</p>
<script type="math/tex; mode=display">
a^{(1)} = x</script><blockquote>
<p>$a^{(1)}$就是第一层的激励值，也就是输入层</p>
</blockquote>
<script type="math/tex; mode=display">
z^{(2)} = Θ^{(1)}a^{(1)}</script><script type="math/tex; mode=display">
a^{(2)} = g(z^{(2)})</script><blockquote>
<p>这里记得添加偏差项$a_{0}^{(2)}$</p>
</blockquote>
<script type="math/tex; mode=display">
z^{(3)} = Θ^{(2)}a^{(2)}</script><script type="math/tex; mode=display">
a^{(3)} = g(z^{(3)})</script><blockquote>
<p>这里记得添加偏差项$a_{0}^{(3)}$</p>
</blockquote>
<script type="math/tex; mode=display">
z^{(4)} = Θ^{(3)}a^{(3)}</script><script type="math/tex; mode=display">
a^{(4)} = h\_{Θ}(x) = g(z^{(4)})</script><p>通过上面的步骤计算，我们就可以得出假设函数的输出结果了：</p>
<p><img src="/img/16_09_18/007.png" alt=""> </p>
<p>接下来，为了计算导数项，我们将采用一种叫做<strong>反向传播(Backpropagation)</strong>的算法。</p>
<p>反向传播算法从直观上说就是对每一个节点求下面这一个误差项:</p>
<p><img src="/img/16_09_18/008.png" alt=""> </p>
<blockquote>
<p>$δ_{j}^{(l)}$这种形式代表了第$l$层的第$j$个结点的<strong>误差</strong></p>
<p>我们还记得我们使用$a_{j}^{(l)}$来表示第$l$层的第$j$个结点的<strong>激励值</strong>，所以这个$δ$项，在某种程度上就捕捉到了我们在这个神经结点的激励值的误差。所以我们可能希望这个结点的激励值稍微不一样。</p>
</blockquote>
<p>具体来讲，我们用上面的那个四层的神经网络结构做例子：</p>
<p>每一项的输出单元(layer L = 4)</p>
<script type="math/tex; mode=display">
δ\_{j}^{(4)} = a\_{j}^{(4)} - y\_j</script><blockquote>
<p>对于每一个输出单元，我们准备计算$δ$项，所以第四层的第$j$个单元的$δ$就等于<strong>这个单元的激励值减去训练样本里的真实值</strong>。所以$a_{j}^{(4)}$这一项同样可以写成$h_{Θ}(x)_{j}$：</p>
</blockquote>
<script type="math/tex; mode=display">
δ\_{j}^{(4)} = h\_{Θ}(x)\_{j} - y\_j</script><p>顺便说一下，如果你把$δ$、$a$和$y$这三项都看作向量的话，那么上面的式子你也可以写出向量化的实现：</p>
<script type="math/tex; mode=display">
δ^{(4)} = a^{(4)} - y</script><p>这里的$δ^{(4)}$、$a^{(4)}$和$y$都是一个向量，并且向量维数等于输出单元的数目。</p>
<p>所以现在我们计算出网络结构的误差项$δ^{(4)}$，我们下一步就是计算网络中前面几层的误差项$δ$。</p>
<p>这就是$δ^{(3)}$的计算公式：</p>
<script type="math/tex; mode=display">
δ^{(3)} = (Θ^{(3)})^{T}δ^{(4)}.*g'(z^{(3)})</script><blockquote>
<p>这里的点乘$.*$是我们从MATLAB里知道的对y元素的乘法操作，指的是两个向量中元素间对应相乘。</p>
</blockquote>
<p>其中$g’(z^{(3)})$这一项其实是对激励函数$g$在输入值为$z(3)$的时候所求的导数。</p>
<p>如果你稍微会一些微积分的知识，你可以很容易的求得$g’(z^{(3)})$这一项的值是：</p>
<script type="math/tex; mode=display">
a^{(3)}.*(1-a^{(3)})</script><p>这里的$1$是元素都为1的向量。</p>
<p>接下来，你可以应用一个相似的公式来求得$δ^{(2)}$:</p>
<script type="math/tex; mode=display">
δ^{(2)} = (Θ^{(2)})^{T}δ^{(3)}.*g'(z^{(2)})</script><p>值得注意的是，这里我们没有$δ^{(1)}$项，因为第一层是输入层，不存在误差。所以这个例子中，我们的$δ$项就只有第2层和第3层。</p>
<hr>
<p>反向传播法这个名字源于我们从输出层开始计算$δ$项，然后我们返回到上一层计算第三隐藏层的$δ$项，接着我们再往前一步来计算$δ^{(2)}$。</p>
<p>所以说我们是类似于把输出层的误差反向传播给了第3层，然后再传到第二层。这就是反向传播的意思。</p>
<p>最后，这个推导过程是出奇的复杂，但是如果你按照这样几个步骤来计算，就有可能简单直接地完成复杂的数学证明。</p>
<p>如果你忽略标准化所产生的项，我们可以证明我们想要的偏导项，恰好就是下面这个表达式：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial Θ\_{ij}^{(l)}}J(Θ)=
a\_{j}^{(l)}δ\_{i}^{(l+1)}</script><script type="math/tex; mode=display">
(ignore\ λ; if\ λ = 0)</script><blockquote>
<p>这里我们忽略了$λ$，我们将在之后完善这一个关于正则化项。</p>
</blockquote>
<p>所以到现在，我们通过反向传播计算这些$δ$项，可以非常快速的计算出所有参数的偏导数项。</p>
<hr>
<p>好，现在让我们把上面所讲的所有内容整合在一起，然后说说如何实现反向传播算法：</p>
<p>当我们有一个很大的训练样本的时候，而不是像我们例子里这样的一个训练样本。我们是这样做的：</p>
<p>假设我们有m个样本的训练集：</p>
<p>$Training\ set\ {(x^{(1)},y^{(1)}),…,(x^{(m)},y^{(m)})}$</p>
<p>我们要做的第一件事就是设置这些值：</p>
<p><img src="/img/16_09_18/009.png" alt=""> </p>
<blockquote>
<p>这里的$△$其实是大写的$δ$，实际上这些$△_{ij}^{(l)}$将被用来计算偏导数项$\frac{\partial}{\partial Θ_{ij}^{(l)}}J(Θ)$</p>
<p>所以，正如我们接下来看到的，这些$△_{ij}^{(l)}$将被作为累加项，慢慢地增加，以算出这些偏导数。</p>
</blockquote>
<p>下图是我们接下来要执行的一些操作：</p>
<p><img src="/img/16_09_18/010.png" alt=""> </p>
<p>在这里我们将遍历我们的训练集。</p>
<p>我们要做的第一件事就是设定$a^{(1)}$，也就是输入层的激励函数：$a^{(1)} = x^{(i)}$</p>
<p>接下来我们运用正向传播，来计算第2，3，4，…，L层的激励值$a^{l}$。</p>
<p>接下来，我们将用$y^{(i)}$来计算$δ^{(L)}=a^{(L)}-y^{(i)}$</p>
<p>接下来，我们使用反向传播算法来计算$δ^{(L-1)},δ^{(L-2)},…,δ^{(2)}$</p>
<p>最终，我们将用$△{ij}^{(l)}$来积累我们在前面写好的偏导数项：</p>
<script type="math/tex; mode=display">
△\{ij}^{(l)}:=△\{ij}^{(l)} + a\_{j}^{(l)}δ\_{i}^{(l+1)}</script><p>如果你再看一下上面这个表达式，你可以把它写成向量形式：</p>
<p>具体来说，如果你把$△$看做一个矩阵，$ij$代表矩阵中的位置，那么上面的式子我们就可以写成：</p>
<script type="math/tex; mode=display">
△^{(l)}:=△^{(l)} + δ^{(l+1)}(a^{(l)})^{T}</script><p>最后，执行这个for循环体之后我们挑出这个for循环，然后计算下面这些式子：</p>
<script type="math/tex; mode=display">
D\_{ij}^{(l)} := \frac{1}{m}△\{ij}^{(l)} + λΘ\_{ij}^{(l)}    
\ \ \ \ if\ j ≠ 0</script><script type="math/tex; mode=display">
D\_{ij}^{(l)} := \frac{1}{m}△\{ij}^{(l)}
\ \ \ \ if\ j = 0</script><blockquote>
<p>这里我们对$j ≠ 0$ 和 $j = 0$分两种情况来讨论，在$j=0$的情况下对应的是偏差项，所以这也是为什么在$j=0$的情况下没有写额外的标准化项的原因。</p>
</blockquote>
<p>最后，尽管严格的证明对于你来说太复杂，你现在可以说明的是一旦你计算出来了这些，这就正好是代价函数关于每一个参数的偏导数：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial Θ\_{ij}^{(l)}}J(Θ)
= D\_{ij}^{(l)}</script><p>所以，你可以把它用在梯度下降算法，或者其他更高级的算法中。</p>
<h2 id="反向传播算法的直观介绍"><a href="#反向传播算法的直观介绍" class="headerlink" title="反向传播算法的直观介绍"></a>反向传播算法的直观介绍</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/du981/backpropagation-intuition">视频地址</a></p>
<blockquote>
<p>这一节中，将要更加深入的讨论一下反向传播算法的这些复杂的步骤，并且希望给你一个更加直观的感受，理解这些步骤究竟是在做什么。也希望通过这一节，你能理解它至少还是一个合理的算法。</p>
<p>但可能你即使看了这段视频你还是觉得反向传播依然很复杂，这也没关系，其实即使是我（吴恩达）接触了反向传播这么多年了，有时候任然觉得这是一个难以理解的算法，但还是希望这段视频能有些许帮助。</p>
</blockquote>
<h3 id="距离说明神经网络计算过程"><a href="#距离说明神经网络计算过程" class="headerlink" title="距离说明神经网络计算过程"></a>距离说明神经网络计算过程</h3><p>为了更好地理解反向传播算法，我们再来仔细研究一下向前传播的原理。</p>
<p><img src="/img/16_09_18/011.png" alt=""></p>
<p>这里有一个包含两个输入单元（不包括偏差单元）的神经网络，在第二层有两个隐藏单元（不包括偏差单元），第三层也有两个隐藏单元（不包括偏差单元），最后的输出层有一个输出单元。</p>
<h3 id="向前传播"><a href="#向前传播" class="headerlink" title="向前传播"></a>向前传播</h3><p>为了更清楚的展示向前传播，下图展示了这个神经网络的<strong>向前传播</strong>的运算过程：</p>
<p><img src="/img/16_09_18/012.png" alt=""></p>
<p>事实上，<strong>反向传播</strong>算法的运算过程非常类似于此，只有计算的方向不同而已。</p>
<h3 id="代价函数-1"><a href="#代价函数-1" class="headerlink" title="代价函数"></a>代价函数</h3><p>为了更好的理解反向传播算法的原理，我们把目光转向代价函数：</p>
<p><img src="/img/16_09_18/013.png" alt=""></p>
<p>这个代价函数对应的情况是只有一个输出单元，如果我们有不止一个输出单元的话，只需要对所有的输出单元进行一次求和运算。</p>
<p>请注意这组训练样本$x^{(i)}$,$y^{(i)}$，注意这种只有一个输出单元的情况，如果不考虑正则化即$λ=0$，因此最后的正则化项就没有了。</p>
<p><img src="/img/16_09_18/014.png" alt=""></p>
<p>这个求和运算括号里面与第i个训练样本对应的代价项，也就是说$(x^{(i)},y^{(i)})$对应的代价项，将有下面这个式子决定：</p>
<script type="math/tex; mode=display">
cost(i) = y^{(i)}log h\_{Θ}(x^{(i)}) + (1 - y^{(i)})logh\_{Θ}(x^{(i)})</script><p>而这个代价函数所扮演的角色可以看做是平方误差，当然，如果你愿意，你可以把$cost(i)$想象成：</p>
<script type="math/tex; mode=display">
cost(i)≈(h\_{Θ}(x^{(i)})-y^{(i)})^{2}</script><p>因此，这里的$cost(i)$表征了该神经网络是否能准确地预测样本i的值，也就是输出值，和实际观测值$y^{(i)}$的接近程度。</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>现在我们来看看反向传播是怎么做的。</p>
<p>一种直观的理解是反向传播算法就是在计算所有这些$δ$项：</p>
<script type="math/tex; mode=display">
δ\_{j}^{(l)} = "error" \ of \ cost \ for \ a\_{j}^{(l)} \ (unit \ j \ in \ layer \ l).</script><p>并且我们可以把它们看作是这些激励值的“<strong>误差</strong>”(注意这些激励值是第l层中的第j项)。</p>
<p>更正式一点的说法是$δ$项实际上是关于$z_{j}^{(l)}$的偏微分，也就是cost函数关于我们计算出的输入项的加权和，也就是$z$项的偏微分:</p>
<script type="math/tex; mode=display">
δ\_{j}^{(l)} = \frac{\partial}{\partial z\_{j}^{(l)}}cost(i) \ \ \ \ (for \ j \ge 0 )</script><p>其中：</p>
<script type="math/tex; mode=display">
cost(i) = y^{(i)}log h\_{Θ}(x^{(i)}) + (1 - y^{(i)})logh\_{Θ}(x^{(i)})</script><p>如果我们观察该神经网络内部的话，把这些$z_{j}^{(l)}$项稍微改一点点，那就将影响到神经网络的输出，并且最终会改变代价函数的值。</p>
<p>因此，它们度量着我们对神经网络的权值做多少的改变，对中间的计算量影响是多少，进一步对整个神经网络的输出$h(x)$影响多少，以及对整个的代价影响多少。</p>
<p>可能刚才讲的偏微分的这种理解不太容易理解，没关系，不用偏微分的思想，我们同样也可以理解。</p>
<p>我们再深入一点，研究一下反向传播的过程，对于输入层，如果我们设置$δ$项，假设我们进行第i个训练样本，那么：</p>
<script type="math/tex; mode=display">
δ\_{1}^{(4)}=y^{(i)}-a^{(4)}\_{1}</script><p>接下来我们要对这些值进行反向传播，算出$δ_{1}^{(3)}$、$δ_{2}^{(3)}$，然后同样的再进行下一层的反向传播，算出$δ_{1}^{(2)}$、$δ_{2}^{(2)}$。</p>
<p>举个例子:</p>
<p>接下来，我们来看看如何计算$δ_{2}^{(2)}$。</p>
<p>我要对一些权值进行标记:</p>
<p><img src="/img/16_09_18/016.png" alt=""> </p>
<p>实际上，我们要做的是我们要用下一层的$δ$值和权值相乘，然后加上另一个$δ$值和权值相乘的结果。也就是说，它其实是$δ$值的加权和。权值是这些对应边的强度。</p>
<p><img src="/img/16_09_18/017.png" alt=""> </p>
<p>计算过程是：</p>
<script type="math/tex; mode=display">
δ\_{2}^{(2)}=Θ\_{12}^{(2)}δ\_{1}^{(3)} + Θ\_{22}^{(2)}δ\_{2}^{(3)}</script><p>再看看另一个例子：</p>
<p>如果想要计算$δ_{2}^{(3)}$的值，计算过程也是类似的：</p>
<script type="math/tex; mode=display">
δ\_{2}^{(3)}=Θ\_{12}^{(3)}δ\_{1}^{(4)}</script><p>另外顺便提一下，目前为止我写的$δ$值仅仅是隐藏层中的没有包括偏差单元:”+1”的。包不包括偏差单元取决于你如何实现这个反向传播算法，你也可以对这些偏差单元计算$δ$的值，这些偏差单元总是取为”+1”的值。</p>
<p>通常来说，我在执行反向传播的时候，我是算出了这些偏差单元的$δ$值，但我通常忽略掉它们，而不是把它们带入计算，因为它们其实并不是计算那些微积分的必要部分，</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第五周 (2)BP算法练习</title>
    <url>/2016/10/13/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%94%E5%91%A8%20(2)BP%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="将参数从矩阵展开成向量"><a href="#将参数从矩阵展开成向量" class="headerlink" title="将参数从矩阵展开成向量"></a>将参数从矩阵展开成向量</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/60Uxp/implementation-note-unrolling-parameters">视频地址</a></p>
<blockquote>
<p>在这一节中，我想快速地向你介绍一个细节的实现过程，怎样把你的参数从矩阵展开成向量，以便我们在高级最优化步骤中的使用需要。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function [jVal, gradient] &#x3D; costFunction(theta)</span><br><span class="line">	...</span><br><span class="line">optTheta &#x3D; fminunc(@costFunction, initialTheta, options)</span><br></pre></td></tr></table></figure>
<p>具体来讲，对代价函数<code>costFunction(theta)</code>传入参数<code>theta</code>，函数返回值是代价函数<code>jVal</code>以及导数值<code>gradient</code>，然后你可以将返回值传递给高级最优化算法<code>fminunc</code>。</p>
<blockquote>
<p>顺便提一下，<code>fminunc</code>并不是唯一的算法，你也可以使用别的优化算法，</p>
</blockquote>
<p>其中<code>costFunction</code>中的参数、返回值<code>gradient</code>以及<code>fiminunc</code>的参数<code>initialTheta</code>都是一个$R^{n+1}$阶的向量。</p>
<p><img src="/img/16_10_13/001.png" alt=""></p>
<p>这部分在我们使用逻辑回归的时候运行顺利，但现在对于神经网络，我们的参数将不再是向量，而是矩阵了。</p>
<p>以一个拥有4层的完整的神经网络为例：</p>
<p>其参数<code>theta</code>所代表的参数矩阵为矩阵为$Θ^{(1)}$,$Θ^{(2)}$,$Θ^{(3)}$，在Octave中，我们可以设为<code>Theta1</code>,<code>Theta2</code>,<code>Theta3</code>。</p>
<p><img src="/img/16_10_13/003.png" alt=""></p>
<p><img src="/img/16_10_13/002.png" alt=""></p>
<p>类似的，这些梯度项<code>gradient</code>也是<code>costFunction</code>的返回值之一，在之前的视频中我们演示了如何计算这些梯度矩阵，它们的计算结果是$D^{(1)}$,$D^{(2)}$,$D^{(3)}$，在Octave中用<code>D1</code>,<code>D2</code>,<code>D3</code>来表示。</p>
<p><img src="/img/16_10_13/005.png" alt=""></p>
<p><img src="/img/16_10_13/004.png" alt=""></p>
<p>在这一节中，我想很快地向你介绍怎样取出这些矩阵，并将他们展开成向量，以便它们最终成为恰当的格式，能够传入这里的<code>initialTheta</code>:</p>
<p><img src="/img/16_10_13/006.png" alt=""></p>
<p>并且得到正确的梯度返回值<code>gradient</code>。</p>
<hr>
<p>具体来说，假设我们有这样一个神经网络：</p>
<p><img src="/img/16_10_13/007.png" alt=""></p>
<p>其输入层有10个输入单元($s_{1}=10$)，隐藏层有10个单元($s_{2}=10$)，最后的输出层只有一个输出单元($s_{3}=1$)。</p>
<p>在这种情况下矩阵$Θ$的维度，和矩阵$D$的维度将有这个神经网络的结构所决定，比如$Θ^{(1)}$是一个$10 × 11$的矩阵。</p>
<p>因此，在Octave中，如果你想讲这些矩阵向量化，那么你要做的是取出你的$Θ^{(1)}$、$Θ^{(2)}$、$Θ^{(3)}$，然后使用下面这段代码，这段代码将取出三个$Θ$矩阵中的所有元素，然后把他们全部展开，成为一个很长的向量，也就是<code>thetaVec</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thetaVec &#x3D; [Theta1(:);Theta2(:);Theta3(:)];</span><br></pre></td></tr></table></figure>
<p>同样的，下面这段代码将取出$D$矩阵的所有元素，然后展开成一个长向量<code>DVec</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DVec &#x3D; [D1(:);D2(:);D3(:)];</span><br></pre></td></tr></table></figure>
<p>最后，如果你想要从向量表达式返回到矩阵表达式的话，你要做的就是使用<code>reshape</code>函数，传入向量的区间以及矩阵的行数和列数，即可得到对应的矩阵：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Theta1 &#x3D; reshape(thetaVec(1:110),10,11);</span><br><span class="line">Theta2 &#x3D; reshape(thetaVec(111:220),10,11);</span><br><span class="line">Theta3 &#x3D; reshape(thetaVec(221:231),10,11);</span><br></pre></td></tr></table></figure></h2><p>下面用一个Octave例子来展示上面的计算过程：</p>
<p>首先，让我们假设<code>Theta1</code>是一个10行11列的单位矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Theta1 &#x3D; ones(10,11);</span><br><span class="line">&gt;&gt; Theta1</span><br><span class="line">Theta1 &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br></pre></td></tr></table></figure>
<p><code>Theta2</code>是一个元素都为2的10行11列的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Theta2 &#x3D; 2*ones(10,11);</span><br><span class="line">&gt;&gt; Theta2</span><br><span class="line">Theta2 &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br></pre></td></tr></table></figure>
<p>然后假设<code>Theta3</code>是一个<code>1×11</code>的元素均为3的矩阵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Theta3 &#x3D; 3*ones(1,11);</span><br><span class="line">&gt;&gt; Theta3</span><br><span class="line">Theta3 &#x3D;</span><br><span class="line"></span><br><span class="line">   3   3   3   3   3   3   3   3   3   3   3</span><br></pre></td></tr></table></figure>
<p>现在，我们想把这些所有的矩阵变成一个向量<code>thetaVec</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; thetaVec &#x3D; [ Theta1(:); Theta2(:); Theta3(:)];</span><br><span class="line">&gt;&gt; thetaVec</span><br><span class="line"></span><br><span class="line">thetaVec &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   1</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>thetaVec</code>是一个$231×1$的向量，这里包含了所有矩阵的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; size(thetaVec)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   231     1</span><br></pre></td></tr></table></figure>
<p>如果我想重新得到我最初的三个矩阵，我可以对<code>thetaVec</code>使用<code>reshape</code>命令。</p>
<p>比如，我们可以抽出前110个元素，来重组一个$10×11$的矩阵，即<code>Theta1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; reshape(thetaVec(1:110),10,11)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br></pre></td></tr></table></figure>
<p>我们也可以用同样的方式来取接下来的110个元素，来重组<code>Theta2</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; reshape(thetaVec(111:220),10,11)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br></pre></td></tr></table></figure>
<p>最后再抽出221到231的元素，重组<code>Theta3</code>：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; reshape(thetaVec(221:231),1,11)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   3   3   3   3   3   3   3   3   3   3</span><br></pre></td></tr></table></figure></h2><p>为了使这个过程更形象，下面我们来看怎样将这一方法应用于我们的学习算法：</p>
<p>假设你有一些初始参数值:$Θ^{(1)}$，$Θ^{(2)}$，$Θ^{(3)}$。</p>
<p>我们要做的是取出这些参数，并且将它们展开为一个长向量作为<code>initialTheta</code>，带入<code>fminunc</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fminunc(@costFunction, initialTheta, options)</span><br></pre></td></tr></table></figure>
<p>我们要做的另一件事是执行代价函数<code>@costFunction</code>，实现算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function [jval, gradientVec] &#x3D; costFunction(thetaVec)</span><br></pre></td></tr></table></figure>
<p>代价函数<code>costFunction</code>传入参数<code>thetaVec</code>，这也是我所有参数的向量，是将所有的参数展开成一个向量的形式。</p>
<p>因此，我要做的第一件事就是通过向量<code>thetaVec</code>使用重组函数<code>reshape</code>来得到$Θ^{(1)}$,$Θ^{(2)}$,$Θ^{(3)}$。</p>
<p>这样我就能执行<strong>向前传播</strong>和<strong>反向传播</strong>来计算出导数$D^{(1)}$,$D^{(2)}$,$D^{(3)}$和代价函数$J(Θ)$。</p>
<p>最后，我可以取出这些导数值，然后让它们保存和我展开的$Θ$值相同的顺序来展开它们(按照$D^{(1)}$,$D^{(2)}$,$D^{(3)}$的顺序)，得到<code>gradientVec</code>，这个值由我的代价函数返回，它可以以一个向量的形式返回这些导数值。</p>
<blockquote>
<p>现在，你应该对怎样进行参数的矩阵表达式和向量表达式之间的转换，有了一个更清晰的认识。</p>
<p>使用矩阵表达式的好处是：当你的参数以矩阵的形式存储时，你在进行正向传播和反向传播时，你会觉得更加方便。当你将参数存储为矩阵时，一个大好处是充分利用了向量化的实现过程。</p>
<p>相反地，向量表达式的优点是如果你有像thetaVec或者DVec这样的矩阵，当你使用一些高级的优化算法时，这些算法通常要求你所有的参数都展开成一个长向量的形式。</p>
</blockquote>
<h2 id="梯度检验（Gradient-Checking）"><a href="#梯度检验（Gradient-Checking）" class="headerlink" title="梯度检验（Gradient Checking）"></a>梯度检验（Gradient Checking）</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Y3s6r/gradient-checking">视频地址</a></p>
<blockquote>
<p>在之前的视频中，我们讨论了如何使用向前传播和反向传播计算神经网络中的导数，但反向传播作为一个有很多细节的算法，在实现的时候会有点复杂，而且有一个不好的方面是在实现反向传播时，会遇到很多细小的错误。所以如果你把它和梯度下降算法或者其他优化算法一起运行时，可能看起来它运行正常，并且你的代价函数$J(Θ)$最后可能在每次梯度下降法迭代时，都会减小，即使在实现反向传播时有一些小错误，可能也会检查不出来。</p>
<p>所以它看起来是$J(Θ)$在减小，但是可能你最后得到的神经网络误差比没有错误的要高，而且你很可能就不知道你的这些结果是这些小错误导致的。那你应该怎么办呢？</p>
<p>有一个想法叫做<strong>梯度检验(Gradient Checking)</strong>可以解决基本所有的问题。我现在每次实现神经网络的反向传播或者类似的梯度下降算法或者其他比较复杂的模型，我都会使用梯度检验，如果你这么做，它会帮你确定并且能很确信你实现的向前传播和反向传播或者其他的什么算法是100%正确的。</p>
<p>在之前的视频中，我一般是让你相信我给出的那些计算就是代价函数的梯度，但一旦你们实现数值梯度检验，也就是这节视频的主题，你就能自己验证你写的代码确实是在计算代价函数$J(Θ)$了。</p>
</blockquote>
<h3 id="梯度检验原理"><a href="#梯度检验原理" class="headerlink" title="梯度检验原理"></a>梯度检验原理</h3><p>看下面这样的例子：</p>
<p><img src="/img/16_10_13/008.png" alt=""></p>
<p>加入我有一个代价函数$J(\theta)$，并且我有一个实数值$\theta$：</p>
<p><img src="/img/16_10_13/009.png" alt=""></p>
<p>假如说我想估计这个函数在这一点的导数，这个导数就等于这样一条直线的斜率：</p>
<p><img src="/img/16_10_13/010.png" alt=""></p>
<p>下面我要用数值计算的方法来计算近似的导数，这个是用数值方法计算近似导数的过程：</p>
<p>我要找到$\theta+ε$和$\theta-ε$这两个点，然后用一条直线把这两点连起来：</p>
<p><img src="/img/16_10_13/011.png" alt=""></p>
<p>然后用这条红线的斜率来作为导数的近似值。在数学上，这条红线的斜率等于两点之间垂直方向的差值除以水平方向的差值：</p>
<p><img src="/img/16_10_13/012.png" alt=""></p>
<p>所以垂直方向上的差值为：</p>
<script type="math/tex; mode=display">
J(\theta+ε) - J(\theta-ε)</script><p>水平方向的差值为：</p>
<script type="math/tex; mode=display">
2ε</script><p>那么我们的近似是这样的：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial \theta}J(\theta)≈
\frac{J(\theta+ε) - J(\theta-ε)}{2ε}</script><blockquote>
<p>通常，我给$ε$取很小的值，比如可能取$ε=10^{-4}$，$ε$的取值在一个很大的范围内都是可行的，实际上，如果你让$ε$非常小，那么数学上上面的式子实际上就是导数。只是我们不用想非常非常小的$ε$，因为可能会产生数值问题，所以我通常让$ε$取$ε=10^{-4}$。</p>
<p>顺便说一下，可能你们见过这种估计导数的公式：$\frac{J(\theta+ε) - J(\theta)}{ε}$，这种方式称为<strong>单侧差分</strong>，而上面的那种方式叫做<strong>双侧差分</strong>。双侧差分给我们了一个稍微精确些的估计，所以，我通常用双侧差分，而不用单侧差分估计。</p>
</blockquote>
<h3 id="Octave中实现梯度检验"><a href="#Octave中实现梯度检验" class="headerlink" title="Octave中实现梯度检验"></a>Octave中实现梯度检验</h3><p>具体地说，你在Octave中实现时，要使用下面这个代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradApprox &#x3D; (J(theta + EPSILON) - J(theta - EPSILON))&#x2F;(2*EPSILON)</span><br></pre></td></tr></table></figure>
<p>你的程序要调用<code>gradApprox</code>来计算这个函数。这个函数会通过这个公式：$\frac{J(\theta+ε) - J(\theta-ε)}{2ε}$，它会给出这点导数的数值估计。</p>
<h3 id="当-theta-是向量时"><a href="#当-theta-是向量时" class="headerlink" title="当$\theta$是向量时"></a>当$\theta$是向量时</h3><p>在之前的例子中，$\theta$是一个实数，接下来让我们来讨论更普遍的一种情况：当$\theta$是一个向量参数的情况。</p>
<p>假如说$\theta$是一个$n$维向量（它可能是我们的神经网络参数$Θ^{1}$，$Θ^{2}$，$Θ^{3}$的展开形式）</p>
<p>所以$\theta$是一个有n个元素的向量。</p>
<script type="math/tex; mode=display">
\theta = [\theta\_{1},\theta\_{2},\theta\_{3},...,\theta\_{n}]</script><hr>
<p>我们可以用类似的想法来估计所有的偏导数项：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial \theta\_{1}}J(\theta)
≈
\frac{
J(\theta\_{1} + ε,\theta\_{2},\theta\_{3},...,\theta\_{n})
-
J(\theta\_{1} - ε,\theta\_{2},\theta\_{3},...,\theta\_{n})
}
{2ε}</script><script type="math/tex; mode=display">
\frac{\partial}{\partial \theta\_{2}}J(\theta)
≈
\frac{
J(\theta\_{1},\theta\_{2} + ε,\theta\_{3},...,\theta\_{n})
-
J(\theta\_{1},\theta\_{2} - ε,\theta\_{3},...,\theta\_{n})
}
{2ε}</script><script type="math/tex; mode=display">...</script><script type="math/tex; mode=display">
\frac{\partial}{\partial \theta\_{n}}J(\theta)
≈
\frac{
J(\theta\_{1},\theta\_{2},\theta\_{3},...,\theta\_{n} + ε)
-
J(\theta\_{1},\theta\_{2},\theta\_{3},...,\theta\_{n} - ε)
}
{2ε}</script><p>分别对$\theta$向量的每个元素使用<strong>双侧差分</strong>来计算导数。</p>
<p>上面的这些公式给出了一个队任意参数求近似偏导数的方法。具体地说，你要实现的是下面这个程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 1:n,</span><br><span class="line">	thetaPlus &#x3D; theta;</span><br><span class="line">	thetaPlus(i) &#x3D; thetaPlus(i) + EPSILON;</span><br><span class="line">	thetaMinus &#x3D; theta;</span><br><span class="line">	thetaMinus(i) &#x3D; thetaMinus(i) - EPSILON;</span><br><span class="line">	gradApprox(i) &#x3D; (J(thetaPlus) - J(thetaMinus))&#x2F;(2*EPSILON);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>我们把这个用在Octave里，来计算数值导数。</p>
<p>我们实现神经网络时，我们用<code>for</code>循环来计算代价函数对每个网络中的参数的偏导数<code>gradApprox</code>，然后和我们从反向传播得到的导数<code>DVec</code>进行对比，看是否相等或近似于<code>DVec</code>。</p>
<script type="math/tex; mode=display">
Check\ that\ gradApprox≈DVec</script><p>如果这两种计算导数的方法给了你相同的结果，或者非常接近的结果，那么我就非常确信我实现的反向传播是正确的。然后我把这些<code>DVec</code>向量用在梯度下降法，或者其他高级优化算法里。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，我想把所有的东西放在一起，然后告诉你怎样实现这个数值梯度检验。</p>
<p><strong>实现步骤:</strong></p>
<ul>
<li>实现反向传播来计算<code>DVec</code>($D^{(1)}$，$D^{(2)}$，$D^{(3)}$)。</li>
<li>用<code>gradApprox</code>实现数值梯度检验</li>
<li>然后确定<code>DVec</code>和<code>gradApprox</code>给出的结果非常相近</li>
<li>在使用你的代码去学习训练你的网络之前，重要的是要关掉梯度检验，不在使用<code>gradApprox</code>这个数值导数公式（这么做的原因是，这个梯度检验的计算量非常大，它是一个非常慢的计算近似导数的方法。而相对的反向传播算法是一个在计算导数上效率更高的方法。）</li>
</ul>
<p>再次重申一下，在为了训练分类器运行你的算法，做很多次梯度下降或高级优化算法的迭代之前，要确定你不再使用梯度检验的程序，具体来说，如果你在每次的梯度下降法迭代时，都运行数值梯度检验，你的程序会变得非常慢，因为数值检验程序比反向传播算法要慢得多。</p>
<h2 id="随机初始化-Θ"><a href="#随机初始化-Θ" class="headerlink" title="随机初始化$Θ$"></a>随机初始化$Θ$</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/ND5G5/random-initialization">视频地址</a></p>
<blockquote>
<p>这一节将介绍神经网络训练中的最后一个知识点：<strong>随机初始化$Θ$</strong></p>
</blockquote>
<p>当你运行一个算法（例如梯度下降算法，或者其他高级优化算法）时，我们需要给变量$\theta$一些初始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">optTheta &#x3D; fminunc(@costFunction, initialTheta, options)</span><br></pre></td></tr></table></figure>
<p>现在考虑一下梯度下降算法，同样我们需给定$\theta$一些初始值，接下来使用梯度下降方法慢慢地执行这些步骤使其下降，使$J(\theta)$下降到最小。</p>
<p>那么$\theta$的初始值该设置为多少呢？是否可以设置为一个0向量呢？</p>
<script type="math/tex; mode=display">
Set\ \ initialTheta = zeros(n,1)\ ?</script><p>虽然说在逻辑回归时，初始化所有变量为0是可行的，但在训练神经网络时，这样做是不可行的。</p>
<p>以训练下面这个神经网络为例：</p>
<p><img src="/img/16_10_13/013.png" alt=""></p>
<p>照之前所说，将所有变量初始化为0：</p>
<script type="math/tex; mode=display">
Θ\_{ij}^{(l)}=0 \ \ for\ all\ i,j,l.</script><p>如果是这样的话，当初始化下面这些颜色两两相同的权重时，这些权重都被赋予相同的初始值0：</p>
<p><img src="/img/16_10_13/014.png" alt=""></p>
<p>那么这就意味着经过计算后，这两个隐藏单元$a_{1}$，$a_{2}$的值是相同的：</p>
<script type="math/tex; mode=display">
a\_{1}^{(2)}=a\_{2}^{(2)}</script><p>同样的原因，由于权重相同，也可以证明：</p>
<script type="math/tex; mode=display">
δ\_{1}^{(2)}=δ\_{2}^{(2)}</script><p>同时，如果你更深入地挖掘一下，你不难得出这些变量对参数的偏导数满足以下条件：</p>
<p>以这两条红色的权重为例：</p>
<p><img src="/img/16_10_13/015.png" alt=""></p>
<p>即代价函数的关于这两个权重的偏导数是相等的：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial Θ\_{01}^{(1)}}J(Θ)
=
\frac{\partial}{\partial Θ\_{02}^{(1)}}J(Θ)</script><p>这也意味着，一旦更新梯度下降方法，第一个红色权重也会更新，等于学习率乘以这个式子:$\frac{\partial}{\partial Θ_{01}^{(1)}}J(Θ)$</p>
<p>第二条红色权重更新为学习率乘以这个式子：$\frac{\partial}{\partial Θ_{02}^{(1)}}J(Θ)$。</p>
<p>这也就意味着，一旦更新梯度下降，这两条红色权重的值，在最后将互为相等：</p>
<script type="math/tex; mode=display">
Θ\_{01}^{(1)}=Θ\_{02}^{(1)}</script><p>因此，即使权重现在不都为0，但参数的值最后也互为相等。</p>
<p>同样地，即使更新一个梯度下降，下面这两条红色的权重也会互为相等：</p>
<p><img src="/img/16_10_13/016.png" alt=""></p>
<p>同理，最下面的两个权重也会互为相等。</p>
<p>所以每次更新后，两个隐藏单元的输入的对应的参数将是相同的。这就意味着即使经过一次梯度下降的循环后，你会发现两个隐藏单元任然是两个完全相同的输入函数：</p>
<script type="math/tex; mode=display">
a\_{1}^{(2)}=a\_{2}^{(2)}</script><p>这也意味着，这个神经网络并不能计算出什么更有价值的东西。</p>
<p>想象一下，不止有两个隐藏单元，而是有很多的隐藏单元，这就是会导致所有的隐藏单元都在计算相同的特征，这是完全多余的表达，因为这意味着最后的逻辑回归单元只会得到一种特征。这样便阻止了神经网络学习出更有价值的信息。</p>
<h3 id="随机初始化-Θ-引入"><a href="#随机初始化-Θ-引入" class="headerlink" title="随机初始化$Θ$引入"></a>随机初始化$Θ$引入</h3><p>为了解决这个神经网络变量初始化的问题，我们采用<strong>随机初始化</strong>的方法。</p>
<p>具体的说，上面我们说到的所有权重相同的问题，有时被我们也称为<strong>对称权重</strong>。所以随机初始化解决的就是如何<strong>打破这种对称性(Symmetry breaking)</strong>。</p>
<p>所以我们需要做的是对$Θ_{ij}^{(l)}$的每个值进行初始化，范围在$[-ε,ε]$之间（$-ε\le Θ_{ij}^{(l)} \le ε$）。</p>
<p>在Octave中初始化$Θ$：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Theta1 &#x3D; rand(10,11)*(2*INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta2 &#x3D; rand(1,11)*(2*INIT_EPSILON) - INIT_EPSILON;</span><br></pre></td></tr></table></figure>
<p>其中<code>rand(10,11)</code>代表一个$10×11$的随机矩阵，这个<code>rand()</code>函数就是用来得到一个任意的随机矩阵的方法，并且所有的值都是介于0到1之间的实数。</p>
<p>因此，如果取0到1之间的一个数和$2ε$相乘再减去$ε$，然后得到的结果就是一个在$[-ε,ε]$之间的数。</p>
<blockquote>
<p>顺便说一句，这里的这个$ε$和在进行梯度检查中用的那个$ε$不是一回事，这也是为什么上面这段代码要使用<code>INIT_EPSILON</code>而不是<code>EPSILON</code>的原因。(在梯度检查中用到的是<code>EPSILON</code>)</p>
</blockquote>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>总的来说，为了训练神经网络，应该对权重进行随机初始化为$[-ε,ε]$之间的值。$ε$是接近于0的小数，然后进行反向传播，执行梯度检查，使用梯度下降或者高级的优化算法，试着使代价函数$J(Θ)$达到最小，从某个随机选取的参数$Θ$开始。通过打破对称性的过程，我们希望梯度下降或者其他高级优化算法可以找到$Θ$的最优值。</p>
<h2 id="神经网络总体回顾：所有算法合体吧！"><a href="#神经网络总体回顾：所有算法合体吧！" class="headerlink" title="神经网络总体回顾：所有算法合体吧！"></a>神经网络总体回顾：所有算法合体吧！</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Wh6s3/putting-it-together">视频地址</a></p>
<blockquote>
<p>这一节中，我们将对神经网络的所有内容进行一个整体回顾，看看这些零散的内容相互之间有怎样的联系，以及神经网络学习算法的总体实现过程。</p>
</blockquote>
<h3 id="第一步，选择一个合适的神经网络结构"><a href="#第一步，选择一个合适的神经网络结构" class="headerlink" title="第一步，选择一个合适的神经网络结构"></a>第一步，选择一个合适的神经网络结构</h3><p>当我们在训练一个神经网络的时候，我们要做的第一件事就是搭建网络的大体框架，这里我说的框架意思是神经元之间的链接模式。我们可能会从以下几种结构中选择：</p>
<p><img src="/img/16_10_13/017.png" alt=""></p>
<ul>
<li>第一种网络结构包含三个输入单元、五个隐藏单元、和四个输出单元。</li>
<li>第二种包含三个输入单元，两组五个隐藏单元作为隐藏层，四个输出单元。</li>
<li>第三种组合是三个输入单元，三组五个隐藏单元作为隐藏层，四个输出单元。</li>
</ul>
<p>这些就是可能选择的结构，每一层可以选择多少个隐藏单元，以及可以选择多少个隐藏层。这些都是你构建时的选择，那么我们该如何做出选择呢？</p>
<p>首先，我们知道我们已经定义了输入单元的数量，一旦你确定了特征集$x^{(i)}$对应的输入单元数目，也就确定了特征$x^{(i)}$的维度，输入单元的数目将会由此确定。</p>
<p>其次如果你正在进行多类别分类，那么输出层的单元数目将会由你分类问题中所要区分的类别个数确定。</p>
<blockquote>
<p>值得一提的是，在多类别分类问题中，若$y$的取值范围是在${1,2,3,..,10}$之间，那么你就有10个可能的分类，别忘了把你的y重新写成向量的形式，例如：</p>
</blockquote>
<script type="math/tex; mode=display">
y=
\begin{bmatrix}
   1 \\\\
   0 \\\\
   0 \\\\
   ... \\\\
   0
  \end{bmatrix}</script><blockquote>
<p>假设现在要表示第5个分类，也就是说$y=5$，那么在你的神经网络中，就不能直接使用数值5来表达，因为这种情况下，神经网络将有10个输出单元，你应该用一个向量来表示：</p>
</blockquote>
<script type="math/tex; mode=display">
y=
\begin{bmatrix}
      0 \\\\
    0 \\\\
    0 \\\\
    0 \\\\
       1 \\\\
       0 \\\\
       0 \\\\
    0 \\\\
    0 \\\\
       0
  \end{bmatrix}</script><p>所以对于输入和输出单元的数目的选择，是比较容易理解的。而对于隐藏层单元的个数，以及隐藏层的数目，我们有一个默认的规则，那就是<strong>只使用单个隐藏层</strong>，所以第一种类型的神经网络架构是最常见的：</p>
<p><img src="/img/16_10_13/018.png" alt=""></p>
<p>或者如果你使用超过一层的隐藏层的话，同样我们也有一个默认规则，那就是<strong>每一个隐藏层通常都应该拥有相同的单元数</strong>。所以后面的两种神经网络结构的隐藏层都拥有相同的单元数：</p>
<p><img src="/img/16_10_13/019.png" alt=""></p>
<p>但实际上通常来说，只使用一层隐藏层的结构是较为合理的默认结构。</p>
<p>而对于隐藏单元的个数，通常情况下<strong>隐藏单元越多越好</strong>，不过我们需要注意的是，如果有大量的隐藏单元，计算量一般会比较大。并且，一般来说，每个隐藏层所包含的单元数量还应该和输入$x$的维度相匹配，也要和特征的数目相匹配。可能隐藏单元的数目和输入特征的数量相同，或者是它的二倍或者三倍、四倍。因此，隐藏单元的数目需要和其他参数相匹配。</p>
<p>一般来说隐藏单元的数目取稍大于输入特征数目都是可以接受的。</p>
<h3 id="训练神经网络的步骤"><a href="#训练神经网络的步骤" class="headerlink" title="训练神经网络的步骤"></a>训练神经网络的步骤</h3><p>接下来，我们就来具体介绍如何实现神经网络的训练过程，下面是训练神经网络的六个步骤：</p>
<ul>
<li>1.构建一个神经网络并且随机初始化权值（<strong>Randomly initialize Weight</strong>）</li>
</ul>
<blockquote>
<p>我们通常把权值初始化为很小的值，接近于0</p>
</blockquote>
<ul>
<li>2.执行向前传播算法，也就是对于神经网络的任意一个输入$x^{(i)}$计算出对应的$h_{Θ}(x^{(i)})$。</li>
<li>3.通过代码计算出代价函数$J(Θ)$</li>
<li>4.执行反向传播算法(<strong>Backprop</strong>)来算出这些偏导数：$\frac{\partial}{\partial Θ_{jk}^{(l)}}J(Θ)$</li>
</ul>
<blockquote>
<p>具体来说，我们要对所有训练集数据使用一个<code>for</code>循环进行遍历没一个样本（实际上有更复杂的方式来替代<code>for</code>循环来实现，但对于第一次实现神经网络的训练过程，我非常不建议使用<code>for</code>循环以为的方式，因为这种方式更有助于第一次使用时的理解）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 1:m</span><br></pre></td></tr></table></figure>
<p>注意：下面这部分是在for循环内，但markdown的代码片段不支持显示Letex所以写在了外部：</p>
<p>—-for循环内部开始—-</p>
<p>对样本$(x^{(i)},y^{(i)})$使用向前传播和反向传播算法<br>     (具体来说，就是把输入项带入后，得出每个节点的激励值$a^{(l)}$和delta项$δ^{(l)}$)</p>
<script type="math/tex; mode=display">
△^{(l)} := △^{(l)} + δ^{(l+1)}(a^{(l)})^{T}</script><p>—-for循环内部结束—-</p>
<p>计算出这些$△$的累加值之后，我们将用别的程序来计算出偏导数项：</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial Θ\_{jk}^{(l)}}J(Θ)</script></blockquote>
<ul>
<li>5.使用梯度检查来校验结果。用梯度检查来比较这些已经用反向传播算法得到的偏导数值$\frac{\partial}{\partial Θ_{jk}^{(l)}}J(Θ)$与用数值方法得到的估计值进行比较，来检查，确保这两种方法得到值是基本相近的。</li>
</ul>
<blockquote>
<p>通过梯度检查，我们能确保我们的反向传播算法得到的结果是正确的，但必须要说明的一点是，检查结束后我们需要去掉梯度检查的代码，因为梯度检查计算非常慢。</p>
</blockquote>
<ul>
<li>6.使用一个最优化算法（比如说梯度下降算法或者其他更加高级的优化方法，比如说BFGS算法，共轭梯度法，或者其他一些已经内置到<code>fminunc</code>函数中的方法），将所有这些优化方法和反向传播算法相结合，这样我们就能计算出这些偏导数项的值$\frac{\partial}{\partial Θ_{jk}^{(l)}}J(Θ)$。</li>
</ul>
<blockquote>
<p>到现在，我们已经知道了如何计算代价函数$J(Θ)$，我们知道了如何使用反向传播算法来计算偏导数$\frac{\partial}{\partial Θ_{jk}^{(l)}}J(Θ)$，那么我们就能使用某个最优化方法来最小化$J(Θ)$关于$Θ$的函数值。</p>
</blockquote>
<p>顺便提一下，对于神经网络代价函数$J(Θ)$是一个非凸函数，因此理论上是能够停留在局部最小值的位置。实际上，梯度下降算法和其他一些高级优化方法理论上都能收敛于局部最小值，但一般来讲这个问题其实并不是什么要紧的事，尽管我们不能保证这些优化算法一定会得到全局最优值，但通常来讲，像梯度下降这类的算法在最小化代价函数$J(Θ)$的过程中，还是表现的很不错的，通常能够得到一个很小的局部最小值，尽管这可能不一定是全局最优值。</p>
<h3 id="梯度下降法在神经网络中的直观理解"><a href="#梯度下降法在神经网络中的直观理解" class="headerlink" title="梯度下降法在神经网络中的直观理解"></a>梯度下降法在神经网络中的直观理解</h3><p>最后，梯度下降算法，似乎对于神经网络来说还是比较神秘的，希望下面这幅图能让你对梯度下降法在神经网络中的应用产生一个更直观的理解：</p>
<p><img src="/img/16_10_13/020.png" alt=""></p>
<p>这实际上有点类似我们早先时候解释梯度下降时的思路：我们有一个代价函数$J(Θ)$，并且在我们的神经网络中有一系列参数值，这里我之写下了两个参数值$Θ_{12}^{(1)}$,$Θ_{11}^{(1)}$，当然实际上在神经网络里，我们可以有很多很多的参数值：$Θ^{(1)}$,$Θ^{(2)}$…。因此我们参数的维度就会很高了，也无法绘制成直观的图像。所以这里我们假设这个神经网络中只有两个参数值：$Θ_{12}^{(1)}$,$Θ_{11}^{(1)}$。</p>
<p>那么代价函数$J(Θ)$度量的就是这个神经网络对训练数据的拟合情况。</p>
<p>所以，如果你取某个参数，比如说在这样一个局部最优值：</p>
<p><img src="/img/16_10_13/021.png" alt=""></p>
<p>这一点的位置所对应的参数$Θ$的情况是对于大部分的训练数据，我的假设函数的输出会非常接近于$y^{(i)}$:</p>
<script type="math/tex; mode=display">
h\_{Θ}(x^{(i)})≈y^{(i)}</script><p>那么如果是这样的话，那么我们的代价函数$J(Θ)$值就会很小。</p>
<p>而反过来，如果我们取这个值：</p>
<p><img src="/img/16_10_13/022.png" alt=""></p>
<p>我们的代价函数$J(Θ)$值就会很大。</p>
<p>因此<strong>梯度下降的原理是我们从某个随机的初始点开始，它将会不停的下降，那么反向传播算法的目的就是算出梯度下降的方向，而梯度下降的过程就是沿着这个方向一点点的下降，一直到我们希望得到的点，这一点就是我们希望找到的局部最优点</strong>。</p>
<p>所以，当你在执行反向传播算法并使用梯度下降或者更高级的优化方法时，上面的图片很好地帮你解释了基本的原理，也就是视图找到某个最优的参数值。这个值使得我们的神经网络的输出值与$y^{(i)}$的实际值（也就是训练集的输出观测值）尽可能的接近</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第五周 (4)神经网络实现自动驾驶</title>
    <url>/2016/10/16/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E4%BA%94%E5%91%A8%20(4)%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/</url>
    <content><![CDATA[<h2 id="使用神经网络实现自动驾驶"><a href="#使用神经网络实现自动驾驶" class="headerlink" title="使用神经网络实现自动驾驶"></a>使用神经网络实现自动驾驶</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/zYS8T/autonomous-driving">视频地址</a></p>
<p>这一节将介绍一个具有历史意义的神经网络学习的例子，那就是使用神经网络来实现自动驾驶。也就是说汽车通过学习来自己驾驶。</p>
<p>这是Dean Pomerleau那里得到的一段视频，Dean Pomerleau任职于美国东海岸的卡耐基梅隆大学，下面的视频中你会明白可视化技术到底是什么。</p>
<p><img src="/img/16_10_16/001.png" alt=""></p>
<p>在上面这张图中，左下方就是汽车所看到的前方路况图像，是汽车前方摄像头每两秒采集的并且进过压缩处理之后得到的一张30 × 32的图像。这张图片中，你依稀可以看到一条道路。</p>
<p><img src="/img/16_10_16/002.png" alt=""></p>
<p>左上角第一个水平的进度条显示的是驾驶员所选择的方向，就是那条白亮的区段显示的就是人类驾驶者选择的方向，白色区段偏左，就是向左转，反之，则是向右转。</p>
<p><img src="/img/16_10_16/003.png" alt=""></p>
<p>第二个水平的进度条则是学习算法选出的行驶方向，代表的含义和第一个条一样，白色区段偏左，就是向左转，反之，则是向右转。</p>
<p><img src="/img/16_10_16/004.png" alt=""></p>
<p>实际上神经网络在开始学习之前，你会看到网络的输出是一条灰色的区段，覆盖着整个区域，只有在学习算法运行足够长的时间之后，亮白色的区段才能逐渐显现。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ilP4aPDTBPE" frameborder="0" allowfullscreen></iframe>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第八周 (1)聚类</title>
    <url>/2017/04/20/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AB%E5%91%A8%20(1)%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="无监督学习介绍"><a href="#无监督学习介绍" class="headerlink" title="无监督学习介绍"></a>无监督学习介绍</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/czmip/unsupervised-learning-introduction">视频地址</a></p>
<blockquote>
<p>接下来，我将介绍<strong>聚类</strong>这一概念。保证精彩！因为这是我们第一个<strong>无监督学习算法</strong>。我们要从未标记的数据中进行学习, 而不是从已标记的数据。 </p>
</blockquote>
<p>什么是无监督学习算法呢？</p>
<p>之前，在本课程的开始阶段，我曾简短介绍过无监督学习算法。现在，我想将<strong>无监督学习算法</strong>与<strong>监督学习算法</strong>做个对照。</p>
<h3 id="无监督学习算法与监督学习算法对比"><a href="#无监督学习算法与监督学习算法对比" class="headerlink" title="无监督学习算法与监督学习算法对比"></a>无监督学习算法与监督学习算法对比</h3><p>下面是一个监督学习的例子：</p>
<p><img src="/img/17_04_20/001.png" alt=""></p>
<script type="math/tex; mode=display">
训练集：｛(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),(x^{(3)},y^{(3)}),...,(x^{(m)},y^{(m)})｝</script><p>这是一组附有标记的训练数据集，我们想要找出一个决策边界，来将两者分开：</p>
<p><img src="/img/17_04_20/002.png" alt=""></p>
<p>在这种监督式学习中，我们针对一组标记的训练数据提出一个适当的假设。</p>
<hr>
<p>相比之下，在无监督学习案例中，我们面对的是一组<strong>无标记</strong>的训练数据，数据之间不具任何关联的标记。</p>
<p>所以我们得到的数据看起来是下面这样的：</p>
<p><img src="/img/17_04_20/003.png" alt=""></p>
<script type="math/tex; mode=display">
训练集：｛x^{(1)},x^{(2)},x^{(3)},...,x^{(m)}｝</script><p>所以，在无监督学习中，我们将这种未标记的训练数据送入特定的算法，然后我们要求算法替我们分析出数据的结构。</p>
<p>就此数据而言，其中一种可能的结构是所有的数据大致地划分成两个类（或组），这种划分的算法称为<strong>聚类算法()</strong>：</p>
<p><img src="/img/17_04_20/004.png" alt=""></p>
<p>除此之外，无监督学习还包含其他各式各样的算法，用以寻找其他类型的结构。我们下面将会一一介绍。目前，我们先介绍聚类。</p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>稍早前，我已经提到几个应用实例：</p>
<p><img src="/img/17_04_20/005.png" alt=""></p>
<ul>
<li>图1是细分市场，将所有用户划分至不同的细分市场组，以便于营销或服务。</li>
<li>图2是社交分析体系，比如在社交网络中观察一群人，看他们和谁有电子邮件来往，或者查找一群相互有联系的人。</li>
<li>图3是用聚类来组织运算集群或组织数据中心，因为，如果你知道在集群中，哪些计算机的数据中心倾向于一起工作，你可以用它重新组织你的资源，网络的布局，以及数据中心和通信。</li>
<li>图4是使用聚类算法来试图理解星系的形成，和其中的天文细节。</li>
</ul>
<p>总之，聚类是我们学到的第一个无监督学习算法。在接下来的内容中，我将谈论聚类的具体实现方式。</p>
<h2 id="K-Means-算法"><a href="#K-Means-算法" class="headerlink" title="K-Means 算法"></a>K-Means 算法</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/93VPG/k-means-algorithm">视频地址</a></p>
<blockquote>
<p>在聚类问题中，我们有未加标签的数据。我们希望有一个算法能够自动的把这些数据分成<strong>有紧密关系的子集</strong>，或是<strong>簇</strong>。<strong>K均值 (K-means)算法</strong>是现在最为广泛使用的聚类方法。那么在这个视频中，我将会告诉你，什么是K均值算法以及它是怎么运作的。</p>
</blockquote>
<p>K均值算法最好用图来表达。如图所示：</p>
<p><img src="/img/17_04_20/006.png" alt=""></p>
<p>现在有一些<strong>没加标签</strong>的数据，而我想将这些数据分成两个<strong>簇</strong>。</p>
<p>现在我执行K均值算法 方法是这样的 </p>
<p>首先我随机选择两个点，这两个点叫做<strong>聚类中心 (cluster centroids) </strong>:</p>
<p><img src="/img/17_04_20/007.png" alt=""></p>
<p>为什么要两个点呢？因为我希望聚出两个类。</p>
<p>K均值是一个迭代方法，它要做两件事情：</p>
<ul>
<li>第一是<strong>簇分配</strong>。</li>
<li>第二个是<strong>移动聚类中心</strong>。</li>
</ul>
<p>接下来介绍这两个步骤具体是在做什么。</p>
<h3 id="K-Means-第一步：簇分配"><a href="#K-Means-第一步：簇分配" class="headerlink" title="K-Means 第一步：簇分配"></a>K-Means 第一步：簇分配</h3><p>在K均值算法的每次循环中，第一步是要进行<strong>簇分配</strong>。这就是说，我要遍历所有的样本（就是图上所有的绿色的点），然后依据每一个点是更接近红色的这个中心、还是蓝色的这个中心，来将每个数据点分配到两个不同的聚类中心中。</p>
<p>具体来讲，就是对数据集中的所有点，依据他们更接近红色这个中心、还是蓝色这个中心，进行染色。染色之后的结果如图所示：</p>
<p><img src="/img/17_04_20/008.png" alt=""></p>
<p>以上就是簇分配的步骤。</p>
<h3 id="K-Means-第二步：移动聚类中心"><a href="#K-Means-第二步：移动聚类中心" class="headerlink" title="K-Means 第二步：移动聚类中心"></a>K-Means 第二步：移动聚类中心</h3><p>K均值的另一部分，是要<strong>移动聚类中心</strong>。</p>
<p>具体的操作方法是这样的：我们将两个聚类中心（也就是红色的叉和蓝色的叉）移动到和它一样颜色的那堆点的均值处。</p>
<p>那么我们要做的是找出所有红色的点，计算出它们的均值位置，然后我们就把红色点的聚类中心移动到这里。对蓝色的点也同样计算平均位置，然后移动蓝色聚类中心到该平均位置处。</p>
<p><img src="/img/17_04_20/009.png" alt=""></p>
<h3 id="K-Means-第三步：重复执行上面两步"><a href="#K-Means-第三步：重复执行上面两步" class="headerlink" title="K-Means 第三步：重复执行上面两步"></a>K-Means 第三步：重复执行上面两步</h3><p>然后我们就会进入下一个<strong>簇分配</strong>。我们重新检查所有没有标签的样本，依据它离红色中心还是蓝色中心更近一些，重新将它染成红色或是蓝色。</p>
<p><img src="/img/17_04_20/010.png" alt=""></p>
<p>然后我们再次<strong>移动聚类中心</strong>。计算蓝色点的均值，以及红色点的均值，然后移动两个聚类中心：</p>
<p><img src="/img/17_04_20/011.png" alt=""></p>
<p>然后再做一遍<strong>簇分配</strong>和<strong>移动聚类中心</strong>操作：</p>
<p><img src="/img/17_04_20/012.png" alt=""></p>
<p>实际上，如果你从这一步开始，一直迭代下去，聚类中心是不会变的；并且 那些点的颜色也不会变。在这时，我们就能说<strong>K均值方法已经收敛了</strong>。</p>
<h3 id="K-Means的规范化描述"><a href="#K-Means的规范化描述" class="headerlink" title="K-Means的规范化描述"></a>K-Means的规范化描述</h3><p>我们来用更加规范的格式描述K均值算法。</p>
<p>K均值算法接受两个输入：</p>
<ul>
<li>第一个是参数$K$，表示你想从数据中聚类出的簇的个数。</li>
</ul>
<blockquote>
<p>稍后会讲到选择$K$的方法</p>
</blockquote>
<ul>
<li>第二个输入参数是训练集$｛x^{(1)},x^{(2)},…,x^{(m)}｝$</li>
</ul>
<blockquote>
<p>因为这是非监督学习，我们的数据集中不需要$y$，同时在非监督学习的 K均值算法里，我们约定$x^{(i)}$是一个$n$维向量，这就是“训练样本是$n$维而不是$n+1$维”的原因（按照惯例，排除$x_0=1$这一项）。</p>
</blockquote>
<p><strong>K均值算法：</strong></p>
<p><img src="/img/17_04_20/013.png" alt=""></p>
<ul>
<li><p>第一步：随机初始化$K$个<strong>聚类中心</strong>，记作$μ_1$,$μ_2$一直到$μ_K$。 </p>
</li>
<li><p>第二步：</p>
<ul>
<li><p>K均值内部循环执行以下步骤：</p>
<ul>
<li><p>簇分配</p>
<p> 首先对于每个训练样本，我们用变量$c^{(i)}$表示$K$个聚类中心中最接近$x^{(i)}$的那个中心的下标（具体的类别），这就是簇分配。</p>
<blockquote>
<p>大写的$K$表示所有聚类中心的个数，小写的$k$则表示某个聚类中心的下标。</p>
</blockquote>
<p>  我们希望的是：<strong>在所有K个中心中，找到一个$k$使得$x_i$到$μ_k$的距离是$x^{(i)}$到所有的聚类中心的距离中最小的那个</strong>，这就是计算$c_i$的方法。</p>
<p>  这里还有另外的表示$c_i$的方法：我用<strong>范数</strong>的形式$||x^{(i)}-μ_k||$来表示，这是第$i$个训练样本到聚类中心$μ_k$的距离。</p>
<p>  接下来我要做的是找出$k$的值，让这个式子$||x^{(i)}-μ_k||$最小，然后将 $c^{(i)}$ 赋值为$k$。</p>
<p>  出于惯例，人们更喜欢用距离的平方$||x^{(i)}-μ_k||^2$来表示$x^{(i)}$距聚类中心$μ_k$的距离。所以我们可以认为 $c^{(i)}$ 的类别是属于距样本$x^{(i)}$的距离的平方最小的那个聚类中心的。 当然使距离的平方最小或是距离最小，都能让我们得到相同的$c^{(i)}$，但是我们通常还是使用距离的平方，因为这是约定俗成的。</p>
</li>
<li><p>移动聚类中心</p>
<p>  对于每个聚类中心：$k$从1循环到$K$，将$μ_k$赋值为这个簇的均值。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>举个栗子：</strong></p>
<p>某一个聚类中心，比如说是$μ_2$被分配了一些训练样本：1,5,6,10 这个表明$c^{(1)}=2$，$c^{(5)}=2$，$c^{(6)}=2$，$c^{(10)}=2$。如果我们从<strong>簇分配</strong>那一步得到了这些结果，这表明，样本1,5,6,10被分配给了聚类中心2；然后在移动聚类中心这一步中，我们计算出这四个的平均值，即计算$x_{(1)}+x_{(5)}+x_{(6)}+x_{(10)}$，然后计算它们的平均值。这时$μ_2$就是一个$n$维的向量，因为$x^{(1)}$，$x^{(5)}$，$x^{(6)}$，$x^{(10)}$ 都是$n$维的向量。这样聚类中心$μ_2$的移动就结束了。</p>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><p>现在，我要问的问题是：</p>
<p>既然我们要让$μ_k$移动到分配给它的那些点的均值处，那么如果存在一个没有点分配给它的聚类中心，那怎么办? </p>
<p>通常在这种情况下，我们就直接移除那个聚类中心。如果这么做了，最终将会得到$K-1$个簇，而不是$K$个簇。</p>
<p>但如果你就是需要$K$个簇，尽管存在没有点分配给它的聚类中心，你所要做的是，重新随机找一个聚类中心。（但是直接移除那个中心，是更为常见的方法。不过在实际过程中，这个问题不会经常出现。）</p>
<hr>
<p>在这个视频结束之前，我还想告诉你<strong>K均值算法</strong>的另外一个常见应用：<strong>应对没有很好分开的簇(non-separated clusters)</strong>。</p>
<p>到目前为止，我们的K均值算法都是基于一些像图中所示的数据：</p>
<p><img src="/img/17_04_20/014.png" alt=""></p>
<p>有很好的隔离开来的三个簇，但是事实情况是，K均值经常会用于一些这样的数据：</p>
<p><img src="/img/17_04_20/015.png" alt=""></p>
<p>看起来并没有很好的分开几个簇。</p>
<p>这是一个关于T恤的大小的应用的例子。假设你是T恤制造商，你找到了一些人，想把T恤卖给他们，然后你搜集了一些这些人的身高和体重的数据。我猜，身高体重更重要一些。然后你可能收集到了上图中一些关于人们身高和体重的样本，然后你想确定一下T恤的大小。</p>
<p>假设我们要设计三种不同大小的t恤：小号、中号、和大号，那么小号应该是多大的?中号呢?大号呢?</p>
<p>使用K均值算法进行聚类，是一种解决这个问题的方法。就像我展示的那样，而且K均值可能将这些数据聚成三个簇：</p>
<p><img src="/img/17_04_20/016.png" alt=""></p>
<p>所以说，尽管这些数据原本看起来并没有三个分开的簇，但是从某种程度上讲，K均值仍然能将数据分成几个类。你能做的就是看这第一群人，然后查看他们的身高和体重，试着去设计对这群人来说比较合身的小号衣服；以及设计一个中号的衣服；设计一个大号的衣服。</p>
<p>这就是一种<strong>市场细分</strong>的例子。当你用K均值方法将你的市场分为三个不同的部分，你就能够区别对待你三类不同的顾客群体，从而更好的适应他们不同的需求。就像大、中、小，三种不同大小的衣服那样。</p>
<p><img src="/img/17_04_20/017.png" alt=""></p>
<p>这就是K均值算法，而且你现在应该已经知道如果去实现，K均值算法并且利用它解决一些问题。在下面的视频中，我想把K均值算法 研究的更深入一些，然后讨论一下如何能让K均值表现得更好一些的问题。</p>
<h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/G6QWt/optimization-objective">视频地址</a></p>
<p>在大多数我们已经学到的<strong>监督学习</strong>算法中(例如线性回归，逻辑回归，以及更多的算法）都有一个优化目标函数，即需要通过算法进行最小化的代价函数。</p>
<p>事实上，<strong>K均值</strong>也有这样一个<strong>优化目标函数</strong>（或者说是代价函数）。</p>
<p>了解和使用这个<strong>K均值</strong>的优化目标函数有两方面的目的：</p>
<ul>
<li>首先这将能帮助我们调试学习算法，确保K均值算法是在正确运行中。</li>
<li>第二个也是最重要的一个目的是，<strong>K均值</strong>优化目标函数将帮助我们找到更好的簇，并且避免局部最优解。（后面会讲到）</li>
</ul>
<hr>
<p>另外顺便提一下，当K均值正在运行时，我们将对两组变量进行跟踪：</p>
<p>首先是$c^{(i)}$:</p>
<script type="math/tex; mode=display">
c^{(i)}=表示 K 个聚类中心中最接近x^{(i)}的那个中心的索引（即当前样本x^{(i)}所归为的那个簇的索引）</script><p>其次是$μ_k$:</p>
<script type="math/tex; mode=display">
μ\_k=表示 第k个簇的聚类中心 （μ\_k\in R^n）</script><p>顺便再提一句，K均值中我们用大写$K$来表示<strong>簇的总数</strong>，用小写$k$来表示<strong>聚类中心的序号</strong>。因此，小写$k$的范围如下：</p>
<script type="math/tex; mode=display">
k\in｛1,2,...,K｝</script><p>除此以外，还有另一个符号，我们用$μ_c^{(i)}$：</p>
<script type="math/tex; mode=display">
μ\_c^{(i)}=表示x^{(i)}所属的那个簇的聚类中心</script><p>举个例子来解释：</p>
<p>假如说$x^{(i)}$被划为了第5个簇，这就是说$x^{(i)}$被分配到了第5个簇，也就是$c^{(i)}=5$。因此$μ_c^{(i)}=μ_5$。所以这里的 $μ_c^{(i)}$就是第5个簇的聚类中心。</p>
<p>而也正是我的样本$x^{(i)}$所属的第5个簇有了这样的符号表示，现在我们就能写出K均值聚类算法的优化目标了。</p>
<h3 id="K均值的代价函数"><a href="#K均值的代价函数" class="headerlink" title="K均值的代价函数"></a>K均值的代价函数</h3><p>以下便是K均值算法需要最小化的<strong>代价函数</strong>：</p>
<script type="math/tex; mode=display">
J(c^{(1)},...,c^{(m)},μ\_1,...,μ\_K)=\frac{1}{m}\sum_{i=1}^m||x^{(i)}-μ\_c^{(i)}||^2</script><p>代价函数$J$的参数$c^{(1)},…,c^{(m)}$以及$μ_1,…,μ_K$，随着算法的执行过程，这些参数将不断变化。</p>
<p>函数的右边给出了优化目标，即每个样本$x^{(i)}$到它所属的聚类中心距离的平方值。$x^{(i)}$就是训练样本的位置，$μ_c^{(i)}$是$x^{(i)}$样本所属的聚类中心的位置。</p>
<p>例如:</p>
<p><img src="/img/17_04_20/018.png" alt=""></p>
<p>如图，图中$x^{(i)}$样本被划分到了$μ_5$这个聚类中心，那么$||x^{(i)}-μ_c^{(i)}||^2$这个距离的平方，也就是在求样本点$x^{(i)}$到$μ_5$之间的距离的平方。</p>
<hr>
<p>K均值的目标就是要最小化代价函数：</p>
<script type="math/tex; mode=display">
\min\limits_{c^{(1)},...,c^{(m)},\\\\μ\_1,...,μ\_K}
J(c^{(1)},...,c^{(m)},μ\_1,...,μ\_K)</script><p>在K均值算法中，有时候也叫做<strong>失真代价函数(distortion cost function)</strong>。</p>
<hr>
<p>现在，我们已经理解了K均值算法的原理就是最小化代价函数$J$的过程。我们也可以用这个原理，来试着调试我们的学习算法，保证我们对K均值算法的实现过程是正确的。</p>
<p>在下一节视频中，我们将一起看看如何帮助K均值找到更好的簇，同时避免局部最优解。</p>
<h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/drcBh/random-initialization">视频地址</a></p>
<blockquote>
<p>在本节课中，我们讨论一下如何初始化K均值聚类方法。</p>
<p>更重要的是，这将引导我们讨论<strong>如何避开局部最优来构建K均值聚类方法</strong>。</p>
</blockquote>
<p>对于我们之前讨论过的K均值聚类算法：</p>
<p><img src="/img/17_04_20/019.png" alt=""></p>
<p>其中我们之前没有讨论得太多的是这一步：</p>
<p><img src="/img/17_04_20/020.png" alt=""></p>
<p>即随机初始化聚类中心$μ_1,μ_2,…,μ_{K} \in R^n$。</p>
<p>如何初始化聚类中心这一步，有几种不同的方法可以用来随机初始化聚类中心。但是，事实证明，有一种可能是效果最好的方法。接下来我就将这个方法介绍给你。</p>
<hr>
<p>这里展示了我通常是如何初始化我的聚类中心的。</p>
<ul>
<li><p>1.确保$K&lt;m$</p>
<ul>
<li>当运行K均值方法时，你需要有一个聚类中心数值$K$，$K$值要比训练样本的数量$m$小，即$K&lt;m$。</li>
</ul>
</li>
<li><p>2.随机初始化</p>
<ul>
<li>随机挑选$K$个训练样本，然后我要做的是设定$μ_1,…,μ_k$让它们等于这$K$个样本。</li>
</ul>
</li>
</ul>
<hr>
<p>下面用一个具体例子来说明：</p>
<p>我们假设$K=2$，那么我们就需要找到两个聚类中心。为了初始化聚类中心，我要做的是随机挑选几个样本。比如说，我挑选了下面这两个点作为聚类中心：</p>
<p><img src="/img/17_04_20/021.png" alt=""></p>
<p>此时的这个例子看起来划分的相当不错，但是有时候我可能不会那么幸运。也许我最后会挑选到下面这样的两个点作为聚类中心：</p>
<p><img src="/img/17_04_20/022.png" alt=""></p>
<p>通过对上面两种初始化情况的对比，你可能会猜到K均值算法在它们两种情况下，会得到不同的结果。这取决于聚类簇的随机初始化方法。K均值方法最后可能得到不同的结果，尤其是如果K均值方法落在局部最优的时候。</p>
<p>如果给你一些这样的数据：</p>
<p><img src="/img/17_04_20/023.png" alt=""></p>
<p>这看起来好像有3个聚类：</p>
<p><img src="/img/17_04_20/024.png" alt=""></p>
<p>那么，如果你运行K均值方法，如果它最后得到一个局部最优，这可能是真正的全局最优，你可能会得到这样的聚类结果：</p>
<p><img src="/img/17_04_20/025.png" alt=""></p>
<p>但是如果你运气特别不好，随机初始化K均值方法也可能会卡在不同的局部最优上面：</p>
<p><img src="/img/17_04_20/026.png" alt=""></p>
<p>对于左边的这种情况，相当于将左下方和上方的样本分为了一类，将右下方的样本分了两类：</p>
<p><img src="/img/17_04_20/027.png" alt=""></p>
<p>对于右边的这种情况，相当于将下面的样本整体的分为了一类，将上方的样本分为了两类。</p>
<p>因此，如果你担心K均值方法会遇到上面这种局部最优的问题，并且你想提高K均值方法找到最有可能的聚类的几率的话，我们能做的就是尝试多次随机的初始化，而不是仅仅初始化一次K均值方法就希望它会得到很好的结果。</p>
<p>我们能做的是：<strong>初始化K均值很多次，并运行K均值方法很多次，通过多次尝试来保证我们最终能得到一个足够好的结果。一个尽可能局部或全局最优的结果。</strong></p>
<p>这才是正确的随机初始化聚类中心的方法。</p>
<h3 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h3><p>具体来说，假如我决定运行K均值方法一百次，那么我就需要执行这个循环100次。这是一个相当典型的次数数字，有时会是从50到1000之间的数字。</p>
<p>假设说有决定运行K均值方法100次，那么这就意味着我们要随机初始化K均值方法100次。对于这100次随机初始化的每一次，我们都需要运行K均值方法。我们会得到一系列聚类结果和一系列聚类中心之后，我们可以计算<strong>失真函数</strong>$J$。用我们得到的这些聚类结果和聚类中心来计算这样一个结果函数。</p>
<p>完成整个100次迭代之后，你会得到这100种聚类数据的这些方法。最后你要做的是，在所有这100种用于聚类的方法中，选取能够给我们代价最小的一个，给我们最低畸变值的一个。</p>
<p>事实证明，如果你运行K均值方法时，所用的聚类数相当小。比如聚类数是从2到10之间的任何数的话，做多次的随机初始化，通常能够保证你能有一个较好的局部最优解，保证你能找到更好的聚类数据。但是如果K非常大的话，比如K比10大很多，就不太可能会有太大的影响。事实上，这种情况下有可能你的第一次随机初始化就会给你相当好的结果。</p>
<p>做多次随机初始化可能会给你稍微好一点的结果，但是不会好太多。但是在这样一个聚类数相对较小的体系里，特别是如果你有2个或者3个或者4个聚类的话，随机初始化会有较大的影响。可以保证你在最小化失真函数的时候，得到一个很小的值。并且能得到一个很好的聚类结果。</p>
<p>这就是K均值的随机初始化的方法。</p>
<h2 id="选择簇的数量"><a href="#选择簇的数量" class="headerlink" title="选择簇的数量"></a>选择簇的数量</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Ks0E9/choosing-the-number-of-clusters">视频地址</a></p>
<blockquote>
<p>在本节中，我想讨论一下K-均值聚类的最后一个细节，就是确定聚类的数目，即如何去选择$K$的值。</p>
<p>说实话，这个问题没有一个非常标准的解答。目前用来决定聚类数目的最常用的方法，仍然是通过看可视化的图，或者看聚类算法的输出结果，或者其他一些东西来手动地决定聚类的数目。</p>
<p>但是，我确实经常被别人问到这样的问题：“你是如何来选择聚类的数目的？” 我只能告诉你一些人们现在对这个问题的思考，人们现在对这个问题的最为常见的做法，实际上仍是手动选择聚类的数目。</p>
</blockquote>
<hr>
<p>选择聚类的数目可能不总是那么容易，大部分情况下，对于数据集中有多少个聚类中心通常是模棱两可的。</p>
<p>看到这样一个数据集：</p>
<p><img src="/img/17_04_20/028.png" alt=""></p>
<p>有些人可能会看到四个聚类，那么这就意味着需要使用$K=4$：</p>
<p><img src="/img/17_04_20/029.png" alt=""></p>
<p>或者有些人可能会看到两个聚类，这就意味着$K=2$：</p>
<p><img src="/img/17_04_20/030.png" alt=""></p>
<p>可能其他人会看到3个聚类。</p>
<p>在我看来它的真实的类别数实际上确实是模棱两可的，所以我并不认为这里有一个正确答案。这就是无监督学习的一部分。没有给我们标签，所以不会总有一个清晰的答案。这就是为什么，做一个能够自动选择聚类数目的算法，是非常困难的原因之一。</p>
<h3 id="肘部法则-Elbow-Method"><a href="#肘部法则-Elbow-Method" class="headerlink" title="肘部法则 (Elbow Method)"></a>肘部法则 (Elbow Method)</h3><p>当人们讨论选择聚类数目的方法时，可能会提及一个叫做<strong>肘部法则 (Elbow Method)</strong>的方法。现在我来介绍一下它，之后会提及到它的一些优点和缺点。</p>
<h4 id="肘部法则引入"><a href="#肘部法则引入" class="headerlink" title="肘部法则引入"></a>肘部法则引入</h4><p>那么对于肘部法则，我们所需要做的是改变K的值（也就是聚类类别的总数）。</p>
<p>我们用K值为1来运行K-均值聚类算法。这就意味着所有的数据都会分到一个类里。然后计算代价函数（或者说计算畸变）$J$，并将其画在这儿：</p>
<p><img src="/img/17_04_20/031.png" alt=""></p>
<p>然后我们选用两个聚类来运行K-均值聚类算法。可能用了多个随机的初始中心，也可能没用。那么有两个聚类的话，我们很可能得到一个较小的畸变值，把它画在这儿：</p>
<p><img src="/img/17_04_20/032.png" alt=""></p>
<p>然后用三个聚类来运行K-均值聚类。你很有可能得到更小的畸变值，把它画在这儿：</p>
<p><img src="/img/17_04_20/033.png" alt=""></p>
<p>之后再让聚类数目等于4、5来运行K-均值聚类，最后我们就能得到一条曲线，它展示了随着聚类数量的增多，畸变值是如何下降的。我们可能会得到一条这样的曲线：</p>
<p><img src="/img/17_04_20/034.png" alt=""></p>
<p>看到这条曲线，肘部法则会说：“我们来看这个图，这里看起来像是一个很清楚的肘点”。</p>
<p><img src="/img/17_04_20/035.png" alt=""></p>
<p>这就类比于人的手臂。这就是肘部法则。</p>
<p>在这里，你会发现这样一种模式：K从1变化到2、再从2到3时，畸变值迅速下降；然后在3的时候，到达一个肘点。此后畸变值就下降得非常慢。这样看起来，也许使用3个类是聚类数目的正确选择。这是因为那个点是曲线的肘点。就是说畸变值快速地下降，直到$K=3$这个点，在这之后就下降得非常慢，那么我们就选$K=3$。</p>
<h4 id="肘部法则局限性"><a href="#肘部法则局限性" class="headerlink" title="肘部法则局限性"></a>肘部法则局限性</h4><p>当你应用肘部法则的时候，如果你得到了一个像上面这样的图，那么这非常好，这是一种用来选择聚类个数的合理方法。而事实证明肘部法则并不那么常用，其中一个原因是如果你把这种方法用到一个聚类问题上，事实上你最后得到的曲线通常看起来是更加模棱两可的，就像这样：</p>
<p><img src="/img/17_04_20/036.png" alt=""></p>
<p>如果你看到这条曲线，也许没有一个清晰的肘点，而畸变值像是连续下降的，也许3是一个好选择，也许4是一个好选择，也许5也不差。如果实际情况中，你遇到的肘点的位置并不明确，这使得用这个方法来选择聚类数目变得较为困难。</p>
<h4 id="肘部法则小结"><a href="#肘部法则小结" class="headerlink" title="肘部法则小结"></a>肘部法则小结</h4><p>简单小结一下肘部法则：它是一个值得尝试的方法，但是我不会期待它在任何问题上都有很高的表现。</p>
<h3 id="通过下游来决定聚类数量"><a href="#通过下游来决定聚类数量" class="headerlink" title="通过下游来决定聚类数量"></a>通过下游来决定聚类数量</h3><p>最后，有另外一种方法来考虑如何选择K的值。</p>
<p>通常人们使用K-均值聚类算法是为了某些后面的用途，或者说某种下游的目的。而要求得一些聚类也许你会用K-均值聚类算法来做市场分割。例如我们之前谈论的T恤尺寸的例子，也许你会用K-均值聚类来让电脑的聚类变得更好，或者可能为了某些别的目的学习聚类，等等。如果那个后续下游的目的（比如市场分割）能给你一个评估标准，那么通常来说决定聚类数量的 更好的办法是，看不同的聚类数量能为后续下游的目的提供多好的结果。</p>
<p>我们来看一个具体的例子：</p>
<p>我们再看一下T恤尺寸这个例子。我想要决定“我是需要3种T恤尺寸么吗？”</p>
<p>所以我选择$K=3$。我可能有小号、中号、大号三类T恤，或者我可以选择$K=5$，那么我可能有特小号、小号、中号、大号和特大号尺寸的T恤。所以，你可能有3种、4种或者5种T恤尺寸。</p>
<p>因此如果我用$K=3$来运行K-均值聚类，我得到的结果可能是这样的：</p>
<p><img src="/img/17_04_20/037.png" alt=""></p>
<p>然而，果我用$K=5$来运行K-均值聚类的话，我得到的结果可能是这样的：</p>
<p><img src="/img/17_04_20/038.png" alt=""></p>
<p>这个例子给了我们对于选择聚类数目问题的另一种方法。</p>
<p>具体来说，你要做的是从T恤生意的角度来思考这个事情，然后问“如果我有5个分段 ，那么我的T恤有多适合我的顾客？那么我的T恤有多适合我的顾客？我可以卖出多少T恤？我的顾客将会有多高兴呢？”</p>
<p>从T恤生意的角度去考虑，其中真正有意义的是：我是需要更多的T恤尺寸 来更好地满足我的顾客？还是说我需要更少的T恤尺寸，我制造的T恤尺码就更少，我就可以将它们更便宜地卖给顾客？因此T恤的销售业务的观点 可能会提供给你一个决定采用3个类还是5个类的方法。</p>
<h3 id="簇数量选择-总结"><a href="#簇数量选择-总结" class="headerlink" title="簇数量选择 总结"></a>簇数量选择 总结</h3><p>总结一下：大部分时候聚类数目仍然是通过手动人工输入或我们的洞察力来决定，一种可以尝试的方法是使用肘部法则，使用肘部法则但是我不会总是 期望它能表现得好。选择聚类数目的更好方法是去问一下你运行K-均值聚类是为了什么目的？然后想一想聚类的数目是多少才适合你运行K-均值聚类的后续目的。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第八周 (2)降维</title>
    <url>/2017/05/12/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AB%E5%91%A8%20(2)%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<blockquote>
<p>在这个模块中，我们将介绍<strong>主成分分析（PCA）</strong>，并显示它可以用于数据压缩，加快学习算法，以及可视化的复杂数据集。</p>
</blockquote>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><h2 id="动机I：数据压缩"><a href="#动机I：数据压缩" class="headerlink" title="动机I：数据压缩"></a>动机I：数据压缩</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/0EJ6A/motivation-i-data-compression">视频地址</a></p>
<blockquote>
<p>本节我将开始介绍第二种无监督学习问题，它叫<strong>降维(dimensionality reduction)</strong>。</p>
<p>我们希望使用降维的一个主要原因是数据压缩。我们会在后几节中看到，数据压缩不仅通过压缩数据使得数据占用更少的计算机内存和硬盘空间，它还能给算法提速。</p>
</blockquote>
<p>首先我们来介绍什么是降维。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>举一个例子，假如我们有一个有很多很多很多特征变量的数据集：</p>
<p><img src="/img/17_05_12/001.png" alt=""></p>
<p>这里为了方便展示，只画了其中两个。</p>
<p>假设我们不知道这两个特征量。其中$x_1$是某个物体的长度，以厘米为单位；另一个$x_2$是它以英寸为单位的长度。所以这是一个非常冗余的数据，与其用两个特征变量$x_1$和$x_2$，它们都是测量到的长度，或许我们应该把这个数据降到一维，只用一个长度的数据。</p>
<p>这个例子可能看起来好像是我生造的，但这个厘米英寸的例子其实还真不是那么无聊。我在工业界看到的情况也是大同小异。</p>
<blockquote>
<p>如果你有上百或者上千的特征变量，很容易就会忘记你到底有什么特征变量，而且有时候可能有几个不同的工程师团队。一队工程师可能给你200个特征变量，第二队工程师可能再给你300个特征变量，然后第三队工程师给你500个特征变量。所以你一共有1000个特征变量，这样就很难搞清哪个队给了你什么特征变量。实际上得到这样冗余的特征变量并不难。</p>
</blockquote>
<p>所以如果以厘米计的长度被取整到最近的厘米整数，以英寸计的长度被取整到最近的英寸整数。这就是为什么这些样本没有完美地在一条直线上。就是因为取整所造成的误差。</p>
<p><img src="/img/17_05_12/002.png" alt=""></p>
<p>这种情况下，如果我们可以把数据降到一维而不是二维，就可以减少冗余。</p>
<h3 id="降维含义"><a href="#降维含义" class="headerlink" title="降维含义"></a>降维含义</h3><p>让我们再详细讲讲从二维降到一维到底意味着什么。</p>
<h4 id="二维降到一维"><a href="#二维降到一维" class="headerlink" title="二维降到一维"></a>二维降到一维</h4><p>让我给这些样本涂上不同的颜色涂上不同的颜色：</p>
<p><img src="/img/17_05_12/003.png" alt=""></p>
<p>在这个例子中降低维度的意思是：我希望找到一条线，基本所有数据映射到这条线上。这样做之后，我就可以直接测量这条线上每个样本的位置。我想把这个新特征叫做$z_1$。</p>
<p><img src="/img/17_05_12/004.png" alt=""></p>
<p>要确定这条线上的位置，我只需要一个数字。这就是说新特征变量$z_1$能够表示这条绿线上每一个点的位置。</p>
<p>在之前如果想要表示一个样本点，我需要一个二维向量$(x_1,x_2)$，但是现在我可以用一个一维向量$z_1$来表示这个样本点：</p>
<p><img src="/img/17_05_12/005.png" alt=""></p>
<p>总结一下，在把所有训练样本映射到一条线上之后，我就能做到只用一个数字来表示每个训练样本的位置。这是一个对原始训练样本的近似。相对于之前需要用两个数字来表示一个样本而言，现在我只需要一个数字就可以表示了。这样就减少了一半的内存需求或者硬盘需求。</p>
<p>更重要的是，数据压缩还会让我们的学习算法运行地更快。</p>
<h4 id="三维降到二维"><a href="#三维降到二维" class="headerlink" title="三维降到二维"></a>三维降到二维</h4><p>现在，我展示一个把三维数据降到二维的例子。</p>
<p><img src="/img/17_05_12/006.png" alt=""></p>
<blockquote>
<p>顺便说一下，在更典型的降维例子中，我们可能有1000维的数据，我们可能想降低到100维，但是因为我在这里能可视化的展示数据的维度是有限制的，所以我要用的例子是三维到二维的。</p>
</blockquote>
<p>我们有一个图上这样的数据集，我有一个样本$x^{(i)}$的集合，$x^{(i)}$是一个三维实数的点，所以我的样本是三维的：</p>
<script type="math/tex; mode=display">
x^{(i)} \in R^3</script><p>实际上，这些样本点，差不多都处于同一平面上。降维在这里的作用，就是把所有的数据，都投影到一个二维的平面内。所以，我们要对所有的数据进行投影，使得它们落在这个平面上：</p>
<p><img src="/img/17_05_12/007.png" alt=""></p>
<p>最后为了表示一个点在平面上的位置，我们需要两个数来表示平面上一个点的位置。这两个数可能叫做$z_1$和$z_2$：</p>
<p><img src="/img/17_05_12/008.png" alt=""></p>
<p>这也意味着我们现在可以用一个二维向量$z$来表示每一个训练样本了：</p>
<p><img src="/img/17_05_12/009.png" alt=""></p>
<script type="math/tex; mode=display">
z^{(i)} \in R^2</script><hr>
<p>为了更好的理解降维的过程，现在让我们用3D绘图来重现上面的整个过程：</p>
<p><img src="/img/17_05_12/010.png" alt=""></p>
<p>我们走的过程是这样的：左边是原始数据集，中间是投影到2D的数据集，右边是以$z_1$和$z_2$为坐标轴的2D数据集。</p>
<p>我们来更详细地看一下：</p>
<p>原始数据集是这样的：</p>
<p><img src="/img/17_05_12/011.gif" alt=""></p>
<p>可以看出来，大部分数据差不多可能都落在某个2D平面上，或者说距离某个2D平面不远。</p>
<p>所以我们可以把它们投影到2D平面上。下面是投影后的效果：</p>
<p><img src="/img/17_05_12/012.gif" alt=""></p>
<p>你可以看到所有的数据落在一个平面上，因为我们把所有的东西都投影到一个平面上了。所以我们现在只需要两个数:$z_1$和$z_2$来表示点在平面上的位置即可：</p>
<p><img src="/img/17_05_12/013.png" alt=""></p>
<p>这就是把数据从三维降到二维的过程。</p>
<p>这就是降维以及如何使用它来压缩数据的过程。</p>
<h2 id="动机II：可视化数据"><a href="#动机II：可视化数据" class="headerlink" title="动机II：可视化数据"></a>动机II：可视化数据</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/t6pYD/motivation-ii-visualization">视频地址</a></p>
<blockquote>
<p>在上节中，我们讲到一种通过数据降维来进行数据压缩的方法。在本节我将会讲到第二种数据降维的应用，那就是<strong>可视化数据</strong>。</p>
<p>对于大多数的机器学习应用，它真的可以帮助我们来开发高效的学习算法，但前提是我们能更好地理解数据。降维就是数据可视化的一种方法。</p>
</blockquote>
<p>假如我们已经收集了大量的有关全世界不同国家的统计数据集：</p>
<p><img src="/img/17_05_12/014.png" alt=""></p>
<p>第一个特征$x_1$是国家的国内生产总值；第二个特征$x_2$是一个百分比，表示人均占有的GDP；第三个特征$x_3$是人类发展指数；第四个特征$x_4$是预期寿命；…直到$x_{50}$</p>
<p>在这里我们有大量的国家的数据，对于每个国家有50个特征。我们有这样的众多国家的数据集，为了使得我们能更好地来理解数据，我们需要对数据进行可视化展示。这里我们有50个特征，但绘制一幅50维度的图是异常困难的，因此我们需要对数据进行降维，然后再可视化。</p>
<p>具体做法如下：</p>
<p>我们使用特征向量$x^{(i)}$来表示每个国家。$x^{(i)}$有着50个维度。我们需要对这50个特征降维之后，我们可以用另一种方式来代表$x^{(i)}$：使用一个二维的向量$z$来代替之前50维的$x$。</p>
<p><img src="/img/17_05_12/015.png" alt=""></p>
<script type="math/tex; mode=display">
z^{(i)} \in R^2</script><p>我们用$z_1$和$z_2$这两个数来总结50个维度的数据，我们可以使用这两个数来绘制出这些国家的二维图，使用这样的方法尝试去理解二维空间下不同国家在不同特征的差异会变得更容易。</p>
<p>在降维处理时，我们用$z_1$来表示那些象征着国家整体情况的数据，例如”国家总面积”、”国家总体经济水平”等；用$z_2$来表示象征着人均情况的数据，例如”人均GDP”，”人均幸福感”等。</p>
<p>降维处理之后，将数据按照这两个维度展示如下：</p>
<p><img src="/img/17_05_12/016.png" alt=""></p>
<p>在图中，右侧的点，象征着国家整体经济比较好的国家；上方的点，象征着人均经济比较好、人均幸福感较高、人均寿命较长…的国家。</p>
<hr>
<p>那么具体我们要如何去压缩数据达到降维的效果呢？在下一节视频中我们将会开始开发一种特别的算法。简称<strong>PCA</strong>或者<strong>主成分分析 </strong>。这个算法允许我们进行数据可视化，同时可以进行早先我们提到的一些有关数据压缩方面的应用。</p>
<h1 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h1><h2 id="主成分分析（PCA）相关概念"><a href="#主成分分析（PCA）相关概念" class="headerlink" title="主成分分析（PCA）相关概念"></a>主成分分析（PCA）相关概念</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/GBFTt/principal-component-analysis-problem-formulation">视频地址</a></p>
<blockquote>
<p>对于降维问题来说，目前最流行最常用的算法是<strong>主成分分析法(Principal Componet Analysis, PCA）</strong>。</p>
<p>在本节中，我想首先开始讨论PCA问题的公式描述，也就是说，我们用公式准确地精确地描述：我们想让PCA来做什么。</p>
</blockquote>
<h3 id="PCA的执行过程2D-gt-1D"><a href="#PCA的执行过程2D-gt-1D" class="headerlink" title="PCA的执行过程2D -&gt; 1D"></a>PCA的执行过程2D -&gt; 1D</h3><p>假设我们有这样的一个数据集:</p>
<p><img src="/img/17_05_12/017.png" alt=""></p>
<p>这个数据集含有二维实数空间内的样本X。</p>
<p>假设我想对数据进行降维，从二维降到一维。也就是说我想找到一条直线将数据投影到这条直线上，那怎么找到一条好的直线来投影这些数据呢？ </p>
<p>这样的一条直线也许是个不错的选择：</p>
<p><img src="/img/17_05_12/018.png" alt=""></p>
<p>你认为这是一个不错的选择的原因是：如果你观察投影到直线上的点的位置，我们发现每个点到它们对应的投影到直线上的点之间的距离非常小。（也就是说这些蓝色的线段非常的短）：</p>
<p><img src="/img/17_05_12/019.png" alt=""></p>
<p>所以，正式的说<strong>PCA</strong>所做的就是<strong>寻找一个低维的面(在这个例子中，其实是一条直线）数据投射在上面，使得这些蓝色小线段的平方和达到最小值</strong>。这些蓝色线段的长度被叫做<strong>投影误差</strong>。</p>
<p>所以<strong>PCA</strong>所做的就是寻找一个投影平面，对数据进行投影，使得这个能够最小化。</p>
<p>另外在应用<strong>PCA</strong>之前，通常的做法是先进行<strong>均值归一化</strong>和<strong>特征规范化</strong>，使得特征$x_1$和$x_2$均值为0，数值在可比较的范围之内。</p>
<blockquote>
<p>在这个例子里，我已经这么做了。但是在后面我还将回过来讨论更多有关PCA背景下的特征规范化和均值归一化问题。</p>
</blockquote>
<hr>
<p>我们正式一点地写出<strong>PCA</strong>的目标是这样的：</p>
<p>如果我们将数据从二维降到一维的话，我们需要试着寻找一个向量$u^{(i)}$，该向量属于$n$维空间中的向量（在这个例子中是二维的），我们将寻找一个对数据进行投影的方向，使得<strong>投影误差能够最小</strong>（在这个例子里，我们把PCA寻找到这个向量记做$u^{(1)}$）：</p>
<p><img src="/img/17_05_12/020.png" alt=""></p>
<p>所以当我把数据投影到这条向量所在的直线上时，最后我将得到非常小的重建误差。</p>
<blockquote>
<p>另外需要说明的时无论PCA给出的是这个$u^{(1)}$是正还是负都没关系。因为无论给的是正的还是负的$u^{(1)}$它对应的直线都是同一条，也就是我将投影的方向。</p>
</blockquote>
<p>这就是将二维数据降到一维的例子。</p>
<p>更一般的情况是我们有$n$维的数据想降到$k$维。在这种情况下我们不仅仅只寻找单个的向量（$u^{(1)}$）来对数据进行投影，我们要找到$k$个方向($u^{(k)}$)来对数据进行投影，从而最小化投影误差。</p>
<h3 id="PCA的执行过程3D-gt-2D"><a href="#PCA的执行过程3D-gt-2D" class="headerlink" title="PCA的执行过程3D -&gt; 2D"></a>PCA的执行过程3D -&gt; 2D</h3><p>下面的例子中，假设我有一些三维数据点：</p>
<p><img src="/img/17_05_12/021.png" alt=""></p>
<p>我想要做的是是寻找两个向量$u^{(1)}$和$u^{(2)}$：</p>
<p><img src="/img/17_05_12/022.png" alt=""></p>
<p>这两个向量一起定义了一个二维平面，我将把数据投影到这个二维平面上。</p>
<blockquote>
<p>如果你精通线性代数，那么这里更正式的定义是：我们将寻找一组向量$u^{(1)}$，$u^{(2)}$，…，$u^{(k)}$，我们将要做的是将数据投影到这$k$个向量展开的线性子空间上。</p>
<p>但是如果你不熟悉线性代数，那就想成是寻找$k$个方向（而不是之寻找一个方向）对数据进行投影。</p>
</blockquote>
<p>所以对于3D降维到2D的这个例子来说，寻找一个$k$维的平面，就是在寻找二维的平面。</p>
<hr>
<p>因此<strong>PCA</strong>做的就是：<strong>寻找一组$k$维向量(一条直线、或者平面、或者诸如此类等等)对数据进行投影，来最小化正交投影误差。</strong></p>
<h3 id="PCA和线性回归的关系"><a href="#PCA和线性回归的关系" class="headerlink" title="PCA和线性回归的关系"></a>PCA和线性回归的关系</h3><p>最后一个我有时会被问到的问题是：<strong>PCA和线性回归有怎么样的关系？</strong></p>
<p>因为当我解释<strong>PCA</strong>的时候，我有时候会画出这样看上去有点像线性回归的图：</p>
<p><img src="/img/17_05_12/023.png" alt=""></p>
<p>但是，事实上<strong>PCA不是线性回归</strong>。尽管看上去有一些相似，但是它们确实是两种不同的算法。</p>
<h4 id="不同点-之一"><a href="#不同点-之一" class="headerlink" title="不同点 之一"></a>不同点 之一</h4><p>如果我们做线性回归，我们做的是在给定某个输入特征$x$的情况下预测某个变量$y$的数值。因此对于线性回归，我们想做的是拟合一条直线，来最小化点和直线之间的平方误差：</p>
<p><img src="/img/17_05_12/024.png" alt=""></p>
<p>所以我们要最小化的是，上图中蓝线幅值的平方。注意我画的这些蓝色的垂直线，这是垂直距离。它是某个点与通过假设的得到的其预测值之间的距离。</p>
<p>与此想反，PCA要做的是最小化这些样本点与直线的最短距离(直角距离)：</p>
<p><img src="/img/17_05_12/025.png" alt=""></p>
<p>这是一种非常不同的效果。</p>
<h4 id="不同点-之二"><a href="#不同点-之二" class="headerlink" title="不同点 之二"></a>不同点 之二</h4><p>更更更一般的是，当你做线性回归的时候，有一个特别的变量$y$作为我们即将预测的值，线性回归所要做的就是用$x$的所有的值来预测$y$。然而在PCA中，没有这么一个特殊的变量$y$是我们要预测的。我们所拥有的是特征$x_1$,$x_2$,…,$x_n$，所有的这些特征都是被同样地对待。</p>
<p>在上面那个从3维降到2维的例子中，原先的3个特征$x_1$,$x_2$,$x_3$都是被同样地对待的，没有特殊的变量$y$需要被预测。</p>
<hr>
<p>因此，PCA不是线性回归。尽管有一定程度的相似性，使得它们看上去是有关联的，但它们实际上是非常不同的算法。</p>
<p>因此，希望你们能理解PCA是做什么的：它是寻找到一个低维的平面，对数据进行投影，以便最小化投影误差平方的（最小化每个点与投影后的对应点之间的距离的平方值）。</p>
<h2 id="PCA算法-实现过程"><a href="#PCA算法-实现过程" class="headerlink" title="PCA算法 实现过程"></a>PCA算法 实现过程</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/GBFTt/principal-component-analysis-problem-formulation">视频地址</a></p>
<blockquote>
<p>本节，将介绍<strong>PCA</strong>算法的具体细节，学完本节后，你就应该知道<strong>PCA</strong>的实现过程，并且应用PCA来给你的数据降维了。</p>
</blockquote>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>在使用PCA之前，我们通常会有一个数据预处理的过程。</p>
<p>拿到某组有m个无标签样本的训练集，一般先进行<strong>均值归一化(mean normalization)</strong>。这一步很重要。然后还可以进行<strong>特征缩放(feature scaling)</strong>，这根据你的数据而定。</p>
<blockquote>
<p>这跟我们之前在<strong>监督学习</strong>中提到的<strong>均值归一</strong>和<strong>特征缩放</strong>是一样的。</p>
</blockquote>
<h4 id="数据预处理第一步：均值归一化-mean-normalization"><a href="#数据预处理第一步：均值归一化-mean-normalization" class="headerlink" title="数据预处理第一步：均值归一化(mean normalization)"></a>数据预处理第一步：均值归一化(mean normalization)</h4><p>对于<strong>均值归一</strong>，我们首先应该计算出每个特征的均值$μ$，然后我们用$x-μ$来替换掉$x$。这样就使得所有特征的均值为0。</p>
<p><strong>举例说明：</strong></p>
<p>比如说，如果$x_1$表示房子的面积，$x_2$表示房屋的卧室数量，然后我们可以把每个特征进行缩放，使其处于同一可比的范围内。</p>
<p>同样地，跟之前的监督学习类似，我们可以首先计算出每个特征的均值：</p>
<script type="math/tex; mode=display">
μ\_j=\frac{1}{m}\sum\_{i=1}^{m}x\_j^{(i)}</script><p>然后每个样本值对应的特征减去其对应的均值：</p>
<script type="math/tex; mode=display">
x\_j^{(i)} ← x\_j^{(i)}-μ\_j</script><p>将所有的特征替换为这种形式的结果。这样就保证了所有特征的均值为0。</p>
<h4 id="数据预处理第二步：特征缩放-feature-scaling"><a href="#数据预处理第二步：特征缩放-feature-scaling" class="headerlink" title="数据预处理第二步：特征缩放(feature scaling)"></a>数据预处理第二步：特征缩放(feature scaling)</h4><p>然后，由于不同特征的取值范围都很不一样，我们还需要进行<strong>特征缩放</strong>。</p>
<p>我们需要将每个特征的取值范围都划定在同一范围内，因此对于均值化处理之后的特征值$x_j^{(i)}-μ_j$，我们还需要做进一步处理：</p>
<script type="math/tex; mode=display">
x\_j^{(i)} ← \frac{x\_j^{(i)}-μ\_j}{s\_j}</script><p>这里$s_j$表示特征$j$度量范围，即该特征的最大值减去最小值。</p>
<h3 id="PCA算法"><a href="#PCA算法" class="headerlink" title="PCA算法"></a>PCA算法</h3><p>接下来就正式进入PCA的算法部分。</p>
<p>在之前的视频中，我们已经知道了PCA的原理。PCA是在试图找到一个低维的子空间，然后把原数据投影到子空间上，并且最小化平方投影误差的值（投影误差的平方和，即下图中蓝色线段长度的平方和）：</p>
<p><img src="/img/17_05_12/026.png" alt=""></p>
<p>那么应该怎样来计算这个子空间呢? 实际上这个问题有完整的数学证明来解释如何找到这样的子空间，不过这个数学证明过程是非常复杂的，同时也超出了本课程的范围。但如果你推导一遍这个数学证明过程，你就会发现要找到$u^{(1)}$的值，也不是一件很难的事。但在这里，我不会给出证明，我只是简单描述一下实现PCA所需要进行的步骤。</p>
<p>假如说我们想要把数据从$n$维降低到$k$维，我们首先要做的是计算出下面这个协方差矩阵(通常用$∑$来表示)：</p>
<script type="math/tex; mode=display">
∑=\frac{1}{m}\sum\_{i=1}^n(x^{(i)})(x^{(i)})^T</script><blockquote>
<p>很不幸的是，这个希腊符号$∑$和求和符号重复了。希望你对这里不要产生混淆。</p>
</blockquote>
<p>计算出这个协方差矩阵后，假如我们把它存为Octave中的一个名为<code>Sigma</code>的变量，我们需要做的是计算出<code>Sigma</code>矩阵的<strong>特征向量(eigenvectors)</strong>。</p>
<p>在Octave中，你可以使用如下命令来实现这一功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[U,S,V] &#x3D; svd(Sigma); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>顺便说一下，<code>svd</code>表示<strong>奇异值分解(singular value decomposition)</strong>，这是某种更高级的奇异值分解，这是比较高级的线性代数的内容。你不必掌握这些，但实际上<code>Sigma</code>是一个协方差矩阵。有很多种方法来计算它的特征向量。</p>
<p>如果你线性代数学得很好，或者你之前听说过特征向量的话，那也许知道在Octave中还有另一个<code>eig</code>命令，可以用来计算特征向量。实际上<code>svd</code>命令和<code>eig</code>命令将得到相同的结果。但<code>svd</code>其实要更稳定一些，所以我一般选择用<code>svd</code>，不过我也有一些朋友喜欢用<code>eig</code>函数。</p>
<p>在这里对协方差矩阵<code>Sigma</code>使用<code>eig</code>和<code>svd</code>时，你会得到同样的答案。这是因为协方差均值总满足一个数学性质，称为<strong>对称正定(symmetric positive definite)</strong>，其实你不必细究这个具体是什么意思，只要知道这种情况下，使用<code>eig</code>和<code>svd</code>结果是一样的就可以了。</p>
</blockquote>
<p>好了，这就是你需要了解的一点线性代数知识，如果有任何地方不清楚的话不必在意。你只需要知道上面这行Octave代码就行了。</p>
<p>如果你用除了Octave或者MATLAB之外的其他编程环境，你要做的是找到某个可以计算svd，即奇异值分解的函数库文件。在主流的编程语言中，应该有不少这样的库文件。我们可以用它们来计算出协方差矩阵的$U$ $S$ $V$矩阵。</p>
<hr>
<p>我再提几个细节问题。</p>
<p>这个协方差矩阵<code>Sigma</code>应该是一个$n×n$的矩阵，通过定义可以发现这是一个$n×1$的向量，和它自身的转置（一个$1×n$的向量）相乘得到的结果，这个结果自然是一个$n×n$的矩阵。</p>
<p>然后把这n个$n×n$的矩阵加起来，当然还是$n×n$矩阵。</p>
<p>然后svd将输出三个矩阵，分别是$U$ $S$ $V$。你真正需要的是$U$矩阵。</p>
<p>$U$矩阵也是一个$n×n$矩阵：</p>
<p><img src="/img/17_05_12/027.png" alt=""></p>
<p>实际上$U$矩阵的列元素就是我们需要的$u^{(1)}$,$u^{(1)}$等等。</p>
<p>如果我们想将数据的维度从$n$降低到$k$的话，我们只需要提取前$k$列向量。这样我们就得到了$u^{(1)}$到$u^{(k)}$，也就是我们用来投影数据的$k$个方向。</p>
<p>我们取出$U$矩阵的前$k$列得到一个新的，由$u^{(1)}$到$u^{(k)}$组成的矩阵$U_{reduce}$：</p>
<script type="math/tex; mode=display">
\begin{equation}
U\_{reduce}=\left[
\begin{matrix}
|&|&|&...&|\\\\
|&|&|&...&|\\\\
u^{(1)}&u^{(2)}&u^{(3)}&...&u^{(k)}\\\
|&|&|&...&|\\\\
|&|&|&...&|\\\\
\end{matrix}
\right]
\end{equation}</script><p>这是一个$n × k$维的矩阵。</p>
<p>然后我们用这个$U_{reduce}$来对我的数据进行<strong>降维</strong>。我们定义：</p>
<script type="math/tex; mode=display">
\begin{equation}
z=\left[
\begin{matrix}
|&|&|&...&|\\\\
|&|&|&...&|\\\\
u^{(1)}&u^{(2)}&u^{(3)}&...&u^{(k)}\\\
|&|&|&...&|\\\\
|&|&|&...&|\\\\
\end{matrix}
\right]
^{T}x
\\\\
=
\left[
\begin{matrix}
-&-&u^{(1)}&...&-\\\\
-&-&u^{(2)}&...&-\\\\
-&-&u^{(3)}&...&-\\\
.&.&.&...&.\\\\
-&-&u^{(k)}&...&-\\\\
\end{matrix}
\right]
x
\end{equation}</script><script type="math/tex; mode=display">
z \in R^k</script><p>其中$\left[<br>\begin{matrix}<br>-&amp;-&amp;u^{(1)}&amp;…&amp;-\\<br>-&amp;-&amp;u^{(2)}&amp;…&amp;-\\<br>-&amp;-&amp;u^{(3)}&amp;…&amp;-\\<br>.&amp;.&amp;.&amp;…&amp;.\\<br>-&amp;-&amp;u^{(k)}&amp;…&amp;-\\<br>\end{matrix}<br>\right]$是$k×n$的矩阵，$x$是$n×1$的矩阵，因此$z$是$k×1$的矩阵。</p>
<p>这里的$x$可以是训练集中的样本，也可以是交叉验证集中的样本，也可以是测试集样本。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，这就是PCA的全过程：</p>
<ul>
<li><p>首先进行均值归一化</p>
<ul>
<li>保证所有的特征量都是均值为0的。</li>
</ul>
</li>
<li><p>然后可以选择进行特征缩放</p>
<ul>
<li>如果不同特征量的范围跨度很大的话，你确实需要进行特征缩放这一步。</li>
</ul>
</li>
<li><p>在以上的预处理之后，我们计算出这个协方差<code>Sigma</code>矩阵：</p>
</li>
</ul>
<script type="math/tex; mode=display">
Sigma = \frac{1}{m}\sum\_{i=1}^m(x^{(i)})(x^{(i)})^T</script><ul>
<li>然后我们可以应用<code>svd</code>函数来计算出<code>U S V</code>矩阵:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[U,S,V] &#x3D; svd(Sigma);</span><br></pre></td></tr></table></figure>
<ul>
<li>然后，我们取出$U$矩阵的前$k$列元素组成新的$U_{reduce}$矩阵：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ureduce &#x3D; U(:,1:k);</span><br></pre></td></tr></table></figure>
<ul>
<li>最后这个式子给出了我们从原来的特征$x$变成降维后的$z$的过程:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z &#x3D; Ureduce&#96;*x;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，跟<strong>k均值算法</strong>类似，如果你使用<strong>PCA</strong>的话，你的$x$应该是$n$维实数。所以没有$x_0 = 1$这一项。</p>
<p>有一件事儿我没做：$u^{(1)},u^{(2)}…u^{(k)}$通过将数据投影到$k$维的子平面上确实使得投影误差的平方和为最小值，但是我并没有证明这一点，因为这已经超出了这门课的范围。</p>
<p>幸运的是PCA算法能够用不多的几行代码就能实现它。</p>
</blockquote>
<h1 id="应用PCA"><a href="#应用PCA" class="headerlink" title="应用PCA"></a>应用PCA</h1><h2 id="对压缩数据的还原"><a href="#对压缩数据的还原" class="headerlink" title="对压缩数据的还原"></a>对压缩数据的还原</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/X8JoQ/reconstruction-from-compressed-representation">视频地址</a></p>
<blockquote>
<p>在前面的视频中我们介绍了<strong>PCA (主成分分析)</strong>作为压缩数据的算法，你会发现它能将高达一千维度的数据压缩到只有一百个维度；或者将三维数据压缩到两个维度的情况。</p>
<p>如果有一个这样的压缩算法，那么也应该有一种方法可以从压缩过的数据近似地回到原始高维度的数据。</p>
<p>假设有一个已经被压缩过的$z^{(i)}$它有100个维度，怎样使它回到其最初的表示$x^{(i)}$也就是压缩前的1000维的数据呢？ </p>
<p>在本节，我将会告诉你如何做到。</p>
</blockquote>
<p>在PCA算法中，我们有下面这些样本：</p>
<p><img src="/img/17_05_12/028.png" alt=""></p>
<p>我们让这些样本投影在一维平面$z_1$上，并且明确地指定其位置：</p>
<p><img src="/img/17_05_12/029.png" alt=""></p>
<p>那么给出一个一维实数点$z$我们能否，让$z$重新变成原来的二维实数点$x$呢？</p>
<p>即做到：</p>
<script type="math/tex; mode=display">
z \in R → x \in R^2</script><hr>
<p>我们知道:</p>
<script type="math/tex; mode=display">
z = U^T\_{reduce}x</script><p>如果想得到相反的情形，方程应这样变化:</p>
<script type="math/tex; mode=display">
x\_{approx} = U\_{reduce}z</script><p>为了检查维度，在这里$U_{reduce}$是一个$n×k$矩阵，$z$就是一个$k×1$维向量。将它们相乘得到的就是$n×1$维。</p>
<p>所以$x_{approx}$是一个$n$维向量。</p>
<p>同时根据PCA的意图，投影的平方误差不能很大。也就是说$x_{approx}$将会与最开始用来导出$z$的原始$x$很接近。用图表示出来就是这样：</p>
<p><img src="/img/17_05_12/030.png" alt=""></p>
<p>这已经与原始数据非常近似了。</p>
<p>这就是用低维度的特征数据$z$还原到未被压缩的特征数据的过程。我们找到一个与原始数据$x$近似的$x_{approx}$。我们也称这一过程为<strong>原始数据的重构(reconstruction)</strong>。</p>
<h2 id="选择主成分的数量k"><a href="#选择主成分的数量k" class="headerlink" title="选择主成分的数量k"></a>选择主成分的数量k</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/S1bq1/choosing-the-number-of-principal-components">视频地址</a></p>
<blockquote>
<p>在PCA算法中，我们把n维特征变量降维到k维特征变量。这个数字k是PCA算法的一个参数。这个数字k也被称作<strong>主成分的数量</strong>。在本节中我会给你们一些参考，告诉你们人们是怎样思考如何选择PCA的参数k的。</p>
</blockquote>
<h3 id="算法原理：最小化平均平方映射误差"><a href="#算法原理：最小化平均平方映射误差" class="headerlink" title="算法原理：最小化平均平方映射误差"></a>算法原理：最小化平均平方映射误差</h3><p>为了选择参数k（也就是要选择<strong>主成分的数量</strong>），这里有几个有用的概念：</p>
<p>PCA所做的是尽量最小化<strong>平均平方映射误差 (Average Squared Projection Error) </strong>。</p>
<p>因此PCA就是要将下面这个量最小化：</p>
<script type="math/tex; mode=display">
\frac{1}{m}\sum\_{i=1}^m||x^{i}-x\_{approx}^{(i)}||^2</script><p>即最小化$x$和其在低维表面上的映射点之间的距离的平方。这就是平均平方映射误差。</p>
<p>同时我们还要定义一下<strong>数据的总变差(Total Variation)</strong>：</p>
<script type="math/tex; mode=display">
\frac{1}{m}\sum\_{1=m}^m||x^{(i)}||^2</script><p>数据的总变差 (Total Variation) 是这些样本的长度的平方的均值。它的意思是 “平均来看，我的训练样本距离零向量（原点）多远？”。</p>
<p>当我们去选择k值的时候，我们通过平均平方映射误差除以数据的总变差来表示数据的变化有多大。我们想要这个比值能够小于1%：</p>
<script type="math/tex; mode=display">
\frac{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}-x\_{approx}^{(i)}||^2
}{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}||^2
}
\le0.01</script><p>大部分人在考虑，选择k的方法时，不是直接选择k值，而是这里的数字应该设置为多少：</p>
<p><img src="/img/17_05_12/031.png" alt=""></p>
<p>它应该是0.01还是其它的数？如果选择了0.01，那么用PCA的语言说就是保留了99%的差异性。</p>
<p>数字0.01是人们经常用的一个值，另一个常用的值是0.05。如果选择了0.05，就意味着95%的差异性被保留了。从95到99是人们最为常用的取值范围。</p>
<p>你可能会惊讶的发现，对于许多数据集，即使保留了99%的差异性，可以大幅地降低数据的维度。因为大部分现实中的数据，许多特征变量都是高度相关的。所以实际上大量压缩数据是可能的，而且仍然会保留99%或95%的差异性。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>那么你该如何实现它呢？</p>
<h4 id="原始的算法"><a href="#原始的算法" class="headerlink" title="原始的算法"></a>原始的算法</h4><p>有一种方式是从1开始，依次递增k的值，尝试检查差异性是否达到预设值。</p>
<p>例如：</p>
<ul>
<li>尝试$k=1$时的PCA。</li>
<li>计算出$U_{reduce}，z^{(1)}，z^{(2)}，…，z^{(m)}，x^{(1)}_{approx}，…，x^{(m)}_{approx}$</li>
<li>检查是否满足：</li>
</ul>
<script type="math/tex; mode=display">
\frac{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}-x\_{approx}^{(i)}||^2
}{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}||^2
}
\le0.01</script><p>如果满足条件，我们就用$k=1$；但如果不满足，那么我们接下来尝试$k=2$，然后我们要重新走一遍这整个过程。</p>
<p>以此类推一直试到上面不等式成立为止。</p>
<h4 id="一种更快的算法"><a href="#一种更快的算法" class="headerlink" title="一种更快的算法"></a>一种更快的算法</h4><p>可以想象，上面这种方式非常低效。每次尝试使用新的$k$值带入计算时，整个计算过程都需要重新执行一遍，还好我没有一种更快捷方便的计算方式。</p>
<p>当你调用<code>svd</code>来计算PCA时，你会得到三个矩阵<code>[U,S,V]</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[U,S,V]&#x3D;svd(Sigma)</span><br></pre></td></tr></table></figure>
<p>除了之前提到的<code>U</code>矩阵之外，当你对协方差的矩阵<code>Sigma</code>调用<code>svd</code>时，我没还会得到中间的这个<code>S</code>矩阵。<code>S</code>矩阵是一个$n×n$的对角矩阵，它只有在对角线上的元素不为0，其余的元素都是0。并且显而易见，它是一个方阵：</p>
<script type="math/tex; mode=display">
\begin{equation}
S=\left[
\begin{matrix}
s\_{11}&0&0&...&0\\\\
0&s\_{22}&0&...&0\\\\
0&0&s\_{33}&...&0\\\
┋&┋&┋&...&┋\\\\
0&0&0&...&s\_{nn}\\\\
\end{matrix}
\right]
\end{equation}</script><p>可以证明的是（我不会在此证明）实际上对于一个给定的k值，可以通过这个$S$矩阵方便的计算出差异性那一项的值：</p>
<script type="math/tex; mode=display">
\frac{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}-x\_{approx}^{(i)}||^2
}{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}||^2
}
=
1-\frac{\sum\_{i=1}^k S\_{ii}}{\sum\_{i=1}^n S\_{ii}}</script><hr>
<p>例如，假设差异性要满足小于$0.01$，那么可以得出：</p>
<script type="math/tex; mode=display">
\frac{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}-x\_{approx}^{(i)}||^2
}{
\frac{1}{m}\sum\_{i=1}^m||x^{(i)}||^2
}
=
1-\frac{\sum\_{i=1}^k S\_{ii}}{\sum\_{i=1}^n S\_{ii}}
\le0.01</script><p>即：</p>
<script type="math/tex; mode=display">
\frac{\sum\_{i=1}^k S\_{ii}}{\sum\_{i=1}^n S\_{ii}}
\ge0.99</script><p>那么你可以从1开始，慢慢增大$k$的值，来计算上面这个不等式，直到满足为止即可（得到满足上面不等式的最小$k$值）。</p>
<hr>
<p>通过这种方式，你只需要<strong>调用一次<code>svd</code>函数</strong>，通过<code>svd</code>给出的<code>S</code>矩阵你就可以通过依次增加$k$值的方式来求解了。这样以来就大幅的提升了计算效率。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>总结一下，使用PCA算法时寻找合适$k$值的方法：</p>
<ul>
<li>首先对协方差矩阵<code>Sigma</code>调用一次<code>svd</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[U,S,V] &#x3D; svd(Sigma)</span><br></pre></td></tr></table></figure>
<ul>
<li>然后使用下面的不等式求得满足条件的最小$k$值：</li>
</ul>
<script type="math/tex; mode=display">
\frac{\sum\_{i=1}^k S\_{ii}}{\sum\_{i=1}^n S\_{ii}}
\ge0.99</script><hr>
<p>顺便说一下，即使你想要手动挑选$k$值，如果你想要向别人解释你实现的PCA的性能具体如何，那么一个好方法就是算出这个值：</p>
<script type="math/tex; mode=display">
\frac{\sum\_{i=1}^k S\_{ii}}{\sum\_{i=1}^n S\_{ii}}</script><p>它会告诉你百分之多少的差异性被保留了下来。</p>
<p>如果你把这个数值展现出来，那么熟悉PCA的人们就可以通过它来更好地理解你用来代表原始数据的压缩后的数据近似得有多好。因为有99%的差异性被保留了。</p>
<p>这就是一个<strong>平方投影误差的测量指标</strong>。它可以带给你对于数据压缩后是否与原始数据相似带来一种很好的直观感受。</p>
<h2 id="应用PCA的建议"><a href="#应用PCA的建议" class="headerlink" title="应用PCA的建议"></a>应用PCA的建议</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/RBqQl/advice-for-applying-pca">视频地址</a></p>
<blockquote>
<p>在之前的课程中，我已经提到过<strong>PCA</strong>有时可以用来提高机器学习算法的速度。在本节，我将讲解如何在实际操作中来实现。同时列举一些例子来说明PCA在具体应用过程中的使用建议。</p>
</blockquote>
<h3 id="PCA应用场景总结"><a href="#PCA应用场景总结" class="headerlink" title="PCA应用场景总结"></a>PCA应用场景总结</h3><p>迄今为止我们讨论过的有关PCA的应用中有如下应用场景：</p>
<ul>
<li>数据压缩<ul>
<li>减少内存或者磁盘空间的使用</li>
<li>提升学习算法的效率（k值的选择是关键）</li>
</ul>
</li>
<li>数据可视化<ul>
<li>将数据降维到二/三维度进行可视化展示</li>
</ul>
</li>
</ul>
<h3 id="通过PCA来提高学习算法的速度"><a href="#通过PCA来提高学习算法的速度" class="headerlink" title="通过PCA来提高学习算法的速度"></a>通过PCA来提高学习算法的速度</h3><p>举例说明，假如你正在用机器学习来处理图片数据。假设每张输入的图片尺寸是$100×100$的，那么对于每张图片来说，都有10000个像素点。假设样本$x^{(i)}$是包含了10000像素强度值的特征向量，即：</p>
<script type="math/tex; mode=display">
x^{(i)}\in R</script><p>那么对于我们的样本数据集来说：</p>
<script type="math/tex; mode=display">
(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),...,(x^{(m)},y^{(m)})</script><p>每个样本中，对应的$x^{(i)}$都是10000维的特征向量。</p>
<p>可想而知，这么高维度的数据带入到逻辑回归、神经网络、支持向量机或者任何别的算法中，学习算法运行的都会很慢。</p>
<p>幸运的是，通过使用PCA，我们能够<strong>降低数据的维数，从而使得算法能够更加高效地运行</strong>。这就是PCA提高算法运算效率的原理。</p>
<h4 id="降维步骤"><a href="#降维步骤" class="headerlink" title="降维步骤"></a>降维步骤</h4><p>首先我们需要检查带标签的训练数据集，并提取出输入数据。我们只需要提取出$x$并暂时把$y$放在一边。这一步我们会得到一组无标签的训练集：</p>
<script type="math/tex; mode=display">
x^{(1)},x^{(2)},...,x^{(m)}\in R^{10000}</script><p>从$x^{(1)}$到$x^{(m)}$，每个样本都是10000维的数据。然后我们应用PCA降维，我们会得到一个降维后的1000维的数据集：</p>
<script type="math/tex; mode=display">
z^{(1)},z^{(2)},...,z^{(m)}\in R^{1000}</script><p>这样我们就得到了一个新的训练集：</p>
<script type="math/tex; mode=display">
(z^{(1)},y^{(1)}),(z^{(2)},y^{(2)}),...,(z^{(m)},y^{(m)})</script><p>现在，我可以将这个已经降维的数据集输入到学习算法中，来得出假设函数，并把降维后的数据作为输入带入，做出预测。</p>
<p>以<strong>逻辑回归</strong>为例：</p>
<p>逻辑回归中，我们得到的假设函数如下：</p>
<script type="math/tex; mode=display">
h\_{\theta}(z) = \frac{1}{1+e^{-\theta^{T}z}}</script><p>我们将$z$向量作为输入带入，并得出一个预测值。</p>
<p>最后，如果你有一个新的样本$x$，那么你所要做的是将你的测试样本$x$通过同样的PCA降维之后，你会得到这个样本所对应的$z$。然后将这个$z$值带入到这个假设函数中进行预测。</p>
<blockquote>
<p><strong>注意（重要）：</strong></p>
<p>最后要注意一点，PCA定义了从$x$到$z$的对应关系，这种对应关系只可以通过在训练集上运行PCA定义出来。</p>
<p>具体来讲，这种PCA所学习出的对应关系，所做的就是计算出一系列的参数。这些参数这就是<strong>特征缩放</strong>和<strong>均值归一化</strong>以及降维矩阵$U_{reduce}$。但是对于降维矩阵$U_{reduce}$中的数据，我们需要使我们的参数唯一地适应<strong>训练集</strong>，而不是适应交叉验证或者测试集。因此我们通过在训练集中找到了降维矩阵$U_{reduce}$，我们就可以将同样的对应关系应用到其他样本中了，比如交叉验证数集样本，或者用在测试数据集中。</p>
<p>总结一下，当你在运行PCA的时候，只是在训练集那一部分来进行的，而不是在交叉验证的数据集或者测试集上运行。在训练集上运行PCA后，得到了从$x$到$z$的映射，然后你就可以将这个映射应用到交叉验证数据集，和测试数据集中。</p>
</blockquote>
<p>通过这个例子中的这种方式，我们讨论了将数据从上万维降到千维。在实际应用场景中，我们经常发现，将数据降维到原有维度的五分之一或者十分之一，就分类的精确度而言，降维后的数据对学习算法几乎没有什么影响。如果我们将降维用在低维数据上，我们的学习算法会运行得更快。</p>
<h3 id="PCA的错误使用"><a href="#PCA的错误使用" class="headerlink" title="PCA的错误使用"></a>PCA的错误使用</h3><p>有一个值得提醒的频繁被误用的PCA应用场景，那就是使用它来避免过拟合。</p>
<p>具体原因是将高维度数据降维处理后，相较于原先的数据，会更不容易出现过拟合的现象。例如我们将10000维的数据降到了1000维，那么降维后的1000维数据相较于降维前的10000维数据更不容易产生过拟合。</p>
<p>因此有人认为PCA是一种避免过拟合的方法，但在这里，我需要强调一下，<strong>为了解决过拟合问题而使用PCA是不适合的！并且我不建议这么做。</strong></p>
<p>如果你比较担心过拟合问题，那么你应该使用正则化方法，而不是使用PCA来对数据进行降维。</p>
<blockquote>
<p><strong>PCA会丢失信息：</strong>如果你仔细想想PCA的工作原理，你会发现它并不需要使用数据的标签，你只需要设定好输入数据$x^{(i)}$，同时使用这个方法来寻找更低维度的数据近似，在这个过程中，PCA实际上已经把某些信息舍弃掉了。</p>
</blockquote>
<p>舍弃掉一些数据，并在你对数据标签$y$值毫不知情的情况下对数据进行降维，所以这或许是一个使用PCA方法的可行之路。如果保留99%的方差，即保留绝大部分的方差，那也是舍弃了某些有用的信息。事实证明，当你在保留99%或者95%或者其它百分比的方差时，结果表明只使用正则化对于避免过拟合，会带来比较好的效果。</p>
<p>同时对于过拟合问题，正则化效果也会比PCA更好，因为当你使用线性回归或者逻辑回归或其他的方法配合正则化时，这个最小化问题实际就变成了y值是什么，才不至于将有用的信息舍弃掉。然而PCA不需要使用到这些标签，它更容易将有价值信息舍弃。</p>
<p>总之，<strong>使用PCA的目的是加速学习算法，但不应该用它来避免过拟合</strong>。</p>
<h3 id="两个建议"><a href="#两个建议" class="headerlink" title="两个建议"></a>两个建议</h3><h4 id="真的需要PCA吗？"><a href="#真的需要PCA吗？" class="headerlink" title="真的需要PCA吗？"></a>真的需要PCA吗？</h4><p>有时候人们正在设计机器学习系统，或许会写下像这样的计划：</p>
<p><strong>设计一个机器学习系统：</strong></p>
<ul>
<li>收集训练数据集$｛(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})｝$</li>
<li>运行PCA将数据$x^{(i)}$降维到$z^{(i)}$</li>
<li>对降维后的数据训练逻辑回归算法$｛(z^{(1)},y^{(1)}),(z^{(2)},y^{(2)}),…,(z^{(m)},y^{(m)})｝$</li>
<li>在测试集上测试结果：将$x_{test}^{(i)}$映射到$z_{test}^{(i)}$。对映射后的数据集$｛(z_{test}^{(1)},y_{test}^{(1)}),…,(z_{test}^{(m)},y_{test}^{(m)})｝$运行假设函数$h_{\theta}(z)$</li>
</ul>
<p>通常在一个项目的初期，有些人便直接写出这样的项目计划。</p>
<p>在写下这样一个使用PCA方法的项目计划前，一个非常好的问题是：<strong>如果我们在整个项目中不使用PCA效果会怎样？</strong> </p>
<p>通常人们不会去思考这个问题，尤其是当人们提出一个复杂的项目并且其中使用了PCA或其它方法时，我经常建议大家在使用PCA之前，首先要想清楚你自己做的是什么，以及你想要做什么。这也是你首先需要在原始数据$x^{(i)}$上考虑的问题。并且根据具体情况来分析是否适合使用PCA，还是直接将原始数据带入到学习算法中。</p>
<h4 id="不要一开始就带入PCA"><a href="#不要一开始就带入PCA" class="headerlink" title="不要一开始就带入PCA"></a>不要一开始就带入PCA</h4><p>同时我也建议一开始不要将PCA方法就直接放到算法里，先使用原始数据$x^{(i)}$看看效果。只有一个原因让我们相信算法出现了问题，那就是你的学习算法收敛地非常缓慢，占用内存或者硬盘空间非常大，所以你想来压缩数据。只有当你的$x^{(i)}$效果不好的时候，那么就考虑用PCA来进行压缩数据。</p>
<p>因为我常常看到某些人在项目开始时便将PCA考虑进去，有时他们并没有仔细思考他们做了什么使得结果表现地好，更没有考虑在不用PCA下的情景会是什么样的效果。如果某个数据不使用PCA也可以工作的很好，但我们对于这些数据使用PCA耗费了大量时间，这是不值得的。</p>
<p>然而，尽管有这些需要注意的地方，PCA仍旧是一种不可思议的有用的算法。PCA的使用频率也很高，大部分时候我都用它来加快学习算法。但我认为PCA通常都是被用来压缩数据以减少内存使用或硬盘空间占用的、或者用来可视化数据的。</p>
<p>同时PCA也是一种强有力的无监督学习算法。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第六周 (1)评价一个学习算法</title>
    <url>/2016/10/24/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E5%91%A8%20(1)%E8%AF%84%E4%BB%B7%E4%B8%80%E4%B8%AA%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="如何少走弯路？"><a href="#如何少走弯路？" class="headerlink" title="如何少走弯路？"></a>如何少走弯路？</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/OVM4M/deciding-what-to-try-next">视频地址</a></p>
<h3 id="这些坑可能会耽误你几个月"><a href="#这些坑可能会耽误你几个月" class="headerlink" title="这些坑可能会耽误你几个月"></a>这些坑可能会耽误你几个月</h3><blockquote>
<p>到目前为止，我们已经介绍了许多不同的学习算法。如果你一直跟着这些视频的进度学习，你会发现自己已经不知不觉地成为一个了解许多先进机器学习技术的专家了。</p>
<p>然而，在懂机器学习的人当中，依然存在着很大的差距。一部分人确实掌握了怎样高效有力地运用这些学习算法，而另一些人他们可能对我马上要讲的东西就不那么熟悉了，他们可能没有完全理解怎样运用这些算法，因此总是把时间浪费在毫无意义的尝试上。</p>
<p>我想做的是，确保你在设计机器学习的系统时，你能够明白怎样选择一条最合适、最正确的道路。</p>
<p>因此，在这节视频和之后的几段视频中，我将向你介绍一些实用的建议和指导，帮助你明白怎样进行选择。</p>
<p>具体来讲，我将重点关注的问题是：假如你在开发一个机器学习系统，或者想试着改进一个机器学习系统的性能，你应如何决定接下来应该选择哪条道路？</p>
</blockquote>
<p>以预测房价为例：</p>
<p>假如在预测房价的例子中，你已经完成了正则化线性回归，也就是最小化代价函数$J$的值。</p>
<p><img src="/img/16_10_24/001.png" alt=""></p>
<p>假如在你得到你的学习参数以后，如果你要将你的假设函数放到一组新的房屋样本上进行测试，假如说你发现在预测房价时产生了巨大的误差，现在的问题是要想改进这个算法接下来该怎么办？</p>
<p>实际上你可以想出很多方法来改进这个算法的性能。</p>
<p>通常情况下我们会使用这几种方法：</p>
<ul>
<li>通过使用更多的训练样本</li>
</ul>
<blockquote>
<p>但有的时候，更多的训练样本并不能解决问题。</p>
</blockquote>
<ul>
<li>尝试选用更少的特征集</li>
</ul>
<blockquote>
<p>你可以从众多的特征集中仔细挑选一小部分来防止<strong>过拟合</strong>。</p>
</blockquote>
<ul>
<li>尝试选用更多的特征集</li>
</ul>
<blockquote>
<p>也许目前的特征集对你来讲并不是很有帮助，你希望获取更多有用的特征数据</p>
</blockquote>
<ul>
<li>也可以尝试增加多项式特征的方法($x_{1}^{2}$,$x_{2}^{2}$,$x_{1}x_{2}$,etc.)</li>
<li>通过增大正则化参数$\lambda$</li>
<li>通过减小正则化参数$\lambda$</li>
</ul>
<p>上面的这些方法，都可以扩展开来，都可能是一个花费6个月甚至更长时间的项目。</p>
<p>遗憾的是，大多数人用来选择这些方法的标准是凭感觉的。而且很多人都会错误的选择其中一种方法花费大量的时间和精力，走上了“不归路”。</p>
<p>幸运的是，有一系列简单的方法，能让你事半功倍，排除掉上面的那个优化清单上的至少一半的方法，留下真正有用的方法。同时也有一种很简单的方法，可以很轻松的排除掉很多选择从而为你节省大量不必要花费的时间。</p>
<h3 id="机器学习诊断法引入"><a href="#机器学习诊断法引入" class="headerlink" title="机器学习诊断法引入"></a>机器学习诊断法引入</h3><p>在接下来的视频中，我首先介绍<strong>怎样评估机器学习算法的性能</strong>，然后在之后的几段视频中，我们将开始讨论这些方法，它们也被称为<strong>“机器学习诊断法(Machine learning diagnostic)”</strong>。</p>
<blockquote>
<p>Diagnostic:A test that you can run to gain insight what is/isn’t working with a learning algorithm, and gain guidance as to how best to improve its performance.</p>
<p>诊断法：这是一种测试法，你通过执行这种测试能够深入了解某种算法到底是否有用，并且也可以告诉你如何改进算法的效果。</p>
</blockquote>
<p>诊断法是一种很有用的方法，可以更有效率地利用好你的时间，但同时也会花费一些时间来实现。</p>
<h2 id="评估假设函数"><a href="#评估假设函数" class="headerlink" title="评估假设函数"></a>评估假设函数</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/yfbJY/evaluating-a-hypothesis">视频地址</a></p>
<p>当我们确定学习算法的参数的时候，我们考虑的是选择参量来使训练误差最小化。有人认为，得到一个非常小的训练误差一定是一件好事，但我们已经知道，仅仅是因为这个假设具有很小的训练误差并不能说明它就一定是一个好的假设函数，而且我们也学习了过拟合假设函数的例子。所以这推广到新的训练集上是不适用的。</p>
<p>那么，你该如何判断一个假设函数是过拟合的呢？对于这个简单的例子，我们可以对假设函数$h(x)$进行画图，然后观察图形趋势：</p>
<p><img src="/img/16_10_24/002.png" alt=""></p>
<p>但对于特征变量不止一个的这种一般情况：</p>
<p><img src="/img/16_10_24/003.png" alt=""></p>
<p>想要通过画出假设函数来进行观察，就会变得很难甚至是不可能实现的。</p>
<p>因此我们需要另一种方法来评估我们的假设函数。</p>
<h3 id="评估假设函数的方法"><a href="#评估假设函数的方法" class="headerlink" title="评估假设函数的方法"></a>评估假设函数的方法</h3><p>如下给出了一种评估假设函数的标准方法：</p>
<p>假设我们有这样一组数据组：</p>
<p><img src="/img/16_10_24/004.png" alt=""></p>
<p>虽然这里只有十组数据，但通常情况下我们都有成百上千组训练样本。</p>
<p>为了确保我们可以评估我们的假设函数，我们要做的是将这些数据进行三七分：</p>
<p><img src="/img/16_10_24/005.png" alt=""></p>
<p>第一部分（70%）将成为我们的<strong>训练集(Training Set)</strong></p>
<p>第二部分（30%）将成为我们的<strong>测试集(Test Set)</strong></p>
<blockquote>
<p>将所有数据按照7:3的比例划分，是一种常见的划分比例</p>
</blockquote>
<p>现在我们有了一部分训练数据集：</p>
<script type="math/tex; mode=display">
(x^{(1)},y^{(1)})\\\\
(x^{(2)},y^{(2)})\\\\
......\\\\
(x^{(m)},y^{(m)})</script><blockquote>
<p>这里的$m$依然表示训练样本的总数</p>
</blockquote>
<p>剩下的部分数据将被用作测试数据：</p>
<script type="math/tex; mode=display">
(x^{(1)}\_{test},y^{(1)}\_{test})\\\\
(x^{(2)}\_{test},y^{(2)}\_{test})\\\\
......\\\\
(x^{(m\_{test})}\_{test},y^{(m\_{test})}\_{test})</script><blockquote>
<p>这里$m_{test}$表示测试样本的总数，$_{test}$表示这些样本是来自测试集。</p>
<p><strong>注意</strong>：如果说我们的数据是有某种规律的话，那么我们按照7:3的比例取数据时，应该是随机选取的。</p>
</blockquote>
<h3 id="评估步骤详解"><a href="#评估步骤详解" class="headerlink" title="评估步骤详解"></a>评估步骤详解</h3><h4 id="线性回归中"><a href="#线性回归中" class="headerlink" title="线性回归中"></a>线性回归中</h4><p>在线性回归中，的训练/测试流程：</p>
<ul>
<li>1.需要对训练集进行学习，得到参数$\theta$。</li>
</ul>
<blockquote>
<p>具体来讲就是最小化训练误差$J(\theta)$。这里的是使用那70%的数据训练得出的结果。</p>
</blockquote>
<ul>
<li>2.计算出测试误差</li>
</ul>
<blockquote>
<p>使用$J_{test}(\theta)$来表示测试误差，我们要做的是取出之前从训练集中学习得到的参数$\theta$带入到$J_{test}(\theta)$来计算我们的测试误差。可以写成如下形式：</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{align\*}
J\_{test}(\theta)= \frac{1}{2m\_{test}}\sum\_{i=1}^{m\_{test}}(
 h\_{\theta}(x\_{test}^{(i)}) - y\_{test}^{(i)}
 )^{2}
\end{align\*}</script><blockquote>
<p>这实际上是测试集平方误差的平均值。</p>
</blockquote>
<hr>
<h4 id="分类问题中"><a href="#分类问题中" class="headerlink" title="分类问题中"></a>分类问题中</h4><p>当然，这是当我们使用线性回归和平方误差标准时测试误差的定义，那么如果是分类问题，比如说使用逻辑回归的时候呢？</p>
<p>训练和测试逻辑回归与之前所说的非常类似：</p>
<ul>
<li>1.首先我们要从训练数据中（前70%）学习得到参数$\theta$</li>
<li>2.然后用下面的式子计算测试数据的误差值:</li>
</ul>
<p><img src="/img/16_10_24/006.png" alt=""></p>
<p>在分类问题中的测试误差$J_{test}(\theta)$其实也被称作<strong>误分类率</strong>（也被称为<strong>0/1错分率</strong>）。表示你预测到的正确或错误样本的情况。</p>
<p>比如说可以这样定义一次预测的误差：</p>
<ul>
<li><p>当$h_{\theta}\ge0.5$时$y=0$</p>
</li>
<li><p>或者当$h_{\theta}\lt0.5$时$y=1$</p>
</li>
</ul>
<p>这两种情况下我们的假设都对样本进行另外误判，否则其他情况下假设值都能正确的对样本$y$进行分类。</p>
<script type="math/tex; mode=display">
err(h\_{\theta}^{(x)},y)
=\\{
\begin{align\*}
&= 1 \ \ if\ h\_{\theta}(x)\ge0.5,\ y=0 
        \ or\ if\ h\_{\theta}(x)\le0.5,\ y=1 \\\\
&= 0 \ otherwise
\end{align\*}</script><p>然后我们就能应用错分率误差来定义测试误差，也就是：</p>
<script type="math/tex; mode=display">
\begin{align\*}
Test\ error = 
 \frac{1}{m\_{test}}\sum\_{i=1}^{m\_{test}}err(
 h\_{\theta}(x\_{test}^{(i)}), y\_{test}^{(i)}
 )
\end{align\*}</script><blockquote>
<p>以上我们介绍了一套标准技术来评价一个已经学习过的假设，在下一段视频中，我们要应用这些方法来帮助我们进行诸如特征选择一类的问题（比如多项式次数的选择，或者正则化参数的选择）。</p>
</blockquote>
<h2 id="多项式模型的选择以及训练集-验证集-测试集的划分"><a href="#多项式模型的选择以及训练集-验证集-测试集的划分" class="headerlink" title="多项式模型的选择以及训练集/验证集/测试集的划分"></a>多项式模型的选择以及训练集/验证集/测试集的划分</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/QGKbr/model-selection-and-train-validation-test-sets">视频地址</a></p>
<blockquote>
<p>假如你想要确定对于某组数据最合适的多项式次数是几次，怎样选用正确的特征来构造学习算法，这些问题我们称之为<strong>”模型选择问题“</strong>。</p>
<p>在我们对于这一问题的讨论中，我们还将提到如何将数据分为三组：也就是<strong>训练集、验证集和测试集</strong>，而不仅仅是前面提到的两组数据。</p>
<p>这一节中，我们将会介绍这些内容的含义。</p>
</blockquote>
<h3 id="选择合适的模型解决过拟合问题"><a href="#选择合适的模型解决过拟合问题" class="headerlink" title="选择合适的模型解决过拟合问题"></a>选择合适的模型解决过拟合问题</h3><p>在过拟合的情况中，学习算法在适用于训练集时表现非常完美，但这并不代表此时的假设也很完美。</p>
<p>更一般的说，这也是为什么训练集误差通常不能正确预测出该假设是否能很好地拟合新样本的原因。</p>
<p>具体来讲，如果你把这些参数集，比如$\theta_{0}$,$\theta_{1}$,$\theta_{2}$…调整到尽量拟合你的训练集，那么结果就是你的假设会在训练集上表现地很好，但这并不能确定当你的假设推广到训练集之外的新的样本上时，预测结果是怎样的。</p>
<p>而更为普遍的规律是，只要你的参数非常拟合某个数据组，比如说非常拟合训练集（当然也可以是其他数据集）：</p>
<p><img src="/img/16_10_24/007.png" alt=""></p>
<p>那么你的假设对于相同数据组的预测误差（比如说训练误差）是不能够用来推广到一般情况的，或者说，是不能作为实际的泛化误差的（也就是说，不能说明你的假设对于新样本的效果）。</p>
<hr>
<p>接下来具体来说说模型选择问题：</p>
<p>假如说你现在要选择能最好地拟合你数据的多项式次数，那么下面的式子你应该选择哪一个呢？</p>
<p><img src="/img/16_10_24/008.png" alt=""></p>
<p>假设$d$代表我们应该选择的多项式的次数(上面的式子次数依次为从1到10)，我们除了需要确定参数$\theta$之外，还要考虑如何确定这个多项式的次数$d$。</p>
<p>因此，我们需要确定参数$d$最适当的取值。</p>
<p>具体地说，比如你想要选择一个模型，那就从这10个模型中，选择一个最适当的多项式次数，并且用这个模型进行估计，预测你的假设能否很好地推广到新的样本上。</p>
<p>那么你可以这样做：</p>
<ul>
<li>你可以先选择第一个模型，然后求训练误差的最小值。这样你就会得到一个参数向量$\theta$。</li>
<li>然后你再选择第二个模型，进行同样的过程，这样你会得到另一个参数向量$\theta$。</li>
<li>拟合三次函数模型时，同理，也能得到一个参数向量$\theta$。</li>
<li>…</li>
<li>用相同的方式得到第10个模型的向量$\theta$。</li>
</ul>
<p><img src="/img/16_10_24/009.png" alt=""></p>
<p>如果一次模型训练后得到的参数向量为$\theta^{(1)}$,二次模型训练后得到的参数向量为$\theta^{(2)}$，依次类推，十次模型训练后得到的参数向量为$\theta^{(10)}$。</p>
<p>接下来，我们要做的是对所有这些模型求出<strong>测试集误差</strong>。因此，我们可以算出每一个模型的$Jtest(\theta^{(1)})$、$Jtest(\theta^{(2)})$、$Jtest(\theta^{(3)})$…$Jtest(\theta^{(10)})$。</p>
<p>接下来为了确定哪一个模型最好，我们可以找出<strong>测试集误差最小的模型</strong>。</p>
<p>假设我们最终选择了五次多项式模型:</p>
<script type="math/tex; mode=display">
Choose \ \ \theta\_{0} + ... \theta\_{5}x^{5}</script><h3 id="正确的评价某个假设函数的预测能力"><a href="#正确的评价某个假设函数的预测能力" class="headerlink" title="正确的评价某个假设函数的预测能力"></a>正确的评价某个假设函数的预测能力</h3><blockquote>
<p>由于我们使用的是<strong>测试结果集</strong>来衡量的代价函数，从而得到多项式次数$d$这个参数的值为5，所以这样任然不能公平地说明这个假设可以推广到一般情况。</p>
<p>也就是说我们选择了一个能最好地拟合测试集的参数$d$的值，因此我们的参数向量$\theta^{(5)}$在拟合测试集时的结果很可能导致一个比实际泛化误差更完美的预测结果。（因为我们找到的是一个最能拟合测试集的参数$d$）。因此我们再用测试集来评价我们的假设就显得不公平了。</p>
<p>而我们其实更关心的是对新样本的拟合效果，所以我们之前说到的如果我们用训练集来拟合参数$\theta_{0}$,$\theta_{1}$等参数时，拟合后的模型在作用于训练集上的效果是不能预测出我们将这个假设推广到新样板上时效果如何的。这是因为这些参数能够很好地拟合训练集，因此它们很有可能在对训练集的预测中表现的很好，但对其他的新样本来说就不一定那么好了。</p>
</blockquote>
<p>我们要做的实际上是用测试集来拟合参数$d$，但是这同样也意味着这并不能较为公平地预测出假设函数在遇到新样本时的表现。</p>
<h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>为了解决这一问题在模型选择中，如果我们要评价某个假设，我们通常采用以下的方法：</p>
<p>给定某个数据集，这里我们要将其分为三段：训练集、<strong>交叉验证集（cross validation set）</strong>、测试集。</p>
<p><img src="/img/16_10_24/010.png" alt=""></p>
<p>一种典型的分割比例是：训练集60%，交叉验证集20%，测试集20%。（这个比例可稍作调整）</p>
<p><img src="/img/16_10_24/011.png" alt=""></p>
<blockquote>
<p>$m$是训练集个数，$m_{cv}$是交叉验证集个数，$m_{test}$是测试集个数。</p>
</blockquote>
<p>我们可以得到 训练集/交叉验证集/测试集 的误差：</p>
<p><img src="/img/16_10_24/012.png" alt=""></p>
<p>现在我们的模型选择问题是这样的：我们现在要使用交叉验证集来选择合适的模型：</p>
<p><img src="/img/16_10_24/013.png" alt=""></p>
<p>即通过使用<strong>训练集</strong>对每一个假设函数依次去求最小化的代价函数$minJ(\theta)$，并求得对应的参数向量$\theta^{(d)}$。</p>
<p>然后我们要做的是在<strong>交叉验证集</strong>中测试这些假设的表现，测出$J_{cv}$来看看这些假设在交叉验证集中表现如何。</p>
<p>然后我们要选择<strong>交叉验证集</strong>误差最小的那个假设模型，假如这个模型是$J_{cv}(\theta^{(4)})$对应的那个模型，因此我们就选择这个四次多项式模型：</p>
<script type="math/tex; mode=display">
\theta\_{0} + \theta\_{1}x^{1} + ... + \theta\_{4}x^{4}</script><p>我们得到了拟合出最好的系数$d=4$。</p>
<p>这个过程中，我们没有使用<strong>测试集</strong>进行拟合，这样我们就回避了<strong>测试集</strong>的嫌疑。这样我们就可以光明正大的使用<strong>测试集</strong>来估计所选模型的泛化误差了。</p>
<p>最后，我们可以使用<strong>测试集</strong>来评价模型的表现。</p>
<p>但最后还是要提醒大家的一点是，在如今的机器学习应用中，确实也有很多人是像我之前介绍的那样做的（用测试集来选择模型，然后用同样的测试集来评价模型的表现，报告测试误差，看起来好像还能得到比较不错的泛化误差），我说过这并不是一个好的方法，但不幸的是，现在还有很多人这样做。如果测试集足够多的话，这也许还能行得通，但大多数的机器学习开发人员是不会这么做的，因为最佳做法还是把数据分成 训练集、验证集、测试集。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第六周 (2)偏差VS方差</title>
    <url>/2016/10/24/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E5%91%A8%20(2)%E5%81%8F%E5%B7%AEVS%E6%96%B9%E5%B7%AE/</url>
    <content><![CDATA[<h2 id="偏差-VS-方差"><a href="#偏差-VS-方差" class="headerlink" title="偏差 VS 方差"></a>偏差 VS 方差</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/yCAup/diagnosing-bias-vs-variance">视频地址</a></p>
<blockquote>
<p>当你运行一个学习算法时，如果这个算法的表现不理想，那么多半是出现两种情况：要么是偏差比较大、要么是方差比较大。换句话说，出现的情况要么是欠拟合、要么是过拟合问题。</p>
<p>对于这两种情况，哪个和偏差有关，哪个和方差有关，或者是不是和两个都有关，搞清楚这一点非常重要。因为这两种情况其实是一个很有效的指示器，指示着改进算法最有效的方法和途径。</p>
<p>在这一节中，我将更深入地探讨一下有关偏差和方差的问题，希望你能对它们有一个更深入的理解，并且也能弄清楚怎样评价一个学习算法，能够判断一个算法是偏差还是方差有问题。</p>
</blockquote>
<p>下面这几幅图，可能你已经见过很多次了：</p>
<p><img src="/img/16_10_24/014.png" alt=""></p>
<p>如果你用两个很简单的假设来拟合数据，那么不足以拟合这组数据（欠拟合）：</p>
<p><img src="/img/16_10_24/015.png" alt=""></p>
<p>而如果你用两个很复杂的假设来拟合时，那么对训练集来说，则会拟合的很好，但又过于完美（过拟合）：</p>
<p><img src="/img/16_10_24/016.png" alt=""></p>
<p>而像这样的中等复杂度的假设，对数据拟合得刚刚好：</p>
<p><img src="/img/16_10_24/017.png" alt=""></p>
<p>此时对应的泛华误差，也是三种情况中最小的。</p>
<p>现在我们已经掌握了“训练集”、“验证集”和“测试集”的概念，我们就能更好地理解偏差和方差的问题。</p>
<p>具体来说，我们沿用之前所使用的训练集误差和验证集误差的定义（也就是平方误差）即对训练集或验证集数据进行预测，所产生的平均平方误差。</p>
<p>下面我们来画出如下这个示意图，其中横坐标代表多项式的次数，纵坐标表示训练误差。其中<strong>蓝色线表示训练集误差的变化情况</strong>，<strong>红色线表示验证集误差的变化情况</strong>：</p>
<p><img src="/img/16_10_24/018.png" alt=""></p>
<p>可以看到随着多项式次数的增多，训练集误差呈下降趋势，验证集误差呈先降后升的趋势。</p>
<h3 id="如何分辨算法处于偏差还是方差？"><a href="#如何分辨算法处于偏差还是方差？" class="headerlink" title="如何分辨算法处于偏差还是方差？"></a>如何分辨算法处于偏差还是方差？</h3><p>假设你得出了一个学习算法，而这个算法并没有表现地如你期望那么好，所以你的交叉验证误差或者测试集误差都很大，我们应该如何判断此时的学习算法正处于高偏差的问题还是高方差的问题呢？</p>
<p><img src="/img/16_10_24/019.png" alt=""></p>
<p>图中左边点表示偏差(bias)情况，右侧点表示方差(variance)情况。</p>
<h4 id="偏差情况"><a href="#偏差情况" class="headerlink" title="偏差情况"></a>偏差情况</h4><p>可以看到偏差情况下，测试集误差和验证集误差都很大，两者误差可能很接近：</p>
<p><img src="/img/16_10_24/020.png" alt=""></p>
<p>那么当你遇到这种情况，就说明你的算法正处于高偏差的问题。</p>
<h4 id="方差情况"><a href="#方差情况" class="headerlink" title="方差情况"></a>方差情况</h4><p>而反过来，如果你的交叉验证集误差远远大于训练集误差：</p>
<p><img src="/img/16_10_24/021.png" alt=""></p>
<p>这就预示着你的算法正处于高方差和过拟合的情况。</p>
<h2 id="正则化和偏差-方差"><a href="#正则化和偏差-方差" class="headerlink" title="正则化和偏差/方差"></a>正则化和偏差/方差</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/4VDlf/regularization-and-bias-variance">视频地址</a></p>
<blockquote>
<p>你现在应该已经知道算法正则化可以有效地防止过拟合，但正则化跟算法的偏差和方差又有什么关系呢？在这一节中，我想更深入地探讨一下偏差和方差的问题。讨论一下两者之间是如何互相影响的，以及和算法的正则化之间的相互关系。</p>
</blockquote>
<p>假设我们要对这样一个高阶多项式进行拟合：</p>
<p><img src="/img/16_10_24/022.png" alt=""></p>
<p>为了防止过拟合现象，我们要使用一个正则化项，因此我们试图通过这样一个正则化项：</p>
<p><img src="/img/16_10_24/023.png" alt=""></p>
<p>来让参数的值尽可能的小。正则化项的求和范围照例取为$j=1$到$j=m$，而非$j=0$到$j=m$。</p>
<h3 id="正则化参数-λ-对假设函数的影响"><a href="#正则化参数-λ-对假设函数的影响" class="headerlink" title="正则化参数$λ$对假设函数的影响"></a>正则化参数$λ$对假设函数的影响</h3><p>然后我们来分析以下三种情形：</p>
<ul>
<li><strong>第一种情形是正则化参数$λ$取一个比较大的值（比如$λ$的值取为10000甚至更大）</strong></li>
</ul>
<blockquote>
<p>在这种情况下，所有这些参数$\theta_{1},\theta_{2},\theta_{3}$等等，将被大大惩罚。其结果是这些参数的值将近似于等于0，并且假设模型$h(x)$的值将等于或者近似等于$\theta_{0}$。因此我们最后得到的假设函数应该是这个样子的：<br><img src="/img/16_10_24/024.png" width = "300" height = "200" align=center /><br>这对于数据集来说，不是一个好的假设</p>
</blockquote>
<ul>
<li><strong>与之对应的另一种情况是$λ$值很小（比如说$λ$的值等于0）</strong></li>
</ul>
<blockquote>
<p>在这种情况下，如果我们要拟合一个高阶多项式的话，那么我们通常会处于过拟合（overfitting）的情况。</p>
<p><img src="/img/16_10_24/025.png" width = "300" height = "200" align=center /></p>
<p>在拟合一个高阶多项式时，如果没有进行正则化或者正则化程度很微小的话，我们通常会得到高方差和过拟合的结果。因为$λ$的值等于0，相当于没有正则化项，因此会对假设过拟合。</p>
</blockquote>
<ul>
<li><strong>只有当我们取一个中间大小的，既不大也不小的$λ$值时，我们才会得到一组合理的对数据刚好拟合的$\theta$参数值。</strong></li>
</ul>
<blockquote>
<p><img src="/img/16_10_24/026.png" width = "300" height = "200" align=center /></p>
</blockquote>
<p>那么我们应该怎样自动地选择出一个最合适的正则化参数$λ$呢？</p>
<p>重申一下，我们的模型和学习参数以及最优化目标是这样的:</p>
<p>让我们假设在使用正则化的情形中，定义$Jtrain(\theta)$为另一种不同的形式，同样定义为最优化目标，但不使用正则化项:</p>
<p><img src="/img/16_10_24/027.png" alt=""></p>
<p>在先前的授课视频中，当我们没有使用正则化时，我们定义的$JTrain(\theta)$就是代价函数$J(\theta)$。</p>
<p>但当我们使用正则化，多出这个$λ$项时，我们就将训练集误差($Jtrain$)定义为<strong>训练集数据预测误差的平方求和</strong>。或者说是训练集的评价误差平方和，但不考虑正则化项。</p>
<p>与此类似，我们来定义交叉验证集误差和测试集误差，和之前一样定义为对交叉验证集合测试集进行预测的平均误差平方和。</p>
<p><img src="/img/16_10_24/028.png" alt=""></p>
<p>总结一下，<strong>我们对于训练误差$Jtrain$,$Jcv$,$Jtest$的定义，都是平均误差平方和</strong>。</p>
<hr>
<h3 id="选择一个正确的-λ"><a href="#选择一个正确的-λ" class="headerlink" title="选择一个正确的$λ$"></a>选择一个正确的$λ$</h3><p>下面就是我们自动选取正则化参数$λ$的方法：</p>
<p>通常我的做法是选取一系列我想要尝试的$λ$值。因此首先我可能考虑不使用正则化的情形，以及一系列我可能会试的值，比如说我可能从0.01,0.02,0.04开始，一直试下去，通常我会将步长设为2倍的速度增长，直到一个比较大的值。在本例中，我们最终取值为10.24（实际上我们取的值是10，但已经非常接近了）。</p>
<p><img src="/img/16_10_24/029.png" alt=""></p>
<p>因此，这样我就得到了12个不同的正则化参数$λ$，对应的12个不同的模型，当然了，你也可以试小于0.01的值或者大于10的值。但在这里，我就不讨论这些情况了。</p>
<p>得到这12组模型后，接下来我们要做的事情是选用第一个模型，也就是$λ=0$，然后最小化我们的代价函数$J(\theta)$，这样我们就得到了某个参数向量$\theta$。</p>
<p>与之前视频的做法类似，我使用$\theta^{(1)}$来表示第一个参数向量$\theta$然后我再取第二个模型$λ=0.01$的模型，最小化代价方差，当然现在$λ=0.01$，那么会得到一个完全不同的参数向量$\theta$，用$\theta^{(2)}$来表示。</p>
<p>同理，接下来，我会得到$\theta^{(3)}$对应于我的第三个模型，以此类推，一直到最后一个$λ=10$或$λ=10.24$的模型对应的$\theta^{(12)}$。</p>
<p><img src="/img/16_10_24/030.png" alt=""></p>
<p>接下来我就可以用交叉验证集来评价这些假设参数了。</p>
<p>因此，我可以从第一个模型开始，然后是第二个模型，对每一个不同的正这化参数$λ$进行拟合，然后用交叉验证集来评价每一个模型:</p>
<p><img src="/img/16_10_24/031.png" alt=""></p>
<p>测出每一个参数$\theta$在交叉验证集上的评价误差平方和，然后我就选取这12个模型中交叉验证集误差最小的那个模型作为最终选择。</p>
<p>对于本例而言，假如说最终我选择了$\theta^{(5)}$，因为此时的交叉验证集误差最小，做完这些最后，如果我想看看该模型在测试集上的表现，我可以用经过学习得到的模型$\theta^{(5)}$来测出它对测试集的预测效果是如何。（再次重申，这里我们依然使用交叉验证集来拟合模型，这也是为什么我之前预留了一部分数据作为测试集的原因。）</p>
<p>这样我就可以用这部分测试集比较准确地估算出我的参数向量$\theta$对于新样本的泛化能力，这就是模型选择在选取正则化参数$λ$时的应用。</p>
<h3 id="正则化参数-λ-对交叉验证集误差和训练集误差产生的影响"><a href="#正则化参数-λ-对交叉验证集误差和训练集误差产生的影响" class="headerlink" title="正则化参数$λ$对交叉验证集误差和训练集误差产生的影响"></a>正则化参数$λ$对交叉验证集误差和训练集误差产生的影响</h3><p>在这一节中，我想讲的最后一个问题是，当我们改变正则化参数$λ$的值时，交叉验证集误差和训练集误差会随之发生怎样的变化。</p>
<p>我想提醒一下，我们最初的代价函数$J(\theta)$是包含正则化项的，但在这里我们把训练误差和交叉验证集误差定义为不包括正则化项。</p>
<p><img src="/img/16_10_24/033.png" alt=""></p>
<p>我要做的是绘制出$Jtrain(\theta)$和$Jcv(\theta)$的曲线，表达的是随着增大正则化项参数$λ$，看看假设在训练集上的是如何变化的，以及在交叉验证集上表现如何变化。</p>
<p>就像我们之前看到的，如果$λ$的值很小，那也就是说我们几乎没有使用正则化，因此我们有很大可能处于过拟合；而如果$λ$的值取的很大的时候，我们很有可能处于高偏差的情况。</p>
<h3 id="λ-在训练集上的变化"><a href="#λ-在训练集上的变化" class="headerlink" title="$λ$在训练集上的变化"></a>$λ$在训练集上的变化</h3><p>所以，如果你画出$Jtrain(\theta)$和$Jcv(\theta)$的曲线，你就会发现当$λ$的取值很小时，对训练集的拟合相对较好，因为没有使用正则化。而如果$λ$的值很大时，你将处于高偏差问题，不能对训练集很好地拟合，训练集误差$Jtrain(\theta)$的值会趋于上升。</p>
<p><img src="/img/16_10_24/032.png" alt=""></p>
<p>此时，你练训练集都不能很好地拟合。反过来，当$λ$的值取得很小的时候，你的数据能随意地与高次多项式很好地拟合。</p>
<h3 id="λ-在交叉验证集上的变化"><a href="#λ-在交叉验证集上的变化" class="headerlink" title="$λ$在交叉验证集上的变化"></a>$λ$在交叉验证集上的变化</h3><p>在曲线的右端，当$λ$的值取得很大时，我们会处于欠拟合问题。这对应着偏差问题，那么此时交叉验证集误差将会很大。我们的假设不能在交叉验证集上表现地比较好。</p>
<p><img src="/img/16_10_24/034.png" alt=""></p>
<p>而在曲线的左端，对应的是高方差问题，此时我们的$λ$值取得很小很小，因此我们会对数据过度拟合，所以交叉验证集误差也会很大。</p>
<p>这就是当我们改变正则化参数$λ$的值时，交叉验证集误差和训练集误差随之发生的变化。当然，在中间取的某个$λ$的值，表现得刚好合适，这种情况下表现最好，交叉验证集误差或者测试集误差都很小。</p>
<blockquote>
<p>当然由于我在这里画的图显得太卡通，也太理想化了，对于真实的数据，你得到的曲线可能比这个看起来更凌乱，会有很多的噪声，对某个实际的数据集，你或多或少能看出像这样一个趋势。通过绘出这条曲线，通过交叉验证集误差的变化趋势，你可以用自己选择出，或者编写程序自动得出能使交叉验证集误差最小的那个点，然后选出那个与之对应的参数$λ$的值。</p>
<p>当我在尝试为学习算法选择正则化参数$λ$的时候，我通常都会画出像这样一个图，帮助我更好地理解各种情况，同时也帮助我确认我选择的正则化参数值到底好不好。</p>
<p>希望这节课的内容让你更深入地理解了正则化以及它对学习算法的偏差和方差的影响，到目前为止你已经从不同角度认识了方差和偏差问题 在下一节视频中我要做的是基于我们已经介绍过的所有这些概念，将它们结合起来，建立我们的诊断法。也称为<strong>学习曲线</strong>这种方法通常被用来诊断一个学习算法到底是处于偏差问题还是方差问题，还是两者都有。</p>
</blockquote>
<h2 id="学习曲线-Learning-Curves"><a href="#学习曲线-Learning-Curves" class="headerlink" title="学习曲线(Learning Curves)"></a>学习曲线(Learning Curves)</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Kont7/learning-curves">视频地址</a></p>
<blockquote>
<p>绘制学习曲线非常有用，也许你想检查你的学习算法运行是否正常，或者你希望改进算法的表现或效果，那么学习曲线就是一种很好的工具。</p>
<p>我经常使用学习曲线来判断某一个学习算法是否处于偏差方差问题，或者二者皆有。</p>
</blockquote>
<p>为了绘制一条学习曲线，我通常先绘制出$Jtrain(\theta)$（也就是训练集数据的平均误差平方和）或者$Jcv(\theta)$（也就是交叉验证集数据的平均误差平方和）。</p>
<p><img src="/img/16_10_24/035.png" alt=""></p>
<p>我要将其绘制成一个关于参数m的函数（也就是一个关于<strong>训练集样本总数</strong>的函数）。</p>
<p><img src="/img/16_10_24/036.png" alt=""></p>
<p>所以m一般都是一个常数，比如$m=100$，表示100组训练样本。但我要自己取一些m的值，比如说我取10，20，30或者40组训练集，然后绘制出训练集误差，以及交叉验证集误差。</p>
<p>那么我们来看看，这条曲线绘制出来是什么样子。</p>
<p>假设我使用二次函数来拟合模型：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = \theta\_{0} + \theta\_{1}x + \theta\_{2}x^{2}</script><p>当只有一组训练样本，即$m=1$，假设函数对数据的拟合情况正如下图所示：</p>
<p><img src="/img/16_10_24/037.png" width = "300" height = "200" align=center /></p>
<p>由于我只有一个训练样本，拟合的结果很明显会很好。对这一个训练样本拟合，其误差一定为0。</p>
<p>如果有两组训练样本，二次函数也能很好地拟合：</p>
<p><img src="/img/16_10_24/038.png" width = "300" height = "200" align=center /></p>
<p>即使是使用正则化，拟合结果也会很好。而如果不使用正则化的话，那么拟合效果绝对棒极了。</p>
<p>如果我用三组训练样本的话，看起来依然能很好地用二次函数拟合：</p>
<p><img src="/img/16_10_24/039.png" width = "300" height = "200" align=center /></p>
<p>也就是说，当$m=1$、$m=2$或$m=3$时，对训练集数据进行预测，得到的训练集误差都将等于0（这里假设我不使用正则化，当然如果使用正则化那么误差就稍大于0）。</p>
<p>好的，总结一下，我们现在已经看到，当训练样本容量m很小的时候，训练误差也会很小，因为很显然，如果我们训练集很小，那么很容易就能把训练集拟合到很好，甚至完全拟合。</p>
<p>现在我们来看看当$m=4$的时候，二次函数似乎也能对数据拟合得很好：</p>
<p><img src="/img/16_10_24/040.png" width = "300" height = "200" align=center /></p>
<p>那我们再看当$m=5$的情况，这时候再用二次函数来拟合，好像效果有下降，但还是差强人意：</p>
<p><img src="/img/16_10_24/041.png" width = "300" height = "200" align=center /></p>
<p>而当我的训练集越来越大的时候，你不难发现，要保证使用二次函数的拟合效果依然很好，就显得越来越困难了：</p>
<p><img src="/img/16_10_24/042.png" width = "300" height = "200" align=center /></p>
<p>因此，事实上随着训练集容量的增大，我们不难发现我们的平均训练误差是逐渐增大的，因此如果你画出这条曲线，你就会发现，训练集误差对假设进行预测的误差平均值随着m的增大而增大。</p>
<p><img src="/img/16_10_24/043.png" width = "300" height = "200" align=center /></p>
<p>那么对于交叉验证误差的情况如何呢？</p>
<p>好的，交叉验证集误差是对完全陌生的交叉验证集数据进行预测得到的误差，那么我们知道，当训练集很小的时候，泛化程度不会很好（意思是不能很好的适应新样本）。因此这个假设就不是一个理想的假设，只有当我使用一个更大的训练集时，我才有可能得到一个能够更好拟合数据的可能的假设。</p>
<p>因此你的验证集误差和测试集误差都会随着训练集样本容量m的增加而减小，因为你是用的数据越多，你能获得的泛化能力就越强，或者说对新样本的适应能力就越强。因此数据越多，越能拟合出合适的假设。</p>
<p>所以如果你把$Jtrain(\theta)$和$Jcv(\theta)$绘制出来，就应该得到这样的曲线：</p>
<p><img src="/img/16_10_24/044.png" width = "300" height = "200" align=center /></p>
<hr>
<h3 id="高偏差-高方差下的学习曲线"><a href="#高偏差-高方差下的学习曲线" class="headerlink" title="高偏差/高方差下的学习曲线"></a>高偏差/高方差下的学习曲线</h3><p>现在我们来看看当处于高偏差或者高方差的情况时，这些学习曲线又会变成什么样子。</p>
<h4 id="高偏差下的学习曲线"><a href="#高偏差下的学习曲线" class="headerlink" title="高偏差下的学习曲线"></a>高偏差下的学习曲线</h4><p>假如你的假设处于高偏差问题，为了更清楚地解释这个问题，我要用一个简单的例子来说明，也就是用一条直线来拟合数据的例子（很显然，一条直线不能很好地拟合数据）：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x)=\theta\_{0} + \theta\_{1}x</script><p><img src="/img/16_10_24/045.png" width = "300" height = "200" align=center /></p>
<p>现在我们来想一想，如果增大样本容量m会发生什么情况呢？</p>
<p><img src="/img/16_10_24/046.png" width = "300" height = "200" align=center /></p>
<p>当样本数量增多的时候，你不难发现用来拟合这些数据的直线相较于之前不会变化太大，因为这条直线是对这组数据最接近的拟合，但一条直线再怎么接近，也不可能对这组数据进行很好的拟合。</p>
<p>所以，如果你绘制出交叉验证集误差，应该是这个样子：</p>
<p><img src="/img/16_10_24/047.png" width = "300" height = "200" align=center /></p>
<p>最左边表示训练集样本容量很小，比如说只有一组样本，那么表现当然很不好；当达到某一个容量值的时候，你就会找到那条最有可能拟合数据的那条直线，并且此时即便你继续增大训练集的样本容量m，你基本上还是会得到一条差不多的直线。因此交叉验证集误差将会很快变为水平而不再变化。</p>
<p>那么训练误差又如何呢？</p>
<p>同样，训练误差一开始也是很小的，而在高偏差的情形中，你会发现训练集误差会逐渐增大，一直趋于接近交叉验证集误差，这是因为你的参数很少。但当m很大的时候，数据太多，此时训练集和交叉验证集的预测结果将会非常接近：</p>
<p><img src="/img/16_10_24/048.png" width = "300" height = "200" align=center /></p>
<p>这就是当你的学习算法处于高偏差情形时学习曲线的大致走向。</p>
<p>最后补充一点，高偏差的情形反映出的问题是交叉验证集和训练集误差都很大，也就是说，你最终会得到一个值比较大的$Jcv(\theta)$和$Jtrain(\theta)$。</p>
<p>这也得出一个很有意思的结论，那就是如果一个学习算法有很大的偏差，那么当我们选用更多的训练样本时，我们发现交叉验证集误差的值不会表现出明显的下降，实际上是变为水平了。</p>
<p><strong>所以如果学习算法正处于高偏差的情形，那么选用更多的训练集数据对于改善算法表现无益。</strong></p>
<p>所以能够看清你的算法正处于高偏差的情形，是一件很有意义的事情，因为这样可以让你避免把时间浪费在想收集更多的训练样本上，因为再多的数据也是无意义的。</p>
<hr>
<h4 id="高方差下的学习曲线"><a href="#高方差下的学习曲线" class="headerlink" title="高方差下的学习曲线"></a>高方差下的学习曲线</h4><p>接下来我们再来看看正处于高方差的时候，学习曲线应该是什么样子的。</p>
<p>首先我们看看训练集误差，如果你的训练集样本容量很小，如下图：</p>
<p><img src="/img/16_10_24/049.png" width = "300" height = "200" align=center /></p>
<p>如果我们用很高阶次的多项式来拟合：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x) = \theta\_{0} + \theta\_{1}x + ... + \theta\_{100}x^{100}</script><blockquote>
<p>当然不会有人用这样的多项式，这里只是为了演示使用。</p>
</blockquote>
<p>假设我们使用一个很小的$\lambda$，那么很显然，我们会对这组数据拟合的非常好：</p>
<p><img src="/img/16_10_24/050.png" width = "300" height = "200" align=center /></p>
<p>所以，如果训练集样本容量很小时，训练集误差$Jtrain(\theta)$将会很小，随着训练集样本容量的增加，可能这个假设函数任然会对数据或多或少有一点过拟合，但很明显此时要对数据很好地拟合显得更加困难和吃力了：</p>
<p><img src="/img/16_10_24/051.png" width = "300" height = "200" align=center /></p>
<p>所以随着训练集样本容量的增大，我们会发现$Jtrain(\theta)$的值会随之增大，因为当训练样本越来越多的时候，我们就越难将训练集数据拟合得很好，但总体来说，训练集误差还是很小：</p>
<p><img src="/img/16_10_24/052.png" width = "300" height = "200" align=center /></p>
<p>那么交叉验证集误差又如何呢？</p>
<p>在高方差的情形中，假设函数对数据过拟合，因此交叉验证集误差将会一直都很大，即便我们选择一个比较合适恰当的训练集样本数：</p>
<p><img src="/img/16_10_24/053.png" width = "300" height = "200" align=center /></p>
<p><strong>所以算法处于高方差情形最明显的一个特点是在训练集误差和交叉验证集误差之间以一段很大的差距：</strong></p>
<p><img src="/img/16_10_24/054.png" width = "300" height = "200" align=center /></p>
<p>而这个曲线也反映出如果我们要考虑增大训练集的样本数，这两条学习曲线会逐渐靠近，<strong>高方差情形下使用更多的数量级对改进算法的表现事实上是有效果的。</strong></p>
<hr>
<blockquote>
<p>以上画出的学习曲线都是相当理想化的形式，针对一个实际的学习算法，如果你画出学习曲线的话，你会看到基本类似的结果。虽然有的时候数据会带有一点噪声或干扰的曲线，但总的来说像这样画出学习曲线确实能帮助你来看清你的学习算法是否处于高偏差、高方差、或者二者皆有的情形。</p>
<p>所以在改进一个学习算法的时候，通常要先画出这些学习曲线。这项工作会让你更轻松地看出偏差或方差的问题。</p>
</blockquote>
<h2 id="重新审视决定下一步做什么"><a href="#重新审视决定下一步做什么" class="headerlink" title="重新审视决定下一步做什么"></a>重新审视决定下一步做什么</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/zJTzp/deciding-what-to-do-next-revisited">视频地址</a></p>
<blockquote>
<p>我们讨论了模型选择问题，偏差和方差的问题，那么这些诊断法则怎样帮助我们判断哪些方法可能有助于改进学习算法的效果，而哪些可能是徒劳的呢？让我们再次回到最开始的例子，在那里寻找答案。</p>
</blockquote>
<p>这就是我们之前的例子：</p>
<blockquote>
<p>Debugging 一个学习算法：</p>
<p>假设你用正则化线性回归来预测房价。但当你尝试在一组新的数据上使用你的假设函数时，你发现它出现了很大的无法容忍的误差。你接下来要怎么做来改进这个算法呢？</p>
</blockquote>
<p>我们使用正则化的线性回归拟合模型，却发现该算法没有达到预期效果。我们提到我们有如下选择方案：</p>
<ul>
<li>通过使用更多的训练样本</li>
<li>尝试选用更少的特征集</li>
<li>尝试选用更多的特征集</li>
<li>也可以尝试增加多项式特征的方法$(x_{1}^{2},x_{2}^{2},x_{1}x_{2},etc.)$</li>
<li>通过增大正则化参数$λ$</li>
<li>通过减小正则化参数$λ$</li>
</ul>
<p>那么如何判断哪些方法更可能是有效的呢？</p>
<p>第一种可供选择的方法是使用更多的训练集数据，这种方法对于<strong>高方差问题</strong>是有帮助的。</p>
<p>第二种方法的情况同样是对<strong>高方差问题</strong>时有效。</p>
<blockquote>
<p>换句话说如果你通过绘制学习曲线或者别的什么方法看出你的模型处于高偏差问题，那么切记千万不要浪费时间视图从已有的特征中挑出一小部分来使用。</p>
<p>如果你发现你的算法处于高方差的情形，那么你需要花一点时间来挑选出一小部分合适的特征，这是把时间用在了刀刃上的。</p>
</blockquote>
<p>第三种方法选用更多的特征集，通常来讲尽管不是所有时候都适用，但增加特征数<strong>一般可以帮助解决高偏差问题</strong>。</p>
<blockquote>
<p>如果你需要增加更多的特征时，一般是由于你现有的假设函数太简单，因此我们才决定增加一些别的特征来让假设函数更好地拟合训练集。</p>
</blockquote>
<p>第四种方式，增加多项式特征与第三种方式类似，也是用于修正<strong>高偏差问题</strong>。</p>
<blockquote>
<p>具体来说，如果你画出的学习曲线告诉你你还是处于高方差问题，那么采取这种方法就是浪费时间。</p>
</blockquote>
<p>第五种和第六种方式，增大和减小正则化参数$λ$，是很方便的方法，不至于花费太多时间。减小$λ$可以修正<strong>高偏差问题</strong>，增大$λ$可以修正<strong>高方差问题</strong>。</p>
<hr>
<h3 id="和神经网络的联系"><a href="#和神经网络的联系" class="headerlink" title="和神经网络的联系"></a>和神经网络的联系</h3><p>最后我们回顾一下这几节课介绍的这些内容，并且看看它们和神经网络的联系。</p>
<p>我想介绍一些很实用的经验或建议，这些也是我平时为神经网络模型选择结构或者链接形式的一些技巧。</p>
<p>当你在用一个相对比较简单的神经网络模型进行神经网络拟合的时候：</p>
<ul>
<li>其中有一种选择是选择相对简单的隐藏层结构，比如说只有一个隐藏层，或者相对来讲比较少的隐藏层单元：</li>
</ul>
<p><img src="/img/16_10_24/055.png" width = "300" height = "200" align=center /></p>
<blockquote>
<p>这种结构简单的神经网络参数就不会很多，很容易出现<strong>欠拟合</strong>。这种比较小型的神经网络其最大优势在于计算量较小。</p>
</blockquote>
<ul>
<li>与之相对的另一种情况是相对较大型的神经网络结构：要么隐藏层单元比较多，要么隐藏层单元比较多：</li>
</ul>
<p><img src="/img/16_10_24/056.png" width = "300" height = "200" align=center /></p>
<blockquote>
<p>这种比较复杂的神经网络参数一般比较多，也更容易出现<strong>过拟合</strong>。这种结构的一大劣势也许不是主要的，但还是需要考虑，那就是当网络中的神经元数量很多的时候，这种结构会显得计算量较大，虽然有这个情况，但通常来讲这不是大问题。</p>
<p>这种大型网络最主要的问题还是它更容易出现过拟合现象。</p>
<p><strong>事实上，如果你经常应用神经网络，特别是大型神经网络的话，你就会发现越大型的网络性能越好，但如果发生了过拟合，你可以使用正则化的方法来修正过拟合。</strong></p>
<p>一般来说，使用一个大型的神经网络并使用正则化来修正过拟合问题，通常比使用一个小型的神经网络效果更好。但主要问题可能出现在计算量相对较大。</p>
<p><strong>最后，你还要选择隐藏层的层数，你是该用一个隐藏层呢，还是用三个呢？通常来说，默认的情况是使用一个隐藏层。但是如果你确实想要选择多个隐藏层你也可以试试把数据分割为训练集、验证集和测试集，然后使用交叉验证的方法比较一个隐藏层的神经网络然后试试两个三个隐藏层以此类推，然后看看哪个神经网络在交叉验证集上表现得最理想，然后你对每一个模型都用交叉验证集数据进行测试，算出三种情况下（隐藏层分别为一层、两层、三层）的交叉验证集误差$Jcv(\theta)$，然后选出你认为最好的神经网络结构。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第六周 (3)机器学习系统设计-[构建垃圾邮件分类器][误差分析]</title>
    <url>/2016/12/18/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E5%91%A8%20(3)%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="构建垃圾邮件分类器"><a href="#构建垃圾邮件分类器" class="headerlink" title="构建垃圾邮件分类器"></a>构建垃圾邮件分类器</h2><blockquote>
<p>在接下来的视频中，我将谈到机器学习的系统设计。</p>
<p>这些视频将谈及在设计复杂的机器学习系统时，你将遇到的主要问题。同时我们会试着给出一些关于如何巧妙构建一个复杂的机器学习系统的建议。</p>
<p>接下来的视频可能看起来有点不连贯，因为这些视频会涉及一些你在设计机器学习系统时可能会遇到的不同问题。虽然下面的课程数学性可能不是那么的强，但是我认为我们将要讲到的这些东西是非常有用的。可能在构建大型机器学习系统时节省大量的时间。</p>
</blockquote>
<h3 id="先想想第一步做什么"><a href="#先想想第一步做什么" class="headerlink" title="先想想第一步做什么"></a>先想想第一步做什么</h3><p><a href="https://www.coursera.org/learn/machine-learning/lecture/4h5X4/prioritizing-what-to-work-on">视频地址</a></p>
<p>具体的说，我们首先要讲的是当我们在进行机器学习时，着重要考虑什么问题。首先我要举一个垃圾邮件分类的例子。</p>
<p>假如你想建立一个垃圾邮件分类器，看这些垃圾邮件与非垃圾邮件的例子（左侧是垃圾邮件，右侧是非垃圾邮件）：</p>
<p><img src="/img/16_12_18/001.png" alt=""></p>
<h4 id="建立特征向量"><a href="#建立特征向量" class="headerlink" title="建立特征向量"></a>建立特征向量</h4><p>左侧这封邮件想要向你推销某个商品。注意这封垃圾邮件有意的拼错一些单词，例如<code>w4tchs</code>,<code>Med1cine</code>。右边的邮件显然不是一个垃圾邮件。假设我们已经有一些加过标签的训练集，包括标注的垃圾邮件（<code>y=1</code>）和非垃圾邮件(<code>y=0</code>)。我们如何以监督学习的方法来构造一个分类器来区分垃圾邮件和非垃圾邮件呢？</p>
<p>为了应用监督学习，我们首先必须确定的是如何用邮件的特征构造向量$x$。给出训练集中的特征$x$和标签$y$，我们就能够训练出某种分类器，比如用逻辑回归的方法。</p>
<ul>
<li>$x = features\ of\ email\ (邮件的特征)$</li>
<li>$y = spam(1)\ or\ not\ spam(0)\ (是否为垃圾邮件：1是、0否)$</li>
</ul>
<p>这里有一种选择邮件的一些特征变量的方法，比如说我们可能会想出一系列单词，我们可以认为这些单词能够用来区分垃圾邮件或非垃圾邮件。</p>
<p>比如说，如果有封邮件，包含单词<code>deal</code>，那么它就很有可能是一封垃圾邮件，同时包含单词<code>buy</code>的邮件也很有可能是一封垃圾邮件，包含<code>discount</code>的邮件也很有可能是垃圾邮件。</p>
<p>如果一封邮件中包含了我的名字，这有可能是一个知道我的人写的，说明这封邮件不太可能是垃圾邮件。因为某些原因，我认为<code>now</code>这个单词表明了这封邮件可能并不是垃圾邮件，因为我经常收到一些很紧急的邮件，当然还有别的单词。我们可以选出这样成百上千的单词。</p>
<p>给出一封这样的邮件：</p>
<p><img src="/img/16_12_18/002.png" alt=""></p>
<p>我们可以将这封邮件用一个特征向量来表示，方法如下：</p>
<p>首先根据字母顺序排序列出我之前选好的单词：</p>
<p><code>andrew</code>,<code>buy</code>,<code>deal</code>,<code>discount</code>,…,<code>now</code>,…</p>
<p>然后对当前这封邮件检查一下这些词汇是否出现在这封邮件中。</p>
<p>我用一个特征向量x来表示这些词汇是否出现在了邮件中：</p>
<script type="math/tex; mode=display">
x=
\begin{bmatrix}
   0(andrew) \\\\
   1(buy) \\\\
   1(deal) \\\\
   0(discont) \\\\
   ... \\\\
   1(now) \\\\
   ...
\end{bmatrix}</script><p>在这个例子中，我选择了100个词用于表示是否可能为垃圾邮件，所以这个特征向量的维度是100。</p>
<p>并且:</p>
<script type="math/tex; mode=display">
x\_{j} = 
\begin{matrix}
   1\ 如果单词出现在email中 \\\\
   0\ 如果单词没出现在email中
\end{matrix}</script><p>这样我们就可以用特征向量来表示这封邮件。</p>
<p>顺便说一句，虽然我所描述的这个过程是我自己选取的100个词，但是在实际工作中最普遍的做法是遍历整个训练集，然后在训练集中选出出现次数最多的n个单词，n一般介于10000到50000之间。然后把这些词作为你要用的特征，因此不同于手动选取，我们只用遍历训练样本，然后选出出现频率最高的词语。这些单词会构成特征，这样你就可以使用它们来做垃圾邮件分类了。</p>
<h4 id="从何处入手来提高分类准确度？"><a href="#从何处入手来提高分类准确度？" class="headerlink" title="从何处入手来提高分类准确度？"></a>从何处入手来提高分类准确度？</h4><p>如果你正在构造一个垃圾邮件分类器，你应该会面对这样一个问题，那就是：</p>
<p><strong>你最该去使用哪一种改进你的方法，从而使得你的垃圾邮件分类器具有较高的准确度？</strong></p>
<h5 id="积累大量数据"><a href="#积累大量数据" class="headerlink" title="积累大量数据"></a>积累大量数据</h5><p>从直觉上讲，是要收集大量的数据。事实上确实好多人这么做，很多人认为收集越多的数据，算法就会表现的越好。事实上就垃圾邮件分类而言，有一个叫做<strong>“Honey  Pot”</strong>的项目，它可以建立一个假的邮箱地址，故意将这些地址泄露给发垃圾邮件的人，这样就能收集到大量的垃圾邮件了。这样的话我们就能得到非常多的垃圾邮件来训练学习算法了。</p>
<h5 id="从email的header中提取路径等信息"><a href="#从email的header中提取路径等信息" class="headerlink" title="从email的header中提取路径等信息"></a>从email的header中提取路径等信息</h5><p>但是在前面的课程中我们知道，大量的数据可能会有帮助，但也可能没有。对于大部分的机器学习问题，还有很多办法用来提升机器学习效果。比如对于垃圾邮件来说，也许你会想到用更复杂的特征变量，像是邮件的路径信息（这种信息通常会出现在邮件的标题中）。因此，垃圾邮件发送方在发送垃圾邮件时，他们总会试图让这个邮件的来源变得模糊一些，或者是用假的邮件标题，或者通过不常见的服务器来发送邮件，用不常用的路由来发送邮件。</p>
<p>因此我们可以通过邮件的标题部分来构造更加复杂的特征，来获得一系列的邮件路由信息，进而判定是不是一封垃圾邮件。</p>
<h5 id="从email的正文中提取特征"><a href="#从email的正文中提取特征" class="headerlink" title="从email的正文中提取特征"></a>从email的正文中提取特征</h5><p>你可能还会想到别的方法，比如从邮件的正文出发，寻找一些复杂点的特征，例如单词<code>discount</code>是否和单词<code>discounts</code>是一样的，又比如单词<code>deal</code>和<code>dealer</code>是否也应视为等同？甚至像这个例子中有的单词小写，有的单词大写。或者我们是否应该用标点符号来构造复杂的特征变量，因为垃圾邮件可能更多的使用感叹号。</p>
<h5 id="构建错词识别算法，来区分邮件中恶意拼写错误的单词"><a href="#构建错词识别算法，来区分邮件中恶意拼写错误的单词" class="headerlink" title="构建错词识别算法，来区分邮件中恶意拼写错误的单词"></a>构建错词识别算法，来区分邮件中恶意拼写错误的单词</h5><p>同样的，我们也可能构造更加复杂的算法来检测或者纠正那些故意的拼写错误 ，例如<code>m0rtgage</code>,<code>med1cine</code>,<code>w4tches</code>。因为垃圾邮件发送方确实这么做了，因为如果你将4放到<code>w4tches</code>中,那么用我们之前提到的简单的方法，垃圾邮件分类器不会把<code>w4tches</code>和<code>watches</code>看成一样的，这样我们就很难区分这些故意拼错的垃圾邮件。发垃圾邮件的也很机智，他们这么做就逃避了一些过滤。</p>
<hr>
<p>当我们使用机器学习时，总是可以“头脑风暴”一下，想出一堆方法来试试，就像这样。顺带一提，我有一段时间研究过垃圾邮件分类的问题，尽管我能够理解垃圾邮件分类的问题，我确实懂一些这方面的东西，但是我还是很难告诉你，这四种方法中，你最该去使用哪一种。</p>
<p>事实上，坦白地说，最常见的情况是：一个研究小组，可能会随机确定其中的一个方法，但是有时候，这种方法并不是最有成效的。你知道，你只是随机选择了其中的一种方法。<strong>实际上，当你需要通过头脑风暴来想出不同方法来尝试去提高精度的时候，你可能已经超越了很多人了。令人难过的是，大部分人他们并不尝试着列出可能的方法。</strong>他们做的只是某天早上醒来，因为某些原因，有了一个突发奇想：”让我们来试试 用Honey Pot项目 收集大量的数据吧”。不管出于什么奇怪的原因，早上的灵机一动，还是随机选一个，然后干上大半年。</p>
<p>但是我觉得我们有更好的方法，是的，我们将在随后的课程中讲到这个，那就是<strong>误差分析</strong>。</p>
<p>我会告诉你，<strong>怎样用一个更加系统性的方法从一堆不同的方法中选取合适的那一个。</strong>因此，你更有可能选择一个真正的好方法，能让你花上几天几周甚至是几个月去进行深入的研究。</p>
<h2 id="误差分析，几个小窍门"><a href="#误差分析，几个小窍门" class="headerlink" title="误差分析，几个小窍门"></a>误差分析，几个小窍门</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/x62iE/error-analysis">视频地址</a></p>
<p>在上一节课中，我讲到应当怎样面对机器学习问题，有很多提高算法表现的方法，在本次课程中，我们将会讲到<strong>误差分析(error analysis)</strong>的概念。这会帮助你更系统地做出决定。</p>
<h3 id="推荐方法："><a href="#推荐方法：" class="headerlink" title="推荐方法："></a><strong>推荐方法：</strong></h3><ul>
<li>1.以一个你可以快速实现的简单的算法作为开始。实现它并且在交叉验证数据集上进行测试。</li>
</ul>
<blockquote>
<p>如果你准备研究机器学习的东西，或者构造机器学习应用程序，最好的实践方法不是建立一个非常复杂的系统，拥有那么多复杂的变量，而是构建一个简单的算法，这样你可以很快地实现它。</p>
</blockquote>
<ul>
<li><p>2.绘制出学习曲线来进而决定是否需要更多的数据，或者更多的特征，等等。</p>
</li>
<li><p>3.误差分析：主要检查出在你的算法下，有误差的（在交叉验证集中的）样本数据。</p>
</li>
</ul>
<h3 id="错误分析："><a href="#错误分析：" class="headerlink" title="错误分析："></a><strong>错误分析：</strong></h3><p>$m_{cv}=500$个在交叉验证集中的样本。</p>
<p>算法错误的分类了100封邮件。</p>
<p>手工的检查这100个错误邮件，然后基于下面两个条件重新进行分类：</p>
<ul>
<li>(i) 它们是什么类别的邮件<blockquote>
<p>如果你发现算法对于某个类别的分类区分的很差（比如说大部分的错误分类的邮件其实都属于<strong>钓鱼邮件</strong>这种类别，就证明算法对钓鱼邮件的识别很差）这说明，你应该花更多时间来研究这种类型的邮件。然后看看你是否能通过构造更好的特征变量来正确区分这种类型的邮件。</p>
</blockquote>
</li>
<li>(ii) 看看哪些特征变量可能会帮助算法正确地分类邮件<blockquote>
<p>比如说查看邮件分别属于<strong>故意拼写错误</strong>、<strong>不正常的来源</strong>、<strong>有垃圾邮件特有的标点符号</strong>，如果你发现在错误分类的邮件中，很少有<strong>故意拼写错误</strong>的情况，那么你就可以不用花太多时间在这一类别上了。如果你发现<strong>有垃圾邮件特有的标点符号</strong>这种类别的邮件很多，那么这就是一个很强的特征，说明你应该花费时间在这种类别的分类上。</p>
</blockquote>
</li>
</ul>
<p>这种类型的误差分析是一种手动检测的过程，检测算法可能会犯的错误，这通常能够帮你找到更为有效的手段。这也解释了为什么我总是推荐先实践一种快速但不完美的算法。</p>
<p>我们真正想要的是找出什么类型的邮件，是这种算法最难分类出来的，对于不同的机器学习算法，它们所遇到的问题一般总是相同的。通过实现一些快速即便不完美的算法，你能够更快地找到错误的所在，并且快速找出算法难以处理的例子。这样你就能集中精力在这些真正的问题上。</p>
<h3 id="数值计算的方式来评估你的机器学习算法："><a href="#数值计算的方式来评估你的机器学习算法：" class="headerlink" title="数值计算的方式来评估你的机器学习算法："></a><strong>数值计算的方式来评估你的机器学习算法：</strong></h3><p>如果你在构造一个学习算法，如果你能有一种评估你算法的方法，这将是非常有用的。</p>
<p>假设我们试图决定是否把像”discount”,”discounts”,”discounter”,”discountring”这样的单词都视为等同。</p>
<p>一种方法是检查这些单词的开头几个字母，比如检查”discoun”这几个字母，认为以这几个字母开头的单词大概可能有着相同的意思。</p>
<blockquote>
<p>在自然语言处理中，这种方法是通过一种叫做<strong>词干提取</strong>的软件实现的。如果你想自己来试试，你可以在网上搜索<strong>“Porter<br> Stemmer(波特词干提取法)”</strong>，这是在词干提取方面一个比较不错的软件。这个软件会将单词”discount”、”discounts”等词视为同一个单词。</p>
<p>但是这类词干提取软件只会检查单词的开头几个字母，这虽然有用，但也可能会造成一些问题。举个例子，这个软件会把单词”universe(宇宙)”和”university(大学)”也视为同一个单词，因为他们的开头是一样的。</p>
</blockquote>
<p>因此，当你在决定是否应该使用词干提取软件来分类时，这总是很难说清楚到底是好还是坏。特别地，<strong>误差分析</strong>也并不能帮助你决定词干提取是不是一个好的方法。</p>
<p>与之相对地最好的方法来发现词干提取软件对你的分类器到底有没有用，是迅速的着手试一试，来看看它表现到底怎么样。</p>
<p>为了这么做，通过数值来评估你的算法是非常有用的，具体的说，自然而然地你应该通过<strong>交叉验证</strong>来验证不用词干提取与用词干提取的算法的错误率。</p>
<p>因此，如果你不在你的算法中使用词干提取，然后你得到比如5%的分类错误率，然后你再使用词干提取来运行你的算法，你得到比如3%的分类错误率，那么这很大的减少了错误的发生，于是你决定词干提取是一个好方法。</p>
<p>就这个特定的问题而言，这里有一个数量的评估数字，即<strong>交叉验证错误率</strong>。我们以后会发现这个例子中的评估数字还需要一些处理，但是我们可以在今后的课程中看到这么做还是会让你能更快地做出决定，比如是否使用词干提取。</p>
<hr>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>当你在研究一个新的机器学习问题时，我总是推荐你实现一个较为简单快速即便不是那么完美的算法，我几乎从未见过人们是这样做。大家经常干的事情是花费大量的时间在构造算法上，构造他们以为的简单的方法，因此，不要担心你的算法太简单，或者太不完美，而是尽可能快地实现你的算法，当你有了初始的实现之后，它会变成一个非常有力的工具，来帮助你决定下一步的做法。因为我们可以先看看算法造成的错误，通过误差分析来看看它犯了什么错，然后来决定优化的方式。</p>
<p>另一件事，假设你有了一个快速而不完美的算法实现，又有一个数值的评估数据，这会帮助你尝试新的想法快速地发现你尝试的这些想法是否能够提高算法的表现。从而你会更快地做出决定，在算法中放弃什么，吸收什么。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第六周 (4)操作偏斜数据</title>
    <url>/2017/01/19/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E5%91%A8%20(4)%E6%93%8D%E4%BD%9C%E5%81%8F%E6%96%9C%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="偏移类的错误度量"><a href="#偏移类的错误度量" class="headerlink" title="偏移类的错误度量"></a>偏移类的错误度量</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/tKMWX/error-metrics-for-skewed-classes">视频地址</a></p>
<blockquote>
<p>在前面的课程中,我提到了<strong>误差分析</strong>以及设定误差度量值的重要性。那就是设定某个实数来评估你的学习算法，并衡量它的表现。有了算法的评估和误差度量值，有一件重要的事情要注意，就是使用一个合适的误差度量值。这有时会对于你的学习算法造成非常微妙的影响。</p>
<p>这件重要的事情就是<strong>偏斜类（skewed classes）</strong>的问题。</p>
</blockquote>
<p>想一想之前的癌症分类问题，我们拥有内科病人的特征变量，我们希望知道他们是否患有癌症，这就像我们之前讲过的恶性与良性肿瘤的分类问题。</p>
<p><strong>癌症分类实例</strong></p>
<ul>
<li>训练逻辑回归模型$h_{\theta}(x)$。(如果是癌症$y=1$，否则$y=0$)</li>
<li>发现你在测试集上有1%的错误率。(99%的诊断是正确的)</li>
<li>只有0.50%的病人患有癌症</li>
</ul>
<p>我们训练逻辑回归模型，假设我们用测试集检验了这个分类模型，并且发现它只有1%的错误，因此我们99%会做出正确诊断。看起来是非常不错的结果，我们99%的情况都是正确的。</p>
<p>但是，假如我们发现，在测试集中只有0.5%的患者真正得了癌症，那么在这个例子中 1%的错误率就不再显得那么好了。</p>
<p>举个具体的例子，这里有一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function y &#x3D; predictCancer(x)</span><br><span class="line">	y &#x3D; 0; %ignore x!</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
<p>不是机器学习代码，它忽略了输入值<code>X</code>，它让<code>y</code>总是等于0，因此它总是预测没有人得癌症，那么这个算法实际上只有<code>0.5%</code>的错误率。因此这甚至比我们之前得到的<code>1%</code>的错误率更好。这是一个非机器学习算法，因为它只是预测<code>y</code>总是等于<code>0</code>。</p>
<p>这种情况发生在正例和负例的比率非常接近于一个极端值，在这个例子中，正样本的数量与负样本的数量相比，非常非常少。因为<code>y=1</code>非常少，我们把这种情况叫做<strong>偏斜类</strong>。</p>
<p>一个类中的样本数与另一个类的数据相比多很多，通过总是预测<code>y=0</code>或者总是预测<code>y=1</code>算法可能表现非常好。因此使用分类误差或者分类精确度来作为评估度量可能会产生如下问题：</p>
<p>假如说你有一个算法，它的精确度是<code>99.2%</code>，因此它只有<code>0.8%</code>的误差。假设你对你的算法做出了一点改动，现在你得到了<code>99.5%</code>的精确度，只有<code>0.5%</code>的误差，这到底是不是算法的一个提升呢？</p>
<p>用某个实数来作为评估度量值的一个好处就是，它可以帮助我们<strong>迅速决定我们是否需要对算法做出一些改进</strong>。</p>
<p>将精确度从<code>99.2%</code>提高到<code>99.5%</code>，但是我们的改进到底是有用的，还是说我们只是把代码替换成了像<code>y=0</code>这样的东西？</p>
<p>因此如果你有一个偏斜类，用分类精确度并不能很好地衡量算法，因为你可能会获得一个很高的精确度，非常低的错误率。但是我们并不知道我们是否真的提升了分类模型的质量，因为<code>y=0</code>并不是一个好的分类模型。但是<code>y=0</code>会将你的误差降低至<code>0.5%</code>。</p>
<h3 id="查准率（precision）和召回率（recall）"><a href="#查准率（precision）和召回率（recall）" class="headerlink" title="查准率（precision）和召回率（recall）"></a>查准率（precision）和召回率（recall）</h3><p>当我们遇到这样一个偏斜类时，我们希望有一个不同的误差度量值，或者不同的评估度量值。其中一种评估度量值叫做<strong>查准率（precision）</strong>和<strong>召回率（recall）</strong>。</p>
<p>让我来解释一下：</p>
<p>假设我们正在用测试集来评估一个分类模型，对于测试集中的样本，每个测试集中的样本都会等于0或者1(假设这是一个二分问题)我们的学习算法要做的是：做出值的预测，并且学习算法会为每一个测试集中的实例做出预测，预测值也是等于0或1。</p>
<p>让我画一个2x2的表格：</p>
<p><img src="/img/17_01_19/001.png" alt=""></p>
<p>基于实际的类与预测的类：</p>
<ul>
<li>如果有一个样本它实际所属的类是1，预测的类也是1，那么我们把这个样本叫做<strong>真阳性（true positive）</strong>，意思是说我们的学习算法 预测这个值为阳性，实际上这个样本也确实是阳性。</li>
<li>如果我们的学习算法预测某个值是阴性(等于0)，实际的类也确实属于0，那么我们把这个叫做<strong>真阴性（true negative）</strong>，我们预测为0的值实际上也等于0。</li>
<li>如果我们的学习算法预测某个值等于1，但是实际上它等于0，这个叫做<strong>假阳性（false positive）</strong>。<blockquote>
<p>比如我们的算法预测某些病人患有癌症，但是事实上他们并没有得癌症。</p>
</blockquote>
</li>
<li>最后如果我们的学习算法预测某个值等于0，但是实际上它等于1，这个叫做<strong>假阴性（false negative）</strong>。因为我们的算法预测值为0，但是实际值是1。</li>
</ul>
<p>这样我们有了一个另一种方式来评估算法的表现。</p>
<p>我们要计算两个数字：</p>
<h4 id="查准率（Precision）"><a href="#查准率（Precision）" class="headerlink" title="查准率（Precision）"></a>查准率（Precision）</h4><p>第一个叫做<strong>查准率</strong>这个意思是，对于所有我们预测他们患有癌症的病人，有多大比率的病人是真正患有癌症的，让我把这个写下来：</p>
<script type="math/tex; mode=display">
\frac{真阳性的数量} {预测值为阳性的数量} = \frac{真阳性的数量} {真阳性的数量 + 假阳性的数量}</script><p>这个就叫做<strong>查准率</strong>，<strong>查准率</strong>越高就越好。这是说，对于那些病人，我们告诉他们：”非常抱歉，我们认为你得了癌症”，高查准率说明对于这类病人我们对预测他们得了癌症有很高的准确率。</p>
<h4 id="召回率（Recall）"><a href="#召回率（Recall）" class="headerlink" title="召回率（Recall）"></a>召回率（Recall）</h4><p>另一个数字我们要计算的，叫做<strong>召回率</strong>，<strong>召回率</strong>是如果所有的在数据集中的病人（假设测试集中的病人，或者交叉验证集中的病人）确实得了癌症，有多大比率 我们正确预测他们得了癌症。召回率被定义为：</p>
<script type="math/tex; mode=display">
\frac{真阳性的数量} {实际阳性的数量} = \frac{真阳性的数量} {真阳性的数量 + 假阴性的数量}</script><p>同样地，召回率越高越好。</p>
<p>通过计算<strong>查准率</strong>和<strong>召回率</strong>我们能更好的知道分类模型到底好不好。</p>
<p>具体地说，如果我们有一个算法，总是预测<code>y=0</code>，即它总是预测没有人患癌症，那么这个分类模型的召回率等于0，因为它不会有<strong>真阳性</strong>。因此我们能会快发现这个分类模型不是一个好的模型。</p>
<p>总的来说，即使我们有一个非常偏斜的类，算法也不能够”欺骗”我们。我们能够更肯定的是：拥有高查准率或者高召回率的模型是一个好的分类模型。这给予了我们一个更好的评估值，给予我们一种更直接的方法来评估模型的好与坏。</p>
<p>最后一件需要记住的事，在查准率和召回率的定义中，我们总是习惯性地用<code>y=1</code>，因此如果我们试图检测某种很稀少的情况（比如癌症，我希望它是个很稀少的情况），查准率和召回率会被定义为<code>y=1</code>而不是<code>y=0</code>作为某种我们希望检测的出现较少的类。通过使用查准率和召回率，我们发现即使我们拥有非常偏斜的类，算法不能够通过总是预测<code>y=1</code>或<code>y=0</code>来”欺骗”我们。因为它不能够获得高查准率和召回率。具体地说，如果一个分类模型拥有高查准率和召回率，那么我们可以确信地说这个算法表现很好，即便它是一个很偏斜的类。</p>
<p>因此对于偏斜类的问题，查准率和召回率给予了我们更好的方法来检测学习算法表现如何，这是一种更好地评估学习算法的标准。当出现偏斜类时，比仅仅只用分类误差或者分类精度好。</p>
<h2 id="查准率和召回率练习"><a href="#查准率和召回率练习" class="headerlink" title="查准率和召回率练习"></a>查准率和召回率练习</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/CuONQ/trading-off-precision-and-recall">视频地址</a></p>
<blockquote>
<p>在之前的课程中，我们谈到<strong>查准率</strong>和<strong>召回率</strong>作为遇到偏斜类问题的评估度量值。在很多应用中，我们希望能够保证<strong>查准率</strong>和<strong>召回率</strong>的相对平衡。在这节课中，我将告诉你应该如何处理此类问题，同时也向你展示一些查准率和召回率 作为算法评估度量值的更有效的方式。</p>
</blockquote>
<p>回忆一下，这是我们在上一节中讲到的<strong>查准率</strong>和<strong>召回率</strong>的定义：</p>
<script type="math/tex; mode=display">
查准率 = \frac{真阳性的数量} {预测值为阳性的数量} = \frac{真阳性的数量} {真阳性的数量 + 假阳性的数量}</script><script type="math/tex; mode=display">
召回率 = \frac{真阳性的数量} {实际阳性的数量} = \frac{真阳性的数量} {真阳性的数量 + 假阴性的数量}</script><p>让我们继续用癌症分类的例子。</p>
<p>如果病人患癌症，则<code>y=1</code>反之则<code>y=0</code>。</p>
<p>假设我们用<strong>逻辑回归模型</strong>训练了数据，输出概率是在<code>0-1</code>之间的值：</p>
<script type="math/tex; mode=display">
0\le h\_{\theta}(x)\le1</script><p>因此可以得到：</p>
<ul>
<li>如果$h_{\theta}(x)\ge0.5$，预测值为1 </li>
<li>如果$h_{\theta}(x)\lt0.5$，预测值为0 </li>
</ul>
<p>这个回归模型能够计算<strong>查准率</strong>和<strong>召回率</strong>。但是现在，假如我们希望在我们非常确信地情况下，才预测一个病人得了癌症。</p>
<blockquote>
<p>因为你知道如果你告诉一个病人，说他得了癌症，他会非常震惊，因为这是一个非常坏的消息，而且他们会经历一段非常痛苦的治疗过程，因此我们希望只有在我们非常确信的情况下，才告诉这个人他得了癌症。</p>
</blockquote>
<p>这样做的一种方法是修改算法。</p>
<h3 id="高查准率低召回率情况"><a href="#高查准率低召回率情况" class="headerlink" title="高查准率低召回率情况"></a>高查准率低召回率情况</h3><p>我们不再将临界值设为<code>0.5</code>，也许我们只在$h_{\theta}(x)\ge0.7$的情况下，才预测$y=1$。因此我们会在我们认为他有$\ge70\%$得癌症的概率情况下，告诉一个人他得了癌症。</p>
<p>如果你这么做，那么你只在非常确信地情况下才去预测癌症，那么你的回归模型会有较高的<strong>查准率</strong>，因为在所有你准备告诉他们患有癌症的病人中，他们有较高的可能性真的患有癌症。</p>
<p>你预测患有癌症的病人中有较大比率的人，他们确实患有癌症。因为这是我们在非常确信的情况下做出的预测。</p>
<p>与之相反，这个回归模型会有较低的<strong>召回率</strong>，因为当我们做预测的时候，我们只给很小一部分的病人预测$y=1$，现在我们把这个情况夸大一下，我们不再把临界值 设在$0.7$，我们把它设为$0.9$，我们只在至少$90\%$肯定这个病人患有癌症的情况下才预测$y=1$。那么这些病人当中，有非常大的比率，真正患有癌症。因此这是一个<strong>高查准率</strong>的模型。但是<strong>召回率</strong>会变低，因为我们希望能够正确检测患有癌症的病人。</p>
<h3 id="高召回率低查准率情况"><a href="#高召回率低查准率情况" class="headerlink" title="高召回率低查准率情况"></a>高召回率低查准率情况</h3><p>现在考虑一个不同的例子。</p>
<p>假设我们希望避免遗漏掉患有癌症的人，即我们希望避免<strong>假阴性</strong>。具体地说，如果一个病人实际患有癌症，但是我们并没有告诉他患有癌症，那这可能会造成严重后果。因为如果我们告诉病人他们没有患癌症，那么他们就不会接受治疗。但是如果他们真的患有癌症，我们又没有告诉他们，那么他们就根本不会接受治疗，这可能会造成严重后果，甚至使病人丧失生命，因为我们没有告诉他患有癌症，他没有接受治疗。这种情况下，我们希望预测病人患有癌症，即$y=1$。这样他们会做进一步的检测，然后接受治疗以避免他们真的患有癌症。</p>
<p>在这个例子中，我们不再设置高的<strong>临界值</strong>，我们会设置另一个值，将<strong>临界值</strong>设得较低，比如$0.3$。这样以来，我们认为这些病人有$\gt30\%$的概率患有癌症，我们以更加保守的方式来告诉他们患有癌症，因此他们能够接受治疗。但是在这种情况下，我们会有一个较<strong>高召回率</strong>的模型。因为在患有癌症的病人中，有很大一部分被我们正确标记出来了，但是我们会得到较低的查准率，因为我们预测患有癌症的病人比例越大，那么就有较大比例的人其实没有患癌症。</p>
<hr>
<p>顺带一提，当我在给别的学生讲这个的时候，令人惊讶的是有的学生问，怎么可以从两面来看这个问题？为什么我总是只想要高查准率或高召回率，但是这看起来可以使两边都提高。更普遍的一个原则是：这取决于你想要什么。你想要<strong>高查准率低召回率</strong>，还是<strong>高召回率低查准率</strong>？你可以预测$y=1$当$h_\theta(x)\ge临界值$。因此总的来说，对于大多数的回归模型，你得权衡查准率和召回率。</p>
<h3 id="临界值的选取"><a href="#临界值的选取" class="headerlink" title="临界值的选取"></a>临界值的选取</h3><p>当你改变临界值的值时，你可以画出曲线来权衡查准率和召回率：</p>
<p><img src="/img/17_01_19/002.png" width = "300" height = "200" align=center /></p>
<p>这里的一个值，反应出一个较高的临界值，这个临界值可能等于$0.99$，我们假设 只在有大于$99\%$的确信度的情况下，才预测$y=1$。至少，有$99\%$的可能性。因此这个点反应<strong>高查准率低召回率</strong>：</p>
<p><img src="/img/17_01_19/003.png" width = "300" height = "200" align=center /></p>
<p>然而这里的一个点，反映一个较低的临界值，比如说$0.01$，毫无疑问，在这里预测$y=1$，如果你这么做，你最后会得到<strong>低查准率高的召回率</strong>的预测结果：</p>
<p><img src="/img/17_01_19/004.png" width = "300" height = "200" align=center /></p>
<p>当你改变临界值时，如果你愿意，你可以画出回归模型的所有曲线，来看看你能得到的查准率和召回率的范围。</p>
<p>顺带一提，查准率-召回率曲线可以是各种不同的形状，有时它看起来是这样：</p>
<p><img src="/img/17_01_19/005.png" width = "300" height = "200" align=center /></p>
<p>有时是那样：</p>
<p><img src="/img/17_01_19/006.png" width = "300" height = "200" align=center /></p>
<p>查准率-召回率曲线的形状有很多可能性，这取决于回归模型的具体算法。因此这又产生了另一个有趣的问题，那就是<strong>有没有办法自动选取临界值</strong>，或者更广泛地说，如果我们有不同的算法，我们如何比较不同的查准率和召回率呢？</p>
<h4 id="选取临界值的方式：-F-1-Score-F-score"><a href="#选取临界值的方式：-F-1-Score-F-score" class="headerlink" title="选取临界值的方式：$F_{1}Score$(F score)"></a>选取临界值的方式：$F_{1}Score$(F score)</h4><p>具体来说，假设我们有三个不同的学习算法；或者这三个不同的学习曲线是同样的算法，但是临界值不同。我们怎样决定哪一个算法是最好的？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">查准率(P)</th>
<th style="text-align:center">召回率(R)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">算法1</td>
<td style="text-align:center">0.5</td>
<td style="text-align:center">0.4</td>
</tr>
<tr>
<td style="text-align:center">算法2</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">0.1</td>
</tr>
<tr>
<td style="text-align:center">算法3</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">1.0</td>
</tr>
</tbody>
</table>
</div>
<p>我们之前讲到的其中一件事就是评估度量值的重要性。这个概念是通过一个具体的数字来反映你的回归模型到底如何。但是查准率和召回率的问题我们却不能这样做，因为在这里我们有两个可以判断的数字。</p>
<p>因此我们经常会不得不面对这样的情况：如果我们正在试图比较<strong>算法1</strong>和<strong>算法2</strong>，我们最后问自己，到底是<code>0.5</code>的查准率与<code>0.4</code>的召回率好；还是说<code>0.7</code>的查准率与<code>0.1</code>的召回率好？如果你最后这样坐下来思考，这回降低你的决策速度。思考到底哪些改变是有用的，应该被融入到你的算法中。</p>
<p>与此相反的是，如果我们有一个评估度量值，一个数字，能够告诉我们到底是算法1好还是算法2好，这能够帮助我们更快地决定哪一个算法更好，同时也能够更快地帮助我们评估不同的改动，哪些应该被融入进算法里面。那么我们怎样才能得到这个评估度量值呢？</p>
<p>你可能会去尝试的一件事情是计算一下查准率和召回率的平均值:</p>
<script type="math/tex; mode=display">
平均值：\frac{P+R} {2}</script><p>用<strong>P</strong>和<strong>R</strong>来表示查准率和召回率，你可以做的是计算它们的平均值，看一看哪个模型有最高的均值:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">查准率(P)</th>
<th style="text-align:center">召回率(R)</th>
<th style="text-align:center">平均值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">算法1</td>
<td style="text-align:center">0.5</td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.45</td>
</tr>
<tr>
<td style="text-align:center">算法2</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.4</td>
</tr>
<tr>
<td style="text-align:center">算法3</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">0.51</td>
</tr>
</tbody>
</table>
</div>
<p>但是这可能并不是一个很好的解决办法，因为像我们之前的例子一样,如果我们的回归模型总是预测$y=1$，这么做你可能得到非常高的召回率得到非常低的查准率；相反地，如果你的模型总是预测$y=0$，就是说如果很少预测$y=1$，对应的设置了一个高临界值，最后你会得到非常高的查准率和非常低的召回率。</p>
<p>这两个极端情况一个有<strong>非常高的临界值</strong>，一个有<strong>非常低的临界值</strong>，它们中的任何一个都不是一个好的模型，我们可以通过非常低的查准率，或者非常低的召回率来判断这不是一个好模型。</p>
<p>在这里如果使用平均值的方式来计算，那么<strong>算法3</strong>的计算结果是最高的，但这并不是一个好模型，因为你总是预测$y=1$，这并不是一个有用的模型，因为它只能输出$y=1$。</p>
<p>所以，我们认为通过计算查准率和召回率平均值的方式来评估算法的好坏，不是一个好方法。</p>
<hr>
<p>相反的，有一种结合查准率和召回率的另一种方式，叫做<strong>F score</strong>，公式如下：</p>
<script type="math/tex; mode=display">
F\_{1}Score : 2\frac{PR} {P+R}</script><p>通过<strong>F score</strong>方法我们可以得出：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">查准率(P)</th>
<th style="text-align:center">召回率(R)</th>
<th style="text-align:center">平均值</th>
<th style="text-align:center">$F_{1}Score$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">算法1</td>
<td style="text-align:center">0.5</td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.45</td>
<td style="text-align:center">0.444</td>
</tr>
<tr>
<td style="text-align:center">算法2</td>
<td style="text-align:center">0.7</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.175</td>
</tr>
<tr>
<td style="text-align:center">算法3</td>
<td style="text-align:center">0.02</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">0.51</td>
<td style="text-align:center">0.0392</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出<strong>算法1</strong>的<strong>F score</strong>最高，所以我们会选择使用<strong>算法1</strong>。</p>
<blockquote>
<p><strong>F score</strong>也叫作$F_{1}Score$，但通常人们叫它<strong>F score</strong>。</p>
</blockquote>
<p><strong>F score</strong>的定义会考虑一部分查准率和召回率的平均值，但是它会给查准率和召回率中较低的值更高的权重，因此你可以看到<strong>F score</strong>的分子是查准率和召回率的乘积，如果查准率等于0或者召回率等于0，<strong>F score</strong>也会等于0。因此它结合了查准率和召回率，对于一个较大的<strong>F score</strong>，查准率和召回率都必须较大。</p>
<p>我必须说明的是，有较多的公式可以结合查准率和召回率，<strong>F score</strong>公式只是 其中一个，但是出于历史原因和习惯问题，人们在机器学习中普遍使用<strong>F score</strong>。<strong>F score</strong>这个术语没有什么特别的意义，所以不要担心它到底为什么叫做<strong>F score</strong>或者$F_{1}Score$。</p>
<p><strong>F score</strong>给出了你所需要的有效方法，因为无论是查准率等于0，还是召回率等于0，它都会得到一个很低的<strong>F score</strong>。因此，如果要得到一个很高的<strong>F score</strong>，你的算法的查准率和召回率都要接近于1。具体地说，如果$P=0$或者$R=0$，你的<strong>F score</strong>也会等于0。</p>
<blockquote>
<p>在这次的视频中，我们讲到了如何权衡查准率和召回率，以及我们如何变动临界值 来决定我们希望预测$y=1$还是$y=0$。比如我们需要一个$70\%$还是$90\%$置信度的临界值，或者别的，来预测$y=1$。</p>
<p>通过变动临界值，你可以控制权衡查准率和召回率。</p>
<p>之后我们讲到了<strong>F score</strong>，它权衡查准率和召回率，给了你一个评估度量值。当然，如果你的目标是自动选择临界值来决定你希望预测$y=1$还是$y=0$，那么一个比较理想的办法是试一试不同的临界值，然后评估这些不同的临界值在交叉检验集上进行测试，然后选择哪一个临界值能够在交叉检验集上得到最高的<strong>F score</strong>，这是自动选择临界值的较好办法。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第六周 (5)使用大数据集</title>
    <url>/2017/02/04/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%85%AD%E5%91%A8%20(5)%E4%BD%BF%E7%94%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h2 id="机器学习的数据"><a href="#机器学习的数据" class="headerlink" title="机器学习的数据"></a>机器学习的数据</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/XcNcz/data-for-machine-learning">视频地址</a></p>
<blockquote>
<p>在之前的视频中，我们讨论了评价指标。在本节课的视频中，我们来讨论一下机器学习系统设计中另一个重要的方面，这往往涉及到用来训练的数据有多少。</p>
<p>在之前的一些视频中，我曾告诫大家不要一开始就盲目地花大量的时间来收集大量的数据，因为这种做法只在某些情况下能起到实际的作用。但事实证明，在一定条件下，得到大量的数据，并在某种类型的学习算法中进行训练，却是一种有效的获得一个具有良好性能的学习算法的方法。而这种情况往往出现在这些条件对于你的问题都成立，并且你能够得到大量数据的情况下。这是一个很好的获得非常高性能的学习算法的方式。</p>
</blockquote>
<p>我先讲一个故事。很多很多年前，我认识的两位研究人员 Michele Banko 和 Eric Brill，他们进行了一项有趣的研究：研究在不同的数据集上使用不同的学习算法的效果。他们当时考虑的问题是混淆词分类问题，例如，下面这个句子：</p>
<ul>
<li><strong>For breakfast I ate __ eggs.</strong></li>
</ul>
<p>在这个句子中，空白处的可选词是：</p>
<ul>
<li><strong>to</strong></li>
<li><strong>two</strong></li>
<li><strong>too</strong></li>
</ul>
<p>在这个例子中应该填入<strong>two</strong>。</p>
<p>于是他们把诸如这样的机器学习问题当做一类监督学习问题，并尝试将其分类：什么样的词在一个英文句子特定的位置才是合适的。</p>
<p>他们用了下面几种不同的学习算法，这些算法在他们2001年进行研究的时候都已经 被公认是比较领先的学习算法：</p>
<ul>
<li><strong>感知器(Perceptron) (逻辑回归)</strong></li>
<li><strong>Winnow(类似于回归问题，但不完全相同。过去常用，但现在很少用到)</strong></li>
<li><strong>基于内存的学习方法(Memory-based)</strong></li>
<li><strong>朴素贝叶斯</strong></li>
</ul>
<p>这些算法的具体细节不重要，总之他们使用了这几种算法。他们所做的就是改变了训练数据集的大小，并尝试将这些学习算法用于不同大小的训练数据集中。这就是他们得到的结果：</p>
<p><img src="/img/17_02_04/001.png" width = "300" height = "200" align=center /></p>
<p>横轴代表以百万为单位的数据集大小，即从0.1百万到1000百万（10亿）规模的数据集；纵轴代表精确度，范围是0到1。</p>
<p>从图中可以看出趋势非常明显。首先大部分算法都具有相似的性能，其次随着训练数据集的增大，这些算法的准确性也都对应的增强了。事实上，如果你选择任意一个算法，例如选择了一个”劣等的”算法，如果你给这个劣等算法更多的数据，那么从这些列子中看起来，它很有可能会其他算法更好，甚至会比”优等算法”更好。</p>
<p>由于这项原始的研究非常具有影响力，已经有一系列不同的研究显示了类似的结果。这些结果表明，许多不同的学习算法有时倾向于表现出非常相似的效果，虽然这些效果的表现还取决于一些细节，但是真正能提高算法性能(准确度)的，就是你能够给到一个算法的大量的训练数据。类似这样的结论引起了一种在机器学习中的普遍共识：</p>
<ul>
<li><p><strong>It`s not who has the best algrithm that wins.It`s who has the most data.</strong></p>
</li>
<li><p><strong>取得成功的人不是因为拥有最好算法，而是因为拥有最多数据。</strong></p>
</li>
</ul>
<p>那么这种说法在什么时候是靠谱的，什么时候是不靠谱的呢？因为如果上面的说法在所有情况下都是对的话，那么我们保证我们得到一个高性能的学习算法的最佳方式应该是获取大量的数据，而不是考虑该使用什么学习算法。</p>
<p>其实，在下面这种情况下，获取大量的数据是提高算法性能的好方法：</p>
<p><strong>在特征值x包含足够多的用来准确预测y的信息时，获取大量的数据是提高算法性能的好方法。</strong></p>
<p>例如在上面介绍的混淆词的例子中：</p>
<ul>
<li><strong>For breakfast I ate __ eggs.</strong></li>
</ul>
<p>空白词附近的词就是我们需要捕捉的特征<strong>x</strong>，这些词中包含了大量的信息来告诉我空白处应该填写<strong>two</strong>而不是<strong>to</strong>或者<strong>too</strong>。实际上对于特征捕捉，哪怕是周围词语中的一个词，就能够给我足够的信息来确定出标签<strong>y</strong>是什么了。</p>
<p>这就是通过一个有充足的信息的特征值<strong>x</strong>的来确定<strong>y</strong>的例子。举一个反例：</p>
<p>设想在房屋价格预测问题中，我们获取的房屋信息中只有房屋面积信息，没有其他的特征值，那么如果我告诉你这个房子有500平方英尺，但是我没有告诉你其他的特征信息，我也不告诉你这个房子位于这个城市房价比较昂贵的区域还是便宜的区域，也不告诉你这所房子的房间数量，它里面陈设了多漂亮的家具，以及这个房子是新的还是旧的。我不告诉你除了这个房子有500平方英尺以外的其他任何信息，然而除此之外还有许多其他因素会影响房子的价格，不仅仅是房子的大小。但如果你仅仅知道房屋的尺寸，那么事实上是很难准确预测它的价格的。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第十一周 (1)照片OCR</title>
    <url>/2017/06/04/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8%20(1)%E7%85%A7%E7%89%87OCR/</url>
    <content><![CDATA[<h2 id="问题描述和流水线（Pipeline）"><a href="#问题描述和流水线（Pipeline）" class="headerlink" title="问题描述和流水线（Pipeline）"></a>问题描述和流水线（Pipeline）</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/iDBMm/problem-description-and-pipeline">视频地址</a></p>
<blockquote>
<p>在这一段和下几段视频中，我想向你介绍一种 机器学习的应用实例：<strong>照片OCR技术</strong>。我想介绍这部分内容的原因主要有以下三个:</p>
<ul>
<li><p>第一，我想向你展示一个复杂的机器学习系统是如何被组合起来的。</p>
</li>
<li><p>第二，我想介绍一下<strong>机器学习流水线（machine learning pipeline）</strong>的有关概念以及在决定下一步做什么时如何分配资源。</p>
</li>
<li><p>最后，我也想通过介绍<strong>照片OCR</strong>问题的机会来告诉你机器学习的诸多有意思的想法和理念。其中之一是如何将机器学习应用到计算机视觉问题中，第二是有关<strong>人工数据合成（artificial data synthesis）</strong>的概念。</p>
</li>
</ul>
</blockquote>
<p><strong>照片OCR</strong>是指<strong>照片光学字符识别（photo optical character recognition）</strong>。</p>
<p>随着数码摄影的日益流行，以及近年来手机中拍照功能的逐渐成熟，我们现在很容易就会有一大堆从各地拍摄的数码照片。吸引众多开发人员的其中一个应用是如何让计算机更好地理解这些照片的内容。这种照片OCR技术主要解决的问题是让计算机读出照片中拍到的文字信息。</p>
<p>照片OCR技术的一个应用场景是方便照片的搜索。例如你找出下面这张照片时，你只需要输入图片中的文字“LULA B’s ANTIQUE MALL”即可把照片找出来：</p>
<p> <img src="/img/17_06_04/001.png" width = "500" height = "500" align=center /></p>
<blockquote>
<p>虽然现在OCR对扫描的文档来说已经是一个比较简单的问题了，但对于数码照片来说现在还是一个比较困难的机器学习问题。研究这个的目的不仅仅是因为这可以让计算机更好地理解我们的户外图像，更重要的是它衍生了很多应用。比如在帮助盲人方面，假如你能为盲人提供一种照相机，这种相机可以“看见”他们前面有什么东西，可以告诉他们面前的路牌上写的是什么字。现在也有研究人员将照片OCR技术应用到汽车导航系统中，想象一下你的车能读出街道的标识，并且将你导航至目的地。</p>
</blockquote>
<h3 id="OCR的大概步骤"><a href="#OCR的大概步骤" class="headerlink" title="OCR的大概步骤"></a>OCR的大概步骤</h3><p>照片OCR的大体步骤如下：</p>
<ul>
<li>1.<strong>文字识别技术（Text detection）</strong></li>
</ul>
<p>首先使用<strong>文字识别技术（Text detection）</strong>将给定的图片扫描一遍，找出这张图片中哪里有文字信息：</p>
<p> <img src="/img/17_06_04/002.png" width = "500" height = "500" align=center /></p>
<ul>
<li>2.字符切分</li>
</ul>
<p>接下来就是重点关注这些文字区域，对这些文字区域的矩形轮廓进行字符切分。</p>
<p> <img src="/img/17_06_04/003.png" width = "500" height = "500" align=center /></p>
<p><img src="/img/17_06_04/004.gif" alt=""></p>
<ul>
<li>3.字符分类</li>
</ul>
<p>当文字被分割成独立的字符之后，我们可以尝试运行一个分类器，输入这些可识别的字符，然后试着识别出上面的字符。</p>
<p><img src="/img/17_06_04/005.png" alt=""></p>
<p>因此通过完成所有这些工作，按理说你就能识别出 这个字段写的是“LULAB’s ANTIQUE MALL”，然后图片中其他有文字的地方也是类似的方法进行处理。</p>
<hr>
<blockquote>
<p>其实有很多照片OCR系统会进行更为复杂的处理，比如在最后会进行拼写校正。</p>
<p>假如你的字符分割和分类系统告诉你它识别到的字是“C1eaning”，那么很多拼写修正系统会告诉你，这可能是单词“Cleaning”的拼写，你的字符分类算法刚才把字母“l”识别成了数字“1”。</p>
<p>但在本课中，我们会不考虑最后这一步拼写检查，只关注前面三个步骤。</p>
</blockquote>
<h3 id="机器学习流水线（machine-learning-pipeline）"><a href="#机器学习流水线（machine-learning-pipeline）" class="headerlink" title="机器学习流水线（machine learning pipeline）"></a>机器学习流水线（machine learning pipeline）</h3><p>像上面这样的一个系统，我们把它称之为<strong>机器学习流水线（machine learning pipeline）</strong>。</p>
<p>下面是OCR的流水线：</p>
<p><img src="/img/17_06_04/006.png" alt=""></p>
<p>具体来说，这幅图表示的就是照片OCR的流水线。</p>
<p>我们有一幅图像，然后传给文字检测系统，识别出文字以后，我们将字段分割为独立的字符，最后我们对单个的字母进行识别。</p>
<p>在很多复杂的机器学习系统中，这种流水线形式都非常普遍。在流水线中会有多个不同的模块，比如在本例中我们有文字检测、字符分割和字母识别，其中每个模块都可能是一个机器学习组件。</p>
<p>如果你要设计一个机器学习系统，其中你需要作出的最重要的决定，就是你要怎样组织好这个流水线。换句话说，在这个照片OCR问题中，你应该如何将这个问题分成一系列不同的模块。你需要设计这个流程，以及你的流水线中的每一个模块，这通常会影响到你最终的算法的表现。</p>
<p>如果你有一个工程师的团队在完成同样类似的任务，那么通常你可以让不同的人来完成不同的模块。我可以假设文字检测这个模块需要大概1到5个人、字符分割部分需要另外1到5个人、字母识别部分还需要另外1到5个人：</p>
<p><img src="/img/17_06_04/007.png" alt=""></p>
<p>因此使用流水线的方式通常提供了一个很好的办法来将整个工作分给不同的组员去完成。（当然所有这些工作都可以由一个人来完成，如果你希望这样做的话。）</p>
<p>在复杂的机器学习系统中，流水线的概念已经渗透到各种应用中。你刚才看到的只是一种照片OCR流水线的运作过程。在接下来的几段视频中，我还将继续向你介绍更多的一些关于流水线的内容。我们还将使用这个例子来展示机器学习中其他一些非常重要的概念。</p>
<h2 id="滑动窗体"><a href="#滑动窗体" class="headerlink" title="滑动窗体"></a>滑动窗体</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/bQhq3/sliding-windows">视频地址</a></p>
<blockquote>
<p>在上一节我们谈到了照片OCR流水线以及其工作原理。我们讲到可以照一张照片然后将其通过一系列机器学习组件来尝试读出图片中的文字信息。</p>
<p>在本节，我想再多介绍一些照片OCR流水线中的组件是如何工作的。</p>
</blockquote>
<p>本节我们介绍一下<strong>滑动窗体(sliding windows)</strong>的分类器。在照片OCR中，我们可以使用<strong>滑动窗体(sliding windows)</strong>分类器来识别图片中的文字。</p>
<h3 id="滑动窗体步骤"><a href="#滑动窗体步骤" class="headerlink" title="滑动窗体步骤"></a>滑动窗体步骤</h3><ul>
<li>1.文字检测</li>
</ul>
<p>滑动窗的第一个步骤是<strong>文字检测(text detection)</strong>。</p>
<p>对于OCR问题，我们想要达到下面这种从图片中识别文字的功能：</p>
<p><img src="/img/17_06_04/008.gif" alt=""></p>
<p>文字识别是计算机视觉中的一个非同寻常的问题，因为取决于你想要找到的文字的长度。这些长方形区域会呈现不同的宽高比。</p>
<h4 id="例子：行人检测问题"><a href="#例子：行人检测问题" class="headerlink" title="例子：行人检测问题"></a>例子：行人检测问题</h4><p>为了更好地介绍图像检测，我们从一个简单一点的行人探测的例子开始。</p>
<p>假设我们想要实现一个从图中识别出行人的应用：</p>
<p><img src="/img/17_06_04/009.gif" alt=""></p>
<p>这个问题似乎比文字检测的问题更简单，因为大部分的行人都比较相似。因此可以使用一个固定宽高比的矩形（就是上图中的红色矩形）来分离出你希望找到的行人。但在文字检测中，文字区域的宽高比就无法固定了。</p>
<p>虽然在行人检测的问题中，行人可能会与相机处于不同的距离位置，因此这些矩形的高度也取决于他们离相机的距离远近，但这个矩形的宽高比应该是一样的。</p>
<p>为了建立一个行人检测系统，以下是具体步骤：</p>
<ul>
<li><p>1.指定行人矩形比例</p>
<p>  假如说我们把宽高比标准化到$82：36$这样一个比例。</p>
</li>
<li><p>2.搜集样本</p>
<p>  接下来我们要做的就是到街上去收集一大堆正负训练样本。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">正样本$(y=1)$</th>
<th style="text-align:center">负样本$(y=0)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_06_04/010.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_06_04/011.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>在典型的行人识别应用中，我们可以有1000个到10000个训练样本不等，甚至更多。</p>
</blockquote>
<ul>
<li><p>3.训练算法</p>
<p>  如果你能得到大规模训练样本的话，然后你要做的事是训练一个神经网络或者别的什么学习算法，输入这些$82×36$维的图像块，然后对$y$进行分类，把图像块分成”有行人”和”没有行人”两类。</p>
<p>  因此这一步实际上是一个监督学习。你通过一个图像块然后决定这个图像块里有没有行人。</p>
</li>
</ul>
<hr>
<p>现在假如我们获得一张新的测试样本图像：</p>
<p> <img src="/img/17_06_04/012.png" width = "500" height = "500" align=center /></p>
<p>我们如果想要从这张图中找到行人，首先要做的是对这个图像取一小块长方形（$82×36$）：</p>
<p> <img src="/img/17_06_04/013.png" width = "500" height = "500" align=center /></p>
<p>我们将这个图像块通过我们训练得到的分类器来确定这个图像块中是不是有行人。</p>
<p>然后我们把这个绿色的长方形图片滑动一点点：</p>
<p> <img src="/img/17_06_04/014.png" width = "500" height = "500" align=center /></p>
<p>得到一个新的图像块，并同样把它传入我们的分类器 看看这里面有没有行人。</p>
<p>完成这一步之后，我们再向右滑动一点窗口，同样地把图像块传入分类器。</p>
<p>你每次滑动窗口的大小是一个参数，通常被称为<strong>步长(step size)</strong>，有时也称为<strong>步幅参数(stride parameter)</strong>。步长为1代表每次移动一个像素，这样通常表现得最好但可能计算量比较大，因此通常使用4个像素、或者8个像素、或者更多像素作为步长值。</p>
<p>通过固定步长，你的窗体去逐步扫描完整个图，并在每一步扫描过程中，将窗体扫描到的图片代入之前训练的行人识别的分类器中，直到窗体滑过图片中所有不同的位置：</p>
<p><img src="/img/17_06_04/015.gif" alt=""></p>
<p>但这个矩形是非常小的，只能探测到某种尺寸的行人。接下来我们要做的是看看更大的图像块。因此我们用更大矩形来滑过图片，传入分类器运行：</p>
<p><img src="/img/17_06_04/016.gif" alt=""></p>
<blockquote>
<p>顺便说一下，<strong>“用更大一些的图像块”</strong>的意思是当你用这样的图像块时，我们需要将扫描得到的图片重新压缩到分类器可以识别的尺寸($82×36$像素)。</p>
</blockquote>
<p>以此类推，接下来你可以用一个更大的矩形，以同样的方式滑动窗口。直到完成最后的扫描过程之后，你的算法应该就能检测出图像中是否出现行人了。</p>
<p>因此整个步骤就是：训练一个分类器，然后用一个滑动窗分类器来找出图像中出现的行人。</p>
<hr>
<h4 id="OCR文字检测"><a href="#OCR文字检测" class="headerlink" title="OCR文字检测"></a>OCR文字检测</h4><p>接下来我们转向文字识别的例子，对于照片OCR流水线中，要检测出文字需要的步骤如下：</p>
<h5 id="训练分类器"><a href="#训练分类器" class="headerlink" title="训练分类器"></a>训练分类器</h5><p>跟行人检测类似你也可以先收集一些带标签的训练集：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">正样本：出现文字的区域$(y=1)$</th>
<th style="text-align:center">负样本：没有出现文字的区域$(y=0)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_06_04/017.png" alt=""></td>
<td style="text-align:center"><img src="/img/17_06_04/018.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<p>通过使用这些训练集来训练识别文字的分类器。</p>
<h5 id="滑动窗体，识别文字区域"><a href="#滑动窗体，识别文字区域" class="headerlink" title="滑动窗体，识别文字区域"></a>滑动窗体，识别文字区域</h5><p>训练完了以后，我们就可以把它应用到测试集图片中了。我们以这幅图片为例：</p>
<p><img src="/img/17_06_04/001.png" width = "500" height = "500" align=center /></p>
<p>这里我们用一个固定的比例的矩形作为窗体来运行滑动窗体。如果我这样做的话，最终得到的结果是这样的：</p>
<p><img src="/img/17_06_04/019.png" width = "500" height = "500" align=center /></p>
<p>白色区域代表找到了文字的区域，黑色区域代表没有找到文字。不同的灰度表示分类器给出的输出结果的概率值，所以比如有些灰色的阴影表示分类器在这片区域似乎发现了文字，但并不十分确信；而比较白亮的区域则表示分类器预测这个区域有文字 的概率比较大。</p>
<h5 id="代入“展开器”-expansion-operator"><a href="#代入“展开器”-expansion-operator" class="headerlink" title="代入“展开器”(expansion operator)"></a>代入“展开器”(expansion operator)</h5><p>现在我们还没完成文字检测呢，因为我们实际上想做的是在图像中有文字的各区域都画上矩形窗，所以我们还需要完成一步。我们取出分类器的输出，然后输入到一个被称为<strong>“展开器”(expansion operator)</strong>的东西。</p>
<p>展开器的作用就是取过这张图片，对每一个白色的小点都扩展为一块白色的区域。</p>
<p><img src="/img/17_06_04/020.png" width = "800" height = "500" align=center /></p>
<p>从数学上来讲，对于每一个像素，我们都考察一下它是不是在左边这幅图中的某个白色像素的范围之内。比如说，某一个像素点在最左边那幅图中白色像素点的五或十个像素范围中，那么我们将把右边那幅图的相同像素设为白色。</p>
<p>这样做的效果就是，我们把左边图中的所有的白色小点都扩展了一下，让它们都变大了一些。现在我们可以根据右边的这张图锁定那些连接部分（也就是这些连续的白色区域）然后围绕着它们画个框就行了。</p>
<p>具体来讲，如果我们分析这些白色区域，我们可以简单地凭直觉来判断哪些区域是比较奇怪的，因为我们知道有文字的区域应该不是很高的，而是比较宽的。所以我们忽略那些又高又瘦的白块，这两个：</p>
<p><img src="/img/17_06_04/021.png" width = "500" height = "500" align=center /></p>
<p>然后对剩下的那些，从比例上来看比较像正常的文字区域的白块画上矩形窗：</p>
<p><img src="/img/17_06_04/022.png" width = "500" height = "500" align=center /></p>
<p>这个例子中漏掉了一些字，因为这些字的宽高比看起来不正常，以及写在玻璃上的文字比较难读出来，但整体来讲，检测效果还不错。</p>
<p>这就是使用滑动窗来进行文字检测。</p>
<p>找到这些有文字的长方形以后，我们现在就能够剪下这些图像区域，然后应用流水线的后面步骤对文字进行识别。</p>
<h5 id="字符分割"><a href="#字符分割" class="headerlink" title="字符分割"></a>字符分割</h5><p>如果你还记得的话，你应该知道流水线的第二步是字符分割。所以给出下面这样的图像我们应该怎样分割出图像中的单个字符呢？</p>
<p><img src="/img/17_06_04/023.png" width = "500" height = "200" align=center /></p>
<p>同样地，我们还是使用一种监督学习算法，用一些是否存在<strong>字符之间的分割区域</strong>的正样本和一些负样本来训练一个分类器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">正样本：存在字符间分各区域$(y=1)$</th>
<th style="text-align:center">负样本：不存在字符间分割区域$(y=0)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/17_06_04/024.png" width = "300" height = "200" align=center /></td>
<td style="text-align:center"><img src="/img/17_06_04/025.png" width = "300" height = "200" align=center /></td>
</tr>
</tbody>
</table>
</div>
<p>因此我们要做的就是使用神经网络或者其他的学习算法来训练一个分类器，试着对这些正负样本进行分类。训练好这个分类器以后，我们就要把这个分类器应用到我们文字中。</p>
<p>使用同样的<strong>窗体滑动</strong>方式（只不过使用的分类器不同），扫描文字检测系统输出的文字区域图像：</p>
<p><img src="/img/17_06_04/026.png" width = "300" height = "200" align=center /></p>
<p>分类器告诉我们$y=1$时，就意味着我们需要在中间画一条线，分开两个字符，否则就跳过。如果正常的话，分类器会告诉我们应该在什么地方来将图像分割为独立的字符。</p>
<p><img src="/img/17_06_04/027.png" width = "300" height = "200" align=center /></p>
<p><img src="/img/17_06_04/028.png" width = "300" height = "200" align=center /></p>
<p><img src="/img/17_06_04/029.png" width = "300" height = "200" align=center /></p>
<h2 id="获取大量数据和人工数据"><a href="#获取大量数据和人工数据" class="headerlink" title="获取大量数据和人工数据"></a>获取大量数据和人工数据</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/K0XQT/getting-lots-of-data-and-artificial-data">视频地址</a></p>
<blockquote>
<p>想要获得一个高效的机器学习系统，我们通常需要在低偏差的算法中代入大量的训练数据。但是我们如何获取大量的训练数据呢？</p>
<p>其实在机器学习中有一个很棒的想法，叫做<strong>“人工数据合成”（artificial data synthesis）</strong>。</p>
</blockquote>
<p><strong>人工数据合成</strong>的概念通常包含两种不同的变体：</p>
<ul>
<li>第一种，是我们白手起家来创造新的数据。</li>
<li>第二种，是我们通过扩大一个已经存在的带标签的小的训练集，来获得数据。</li>
</ul>
<p>这节课中我们将对这两种方法进行介绍。</p>
<h3 id="创造新样本"><a href="#创造新样本" class="headerlink" title="创造新样本"></a>创造新样本</h3><p>为了介绍人工数据合成的概念，让我们还是用之前用过的照片OCR流水线中的字母识别问题来举例。 </p>
<p>假如我们可以在别处收集到一大堆标签数据：</p>
<p><img src="/img/17_06_04/030.png" width = "300" height = "300" align=center /></p>
<p>我们的目标就是对任意一个图像块，我们能够识别出图像中心的那个字符。</p>
<p>同时，为了方便，我把这些图像都视为灰度图像而不是彩色图像（实际上用彩色的图像对这个问题的解决也起不了多大作用）。</p>
<p>我们有了这些原始数据，那么我们怎样才能获得一个更大的训练集呢？</p>
<p>众所周知，现代计算机中通常都有一个很大的字体库，我们也可以下载到很多免费的字体样式：</p>
<p><img src="/img/17_06_04/031.png" width = "300" height = "200" align=center /></p>
<p>所以如果你想要获得更多的训练样本，其中一种方法是你可以采集同一个字符的不同种字体，然后将这些字符加上不同的随机背景来创造训练样本。</p>
<p>通过这样的操作之后，你可以得到这样一个合成之后的训练集：</p>
<p><img src="/img/17_06_04/032.png" width = "300" height = "200" align=center /></p>
<blockquote>
<p>在生成模拟数据的时候，需要考虑对模拟的样本进行模糊、变形、旋转等操作，因为这样创造出来的样本比较真实。如果你草率的生成一些样本，那么最终训练出来的算法可能效果不是很好。</p>
</blockquote>
<p>因此通过使用合成的数据，实际上已经获得了无限的训练样本。这就是人工数据合成。</p>
<h3 id="通过已有的样本创造新样本"><a href="#通过已有的样本创造新样本" class="headerlink" title="通过已有的样本创造新样本"></a>通过已有的样本创造新样本</h3><p>人工数据合成的第二种方法是使用你已经有的样本。</p>
<p>我们选取一个真实的样本，然后通过添加别的数据来扩大你的训练集。</p>
<p>比如下图中字母A，来自于一个真实的图像（不是一个合成的图像）：</p>
<p><img src="/img/17_06_04/033.png" width = "100" height = "100" align=center /></p>
<p>为了方便描述，我在图像上加了一些灰色的网格。实际上是没有这些格子的。你要做的就是取出这个图像，进行人工扭曲，或者人工变形：</p>
<p><img src="/img/17_06_04/034.png" width = "500" height = "500" align=center /></p>
<p>这样从一个图像A就能生成16种新的样本。</p>
<p>所以用这种方法，你可以把一个很小的带标签训练集突然一下扩大，得到更多的训练样本。</p>
<p>同样地，要把这个概念投入应用，还是需要仔细考虑的。比如要考虑什么样的变形是合理的。</p>
<h4 id="引入形变方法的注意事项"><a href="#引入形变方法的注意事项" class="headerlink" title="引入形变方法的注意事项"></a>引入形变方法的注意事项</h4><p>如果你想要通过对原始数据形变产生新数据，那么在选择要引入的干扰或变形要能代表你可能会在 测试集中看到的噪音源或干扰项。</p>
<p>比如对于字符识别这个例子，这种扭曲的方法事实上还是很合理的：</p>
<p><img src="/img/17_06_04/035.png" width = "500" height = "300" align=center /></p>
<p>因为这种程度的扭曲，在测试集中是会遇到的。</p>
<p>相对而言，为你的数据添加一些纯随机的噪声，通常来讲是没什么用的。我不确定你从这里能否看出下图中对样本的变形：</p>
<p><img src="/img/17_06_04/036.png" width = "500" height = "300" align=center /></p>
<p>这里我们队这四幅图像中每一个图像的每一个像素都加了一些随机高斯噪声。这其实是完全没有意义的。除非你觉得在你的测试集中会遇到这些像素的噪声，否则的话这些随机的噪声是无意义的，起不到多大作用。</p>
<hr>
<p>人工数据合成的过程并没有什么技巧可言，有时候你只能一遍遍地尝试，然后观察效果。</p>
<p>但你在确定需要添加什么样的变形时，你一定要考虑好你添加的那些额外的变形量是有意义的，能让你产生的训练样本至少在某种程度上是具有一定的代表性，能代表你可能会在测试集中看到的某种图像。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，我将介绍一些在获取更多训练数据时的注意事项。</p>
<h4 id="尝试获取更多数据之前，先优化好你的分类器"><a href="#尝试获取更多数据之前，先优化好你的分类器" class="headerlink" title="尝试获取更多数据之前，先优化好你的分类器"></a>尝试获取更多数据之前，先优化好你的分类器</h4><p>首先，在考虑如何产生大量人工训练样本之前，通常最好应该先保证你已经有了一个低偏差的分类器。这样得到大量的数据才真的会起作用。</p>
<p>标准的方法是画出学习曲线，然后确保你已经有了一个低偏差或者高方差的分类器。如果你没有得到一个低偏差的分类器，你还可以尝试增大分类器的特征数，或者在神经网络中增大隐藏层单元数，直到你得到一个偏差比较小的分类器。</p>
<p>你一定要避免的是，花了几个星期的时间或者几个月的工夫，考虑好了怎么样能获得比较好的人工合成数据，然后才意识到即使获得了大量的训练数据，自己的学习算法的表现依然没有提高多少。</p>
<h4 id="尝试和你的团队沟通，头脑风暴"><a href="#尝试和你的团队沟通，头脑风暴" class="headerlink" title="尝试和你的团队沟通，头脑风暴"></a>尝试和你的团队沟通，头脑风暴</h4><p>第二，当我在解决机器学习问题时，通常我会问我的团队或者我的学生：“我们要付出多少工作量来获得10倍于我们现有的数据量？”</p>
<p>但让我经常感到有一点吃惊的是，他们的回答都是：“这并不是什么难事，最多花上几天时间，我们就能给一个机器学习问题获得十倍于我们现有数据量的数据。”而且通常来说，如果你能得到10倍的数据量，那么你一般都能让你的学习算法表现更好。</p>
<p>因此，如果你加入某个产品设计小组，要设计某个机器学习的应用产品，可以问问你的团队这个问题。说不定几分钟的头脑风暴以后，你的团队就会想出一种方法，真的一下子能获得10倍的数据量。</p>
<h4 id="“众包”-crowd-sourcing-—人工标记样本"><a href="#“众包”-crowd-sourcing-—人工标记样本" class="headerlink" title="“众包” (crowd sourcing)—人工标记样本"></a>“众包” (crowd sourcing)—人工标记样本</h4><p>另一种很好的办法，我们称之为<strong>“众包” (crowd sourcing)</strong>的办法。</p>
<p>现在已经有一些网站，或者一些服务机构能让你通过网络雇一些人替你完成标记大量训练数据的工作。通常都很廉价。</p>
<p>很明显这种方法，就像学术文献一样，它也是很复杂的，同时取决于标记人的可靠性。</p>
<p>可能<strong>“亚马逊土耳其机器人”（Amazon Mechanical Turk）</strong>就是当前最流行的一个众包选择。</p>
<h2 id="上限分析：流水线上的下一步工作是什么"><a href="#上限分析：流水线上的下一步工作是什么" class="headerlink" title="上限分析：流水线上的下一步工作是什么"></a>上限分析：流水线上的下一步工作是什么</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/LrJbq/ceiling-analysis-what-part-of-the-pipeline-to-work-on-next">视频地址</a></p>
<blockquote>
<p>在前面的课程中，我不止一次地说过<strong>在你开发机器学习系统时，你最宝贵的资源就是你的时间</strong>。</p>
<p>作为一个开发者，你需要正确选择下一步的工作。或者也许你有一个开发团队共同开发一个机器学习系统，同样最宝贵的还是开发系统所花费的时间。</p>
<p>你需要尽量避免的你和你的团队花费了大量时间 在某一个模块上，在几周甚至几个月的努力以后才意识到所有这些付出的劳动，都对你最终系统的表现并没有太大的帮助。</p>
<p>在这本节，我将介绍一下关于<strong>上限分析(ceiling analysis)</strong>的内容。这种方式通常能提供一种很有价值的信号，告诉你流水线中的哪个部分最值得你花时间。</p>
</blockquote>
<h3 id="上限分析主要思想"><a href="#上限分析主要思想" class="headerlink" title="上限分析主要思想"></a>上限分析主要思想</h3><p>依然以<strong>照片OCR流水线</strong>为例：</p>
<p><img src="/img/17_06_04/006.png" width = "500" height = "300" align=center /></p>
<p>当我们面对这样一个流水线时，你应该怎样分配资源呢？哪一个方框最值得你投入精力，投入时间去改善效果呢？</p>
<p>为了回答这个问题，我们可以对学习系统使用一个<strong>数值评价量度</strong>。</p>
<p>假如我们用字符准确度作为这个量度，给定一个 测试样本图像，这个数值就表示我们对测试图像中的文字识别正确的比例。</p>
<p>我们假设整个系统的估计准确率为72%（对测试集上的图像分别运行流水线上的每一个模块操作之后，整个测试集的准确率是72%）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整个系统</td>
<td style="text-align:center">72%</td>
</tr>
</tbody>
</table>
</div>
<p>下面是<strong>上限分析</strong>的主要思想：</p>
<p>首先，我们要模拟在<strong>文字检测</strong>准确率100%的情况下，得出当前系统的准确率。（我们可以通过人工的方式找出这种样本）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整个系统</td>
<td style="text-align:center">72%</td>
</tr>
<tr>
<td style="text-align:center"><strong>文字检测</strong></td>
<td style="text-align:center"><strong>89%</strong></td>
</tr>
</tbody>
</table>
</div>
<p>然后以同样的方式，得出在<strong>文字检测</strong>，以及<strong>字符切分</strong>准确率100%的情况下，当前系统的准确率。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整个系统</td>
<td style="text-align:center">72%</td>
</tr>
<tr>
<td style="text-align:center">文字检测</td>
<td style="text-align:center">89%</td>
</tr>
<tr>
<td style="text-align:center"><strong>字符切分</strong></td>
<td style="text-align:center"><strong>90%</strong></td>
</tr>
</tbody>
</table>
</div>
<p>最后，我们也要写出在<strong>文字检测</strong>、<strong>字符切分</strong>以及<strong>字符识别</strong>准确率100%的情况下，当前系统的准确率（当然是100%）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整个系统</td>
<td style="text-align:center">72%</td>
</tr>
<tr>
<td style="text-align:center">文字检测</td>
<td style="text-align:center">89%</td>
</tr>
<tr>
<td style="text-align:center">字符切分</td>
<td style="text-align:center">90%</td>
</tr>
<tr>
<td style="text-align:center"><strong>字符识别</strong></td>
<td style="text-align:center"><strong>100%</strong></td>
</tr>
</tbody>
</table>
</div>
<p>有了这些数据，我们就知道了每一个模块进行改善它们各自的上升空间是多大。</p>
<p>我们可以看到，如果我们拥有完美的文字检测模块，那么整个系统的表现将会从准确率72%上升到89%，因此效果的增益是17%。这就意味着，如果你在现有系统的基础上花费时间和精力改善文字检测模块的效果，那么系统的表现可能会提高17%。</p>
<p>而相对来讲，如果我们取得完美的字符分割模块，那么最终系统表现只提升了1%。这给我们提供了一个很重要的信息，那就是不管我们投入多大精力在字符分割上，系统效果的潜在上升空间也都是很小很小。所以你就不会让一个比较大的工程师团队花时间忙于字符分割模块，因为通过上限分析我们知道了即使你把字符分割模块做得再好，再怎么完美，你的系统表现最多也只能提升1%。</p>
<p>最后，如果我们取得完美的字符识别模块，那么整个系统的表现将提高10%。所以，同样你也可以分析10%的效果提升值得投入多少工作量。</p>
<h3 id="上限分析的原理"><a href="#上限分析的原理" class="headerlink" title="上限分析的原理"></a>上限分析的原理</h3><p>下面我换一个复杂一点的例子再来演绎一下上限分析的原理。</p>
<p>假如说你想对这张图像进行人脸识别：</p>
<p><img src="/img/17_06_04/037.png" width = "300" height = "500" align=center /></p>
<blockquote>
<p>这是一个偏人工智能的例子，当然这并不是现实中的人脸识别技术，但我想通过这个例子来向你展示一个流水线，并且给你另一个关于上限分析的实例。</p>
</blockquote>
<p>假设我们有如下流水线：</p>
<p><img src="/img/17_06_04/038.png" width = "500" height = "500" align=center /></p>
<p>其中具体步骤对应的操作如下：</p>
<p><strong>预处理（移除背景图）:</strong></p>
<p><img src="/img/17_06_04/039.gif" alt=""></p>
<p><strong>检测人脸:</strong></p>
<p><img src="/img/17_06_04/040.png" width = "300" height = "500" align=center /></p>
<p><strong>眼睛分割:</strong></p>
<p><img src="/img/17_06_04/041.png" width = "300" height = "500" align=center /></p>
<p><strong>鼻子分割:</strong></p>
<p><img src="/img/17_06_04/042.png" width = "300" height = "500" align=center /></p>
<p><strong>嘴分割:</strong></p>
<p><img src="/img/17_06_04/043.png" width = "300" height = "500" align=center /></p>
<p>那么对这个流水线怎么进行上限分析呢？</p>
<p>我们同样需要每次关注一个步骤，来计算整体的准确率：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">准确率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整个系统</td>
<td style="text-align:center">85%</td>
</tr>
<tr>
<td style="text-align:center">预处理（移除背景图）</td>
<td style="text-align:center">85.1%</td>
</tr>
<tr>
<td style="text-align:center">检测人脸</td>
<td style="text-align:center">91%</td>
</tr>
<tr>
<td style="text-align:center">眼睛分割</td>
<td style="text-align:center">95%</td>
</tr>
<tr>
<td style="text-align:center">鼻子分割</td>
<td style="text-align:center">96%</td>
</tr>
<tr>
<td style="text-align:center">嘴分割</td>
<td style="text-align:center">97%</td>
</tr>
<tr>
<td style="text-align:center">逻辑回归</td>
<td style="text-align:center">100%</td>
</tr>
</tbody>
</table>
</div>
<p>从数据中，我们可以很明显的看出来，预处理阶，准确率提高了0.1%。这是个很明显的信号，它告诉我们即便把背景分割做得很好，但整个系统的表现也并不会提高多少。所以似乎并不值得花太多精力在预处理或者背景移除上。</p>
<p>在每次通过这个系统的时候，随着使用有正确标签的测试集的模块越来越多，整个系统的表现逐步上升，这样你就能很清楚地看到通过不同的步骤，系统的表现增加了多少（比如有了完美的脸部识别，整个系统的表现似乎提高了5.9%，这告诉你也许在脸部检测上多做点努力是有意义的）。</p>
<p>因此，通过<strong>上限分析</strong>，很清楚地指出了哪一个模块是最值得花精力去完善的。</p>
<blockquote>
<p><strong>一个真实的故事</strong>:</p>
<p>原来有一个大概两个人的研究小组，花了整整18个月都在完善背景移除的效果（我不详细地讲具体的细节和原因是什么），就为了得到一个更好的背景移除效果。事实上他们确实研究出了非常复杂的算法，貌似最后还发表了一篇文章，但最终他们发现所有付出的这些劳动，都不能给他们研发系统的整体表现带来比较大的提升。而如果要是之前，他们组某个人做一下上限分析，他们就会提前意识到这个问题。</p>
<p>后来，他们中有一个人跟我说，如果他们之前也做了某种这样的分析，他们就会可以把精力花在 其他更重要的模块上，而不是把18个月花在背景移除上。</p>
</blockquote>
<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h3><p>经过这么多年在机器学习中的摸爬滚打，我已经学会了<strong>不要凭自己的直觉来判断应该改进哪个模块</strong>，相反地如果要解决某个机器学习问题，最好能把问题分成多个模块，然后做一下上限分析。</p>
<p>这通常它可以告诉你一个更可靠的，关于该把劲儿往哪儿使的方法。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第十周 (1)大数据集梯度下降</title>
    <url>/2017/06/01/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%8D%81%E5%91%A8%20(1)%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[<h2 id="处理大数据的学习算法"><a href="#处理大数据的学习算法" class="headerlink" title="处理大数据的学习算法"></a>处理大数据的学习算法</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/CipHf/learning-with-large-datasets">视频地址</a></p>
<blockquote>
<p>在接下来的几节中，我们会讲<strong>大规模的机器学习</strong>（就是用来处理大数据的算法）。如果我们看近5到10年的机器学习的历史，我们会发现现在的学习算法比5年前的好很多，其中的原因之一就是我们现在拥有很多可以训练算法的数据。</p>
</blockquote>
<p>在机器学习领域有一种说法是：</p>
<ul>
<li><p>“It`s not who has the best algorithm that wins. It`s who has the most data.”</p>
</li>
<li><p>“谁的数据最多，谁才能笑到最后。”</p>
</li>
</ul>
<p>因此，我们更期望在大的数据集上做训练。</p>
<p>但训练大的数据集也有它自己的问题，特别是计算量的问题。</p>
<p>假设我们的训练集的大小$m=100,000,000$。</p>
<blockquote>
<p>这对于现代的数据集其实是很现实的。比如对于美国的人口普查数据集来说美国有3亿人口，我们通常都能得到上亿条的数据。</p>
<p>如果我们看一下很受欢迎的网站的浏览量，我们也很容易得到上亿条的记录。</p>
</blockquote>
<p>假设我们要训练一个线性回归模型或者是逻辑回归模型，这是梯度下降的规则：</p>
<p><img src="/img/17_06_01/001.gif" alt=""></p>
<p>当你在计算梯度下降的时候，这里的$m$是一个上亿的值时，你需要通过计算上亿个数的导数项的和来计算仅仅一步的梯度下降。</p>
<p>在接下来的内容中，我们会介绍如何优化这个算法，或者换一个更高效率的算法。</p>
<p>在这一系列讲大型的机器学习的课程后，我们会知道如何拟合包括上亿数据的<strong>线性回归</strong>、<strong>逻辑回归</strong>、<strong>神经网络</strong>等等的例子。</p>
<p>当然，在我们训练一个上亿条数据的模型之前，我们还应该问自己为什么不用几千条数据呢？也许我们可以随机从上亿条的数据集里选个一千条的子集，然后用我们的算法计算。</p>
<p>在我们投入精力和开发软件来训练大数据的模型之前，我们往往会在一个比较小的数据集上来验证算法是否合适。</p>
<p>我们通常的方法是画出学习曲线，如果你画了学习曲线而且你的训练目标看上去像这样：</p>
<p><img src="/img/17_06_01/002.png" alt=""></p>
<p>$J_{train}(\theta)$是训练集上的代价函数，$J_{cv}(\theta)$是验证集上的代价函数。从图像中可以看出来，这个算法看起来像是处于<strong>高方差</strong>的状态。因此，我们需要增加训练集。</p>
<p>相比之下，如果你画出的学习曲线是这样的：</p>
<p><img src="/img/17_06_01/003.png" alt=""></p>
<p>这看起来像经典的<strong>高偏差</strong>学习算法。在这个例子中，我们可以看出来，数据量增长到一定程度之后，算法并不会好很多。因此我们没必要花费精力来扩大算法的规模。当然，如果你遇到了这种情况，一个很自然的方法是多加一些特征；或者在你的神经网络里加一些隐藏的单元等等。通过这些操作，你的算法的表现会越来越趋于第一种情况的图形：</p>
<p><img src="/img/17_06_01/002.png" alt=""></p>
<p>而这个过程中，我们应该花时间在添加基础设施来改进算法，而不是用多于一千条数据来建模，因为改进算法会更加有效果。</p>
<p>所以在大规模的机器学习中，我们喜欢找到合理的计算量的方法或高效率的计算量的方法来处理大的数据集。</p>
<h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/DoRHJ/stochastic-gradient-descent">视频地址</a></p>
<blockquote>
<p>对于线性回归、逻辑回归、神经网络等等很多机器学习算法，其实现都是通过得出某个代价函数或者某个最优化的目标来实现的，然后使用梯度下降这样的方法来求得代价函数的最小值。当我们的训练集较大时，梯度下降算法则显得计算量非常大。</p>
<p>在本节，我想介绍一种跟普通梯度下降不同的方法：<strong>随机梯度下降(stochastic gradient descent)</strong>。用这种方法我们可以将算法运用到较大训练集的情况中。</p>
</blockquote>
<h3 id="梯度下降回顾"><a href="#梯度下降回顾" class="headerlink" title="梯度下降回顾"></a>梯度下降回顾</h3><blockquote>
<p>关于<strong>随机梯度下降</strong>我们这里虽然是以梯度下降为例，但其思想也可以应用于其他的学习算法中。</p>
</blockquote>
<p>首先来复习一下之前学过的<strong>线性回归模型</strong>，我们的假设函数如下：</p>
<script type="math/tex; mode=display">
h\_{\theta}(x)=
\sum\_{j=0}^n\theta\_jx\_j</script><p>代价函数如下：</p>
<script type="math/tex; mode=display">
J\_{train}(\theta)=
\frac{1}{2m}
\sum\_{i=1}^m
(h\_\theta(x^{(i)})-y^{(i)})^2</script><p>如果我们的参数是一个二维向量，只有$\theta_1$和$\theta_2$，那么它在三维空间中的代价函数图形如下：</p>
<p><img src="/img/17_06_01/004.png" alt=""></p>
<p>我们的梯度下降内部循环执行的操作如下：</p>
<p><img src="/img/17_06_01/005.png" alt=""></p>
<p>通过反复的更新$\theta_j$，我们的代价函数会逐渐找到局部最优解。</p>
<p>这是梯度下降执行过程中，轮廓图观察到的迭代轨迹的变化情况：</p>
<p><img src="/img/17_06_01/006.png" alt=""></p>
<p>可以看到其沿着梯度下降方向快速的收敛到了全局最小。</p>
<p>而梯度下降在大量数据的情况下，每一次的梯度下降的计算量就变得非常大，因为需要对所有的训练样本求和。因此，这种在每次迭代中对所有数据都进行计算的梯度下降算法也被称为<strong>批量梯度下降(batch gradient descent)</strong>。</p>
<h3 id="随机梯度下降原理"><a href="#随机梯度下降原理" class="headerlink" title="随机梯度下降原理"></a>随机梯度下降原理</h3><p>由于<strong>批量梯度下降</strong>算法在大量数据的情况下，运算量巨大，并不适用。因此这里我们介绍一种能快速处理大量数据的梯度下降算法：<strong>随机梯度下降(stochastic gradient descent)</strong>。</p>
<p>随机梯度下降的代价函数如下：</p>
<script type="math/tex; mode=display">
cost(\theta,(x^{(i)},y^{(i)}))
=\frac{1}{2}
(h\_\theta(x^{(i)})-y^{(i)})^2
\\\\
J\_{train}(\theta)=
\frac{1}{m}
\sum\_{i=1}^m
cost(\theta,(x^{(i)},y^{(i)}))</script><p>随机梯度下降算法中，我们的步骤如下：</p>
<ul>
<li>1.将所有数据打乱。</li>
<li>2.重复执行梯度下降计算，注意，这里每一次计算$\theta_j$不是遍历全部的训练集$m$，而是从$m$个训练集里取出1个样本来计算。所以每次梯度下降的计算只需要一个样本代入计算。这一点是和<strong>批量梯度下降</strong>最大的不同：</li>
</ul>
<p><img src="/img/17_06_01/007.png" alt=""></p>
<p>随机梯度下降过程中，相比于批量梯度下降，会更曲折一些，但每一次的迭代都会更快，因为我们不需要对所有样本求和，每一次只需要保证拟合一个样本即可：</p>
<p><img src="/img/17_06_01/008.png" alt=""></p>
<p>实际上，你运行随机梯度下降和批量梯度下降这两种算法的收敛形式是不同的，你会发现随机梯度下降最终会在靠近全局最小值的区域内徘徊，而不是直接逼近全局最小值并停留在那里。但实际上这并没有太大问题，只要参数最终移动到某个非常靠近全局最小值的区域内，这也会得到一个较为不错的假设。这对于目前绝大部分实际应用的目的来说，已经足够了。</p>
<p>由于随机梯度下降每一次的梯度下降计算只需要计算单个样本，而不是像批量梯度下降那样每次计算全部样本，所以随机梯度下降的下降过程会很快。</p>
<p>最后还有一个细节点，在随机梯度下降的过程中，我们定义了一个外层循环，那么这个外层循环应该定义为多少次呢？</p>
<p><img src="/img/17_06_01/009.png" alt=""></p>
<p>那么这个外层循环设置为多少是合适的呢？</p>
<p>这取决于你样本的数量。一般情况下一次就够了，最多10次是比较典型的。所以我们通常循环执行1到10次。</p>
<p>例如对于300,000,000个美国公民的样本数据来说，如果我们循环执行3次，这里的总计算量就是$3 × 300000000 = 900000000$次。</p>
<p>这就是随机梯度下降算法的全部。</p>
<h2 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/9zJUs/mini-batch-gradient-descent">视频地址</a></p>
<blockquote>
<p>在之前我们讨论了<strong>随机梯度下降</strong>以及它是怎样比批量梯度下降更快的。在本节，让我们讨论基于这些方法的另一种变形，叫做<strong>小批量梯度下降</strong>这种算法有时候甚至比随机梯度下降还要快一点。</p>
</blockquote>
<h3 id="小批量梯度下降概念"><a href="#小批量梯度下降概念" class="headerlink" title="小批量梯度下降概念"></a>小批量梯度下降概念</h3><p>在<strong>批量梯度下降</strong>中每次迭代我们都要用所有的m个样本；然而在<strong>随机梯度下降</strong>中每次迭代我们只用一个样本；<strong>小批量梯度下降</strong>的做法介于它们之间。准确地说在这种方法中我们每次迭代使用b个样本，b是一个叫做<strong>“小批量规模”</strong>的参数。</p>
<p>举个例子来说明：</p>
<p>假如我们有1000个训练样本$m=1000$，用<strong>小批量规模</strong>$b=10$的<strong>小批量梯度下降算法</strong>来处理，我们梯度下降的过程如下：</p>
<p><img src="/img/17_06_01/010.png" alt=""></p>
<p>我们每次梯度下降的过程中，都去取10个样本来计算梯度下降的更新。</p>
<p>这就是<strong>小批量梯度下降算法</strong>。它也比批量梯度下降快很多。</p>
<h3 id="小批量梯度下降vs随机梯度下降"><a href="#小批量梯度下降vs随机梯度下降" class="headerlink" title="小批量梯度下降vs随机梯度下降"></a>小批量梯度下降vs随机梯度下降</h3><p>那么<strong>小批量梯度下降算法</strong>和<strong>随机梯度下降算法</strong>相比，有什么优势呢？</p>
<p>答案是<strong>向量化</strong>。具体来说，<strong>小批量梯度下降算法</strong>比<strong>随机梯度下降算法</strong>更好的原因在于前者每次梯度下降过程中，批量处理的数据可以用一种更向量化的方法来实现，允许你部分并行计算10个样本的和，而<strong>随机梯度下降算法</strong>每次只去计算一个样本，没有太多的并行计算。</p>
<p><strong>小批量梯度下降算法</strong>相比<strong>随机梯度下降算法</strong>的一个缺点，是有额外的参数$b$。因此你需要一些时间来调试小批量$b$的大小。但是如果你有一个好的向量化实现，这种方式会比随机梯度下降更快一些。</p>
<h2 id="随机梯度下降的收敛"><a href="#随机梯度下降的收敛" class="headerlink" title="随机梯度下降的收敛"></a>随机梯度下降的收敛</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/fKi0M/stochastic-gradient-descent-convergence">视频地址</a></p>
<blockquote>
<p>现在你已经知道了随机梯度下降算法，但是当你运行这个算法时，你如何确保调试过程已经完成并且能正常收敛呢？ 还有，同样重要的是你怎样调整随机梯度下降中学习速率$α$的值？在本节中，我们会谈到一些方法来处理这些问题，确保它能收敛以及选择合适的学习速率$α$。</p>
</blockquote>
<h3 id="随机梯度下降的收敛-1"><a href="#随机梯度下降的收敛-1" class="headerlink" title="随机梯度下降的收敛"></a>随机梯度下降的收敛</h3><p>在批量梯度下降的算法中，我们确定梯度下降已经收敛的一个标准方法是<strong>画出最优化的代价函数</strong>$J_{train}(\theta)$。</p>
<script type="math/tex; mode=display">
J\_{train}(\theta)=
\frac{1}{2m}
\sum\_{i=1}^m
(h\_{\theta}(x^{(i)})-y^{(i)})^2</script><p>我们要确保代价函数在每一次的迭代中都是下降的。当训练集比较小的时候，计算这个求和是比较方便的，因此我们不难完成。但当你的训练集非常大的时候，这种求和就不方便了，因此我们引入<strong>随机梯度下降</strong>，每次只考虑一个样本，不需要时不时的扫描一遍全部的训练集。</p>
<p>具体来说，对于<strong>随机梯度下降算法</strong>，为了检查算法是否收敛，我们可以进行下面的工作：</p>
<p>随机梯度下降过程中，在每一次梯度下降的迭代执行前，我们都去用当前的随机样本$(x^{(i)},y^{(i)})$来计算当前的关于$\theta$的cost函数：</p>
<script type="math/tex; mode=display">
cost(\theta,(x^{(i)},y^{(i)}))=
\frac{1}{2}
(h\_{\theta}(x^{(i)})-y^{(i)})^2</script><p>在每次迭代之后都去更新$\theta$，每个样本迭代一次。</p>
<p>最后为了检查随机梯度下降的收敛性，我们要做的是每1000次迭代，我们可以画出前一步中计算出的cost函数。</p>
<p>我们把这些cost函数画出来，并对算法处理的最后1000个样本的cost值求平均值。如果你这样做的话它会很有效地帮你估计出你的算法在最后1000个样本上的表现。所以，我们不需要时不时地计算$J_{train}$，那样的话需要所有的训练样本。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>下面是几幅画出来的图的例子：</p>
<h5 id="学习率大小对收敛的影响"><a href="#学习率大小对收敛的影响" class="headerlink" title="学习率大小对收敛的影响"></a>学习率大小对收敛的影响</h5><p>假如你已经画出了最后1000组样本的cost函数的平均值，由于它们都只是1000组样本的平均值，因此它们看起来有一点嘈杂，cost的值不会在每一个迭代中都下降，你可能会得到一种这样的图像：</p>
<p><img src="/img/17_06_01/011.png" alt=""></p>
<p>由于每次都是在一小部分的样本（1000个）上去求平均值，因此看起来是有噪声的。如果你得到像这样的图，那么你应该判断这个算法的代价值是在下降的，并且后来趋于平缓，这基本说明你的算法已经收敛了。</p>
<p>如果你想试试更小的学习速率，那么你很有可能看到的是算法的学习变得更慢了，因此代价函数的下降也变慢了，但同时由于你使用了更小的学习速率，你很有可能会让算法收敛到一个好一点的解。下图中红色的曲线代表随机梯度下降使用一个更小的学习速率：</p>
<p><img src="/img/17_06_01/012.png" alt=""></p>
<p>出现这种情况是因为随机梯度下降不是直接收敛到全局最小值，而是在局部最小附近反复振荡，所以使用一个更小的学习速率，最终的振荡就会更小。有时候这一点小的区别可以忽略，但有时候一点小的区别你就会得到更好一点的参数。</p>
<h5 id="每次计算代价函数的最小样本数对收敛的影响"><a href="#每次计算代价函数的最小样本数对收敛的影响" class="headerlink" title="每次计算代价函数的最小样本数对收敛的影响"></a>每次计算代价函数的最小样本数对收敛的影响</h5><p>假如你还是运行随机梯度下降，对1000组样本取cost函数的平均值并且画出图像，那么可能得到的图形如下：</p>
<p><img src="/img/17_06_01/013.png" alt=""></p>
<p>如果你把这个数1000提高到5000组样本，那么可能你会得到一条更平滑的曲线：</p>
<p><img src="/img/17_06_01/014.png" alt=""></p>
<p>通过在5000个样本中求平均值，你会得到比刚才1000组样本更平滑的曲线。这是你增大平均的训练样本数的情形。当然增大它的缺点就是现在每5000个样本才能得到一个数据点，因此你所得到的关于学习算法表现的反馈，就显得有一些“延迟”。</p>
<h5 id="代价函数不再收敛的情况"><a href="#代价函数不再收敛的情况" class="headerlink" title="代价函数不再收敛的情况"></a>代价函数不再收敛的情况</h5><p>有时候你运行梯度下降可能也会得到这样的图像：</p>
<p><img src="/img/17_06_01/015.png" alt=""></p>
<p>如果出现这种情况，可能你的代价函数就没有在减小了。如果你对这种情况时，也用更大量的样本进行平均，你很可能会观察到红线所示的情况：</p>
<p><img src="/img/17_06_01/016.png" alt=""></p>
<p>能看得出，实际上代价函数是在下降的只不过蓝线用来平均的样本数量太小了，并且蓝线太嘈杂你看不出来代价函数的趋势确实是下降的。所以可能用5000组样本来平均比用1000组样本来平均更能看出趋势。</p>
<p>当然，即使是使用一个较大的样本数量，你还是可能会发现这条学习曲线还是比较平坦的。如果是这样的话，那可能就更肯定地说明，由于某种原因导致算法确实没怎么学习好。这时你就需要调整学习速率，或者改变特征变量，或者改变其他的什么。</p>
<h5 id="代价函数发散时"><a href="#代价函数发散时" class="headerlink" title="代价函数发散时"></a>代价函数发散时</h5><p>如果你画出曲线是这样一种上升的情况时：</p>
<p><img src="/img/17_06_01/017.png" alt=""></p>
<p>这是一个很明显的告诉你算法正在发散的信号。那么你要做的事，就是用一个更小一点的学习速率$α$。</p>
<h3 id="使用可变的学习率-α"><a href="#使用可变的学习率-α" class="headerlink" title="使用可变的学习率$α$"></a>使用可变的学习率$α$</h3><p>我们已经知道，当运行<strong>随机梯度下降</strong>时算法会从某个点开始，然后曲折地逼近最小值，但它不会真的收敛，而是一直在最小值附近徘徊:</p>
<p><img src="/img/17_06_01/018.gif" alt=""></p>
<p>因此你最终得到的参数，实际上只是接近全局最小值，而不是真正的全局最小值。</p>
<p>在大多数随机梯度下降法的典型应用中，学习速率$α$一般是<strong>保持不变</strong>的。因此你最终得到的结果一般来说是上图这个样子的。如果你想让随机梯度下降确实收敛到全局最小值，你可以随时间的变化减小学习速率$α$的值。</p>
<p>所以一种典型的设置$α$的值的方法是让</p>
<script type="math/tex; mode=display">
α=
\frac{常数1}{迭代次数 + 常数2}</script><p><strong>常数1</strong>和<strong>常数2</strong>是两个额外的参数，你需要选择一下才能得到较好的表现。但很多人不愿意用这个办法的原因是你最后会把时间花在确定<strong>常数1</strong>和<strong>常数2</strong>上，这让算法显得更繁琐。但如果你能调整得到比较好的参数的话，你会得到的图形是随着迭代的增加，在最小值附近震荡的范围越来越小，最终几乎靠近全局最小的地方：</p>
<p><img src="/img/17_06_01/019.gif" alt=""></p>
<p>但由于确定这两个常数需要更多的工作量，并且我们通常也对能够很接近全局最小值的参数已经很满意了，因此在随机梯度下降中我们很少采用逐渐减小$α$的值的方法。你看到更多的还是让$α$的值为常数。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第十周 (2)高级主题</title>
    <url>/2017/06/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%8D%81%E5%91%A8%20(2)%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h2 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/ABO2q/online-learning">视频地址</a></p>
<blockquote>
<p>在本节，我将会讨论一种新的大规模的机器学习机制，叫做<strong>在线学习机制</strong>。在拥有连续一波数据或连续的数据流涌进来，而我们又需要一个算法来从中学习的时候来模型化问题时，我们就需要用到<strong>在线学习机制</strong>。 </p>
<p>今天许多大型网站，或者许多大型网络公司，都在使用不同版本的在线学习机制算法从大批的涌入又离开网站的用户身上进行学习。</p>
<p>特别要提及的是，如果你有一个由连续的用户流引发的连续的数据流，用户流进入你的网站，你能做的是使用一个在线学习机制，从数据流中学习用户的偏好，然后使用这些信息，来优化一些关于网站的决策。</p>
</blockquote>
<h3 id="在线学习机制举例"><a href="#在线学习机制举例" class="headerlink" title="在线学习机制举例"></a>在线学习机制举例</h3><h4 id="运输服务对于定价的预测"><a href="#运输服务对于定价的预测" class="headerlink" title="运输服务对于定价的预测"></a>运输服务对于定价的预测</h4><p>假如你有一个提供运输服务的网站，在网站上提供用户选择包裹邮寄的起始地址和目的地址，并显示运输价格。然和我们需要根据用户对给出邮费价格的选择接受或者走掉，来作为正样本（$y=1$）和负样本（$y=0$），通过这些样本来构建学习算法，来帮助我们找到用户的特点，从而给出一个合理的邮费价格预测。</p>
<p>我们使用这些优化后的价格，很有可能会提高我们的利润。</p>
<p>对于持续运行的网站来说，以下就是在线学习算法要做的：</p>
<ul>
<li>网站一直保持在线学习状态。</li>
<li>当一个用户偶然访问网站时，我们会得到当前用户对应的数据$(x,y)$(特征$x$是指用户所指定的起始地与目的地以及我们这一次提供给客户的价格，而$y$的取值是0或1，具体值取决于用户最终是否选择了我们的运输服务)。</li>
<li>通过该用户的数据$(x,y)$来更新$\theta$。<ul>
<li>$\theta_j := \theta_j - \alpha(h_{\theta}(x)-y)x_j \ \ \ \  \ \ \ (j=0,…,n)$</li>
</ul>
</li>
</ul>
<p>与以往的学习过程不同的是，在线学习中，每次梯度下降使用的这个当前用户的样本数据$(x,y)$，我们使用一次之后就丢弃了，我们永远都不会再次使用它。这就是为什么我们在一个时间点只会处理一个样本的原因。</p>
<p>如果你真的运行一个大型网站，在这个网站里你有一个连续的用户流登陆网站，那么这种在线学习算法，是一种非常合理的算法。因为数据本质上是自由的，而且数据本质上是无限的，那么或许就真的没必要重复处理一个样本。当然，如果我们只有少量的用户，那么我们就不选择像这样的在线学习算法，这种情况下最好是要保存好所有的数据，然后对这个数据集使用某种算法。</p>
<p>我也必须要提到一个这种在线学习算法会带来的有趣的效果，那就是它可以对正在变化的用户偏好进行调适。</p>
<h4 id="搜索中对于搜索结果的优化"><a href="#搜索中对于搜索结果的优化" class="headerlink" title="搜索中对于搜索结果的优化"></a>搜索中对于搜索结果的优化</h4><p>在搜索引擎中，我们想使用一种学习机制来学习如何反馈给用户好的搜索列表。</p>
<p>举个具体的例子，假如你有一个在线卖手机的网站，你有一个可以提供搜索的用户界面。在你的网站中，有100部正在售卖的手机，用户每次搜索时会提供10部手机的搜索结果。那么当用户输入类似“安卓 手机 1080p 摄像头”这样的搜索词时，我们应该推荐哪十部手机给用户呢？</p>
<p>我们想要做的是拥有一个在线学习机制来帮助我们 找到在这100部手机中哪十部手机是我们真正应该反馈给用户的，而且这个返回的列表是对类似这样的用户搜索条目最佳的回应。</p>
<p>接下来要说的是一种解决问题的思路。</p>
<p>对于每一个手机以及一个给定的用户搜索命令，我们可以构建一个特征矢量$x$，那么这个特征矢量$x$可能会抓取手机的各种特点，它可能会抓取类似于用户搜索命令与这部电话的类似程度有多高这样的信息，我们获取类似于：这个用户搜索命令中有多少个词，可以与这部手机的名字相匹配；或者这个搜索命令中有多少词，与这部手机的描述相匹配。</p>
<script type="math/tex; mode=display">
x=手机的特征，\\\\用户的搜索词中有多少个词与手机名称匹配，\\\\用户的搜索词中有多少个词与手机的描述匹配，\\\\等等</script><p>所以特征矢量$x$获取手机的特点，并且它还会获取这部手机与搜索命令的结果在各个方面的匹配程度。我们想要做的就是估测一个概率，这个概率是指用户将会点进某一个特定的手机的链接的概率。因为我们想要给用户提供那些他们很可能在浏览器中点进去查看的手机，所以我定义$y=1$是指用户点击了手机的链接，而$y=0$是指用户没有点击链接。</p>
<script type="math/tex; mode=display">
y=1 （如果用户点击了链接） \\\\
y=0 （用户没有点击链接）</script><p>然后我们想要做的就是学习到用户将会点击某一个特定的手机的概率：</p>
<script type="math/tex; mode=display">
p(y=1|x;\theta)</script><p>你知道的，特征$x$获取了手机的特点以及搜索条目与手机的匹配程度。这类问题其实被称作<strong>预估点击率CTR</strong>，它仅仅代表这学习用户将点击某一个特定的、你提供给他们的链接的概率。所以<strong>CTR</strong>是<strong>点击率(Click Through Rate)</strong>的简称。</p>
<p>如果你能够估计任意一个特定手机的点击率，我们可以做的就是利用这个来给用户展示十个他们最有可能点击的手机。因为从这一百个手机中，我们可以计算出每一部手机的可能的点击率，然后选择10部用户最有可能点击的手机，那么这就是一个非常合理的来决定要展示给用户的十个搜索结果的方法。</p>
<p>更明确地说，假定每次用户进行一次搜索，我们回馈给用户十个结果。在线学习算法会真正地提供给我们十个$(x,y)$数据对样本。每当一个用户来到 我们网站时就给了我们十个样本，因为对于这十部我们选择要展示给用户的手机的每一个我们会得到 一个特征矢量x，而且对于这10部手机中的任何一个手机，我们还会得到$y$的取值。这些取值是根据用户有没有点击那个网页链接来决定的。这样运行此类网站的一种方法就是连续给用户展示你的十个最佳猜测，这十个推荐是指用户可能会喜欢的其他的手机，那么每次一个用户访问，你将会得到十个$(x,y)$样本数据对，然后利用一个在线学习 算法来更新你的参数。更新过程中会对这十个样本利用10步梯度下降法，然后你可以丢弃你的数据了。</p>
<p>如果你真的拥有一个连续的用户流进入你的网站，这将会是一个非常合理的学习方法，来学习你的算法中的参数从而来给用户展示十部他们最有可能点击查看的手机。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面几个例子的原理，你应该也能懂得其他应用的原理。例如优惠券推荐、新闻推荐等。</p>
<p>而且实际上，如果你有一个协作过滤系统，你可以想象到一个协作过滤系统可以给你更多的特征，这些特征可以整合到逻辑回归的分类器，从而可以尝试着预测对于你可能推荐给用户的不同产品的点击率。</p>
<p>这就是<strong>在线学习机制</strong>，与<strong>随机梯度下降算法</strong>非常类似，唯一的区别的是我们不会使用一个固定的数据集，而是获取一个用户样本，从那个样本中学习，然后丢弃那个样本并继续下去。而且如果你对某一种应用有一个连续的数据流，这样的算法可能会非常值得考虑。</p>
<p>当然在线学习的一个优点，就是如果你有一个变化的用户群、又或者你在尝试预测的事情在缓慢变化，就像你的用户的品味在缓慢变化，这个在线学习算法可以慢慢地调试你所学习到的假设，将其调节更新到最新的用户行为。</p>
<h2 id="Map-Reduce-和数据并行"><a href="#Map-Reduce-和数据并行" class="headerlink" title="Map Reduce 和数据并行"></a>Map Reduce 和数据并行</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/10sqI/map-reduce-and-data-parallelism">视频地址</a></p>
<blockquote>
<p>在之前，我们讨论了<strong>随机梯度下降</strong>，以及梯度下降算法的其他一些变种，包括如何将其运用于在线学习。然而所有这些算法都只能在一台计算机上运行，但有的时候，机器学习的运算量巨大，以至于单台机器处理起来特别耗时，所以人们希望能在多台机器上同时执行运算来提高效率。</p>
<p>在本节中，我将介绍进行大规模机器学习的另一种方法，称为<strong>Map Reduce</strong>。尽管我们用了很多内容来讲解随机梯度下降算法，而对于<strong>Map Reduce</strong>的介绍比较少，但是请不要根据我们介绍内容的长短来判断哪一种技术更加重要。事实上 许多人认为<strong>Map Reduce</strong>与梯度梯度下降算法相比至少是同等重要的，还有人认为<strong>Map Reduce</strong>甚至比梯度下降方法更重要。</p>
<p>我们之所以在<strong>Map Reduce</strong>上花的时间比较少，只是因为它相对简单，容易解释。然而实际上相比于随机梯度下降方法，<strong>Map Reduce</strong>能够处理更大规模的问题。</p>
</blockquote>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设我们要拟合一个线性回归模型，或者逻辑回归模型，或者其他的什么模型。让我们再次从随机梯度下降算法开始：</p>
<p><img src="/img/17_06_03/001.png" alt=""></p>
<p>假设我们有400个样本$m=400$（实际应用中会比这个数字大很多）：</p>
<script type="math/tex; mode=display">
(x^{(1)},y^{(1)}),...,
(x^{(400)},y^{(400)})</script><p>根据<strong>Map Reduce</strong>的思想，一种解决方案是将训练集划分成几个不同的子集，然后分别放在多台机器上并行的处理我们的训练数据（这里我们把数据集划分成四份，并且放在4台机器上并行处理）。</p>
<p>每台机器内部都去计算对应的子集的求和运算：</p>
<p><img src="/img/17_06_03/002.png" alt=""></p>
<p>最后，当这些计算机全都完成了各自的工作，我们将这些临时变量收集到一起，送到一个中心计算服务器，这台服务器会将这些临时变量合并起来：</p>
<p><img src="/img/17_06_03/003.png" alt=""></p>
<p>图中右侧更新的公式如下：</p>
<script type="math/tex; mode=display">
\theta_j :=
\theta_j - \alpha\frac{1}{400}
(temp_j^{(1)} + temp_j^{(2)} + temp_j^{(3)} + temp_j^{(4)}) 
\\\\
(j = 0,...,n)</script><p>其实这个公式计算的数值和原先的梯度下降公式计算的数值是完全一样的。</p>
<h3 id="Map-Reduce工作原理"><a href="#Map-Reduce工作原理" class="headerlink" title="Map Reduce工作原理"></a>Map Reduce工作原理</h3><blockquote>
<p>这里值得说明的一点是<strong>Map Reduce</strong>基本思想来自于<strong>Jeffrey Dean</strong>和<strong>Sanjay Ghemawat</strong>这两位研究者。其中<strong>Jeffrey Dean</strong>是硅谷最为传奇的一位工程师，今天Google所有的服务所依赖的后台基础架构，有很大一部分是他创建的。</p>
</blockquote>
<p>总结来说<strong>Map Reduce</strong>技术是这么工作的：</p>
<ul>
<li>将原始训练样本均分成4份</li>
<li>将这4份训练样本的子集送给4台不同的计算机，每一台计算机对四分之一的训练数据进行求和运算</li>
<li>最后这4个求和结果 被送到一台中心计算服务器负责对结果进行汇总。</li>
</ul>
<p><img src="/img/17_06_03/004.png" alt=""></p>
<p>通过<strong>Map Reduce</strong>技术，我们相较于之前的方式提升了4倍的速度。</p>
<p>特别的，如果没有网络延时也不考虑通过网络来回传输数据所消耗的时间，那么你可能可以得到4倍的加速。当然，在实际工作中，因为网络延时数据汇总额外消耗时间，以及其他的一些因素，你能得到的加速总是略小于4倍的。但是，不管怎么说，这Map Reduce算法确实让我们能够处理之前单台机器无法处理的大规模数据。</p>
<h3 id="使用Map-Reduce的条件"><a href="#使用Map-Reduce的条件" class="headerlink" title="使用Map Reduce的条件"></a>使用Map Reduce的条件</h3><p>如果你打算将Map Reduce技术用于加速某个机器学习算法，也就是说你打算运用多台不同的计算机并行的进行计算，那么你需要问自己一个很关键的问题，那就是<strong>你的机器学习算法是否可以表示为训练样本的某种求和</strong>。</p>
<p>事实证明，很多机器学习算法的确可以表示为关于训练样本的函数求和。而在处理大数据时，这些算法的主要运算量在于对大量训练数据求和。</p>
<h3 id="Map-Reduce处理逻辑回归"><a href="#Map-Reduce处理逻辑回归" class="headerlink" title="Map Reduce处理逻辑回归"></a>Map Reduce处理逻辑回归</h3><p>对于某些使用<strong>逻辑回归</strong>的优化算法（比如说<strong>LBFGS算法</strong>，或者<strong>共轭梯度算法</strong>等等），我们需要计算两个值：</p>
<h4 id="计算优化目标代价函数"><a href="#计算优化目标代价函数" class="headerlink" title="计算优化目标代价函数"></a>计算优化目标代价函数</h4><p>首先，我们需要提供一种方法用于计算优化目标的代价函数值。比如逻辑回归的代价函数计算如下：</p>
<p><img src="/img/17_06_03/005.png" alt=""></p>
<p>如果你想在10台计算机上并行计算，那么你需要将训练样本分给这10台计算机，让每台计算机计算10份之一训练数据。</p>
<h4 id="计算梯度下降的偏导数项"><a href="#计算梯度下降的偏导数项" class="headerlink" title="计算梯度下降的偏导数项"></a>计算梯度下降的偏导数项</h4><p>另外，高级优化算法还需要提供某种偏导数的计算方法。对于逻辑回归，这些偏导数可以表示为训练数据的求和：</p>
<p><img src="/img/17_06_03/006.png" alt=""></p>
<p>因此，和之前的例子类似，你可以让每台计算机只计算部分训练数据上的求和。最后当这些求和计算完成之后，求和结果会被发送到一台中心计算服务器上，这台服务器将对结果进行再次求和。这等同于对临时变量$temp^{(i)}_j$进行求和。而这些临时标量是第$i$台计算机算出来的。</p>
<p>中心计算服务器对这些临时变量求和得到了总的代价函数值，以及总的偏导数值，然后你可以将这两个值传给高级优化函数。</p>
<p>因此更广义的来说，通过将机器学习算法表示为 求和的形式，或者是训练数据的函数求和形式，你就可以运用<strong>Map Reduce</strong>技术来将算法并行化，这样就可以处理大规模数据了。</p>
<h3 id="单台设备运行Map-Reduce"><a href="#单台设备运行Map-Reduce" class="headerlink" title="单台设备运行Map Reduce"></a>单台设备运行Map Reduce</h3><p>目前我们只讨论了在多台计算机上运用<strong>Map Reduce</strong>技术实现并行计算。但实际上有时即使我们只有一台计算机，我们也可以运用这种技术。</p>
<p>具体来说，现在的许多计算机都是多核的，你可以有多个CPU，而每个CPU又包括多个核。</p>
<p>如果你有一个很大的训练样本，那么你可以使用一台四核的计算机，然后将训练样本分成4份，让每一个核处理其中一份子样本：</p>
<p><img src="/img/17_06_03/007.png" alt=""></p>
<p>这样，在单台计算机或者单个服务器上，你也可以实现利用Map Reduce技术来划分计算任务了。</p>
<p>相对于多台计算机，这样在单台计算机上使用Map Reduce技术的一个优势在于：你不需要担心网络延时问题，因为所有的通讯所有的来回数据传输都发生在一台计算机上。</p>
<h4 id="一个细节问题"><a href="#一个细节问题" class="headerlink" title="一个细节问题"></a>一个细节问题</h4><p>如果你的算法实现使用的是某种自动利用多核的线性代数运算库，那么你就没有必要去手动在单台机器上实现Map Reduce了。但并不是所有的库都会自动并行运算。</p>
<h3 id="一个广告：Hadoop"><a href="#一个广告：Hadoop" class="headerlink" title="一个广告：Hadoop"></a>一个广告：Hadoop</h3><p>今天，网上有许多优秀的开源Map Reduce实现。</p>
<p>实际上一个称为<strong>Hadoop</strong>的开源系统已经拥有了众多的用户。通过自己实现Map Reduce算法 或者使用别人的开源实现，你就可以利用Map Reduce技术来并行化机器学习算法。这样你的算法将能够处理单台计算机处理不了的大数据。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第四周 (1)神经网络引入</title>
    <url>/2016/09/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E5%91%A8%20(1)%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%BC%95%E5%85%A5/</url>
    <content><![CDATA[<h2 id="非线性假设"><a href="#非线性假设" class="headerlink" title="非线性假设"></a>非线性假设</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/OAOhO/non-linear-hypotheses">视频地址</a></p>
<blockquote>
<p>接下来的课程中，我将为大家介绍一种叫做<strong>“神经网络”(Neural Network)</strong>的机器学习算法。我们首先来讨论神经网络的表层结构，在后来的课程中再来具体讨论学习算法。 </p>
</blockquote>
<p>神经网络算法实际上是一个相对古老的算法，并且沉寂了一段时间。不过到了现在，它又称为许多机器学习问题的首选技术。</p>
<p>那么我们已经有了线性回归，和逻辑回归，为什么还需要学习<strong>神经网络</strong>这个算法呢？为了阐述研究神经网络的目的，我们首先来看几个机器学习问题作为例子。这几个例子都依赖于研究复杂的非线性分类器。</p>
<h3 id="线性回归对于非线性假设的不可行性分析"><a href="#线性回归对于非线性假设的不可行性分析" class="headerlink" title="线性回归对于非线性假设的不可行性分析"></a>线性回归对于非线性假设的不可行性分析</h3><p>考虑这个监督学习分类的问题：</p>
<p><img src="/img/16_09_04/008.png" alt=""></p>
<p>我们已经有了对应的训练集，如果利用逻辑回归算法来解决这个问题，我们首先要构造一个包含很多非线性项的逻辑回归函数：</p>
<script type="math/tex; mode=display">
g(\theta\_{0} + \theta\_{1}x\_{1} + \theta\_{2}x\_{2} + \theta\_{3}x\_{1}x\_{2} + \theta\_{4}x\_{1}^{2}x\_{2} + \theta\_{5}x\_{1}^{3}x\_{2} + \theta\_{6}x\_{1}x\_{2}^{2} + ...)</script><blockquote>
<p>这里$g()$函数依然是一个S型函数，即Logistic函数。</p>
</blockquote>
<p>当多项式数足够多时，你可能可以得到一个分开正样本和负样本的分界线：</p>
<p><img src="/img/16_09_04/009.png" alt=""></p>
<p>当你只有两项时，这种方法确实能得到不错的结果，因为你完全可以把$x_{1}$和$x_{2}$的所有组合都包含到多项式中。但对于许多复杂的机器学习问题，涉及的项往往多于两项。</p>
<p><img src="/img/16_09_04/010.png" alt=""></p>
<p>我们之前讨论过房价预测的问题，假设你现在处理的是关于住房的分类问题，而不是一个回归问题。假设你对一栋房子的多方面特点都有所了解，你想预测房子在未来半年内能被卖出去的概率，这是一个分类问题。我们可以想出多达上百个特征。对于这类问题，如果要包含所有的二次项，最终的多项式也可能有很多项：</p>
<script type="math/tex; mode=display">
x\_{1}^{2},x\_{1}x\_{2},x\_{1}x\_{3},x\_{1}x\_{4}...x\_{1}x\_{100},x\_{2}^{2},x\_{2}x\_{3}...</script><blockquote>
<p>对于100个特征的情况下，会有5050个二次项组合。而且随着特征数量的增加，二次项的个数大约以$O(n^{2})$的量级增长，其中$n$是原始项(特征)的个数。</p>
</blockquote>
<p>因此，包含所有的二次项是困难的，所以这可能不是一个好方法，而且由于项数过多，最后的结果很有可能是过拟合的。此外，这里也存在运算量过大的问题。</p>
<blockquote>
<p>当然，你也可以只考虑上面这些二次项的子集，比如$x_{1}^{2},x_{2}^{2},x_{3}^{2}…x_{100}^{2}$，这样就能将二次项的数量大幅减少了，但是却忽略了太多的相关项，在处理问题的时候，不可能得到理想的结果。</p>
</blockquote>
<p>5000多个二次项已经很多了，如果我们还要引入三次项，那么我们的项的个数将以$O(n^{3})$的量级增长，当有100个特征的情况下，大约有170000个三次项组合。所以，当特征个数增大时，这些高阶多项式项数将以几何级数递增，特征空间也随之急剧膨胀。因此，当特征数量较多时，通过这种方式来构建分类器，并不是一个好办法。</p>
<h3 id="图像识别中使用线性回归的不可行性举例"><a href="#图像识别中使用线性回归的不可行性举例" class="headerlink" title="图像识别中使用线性回归的不可行性举例"></a>图像识别中使用线性回归的不可行性举例</h3><p>对于许多实际的机器学习问题，特征个数$n$是很大的，举个关于计算机视觉中的一个例子：</p>
<p>假设你想要使用机器学习算法来训练一个分类器，使它检测一个图像来判断图像是否为一辆汽车，很多人可能会很好奇，这对计算机视觉来说有什么难的？当你们看到下面这幅图时，下面是一辆车，这是一目了然的事情，你肯定会觉得很奇怪，为什么学习算法竟可能会不知道图像是什么：</p>
<p><img src="/img/16_09_04/011.png" alt=""></p>
<p>为了解答这个问题，我们取出图像的一小部分，将其放大，结果表明，当人眼看到一辆汽车时，计算机实际上看到的却是这样一个数据矩阵：</p>
<p><img src="/img/16_09_04/012.png" alt=""></p>
<p>这个矩阵中的每个元素表示了像素强度值，告诉我们图像中每个像素的亮度值。因此，对于计算机视觉来说，问题就变成了根据这个像素点亮度矩阵，来告诉我们这些数值代表一个汽车门把手。</p>
<p><strong>具体而言，当使用机器学习算法构造一个汽车识别器时，我们要想出一个带标签的样本集，其中一些样本是各类汽车，另一部分样本是其他任何东西。将这个样本集输入给学习算法以训练出一个分类器，训练完毕后，我们输入一幅新的图片，让分类器来判定“这是什么东西？”</strong>理想情况下，分类器能识别出这是一辆汽车。</p>
<p><img src="/img/16_09_04/013.png" alt=""></p>
<p>为了理解引入非线性分类器的必要性，我们从学习算法的训练样本中挑出一些汽车的图片，和一些非汽车的图片，让我们从其中每幅图片中挑出一组像素点，在坐标系中标出这幅汽车的位置：</p>
<p><img src="/img/16_09_04/014.png" alt=""></p>
<p>汽车的位置取决于像素点1和像素点2的亮度，让我们用同样的方法标出其他图片中汽车的位置：</p>
<p><img src="/img/16_09_04/015.png" alt=""></p>
<p>观察这张图片两个相同的像素位置的像素亮度，这两点都有着不同的像素亮度，所以在这幅图中，它们处于不同的位置。</p>
<p>我们继续画上两个非汽车样本，并且用”-“表示非汽车：</p>
<p><img src="/img/16_09_04/016.png" alt=""></p>
<p>随着样本数量的增多，我们将发现这两类数据分布在坐标系中的不同区域：</p>
<p><img src="/img/16_09_04/017.png" alt=""></p>
<p>因此我们现在需要一个非线性分类器，来尽量分开这两类样本：</p>
<p><img src="/img/16_09_04/018.png" alt=""></p>
<p>这个分类问题中，特征空间的维度是多少呢？假设我们使用$50*50$像素的图片，虽然这个图片尺寸很小，但依然有2500个像素点。因此我们的特征数量$n$是2500个，特征向量$X$包含了所有像素点的亮度值。如果存储的是每个像素点的灰度值（典型的计算机图片表示方法），那么每个元素值应该介于0到255之间。如果图片存储形式是RGB模式，每个像素点包含红、绿、蓝三个子像素，那么$n=7500$。</p>
<p><img src="/img/16_09_04/019.png" alt=""></p>
<p>因此，如果我们非要通过包含所有的二次项来解决这个非线性问题，那么，这个式子的所有条件的个数大约是300万个：</p>
<p><img src="/img/16_09_04/020.png" alt=""></p>
<p>显然，这数字大的有些离谱了，计算成本太高了。</p>
<h2 id="神经网络和大脑"><a href="#神经网络和大脑" class="headerlink" title="神经网络和大脑"></a>神经网络和大脑</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/IPmzw/neurons-and-the-brain">视频地址</a></p>
<p>神经网络是一种很古老的算法，它最初产生的目的是制造能模拟大脑的机器，在这门课中，我将向你们介绍神经网络。因为它能很好的解决不同的机器学习问题而不只因为它们在逻辑上行得通。这节课中，主要介绍一些神经网络的背景知识，由此我们能知道可以用它们来做什么。</p>
<p>神经网络产生的原因是人们想尝试设计出模仿大脑的算法。从某种意义上说，想要建立学习系统，那么为什么不去模仿我们所认识的，最神奇的学习机器—人类的大脑呢？</p>
<p>神经网络逐渐兴起于二十世纪八九十年代应用得非常广泛，但由于各种原因，在90年代的后期应用减少了，但是最近，神经网络又东山再起了，其中一个原因是，神经网络是计算量有些偏大的算法。然而，大概是由于近些年计算机的运行速度变快，才足以真正运行起大规模的神经网络，正是由于这个原因，和其他一些我们后面会讨论到的技术因素，使得如今的神经网络对于许多应用来说是最先进的技术。</p>
<p>当你想模拟大脑时，是指想制造出与人类大脑作用效果相同的机器，对吧？大脑可以学会去以看而不是听的方式处理图像，学会处理我们的触觉，我们能学习数学，学着做微积分。而且大脑能处理各种不同的令人惊奇的事情，似乎如果你想要模仿它，你得写很多不同的软件来模拟所有大脑告诉我们的这些五花八门的奇妙的事情。不过能不能假设大脑做所有这些不同事情的方法不需要用上千个不同的程序去实现，相反的，大脑处理的方法只需要一个单一的学习算法就可以了？尽管这只是一个假设，不过我可以和你分享一些这方面的证据：</p>
<p><img src="/img/16_09_04/021.png" alt=""></p>
<p>大脑的这一小片红色区域，是你的听觉皮层。你现在正在听到的声音，靠的是耳朵接收到声音信号，并把声音信号传递给你的听觉皮层，正因如此你才能明白我的话。</p>
<p>神经系统科学家做了下面这个有趣的实验：</p>
<p><img src="/img/16_09_04/022.png" alt=""></p>
<p>把耳朵到听觉皮层的神经切断，在这种情况下将其重新接到一个动物的大脑上，这样从眼睛到视神经的信号最终将传到听觉皮层。如果这样做了，那么结果表明听觉皮层将会学会“看”，这里“看”代表了我们所知道的每层含义。所以如果你对动物这样做，那么动物就可以完成视觉辨别任务，它们可以看图像，并根据图像做出适当的决定。它们正是通过脑组织中的这个部分完成的。</p>
<p>来看另一个例子：</p>
<p><img src="/img/16_09_04/023.png" alt=""></p>
<p>这块红色的脑组织是你的躯体感觉皮层，这是你用来处理触觉的。如果你做一个和刚才类似的重接实验，那么躯体感觉皮层也能学会”看“。这个实验和其它一些类似的实验被称为<strong>神经重接实验</strong>。</p>
<p>从这个意义上说，如果人体有同一块脑组织可以处理光、声或触觉信号，那么也许存在一种学习算法，可以同时处理视觉、听觉和触觉，而不是需要运行上千个不同的程序，或者上千个不同的算法来做这些大脑所完成的成千上万的美好事情。也许我们需要做的就是找出一些近似的，或实际的大脑学习算法，然后实现它。大脑通过自学掌握如何处理这些不同类型的数据，在很大的程度上可以猜想如果我们把几乎任何一种传感器接入到大脑的几乎任何一个部位的话，大脑就会学会处理它。</p>
<p>下面再举几个例子：</p>
<p><img src="/img/16_09_04/024.png" alt=""></p>
<p>这张图是用舌头学会“看”的一个例子，这实际上是一个名为BrainPort的系统，它现在正在FDA(美国食品和药物管理局)的临床试验阶段，它能帮助失明人士看见事物。它的原理是：你在前额上带一个灰度摄像头，面朝前它就能获取你面前事物的低分辨率的灰度图像，你连一根线到舌头上安装的电极阵列上，那么每个像素都被映射到你舌头的某个位置上，可能电压值高的点对应一个暗像素，电压值低的点对应于亮像素，即使依靠它现在的功能，使用这种系统就能让你我在几十分钟里就学会用我们的舌头“看”东西。</p>
<p>这是第二个例子：</p>
<p><img src="/img/16_09_04/025.png" alt=""></p>
<p>关于人体回声定位(或者说人体声纳)，你可以通过弹响指或者咂舌头来实现，现在有失明人士确实在学校里接受这样的培训，并学会解读从环境反弹回来的声波模式—这就是声纳。如果你搜索YouTube之后就会发现，有些视频讲述了一个令人称奇的孩子，他因为癌症眼球惨遭移除，虽然失去了眼球但是通过打响指，他可以四处走动而不撞到任何东西。他能滑滑板，他可以将篮球投入篮框中，注意这是一个没有眼球的孩子。</p>
<p>第三个例子是触觉皮带：</p>
<p><img src="/img/16_09_04/026.png" alt=""></p>
<p>如果你把它戴在腰上，蜂鸣器会响，而且总是朝向北时发出嗡嗡声。它可以使人拥有方向感。用类似于鸟类感知方向的方式。</p>
<p>还有一些离奇的例子：</p>
<p><img src="/img/16_09_04/027.png" alt=""></p>
<p>如果你在青蛙身上插入第三只眼，青蛙也能学会使用那只眼睛。</p>
<p>因此，如果你能把几乎任何传感器接入到大脑中，大脑的学习算法就能找出学习数据的方法，并处理这些数据。</p>
<p>从某种意义上来说，如果我们能找出大脑的学习算法，然后在计算机上执行 大脑学习算法或与之相似的算法，也许这将是我们向人工智能迈进做出的最好的尝试。<strong>人工智能的梦想就是有一天能制造出真正的智能机器</strong>，当然我不是教神经网络的，介绍它只因为它可能为我们打开一扇进入遥远的人工智能梦的窗户。对于我个人来说，它也是我研究生涯中致力于的一个项目，但我在这节课中讲授神经网络的原因，主要是对于现代机器学习应用，它是最有效的技术方法。因此在接下来的一些课程中，我们将开始深入到神经网络的技术细节。那么你就可以将它们应用到现代机器学习的应用中，并利用它们很好地解决问题。但对我来说，使我兴奋的原因之一，就是它或许能给我们一些启示，让我们知道当我们在思考未来有什么样的算法能以与人类相似的方式学习时，我们能做些什么。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第四周 (2)神经网络</title>
    <url>/2016/09/07/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E5%91%A8%20(2)%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="神经网络的表示I"><a href="#神经网络的表示I" class="headerlink" title="神经网络的表示I"></a>神经网络的表示I</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/ka3jK/model-representation-i">视频地址</a></p>
<p>这节课介绍神经网络如何表示我们的假设。</p>
<h3 id="神经网络起源"><a href="#神经网络起源" class="headerlink" title="神经网络起源"></a>神经网络起源</h3><p>神经网络是在模拟大脑中的神经元时发明的，因此，要解释如何表示模型假设，我们先来看看神经元在大脑中是什么样的。我们的大脑中充满了这样的神经元：</p>
<p><img src="/img/16_09_07/001.png" alt=""></p>
<p>神经元是大脑中的细胞，其中有两点值得我们注意，一是神经元有一个细胞主体(Cell body)，二是神经元有一定数量的输入神经，这些输入神经叫做<strong>树突(Dendrite)</strong>。可以把它们想象成输入电线，它们接收来自其他神经元的信息。神经元的输出神经叫做<strong>轴突(Axon)</strong>，这些输出神经是用来给其他神经元传递信号或者传送信息的。</p>
<p>简而言之，神经元是一个计算单元，它从<strong>输入神经</strong>接受一定数目的信息，并做一些计算，然后将结果通过它的<strong>轴突</strong>传送到大脑中的其他神经元。</p>
<p>下面是一组神经元的示意图：</p>
<p><img src="/img/16_09_07/002.png" alt=""></p>
<p>神经元利用微弱的电流进行沟通，这些弱电流也称作<strong>动作电位</strong>(其实就是一些微弱的电流)。</p>
<p>所以如果神经元想要传递一个消息，它就会通过它的轴突发送一段微弱的电流，给其他神经元。这就是<strong>轴突</strong>连接到输入神经元(另一个神经元的<strong>树突</strong>)。接下来这个神经元接收这条消息，做一些计算，它有可能会反过来将在轴突上的自己的消息传给其他神经元。这就是所有人类思考的模型：我们的神经元把自己收到的消息进行计算，并向其他神经元传递消息。</p>
<blockquote>
<p>顺便说一下，这也是我们感觉和肌肉运转的原理。如果你想要活动一块肌肉，就会触发一个神经元给你的肌肉，发送脉冲，并引起你的肌肉收缩。如果一些感官，比如说眼睛，想要向大脑传递一个消息，那么它就是像这样发送电脉冲给大脑的。</p>
</blockquote>
<h3 id="神经网络逻辑单元"><a href="#神经网络逻辑单元" class="headerlink" title="神经网络逻辑单元"></a>神经网络逻辑单元</h3><p>在一个计算机的神经网络里，我们将使用一个非常简单的模型来模拟神经元的工作：</p>
<p><img src="/img/16_09_07/003.png" alt=""></p>
<p>我们将神经元模拟成一个逻辑单元。上图中，黄色的圆圈，你可以理解为类似神经元的东西，然后我们通过它的树突(或者说是它的输入神经)传递给它一些信息。然后神经元做一些计算，并通过它的输出神经(即它的轴突)输出计算结果。</p>
<p>这里的$h_{\theta}(x)$通常值的是：</p>
<script type="math/tex; mode=display">
\begin{align\*}
h\_{\theta}(x)
= \frac{1}{1+e^{-\theta^{T}x}}
\end{align*}</script><p>其中$x$和$\theta$指的是我们的参数向量：</p>
<p><img src="/img/16_09_07/004.png" alt=""></p>
<p>这就是一个简单的模拟神经元的模型。</p>
<hr>
<p>当我绘制一个神经网络时，有时会额外增加一个$x_{0}$的输入节点，这个$x_{0}$节点有时也被称作<strong>偏置单位(或偏置神经元)</strong>。但由于$x_{0}=1$，有时我是不会画出它的，这取决于它是否对例子有利。</p>
<h3 id="激励函数"><a href="#激励函数" class="headerlink" title="激励函数"></a>激励函数</h3><p>在神经网络中，有时我们会听到“一个有Sigmoid函数或者Logistic函数作为<strong>激励函数(activation function)</strong>的人工神经元”这样的话。其实这里所指的<strong>激励函数(activation function)</strong>只是对类似非线性函数$g(z)$的另一个术语称呼：</p>
<script type="math/tex; mode=display">
\begin{align\*}
g(z)
= \frac{1}{1+e^{-z}}
\end{align*}</script><script type="math/tex; mode=display">
\begin{align\*}
z
= \theta^{T}x
\end{align*}</script><blockquote>
<p>在之前我们一值称$\theta$为模型的参数，但在神经网络的文献里，有时你可能会看到人们谈论一个模型的<strong>权重(weight)</strong>，这个<strong>权重(weight)</strong>其实和模型的参数$\theta$是一个东西。</p>
</blockquote>
<hr>
<h3 id="解读神经网络"><a href="#解读神经网络" class="headerlink" title="解读神经网络"></a>解读神经网络</h3><h4 id="输入层，输出层，隐藏层"><a href="#输入层，输出层，隐藏层" class="headerlink" title="输入层，输出层，隐藏层"></a>输入层，输出层，隐藏层</h4><p>神经网络其实就是这些不同的神经元组合在一起的集合：</p>
<p><img src="/img/16_09_07/005.png" alt=""></p>
<p>具体来说：</p>
<ul>
<li><p>上图中有三个输入单元：$x_{1}$,$x_{2}$和$x_{3}$，当然我们也可以加入值为1的$x_{0}$。</p>
</li>
<li><p>中间有三个神经元：$a_{1}^{(2)}$，$a_{2}^{(2)}$和$a_{3}^{(2)}$，同理，你可以可以加上值永远为1的偏置单元$a_{0}^{(2)}$。</p>
</li>
<li><p>然后，我们在最右侧有第三层，第三层的这个节点输出了假设函数$h(x)$的计算结果$h_{Θ}(x)$。</p>
</li>
</ul>
<p>用神经网络的术语来说，第一层也被称为<strong>输入层</strong>，因为我们在这一层输入我们的特征项$x_{1}$，$x_{2}$和$x_{3}$。</p>
<p>最后一层，也被称为<strong>输出层</strong>，因为这一层的神经元会输出假设函数的最终计算结果$h_{Θ}(x)$。</p>
<p>中间层，也被称为<strong>隐藏层</strong>，在监督学习中，你能看到输入，也能看到输出，而隐藏层的值在你的训练过程中是看不到的，它的值不是$x$也不是$y$，所以我们叫它隐藏层。神经网络可以有不止一个的隐藏层。<strong>在神经网络中，任何一个非输入层且非输出层，就被称为隐藏层</strong>。</p>
<h4 id="神经网络运行原理"><a href="#神经网络运行原理" class="headerlink" title="神经网络运行原理"></a>神经网络运行原理</h4><p><img src="/img/16_09_07/005.png" alt=""></p>
<p>接下来，让我们来逐步分析，上图所呈现的神经网络的计算步骤。</p>
<p>首先需要说明以下两个符号的含义：</p>
<ul>
<li>$a_{i}^{(j)}$ 表示第j层的第i个神经元。</li>
</ul>
<blockquote>
<p>具体来说$a_{1}^{2}$表示的是第2层的第1个激励，即隐藏层的第一个激励。</p>
<p>所谓<strong>激励(activation)</strong>是指由一个具体神经元读入计算并输出的值。</p>
</blockquote>
<ul>
<li>$Θ^{(j)}$ 表示层与层之间权重的<strong>参数矩阵</strong>(或者叫<strong>权重矩阵</strong>)(比如说从第一层到第二层、或者从第二层到第三层的作用)。</li>
</ul>
<p>具体来说，$a_{1}^{(2)}$的值的计算是这样的：</p>
<script type="math/tex; mode=display">
a\_{1}^{(2)} = g(Θ\_{10}^{(1)}x\_{0} +
Θ\_{11}^{(1)}x\_{1} + 
Θ\_{12}^{(1)}x\_{2} + 
Θ\_{13}^{(1)}x\_{3}
)</script><blockquote>
<p>不要忘记这里的$g$函数是S型函数(或者说是S激励函数，也叫作逻辑激励函数)。</p>
</blockquote>
<p>我们可以把隐藏层的三个神经元的计算结果都写出来：</p>
<script type="math/tex; mode=display">
a\_{1}^{(2)} = g(Θ\_{10}^{(1)}x\_{0} +
Θ\_{11}^{(1)}x\_{1} + 
Θ\_{12}^{(1)}x\_{2} + 
Θ\_{13}^{(1)}x\_{3}
)</script><script type="math/tex; mode=display">
a\_{2}^{(2)} = g(Θ\_{20}^{(1)}x\_{0} +
Θ\_{21}^{(1)}x\_{1} + 
Θ\_{22}^{(1)}x\_{2} + 
Θ\_{23}^{(1)}x\_{3}
)</script><script type="math/tex; mode=display">
a\_{3}^{(2)} = g(Θ\_{30}^{(1)}x\_{0} +
Θ\_{31}^{(1)}x\_{1} + 
Θ\_{32}^{(1)}x\_{2} + 
Θ\_{33}^{(1)}x\_{3}
)</script><p>这里我们有三个输入单元和三个隐藏单元，这样一来，参数矩阵$Θ^{(1)}$控制了我们来自三个输入单元到三个隐藏单元的映射。因此$Θ^{(1)}$的维数是$R^{3×4}$的(考虑$x_{0}$的情况下)矩阵。</p>
<p>更一般的，如果一个神经网络在第$j$层有$s_{j}$个单元，在$j+1$层有$s_{j+1}$个单元，那么第$j$层的参数矩阵$Θ^{(j)}$的维度就是$s_{j+1}×(s_{j} + 1)$</p>
<p>以上我们讨论了三个隐藏单位是怎么计算它们的值的，最后，在输出层，我们还有一个单元，它用来计算$h_{Θ}(x)$：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x) = a\_{1}^{(3)}=g(
Θ\_{10}^{(2)}a\_{0}^{(2)} +
Θ\_{11}^{(2)}a\_{1}^{(2)} + 
Θ\_{12}^{(2)}a\_{2}^{(2)} + 
Θ\_{13}^{(2)}a\_{3}^{(2)}
)</script><p>以上就是从数学上对一个人工神经网络的定义。</p>
<h2 id="神经网络的表示II"><a href="#神经网络的表示II" class="headerlink" title="神经网络的表示II"></a>神经网络的表示II</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/Hw3VK/model-representation-ii">视频地址</a></p>
<blockquote>
<p>这节课，将介绍如何高效地进行计算，并展示一个向量化的实现方法。更重要的是让你们明白神经网络的好处所在，并且介绍它是如何帮助我们学习复杂的非线性假设的。</p>
</blockquote>
<h3 id="前向传播-forward-propagation-的向量化实现"><a href="#前向传播-forward-propagation-的向量化实现" class="headerlink" title="前向传播(forward propagation)的向量化实现"></a>前向传播(forward propagation)的向量化实现</h3><p>以这个神经网络为例：</p>
<p><img src="/img/16_09_07/006.png" alt=""></p>
<p>上一节我们介绍过假设函数的计算方式，以及上面这些方程的含义。接下来，我要定义一些额外的项，来简化上面的式子的表示，比如我要把上面第一行(用来表示第一个隐藏层输出的值)：</p>
<script type="math/tex; mode=display">
a\_{1}^{(2)} = g(Θ\_{10}^{(1)}x\_{0} +
Θ\_{11}^{(1)}x\_{1} + 
Θ\_{12}^{(1)}x\_{2} + 
Θ\_{13}^{(1)}x\_{3}
)</script><p>改写为：</p>
<script type="math/tex; mode=display">
a\_{1}^{(2)} = g(z^{(2)}\_{1})</script><p>可见：</p>
<script type="math/tex; mode=display">
z^{(2)}\_{1} = Θ\_{10}^{(1)}x\_{0} +
Θ\_{11}^{(1)}x\_{1} + 
Θ\_{12}^{(1)}x\_{2} + 
Θ\_{13}^{(1)}x\_{3}</script><p>其中$z^{(2)}_{1}$的上标$^{(2)}$表示<strong>神经网络的第二层(即这里的隐藏层)</strong>，下标$_{1}$表示<strong>当前层的第一个元素</strong>。</p>
<p>我们通过同样的方式定义$a_{2}^{(2)}$和$a_{3}^{(2)}$。</p>
<script type="math/tex; mode=display">
a\_{2}^{(2)} = g(z^{(2)}\_{2})</script><script type="math/tex; mode=display">
a\_{3}^{(2)} = g(z^{(2)}\_{3})</script><p>因此，这些$z$值都是$x_{0}$、$x_{1}$、$x_{2}$和$x_{3}$的加权线性组合，然后带入一个特定的神经元，</p>
<p>如果你仔细观察表达式中红色方框内的区域：</p>
<p><img src="/img/16_09_07/007.png" alt=""></p>
<p>你会发现，这里其实是一个矩阵的乘法运算：</p>
<script type="math/tex; mode=display">
Θ^{(1)}x</script><p>这样一来，我们就能将神经网络的计算，向量化了。</p>
<p>具体而言，我们定义特征向量$x$：</p>
<script type="math/tex; mode=display">
x=
\begin{bmatrix}
x\_{0} \\\\
x\_{1} \\\\
x\_{2} \\\\
x\_{3} 
\end{bmatrix}</script><blockquote>
<p>其中$x_{0}=1$</p>
</blockquote>
<p>并定义$z^{(2)}$：</p>
<script type="math/tex; mode=display">
z^{(2)}=
\begin{bmatrix}
z^{(2)}\_{1} \\\\
z^{(2)}\_{2} \\\\
z^{(2)}\_{3}
\end{bmatrix}</script><blockquote>
<p>注意，这里的$z^{(2)}$是一个三维向量。</p>
</blockquote>
<p>我们只需要两个步骤，就可以计算出$a^{(2)}$向量了：</p>
<script type="math/tex; mode=display">
z^{(2)}=Θ^{(1)}x</script><script type="math/tex; mode=display">
a^{(2)}=g(z^{(2)})</script><blockquote>
<p>注意，这里的$a^{(2)}$也是一个三维向量，这里的激励函数$g()$将对$z^{(2)}$中的每个元素进行计算。<br>说明一下，在输入层虽然我们有$x$输入，但我们可以把这些输入想象成是第一层的激励。所以可以定义$a^{(1)}=x$，这样就有了向量$a^{(1)}$。</p>
</blockquote>
<p>将向量$x$替换为向量$a^{(1)}$:</p>
<script type="math/tex; mode=display">
z^{(2)}=Θ^{(1)}a^{(1)}</script><hr>
<p>现在，就我目前所写的，我得到了$a^{(2)}_{1}$、$a^{(2)}_{2}$和$a^{(2)}_{3}$的值，但是我同样还需要隐藏层的偏置单元$a^{(2)}_{0}$，这个额外的偏执单元值为1：</p>
<script type="math/tex; mode=display">
a^{(2)}\_{0}=1</script><p>加上偏置单元后，向量$a^{(2)}$的长度变成了4：</p>
<script type="math/tex; mode=display">
a^{(2)}\in \mathbb{R}^{4}</script><p>最后，为了计算实际输出值：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x) = a\_{1}^{(3)}=g(
Θ\_{10}^{(2)}a\_{0}^{(2)} +
Θ\_{11}^{(2)}a\_{1}^{(2)} + 
Θ\_{12}^{(2)}a\_{2}^{(2)} + 
Θ\_{13}^{(2)}a\_{3}^{(2)}
)</script><p>我们计算出代表$Θ_{10}^{(2)}a_{0}^{(2)} +Θ_{11}^{(2)}a_{1}^{(2)} + Θ_{12}^{(2)}a_{2}^{(2)} + Θ_{13}^{(2)}a_{3}^{(2)}$的$z^{(3)}$，并将其带入激励函数，最后就能得出$h(x)$的值了：</p>
<script type="math/tex; mode=display">
z^{(3)}=Θ^{(2)}a^{(2)}</script><script type="math/tex; mode=display">
h\_{Θ}(x)=a^{(3)}=g(z^{(3)})</script><p>这就是计算$h_{Θ}(x)$的过程，也称为<strong>前向传播(forward propagation)</strong>。</p>
<blockquote>
<p>这样的命名是因为我们从输入层的激励开始，然后进行前向传播给隐藏层，并计算隐藏层的激励，然后我们继续向前传播，并计算出层的激励，这个从输入层，到隐藏层，再到输出层，依次计算激励的过程，叫<strong>前向传播</strong>。</p>
</blockquote>
<h3 id="神经网络与逻辑回归的对比，以及学习非线性假设的原理"><a href="#神经网络与逻辑回归的对比，以及学习非线性假设的原理" class="headerlink" title="神经网络与逻辑回归的对比，以及学习非线性假设的原理"></a>神经网络与逻辑回归的对比，以及学习非线性假设的原理</h3><p>这种前向传播也可以帮助我们了解神经网络的原理，以及解释为什么神经网络可以帮助我们学习非线性假设。</p>
<p>例如下面这个神经网络：</p>
<p><img src="/img/16_09_07/008.png" alt=""></p>
<p>我们暂时盖住左边部分，看右侧这一部分：</p>
<p><img src="/img/16_09_07/009.png" alt=""></p>
<p>这看起来很像逻辑回归，在逻辑回归中，我们就用这一个逻辑回归单元来预测$h(x)$的值。具体来说：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)=g(Θ\_{10}^{(2)}a\_{0}^{(2)} + Θ\_{11}^{(2)}a\_{1}^{(2)} + Θ\_{12}^{(2)}a\_{2}^{(2)} + Θ\_{13}^{(2)}a\_{3}^{(2)})</script><p>这很像一个很标准的逻辑回归模型，不同之处在于这里使用的是大写的$Θ$而不是小写的$\theta$，神经网络的输入特征值是通过隐藏层计算的。即，神经网络所做的工作看起来就像是逻辑回归，但是它不是使用$x_{1}$、$x_{2}$、$x_{3}$作为输入特征，而是使用$a_{1}^{(2)}$、$a_{2}^{(2)}$、$a_{3}^{(2)}$。</p>
<hr>
<p><img src="/img/16_09_07/010.png" alt=""></p>
<p>然而有趣的是，特征项$a_{1}^{(2)}$、$a_{2}^{(2)}$、$a_{3}^{(2)}$是通过输入的函数来学习的。具体来说，就是从第一层(Layer1)映射到第二层(Layer2)的函数。这个函数由其他一组参数$Θ^{(1)}$决定。所以，在神经网络中，它没有用输入特征$x_{1}$、$x_{2}$、$x_{3}$来训练逻辑回归，而是训练逻辑回归的输入:$a_{1}^{(2)}$、$a_{2}^{(2)}$、$a_{3}^{(2)}$。</p>
<p>可以想象，如果在$Θ^{(1)}$中选择不同的参数有时可以学习到一些很有趣的，和很复杂的特征，就可以得到一个比使用原始输入$x_{1}$、$x_{2}$、$x_{3}$时得到的假设更好的假设。</p>
<p>你也可以使用多项式作为输入，例如：$x_{1}x_{2}$、$x_{2}x_{3}$等作为输入项。这个算法都可以灵活的快速学习任意的特征项，并把最后的结果通过最后一个单元的逻辑回归输出出来。</p>
<h3 id="神经网络的架构"><a href="#神经网络的架构" class="headerlink" title="神经网络的架构"></a>神经网络的架构</h3><p>你还可以用其他类型的图来表示神经网络。神经网络中神经元相连接的方式，称为<strong>神经网络的架构(Architecture)</strong>。</p>
<p>下面是另外一个神经网络架构的例子：</p>
<p><img src="/img/16_09_07/011.png" alt=""></p>
<p>在这个神经网络中，第一层被称为输入层，第四层任然是我们的输出层。其中，第二层和第三层都是隐藏层。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程 第四周 (3)神经网络应用实例</title>
    <url>/2016/09/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%20%E7%AC%AC%E5%9B%9B%E5%91%A8%20(3)%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="神经网络应用实例"><a href="#神经网络应用实例" class="headerlink" title="神经网络应用实例"></a>神经网络应用实例</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/rBZmG/examples-and-intuitions-i">视频地址 part1</a></p>
<p><a href="https://www.coursera.org/learn/machine-learning/lecture/solUx/examples-and-intuitions-ii">视频地址 part2</a></p>
<blockquote>
<p>接下来将通过一个具体的例子来解释神经网络是如何计算关于输入的复杂的非线性函数的。</p>
</blockquote>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>考虑下面的问题：</p>
<p>我们有二进制的输入特征$x_{1}$和$x_{2}$，它们的取值要么是0，要么是1。这个例子中，我画出了两个正样本和两个负样本。</p>
<p><img src="/img/16_09_11/001.png" alt=""></p>
<p>但你可以认为这是更复杂的学习问题的简化版本。在这个复杂问题中，我们可能在右上角有一堆正样本，在右下方有一堆用圆圈来表示的负样本。</p>
<p><img src="/img/16_09_11/002.png" alt=""></p>
<p>我们想要做到的就是有一个非线性的决策边界来区分正负样本：</p>
<p><img src="/img/16_09_11/003.png" alt=""></p>
<p>那么，神经网络是如何做到的呢？为了描述方便，我继续使用上面二进制输入特征的例子。</p>
<p>具体来讲，我们要计算的目标函数:</p>
<script type="math/tex; mode=display">y=x\_{1} XNOR x\_{2}</script><blockquote>
<p>求同或(都为真或都为假时，结果为真，否则结果为假)</p>
</blockquote>
<p>或者也可以写作：</p>
<script type="math/tex; mode=display">NOT(y=x\_{1} XOR x\_{2})</script><blockquote>
<p>求异或(都为真或都为假时，结果为假，否则结果为真)再取反</p>
</blockquote>
<h3 id="AND、OR、NOT的实现"><a href="#AND、OR、NOT的实现" class="headerlink" title="AND、OR、NOT的实现"></a>AND、OR、NOT的实现</h3><h4 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h4><p>为了解释神经网络模型如何来拟合这种训练集。我们先讲解一个稍微简单一些的神经网络，它拟合了<strong>“且运算”(AND)</strong>：</p>
<p><img src="/img/16_09_11/004.png" alt=""></p>
<p>假设我们有二进制输入$x_{1}$和$x_{2}$，目标函数是$y=x_{1}ANDx_{2}$，那么我们怎样得到一个具有单个神经元的神经网络来计算这个<strong>逻辑与</strong>呢？为了做到这一点，我们也需要画出偏置单元（即下图中+1的单元）：</p>
<p><img src="/img/16_09_11/005.png" alt=""></p>
<p>接下来让我给这个网络分配一些权重(参数)：</p>
<p><img src="/img/16_09_11/006.png" alt=""></p>
<p>所以我的假设函数是：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)=g(-30 + 20x\_{1} + 20x\_{2})</script><p>这里$Θ^{(1)}_{10}$就是$-30$、$Θ^{(2)}_{11}$就是$20$、$Θ^{(3)}_{12}$就是$20$。</p>
<p>接下来介绍一下这个小神经元是怎样计算的。</p>
<p>回忆一下激励函数$g(z)$看起来是这样的：</p>
<p><img src="/img/16_09_11/007.png" alt=""></p>
<p>再来看看我们的假设在各种情况下的输出：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{1}$</th>
<th style="text-align:center">$x_{2}$</th>
<th style="text-align:center">$h_{Θ}(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(-30)\approx0$</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(-10)\approx0$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(-10)\approx0$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(10)\approx1$</td>
</tr>
</tbody>
</table>
</div>
<p>这就是逻辑“与”的计算结果。</p>
<hr>
<h4 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h4><p>下面的神经网络使用同样的原理实现了“或”的功能：</p>
<p><img src="/img/16_09_11/008.png" alt=""></p>
<p>假设函数为：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)=g(-10 + 20x\_{1} + 20x\_{2})</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{1}$</th>
<th style="text-align:center">$x_{2}$</th>
<th style="text-align:center">$h_{Θ}(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(-10)\approx0$</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(10)\approx1$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(10)\approx1$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(30)\approx1$</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><p>下面的神经网络使用同样的原理实现了“非”的功能：</p>
<p><img src="/img/16_09_11/009.png" alt=""></p>
<p>假设函数为：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)=g(10 - 20x\_{1})</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{1}$</th>
<th style="text-align:center">$h_{Θ}(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(10)\approx1$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(-10)\approx0$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h3><p>下面的神经网络使用同样的原理实现了“$(NOTx_{1})AND(NOTx_{2})$”的功能：</p>
<p><img src="/img/16_09_11/010.png" alt=""></p>
<p>假设函数为：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)=g(10 - 20x\_{1} - 20x\_{2})</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{1}$</th>
<th style="text-align:center">$x_{2}$</th>
<th style="text-align:center">$h_{Θ}(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(10)\approx1$</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(-10)\approx0$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">$g(-10)\approx0$</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">$g(-30)\approx0$</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="求解-XNOR"><a href="#求解-XNOR" class="headerlink" title="求解    XNOR"></a>求解    XNOR</h3><p>接下来我们使用上面求解的以下三个神经网络，就可以来运算$x_{1}XNORx_{2}$了：</p>
<p><img src="/img/16_09_11/011.png" alt=""></p>
<p>为了拟合$x_{1}XNORx_{2}$的非线性的样本分布：</p>
<p><img src="/img/16_09_11/001.png" alt=""></p>
<p>我们可以构建以下神经网络的隐藏层：</p>
<p><img src="/img/16_09_11/012.png" alt=""></p>
<p>对应的真值表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{1}$</th>
<th style="text-align:center">$x_{2}$</th>
<th style="text-align:center">$a_{1}^{(2)}$</th>
<th style="text-align:center">$a_{2}^{(2)}$</th>
<th style="text-align:center">$h_{Θ}(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>有了$a_{1}^{(2)}$、$a_{2}^{(2)}$后，我们加入偏置单元，然后就可以得到输出层了：</p>
<p><img src="/img/16_09_11/012.png" alt=""></p>
<p>最终的真值表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{1}$</th>
<th style="text-align:center">$x_{2}$</th>
<th style="text-align:center">$a_{1}^{(2)}$</th>
<th style="text-align:center">$a_{2}^{(2)}$</th>
<th style="text-align:center">$h_{Θ}(x)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>1</strong></td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>0</strong></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>0</strong></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>1</strong></td>
</tr>
</tbody>
</table>
</div>
<p>通过一个含有输入层、隐藏层、输出层的神经网络，我们最终拟合了$x_{1}XNORx_{2}$。</p>
<blockquote>
<p>更一般的理解是：在输入层中，我们有原始输入值，然后我们建立了一个隐藏层，用来计算稍微复杂一些的输入量的函数，然后通过添加另一个层我们得到了一个更复杂一点的函数，这就是神经网络可以计算较复杂函数的某种直观解释。</p>
<p>我们知道，当层数很多的时候，你有一个相对简单的输入量的函数作为第二层，而第三层可以建立在此基础上来计算更加复杂一些的函数，然后再下一层，又可以计算再复杂一些的函数：</p>
</blockquote>
<p><img src="/img/16_09_11/014.png" alt=""></p>
<h3 id="手写识别的展示"><a href="#手写识别的展示" class="headerlink" title="手写识别的展示"></a>手写识别的展示</h3><p>接下来，将展示一段视频，来源于<strong>阳乐昆(Yann LeCun)</strong>，他是一名教授，供职于纽约大学，也是神经网络研究早期的奠基者之一，也是这一领域 大牛。他的很多理论和想法现在都已经被应用于各种各样的产品和应用中，遍布全世界。所以我想向大家展示一段他早期工作中的视频，这段视频中，他使用神经网络算法进行手写数字的识别。你也许记得，这门课刚开始的时候，我说过关于神经网络的一个早期成就，就是应用神经网络读取邮政编码，以帮助我们进行邮递。那么这便是其中的一项尝试。</p>
<p>视频说明：</p>
<p><img src="/img/16_09_11/015.png" alt=""></p>
<p>视频如下：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/yxuRnBEczUU" frameborder="0" allowfullscreen></iframe>

<h2 id="神经网络的多类别分类"><a href="#神经网络的多类别分类" class="headerlink" title="神经网络的多类别分类"></a>神经网络的多类别分类</h2><p><a href="https://www.coursera.org/learn/machine-learning/lecture/gFpiW/multiclass-classification">视频地址</a></p>
<blockquote>
<p>这一节将介绍<strong>如何使用神经网络做多类别分类</strong>。</p>
<p>在多类别分类中，通常有不止一个类别需要我们去区分，在上一节最后的视频中，我们提到了有关手写数字识别的问题，这实际上正是一个多类别分类的问题。因为识别数字从0到9，正好是10个类别。</p>
</blockquote>
<p>我们处理多类别分类的方法实际上是基于一个<strong>多神经网络算法</strong>而延伸出来的。</p>
<p>让我们来看看下面这个例子：</p>
<p>还是一个有关计算机视觉识别的例子，就像我之前介绍过的识别汽车的例子一样，但与之不同的是现在我们希望处理的是四个类别的分类问题，四个类别分别是行人、轿车、摩托车、卡车：</p>
<p><img src="/img/16_09_11/016.png" alt=""></p>
<p>任意给出一副图片，我们需要知道图片上是这四个类别中的哪一个。</p>
<p>对于这样的一个问题，我们的做法是，<strong>建立一个具有四个输出单元的神经网络</strong>：</p>
<p><img src="/img/16_09_11/017.png" alt=""></p>
<p>也就是说，此时神经网络的输出是一个思维向量。因此现在的输出需要用一个向量来表示，这个向量中有四个元素，而我们要做的是对第一个输出元素进行分辨图片上是不是一个行人(Pedestrian)，然后对第二个元素分辨它是不是一辆轿车(Car)，对第三个元素分辨它是不是摩托车(Motorcycle)，对第四个元素分辨它是不是一辆卡车(Truck)。</p>
<p>因此，如果图上是行人的话，我希望输出结果是：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\approx
\begin{bmatrix}
1 \\\\
0 \\\\
0 \\\\
0
\end{bmatrix}</script><p>如果图上是轿车的话，我希望输出结果是：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\approx
\begin{bmatrix}
0 \\\\
1 \\\\
0 \\\\
0
\end{bmatrix}</script><p>如果图上是摩托车的话，我希望输出结果是：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\approx
\begin{bmatrix}
0 \\\\
0 \\\\
1 \\\\
0
\end{bmatrix}</script><p>如果图上是卡车的话，我希望输出结果是：</p>
<script type="math/tex; mode=display">
h\_{Θ}(x)\approx
\begin{bmatrix}
0 \\\\
0 \\\\
0 \\\\
1
\end{bmatrix}</script><p>所以，这和我们介绍逻辑回归时讨论过的一对多方法其实是一样的，只不过现在我们有四个逻辑回归的分类器，而我们需要对每一个分类器都分别进行识别分类。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>斯坦福机器学习课程汇总</title>
    <url>/2017/06/05/%E6%96%AF%E5%9D%A6%E7%A6%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先感谢<strong>吴恩达</strong>建立<a href="https://www.coursera.org">Coursera</a>这样一个优秀的在线学习平台，以及他发布在这个平台上的<a href="https://www.coursera.org/learn/machine-learning/">机器学习</a>课程。</p>
<p>这门课程将整个机器学习领域的基础知识，用浅显易懂的方式，深入浅出的进行了介绍。使得一个拥有高中数学知识的学生也能听得明白。</p>
<p>如果你想要涉足机器学习、人工智能领域，或者对这一领域有浓厚的兴趣想要深入了解，那么你会发现很多机器学习入门课程推荐的资料中，都有吴恩达老师的这一系列课程。甚至在大多数资料中，都把这门课放在了首选的位置上。</p>
<p>因此，我把吴恩达老师的课程整理成了MarkDown的格式，方便查阅学习。以下是具体章节的目录，其中每篇文章都有对应的视频连接地址：</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>第一周<ul>
<li><a href="http://t.cn/RSC1bwH">欢迎来到机器学习</a></li>
<li><a href="http://t.cn/RSC1Ju5">监督学习</a></li>
<li><a href="http://t.cn/RSC1XxR">无监督学习</a></li>
<li><a href="http://t.cn/RSC1onR">一元线性回归</a></li>
<li><a href="http://t.cn/RSC1N6G">参数学习-梯度下降算法</a></li>
<li><a href="http://t.cn/RSC1WEE">线性代数复习</a></li>
</ul>
</li>
<li>第二周<ul>
<li><a href="http://t.cn/RSC1T2O">编程环境设置-Octave:MATLAB</a></li>
<li><a href="http://t.cn/RSC1RnN">多元线性回归分析</a></li>
<li><a href="http://t.cn/RSC1nj4">参数的计算分析</a></li>
<li><a href="http://t.cn/RSC1BP3">Octave/Matlab 使用说明</a></li>
</ul>
</li>
<li>第三周<ul>
<li><a href="http://t.cn/RSC1epl">分类和表达式</a><ul>
<li><a href="http://t.cn/RSCBwf7">分类</a></li>
<li><a href="http://t.cn/RSCB4bV">假设函数表达式</a></li>
<li><a href="http://t.cn/RSCBhNP">决策边界</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCBccU">Logistic回归模型</a><ul>
<li><a href="http://t.cn/RSCBMeK">逻辑回归的代价函数</a></li>
<li><a href="http://t.cn/RSCBogn">简化代价函数以及梯度下降</a></li>
<li><a href="http://t.cn/RSCBpkr">高级优化</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCBWU1">多类别分类问题：一对多</a></li>
<li><a href="http://t.cn/RSCBjW6">正则化：解决过拟合问题</a><ul>
<li><a href="http://t.cn/RSCBT6v">解决过拟合问题</a></li>
<li><a href="http://t.cn/RSCB8Vt">代价函数</a></li>
<li><a href="http://t.cn/RSCBELF">正则化线性回归</a></li>
</ul>
</li>
</ul>
</li>
<li>第四周<ul>
<li><a href="http://t.cn/RSCBBZe">神经网络引入</a><ul>
<li><a href="http://t.cn/RSCBDHu">非线性假设</a></li>
<li><a href="http://t.cn/RSCBsN4">神经网络和大脑</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCrZ1M">神经网络</a></li>
<li><a href="http://t.cn/RSCrUfK">神经网络应用实例</a></li>
</ul>
</li>
<li>第五周<ul>
<li><a href="http://t.cn/RSCr5m2">训练神经网络</a><ul>
<li><a href="http://t.cn/RSCrf4H">代价函数</a></li>
<li><a href="http://t.cn/RSCriIb">反向传播(B-P)</a></li>
<li><a href="http://t.cn/RSCr9Rc">反向传播算法的直观介绍</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCr0yH">BP算法</a></li>
<li><a href="http://t.cn/RSCrHqO">神经网络实现自动驾驶</a></li>
</ul>
</li>
<li>第六周<ul>
<li><a href="http://t.cn/RSCruh7">评价一个学习算法</a><ul>
<li><a href="http://t.cn/RSCr1gH">如何少走弯路？</a></li>
<li><a href="http://t.cn/RSCrd7a">评估假设函数</a></li>
<li><a href="http://t.cn/RSCruh7">多项式模型的选择以及训练集/验证集/测试集的划分</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCdL5Q">偏差VS方差</a><ul>
<li><a href="http://t.cn/RSCdL5Q">偏差VS方差</a></li>
<li><a href="http://t.cn/RSCd6C0">正则化和偏差/方差</a></li>
<li><a href="http://t.cn/RSCdo2l">学习曲线(Learning Curves)</a></li>
<li><a href="http://t.cn/RSCdCvC">重新审视决定下一步做什么</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCd0fl">机器学习系统设计</a><ul>
<li><a href="http://t.cn/RSCd0fl">构建垃圾邮件分类器</a></li>
<li><a href="http://t.cn/RSCdH6b">误差分析</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSh83NE">操作偏斜数据</a><ul>
<li><a href="http://t.cn/RSCdBSe">偏移类的错误度量</a></li>
<li><a href="http://sina.lt/eXAz">查准率和召回率练习</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCgyhD">使用大数据集</a></li>
</ul>
</li>
<li>第七周<ul>
<li><a href="http://t.cn/RSCg4WP">大间距分类 SVM</a><ul>
<li><a href="http://t.cn/RSCg4WP#优化目标">优化目标</a></li>
<li><a href="http://t.cn/RSCg4WP#大间距的直觉">大间距的直觉</a></li>
<li><a href="http://t.cn/RSCg4WP#大间距分类器背后的数学原理(选学">大间距分类器背后的数学原理(选学)</a>)</li>
</ul>
</li>
<li><a href="http://t.cn/RSCgJw1">核函数</a></li>
<li><a href="http://t.cn/RSCgXmt">使用SVM</a></li>
</ul>
</li>
<li>第八周<ul>
<li><a href="http://t.cn/RSCgKuS">聚类</a><ul>
<li><a href="http://t.cn/RSCgKuS#">无监督学习介绍</a></li>
<li><a href="http://t.cn/RSCgKuS#K-Means算法">K-Means算法</a></li>
<li><a href="http://t.cn/RSCgKuS#优化目标">优化目标</a></li>
<li><a href="http://t.cn/RSCgKuS#随机初始化">随机初始化</a></li>
<li><a href="http://t.cn/RSCgKuS#选择簇的数量">选择簇的数量</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCg8PK">PCA 降维</a></li>
</ul>
</li>
<li>第九周<ul>
<li><a href="http://t.cn/RSCgubu">密度估计&amp;异常检测</a></li>
<li><a href="http://t.cn/RSCgBQV">构建一个异常检测系统</a></li>
<li><a href="http://t.cn/RSCgDCU">多元高斯分布（选学）</a></li>
<li><a href="http://t.cn/RSCevr6">预测电影评分</a><ul>
<li><a href="http://t.cn/RSCevr6#预测电影评分">预测电影评分</a></li>
<li><a href="http://t.cn/RSCevr6#协同过滤">协同过滤</a></li>
<li><a href="http://t.cn/RSCevr6#低秩矩阵分解">低秩矩阵分解</a></li>
</ul>
</li>
</ul>
</li>
<li>第十周<ul>
<li><a href="http://t.cn/RSCeLpk">大数据集梯度下降</a><ul>
<li><a href="http://t.cn/RSCeLpk#处理大数据的学习算法">处理大数据的学习算法</a></li>
<li><a href="http://t.cn/RSCeLpk#随机梯度下降">随机梯度下降</a></li>
<li><a href="http://t.cn/RSCeLpk#小批量梯度下降">小批量梯度下降</a></li>
<li><a href="http://t.cn/RSCeLpk#随机梯度下降的收敛">随机梯度下降的收敛</a></li>
</ul>
</li>
<li><a href="http://t.cn/RSCeii5">高级主题</a><ul>
<li><a href="http://t.cn/RSCeii5#在线学习">在线学习</a></li>
<li><a href="http://t.cn/RSCeii5#MapReduce和数据并行">Map Reduce 和数据并行</a></li>
</ul>
</li>
</ul>
</li>
<li>第十一周<ul>
<li><a href="http://t.cn/RSCe9Bv">照片OCR</a><ul>
<li><a href="http://t.cn/RSCe9Bv#问题描述和流水线（Pipeline）">问题描述和流水线（Pipeline）</a></li>
<li><a href="http://t.cn/RSCe9Bv#滑动窗体">滑动窗体</a></li>
<li><a href="http://t.cn/RSCe9Bv#获取大量数据和人工数据">获取大量数据和人工数据</a></li>
<li><a href="http://t.cn/RSCe9Bv#上限分析：流水线上的下一步工作是什么">上限分析：流水线上的下一步工作是什么</a></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>斯坦福课程</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习(01)kNN算法</title>
    <url>/2015/12/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(01)%20kNN%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="k-近邻算法概述"><a href="#k-近邻算法概述" class="headerlink" title="k-近邻算法概述"></a>k-近邻算法概述</h2><p>简单的说，k-近邻算法采用<strong>测量不同特征值之间的距离方法进行分类</strong>。</p>
<h3 id="kNN的工作原理是："><a href="#kNN的工作原理是：" class="headerlink" title="kNN的工作原理是："></a>kNN的工作原理是：</h3><blockquote>
<p>在一个样本数据集中（又称作训练样本集），每个样本都存在有<strong>标签</strong>，即我们知道样本数据集中每个数据所属分类的对应关系。输入<strong>没有标签</strong>的新数据时，将新数据的每个特征与样本集中数据的对应特征进行比较，然后算法<strong>提取样本集中特征最相似数据</strong>（最近邻）的分类标签。一般来说，我们只选择样本数据集中<strong>前k个</strong>最相似的数据，这就是k-近邻算法中k的出处，通常<strong>k是不大于20</strong>的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
</blockquote>
<h3 id="k-近邻算法的优缺点"><a href="#k-近邻算法的优缺点" class="headerlink" title="k-近邻算法的优缺点"></a>k-近邻算法的优缺点</h3><p>优点：精度高、对异常值不敏感、无数据输入假定。<br>缺点：计算复杂度高、空间复杂度高。<br>试用数据范围：数值型和标称型。</p>
<h3 id="k-近邻算法的一般流程"><a href="#k-近邻算法的一般流程" class="headerlink" title="k-近邻算法的一般流程"></a>k-近邻算法的一般流程</h3><p>[1] 收集数据：可以使用任何方法。<br>[2] 准备数据：距离计算需要的数值，最好是结构化的数据格式。<br>[3] 分析数据：可以使用任何方法。<br>[4] 训练算法：此步骤不适用于k-近邻算法。<br>[5] 测试算法：计算错误率。<br>[6] 使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。</p>
<h2 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h2><h3 id="使用k-近邻算法分类爱情片和动作片"><a href="#使用k-近邻算法分类爱情片和动作片" class="headerlink" title="使用k-近邻算法分类爱情片和动作片"></a>使用k-近邻算法分类爱情片和动作片</h3><p>有人曾经统计过很多电影的打斗镜头和接吻镜头，下图显示了6部电影的打斗和接吻镜头数。假如有一部未看过的电影，如何确定它是爱情片还是动作片呢？</p>
<p><img src="/img/ml_01_01.png" alt="使用打斗和接吻镜头数分类电影"></p>
<p>首先我们需要知道这个未知电影存在多少个打斗镜头和接吻镜头。上图对应的数据如下：</p>
<p>每部电影的打斗镜头数、接吻镜头数以及电影评估类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">电影名称</th>
<th style="text-align:right">打斗镜头</th>
<th style="text-align:center">接吻镜头</th>
<th style="text-align:center">电影类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">California Man</td>
<td style="text-align:right">3</td>
<td style="text-align:center">104</td>
<td style="text-align:center">爱情片</td>
</tr>
<tr>
<td style="text-align:left">He’s Not Really into Dudes</td>
<td style="text-align:right">2</td>
<td style="text-align:center">100</td>
<td style="text-align:center">爱情片</td>
</tr>
<tr>
<td style="text-align:left">Beautiful Woman</td>
<td style="text-align:right">1</td>
<td style="text-align:center">81</td>
<td style="text-align:center">爱情片</td>
</tr>
<tr>
<td style="text-align:left">Kevin Longblade</td>
<td style="text-align:right">101</td>
<td style="text-align:center">10</td>
<td style="text-align:center">动作片</td>
</tr>
<tr>
<td style="text-align:left">Robo Slayer 3000</td>
<td style="text-align:right">99</td>
<td style="text-align:center">5</td>
<td style="text-align:center">动作片</td>
</tr>
<tr>
<td style="text-align:left">Amped II</td>
<td style="text-align:right">98</td>
<td style="text-align:center">2</td>
<td style="text-align:center">动作片</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:right">18</td>
<td style="text-align:center">90</td>
<td style="text-align:center">未知</td>
</tr>
</tbody>
</table>
</div>
<p>即使不知道未知电影属于哪种类型，我们也可以通过某种方法计算出来。首先<strong>计算未知电影与样本集中其他电影的距离</strong>，如下表所示（暂时不要关心距离是如何计算的）：</p>
<p>已知电影与未知电影的距离</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">电影名称</th>
<th style="text-align:center">与未知电影的距离</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">California Man</td>
<td style="text-align:center">20.5</td>
</tr>
<tr>
<td style="text-align:left">He’s Not Really into Dudes</td>
<td style="text-align:center">18.7</td>
</tr>
<tr>
<td style="text-align:left">Beautiful Woman</td>
<td style="text-align:center">19.2</td>
</tr>
<tr>
<td style="text-align:left">Kevin Longblade</td>
<td style="text-align:center">115.3</td>
</tr>
<tr>
<td style="text-align:left">Robo Slayer 3000</td>
<td style="text-align:center">117.4</td>
</tr>
<tr>
<td style="text-align:left">Amped II</td>
<td style="text-align:center">118.9</td>
</tr>
</tbody>
</table>
</div>
<p>现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到k个距离最近的电影。假定k=3，则三个最靠近的电影依次是<em>He’s Not Really into Dudes</em>、<em>Beautiful Woman</em>和<em>California Man</em>。k-近邻算法按照距离最近的三部电影的类型，决定未知电影的类型，而这三部电影全是爱情片，因此我们判定未知电影是爱情片。</p>
<h2 id="代码实现kNN"><a href="#代码实现kNN" class="headerlink" title="代码实现kNN"></a>代码实现kNN</h2><h3 id="创建样本数据集："><a href="#创建样本数据集：" class="headerlink" title="创建样本数据集："></a>创建样本数据集：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span>():</span></span><br><span class="line">	group = array([<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>])</span><br><span class="line">	labels = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">	<span class="keyword">return</span> group,labels</span><br></pre></td></tr></table></figure>
<p>命令行执行后得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>group,labels = kNN.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group</span><br><span class="line">array([[<span class="number">1.0</span>, <span class="number">1.1</span>],</span><br><span class="line">	[<span class="number">1.0</span>, <span class="number">1.0</span>],</span><br><span class="line">	[<span class="number">0.0</span>, <span class="number">0.0</span>],</span><br><span class="line">	[<span class="number">0.0</span>, <span class="number">0.1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labels</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>向量label包含了每个数据点的标签信息，label包含的元素个数等于group矩阵行数。这里，我们将数据点（1.0，1.1）定义为类A，数据点(0,0.1)定义为类B。</p>
<p>下图是四个点在坐标系中的表示：</p>
<p><img src="/img/ml_01_02.png" alt="k-近邻算法：带有4个数据点的简单例子"></p>
<h3 id="从文本文件中解析数据"><a href="#从文本文件中解析数据" class="headerlink" title="从文本文件中解析数据"></a>从文本文件中解析数据</h3><p>将每组数据划分到某个类中，伪代码如下：</p>
<p><code>对未知类别属性的数据集中的每个点依次执行以下操作：</code></p>
<ul>
<li>(1) 计算已知类别数据集中的点与当前点之间的距离；</li>
<li>(2) 按照距离递增次序排序；</li>
<li>(3) 选取与当前点距离最小的k个点；</li>
<li>(4) 确定前k个点所在类别的出现频率；</li>
<li>(5) 返回前k个点出现频率最高的类别作为当前点的预测分类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inX:用于分类的输入向量  </span></span><br><span class="line"><span class="comment"># dataSet:输入的训练样本集</span></span><br><span class="line"><span class="comment"># labels:标签向量</span></span><br><span class="line"><span class="comment"># k:用于选择最近邻的数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span>(<span class="params">inX, dataSet, labels, k</span>):</span></span><br><span class="line">	<span class="comment"># 距离计算</span></span><br><span class="line">	dataSetSize = dataSet.shape[<span class="number">0</span>] <span class="comment"># 数据的条目数</span></span><br><span class="line">	diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</span><br><span class="line">	sqDiffMat = diffMat**<span class="number">2</span></span><br><span class="line">	sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">	distances = sqDistances**<span class="number">0.5</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 将距离值按照从小到大排序</span></span><br><span class="line">	sortedDistIndicies = distances.argsort()</span><br><span class="line">	classCount=&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 取出前k个元素</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> rangs(k):</span><br><span class="line">		<span class="comment"># 取出对应的label</span></span><br><span class="line">		voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">		<span class="comment"># 计算当前取出的label的数量</span></span><br><span class="line">		classCount[voteIlabel] = classCount.get(voteIlabel,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 逆序排列label对应总数的列表 返回对应的label</span></span><br><span class="line">	sortedClassCount = <span class="built_in">sorted</span>(classCount.iteritems(),key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><code>关于距离计算的部分</code></p>
<p>参考欧式距离公式：<br><img src="/img/ml_01_03.png" alt="欧式距离公式"></p>
<p>例如，计算点(0,0)到(1,2)之间的距离为：<br><img src="/img/ml_01_04.png" alt="距离计算例子1"></p>
<p>计算点(1,0,0,1)与(7,6,9,4)之间的距离为：<br><img src="/img/ml_01_05.png" alt="距离计算例子2"></p>
<p>为了预测数据所在的分类，在Python提示符中输入下列命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kNN.classify0([<span class="number">0</span>,<span class="number">0</span>], group, labels, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出的结果应该是B。</p>
<h3 id="测试分类器"><a href="#测试分类器" class="headerlink" title="测试分类器"></a>测试分类器</h3><p>分类器并不会得到百分之百的正确的结果，为了测试分类器的效果，我们可以使用已知晓答案的数据，当然答案不能告诉分类器，检验分类器给出的结果是否符合预期结果。</p>
<p>通过大量的测试数据，我们可以得到分类器的错误率—分类器给出错误结果的词数 除以 测试执行的总数。</p>
<p>错误率是常用的评估方法，主要用于评估分类器在某个数据集上的执行效果。完美分类器的错误率为0，最差分类器的错误率是1.0，在这种情况下，分类器根本就无法找到一个正确答案。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习(02)决策树</title>
    <url>/2015/12/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(02)%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h2 id="什么是决策树"><a href="#什么是决策树" class="headerlink" title="什么是决策树"></a>什么是决策树</h2><blockquote>
<p>你是否玩过二十个问题的游戏，游戏的规则很简单：参与游戏的一方在脑海里想某个事物，其他参与者向他提问题，只允许提20个问题，问题的答案也只能用对或错回答。问问题的人通过推断分解，逐步缩小待猜测事物的范围。</p>
</blockquote>
<p>决策树的工作原理与20个问题类似，用户输入一系列数据，然后给出游戏的答案。</p>
<p>决策树的概念非常简单。如下图就是一个决策树：</p>
<p><img src="/img/ml_02_01.png" alt="决策树图例"></p>
<p>构造决策树能够读取数据集合，并从中提取出一系列规则。</p>
<p>专家系统中经常使用决策树，而且决策树给出结果往往可以匹敌在当前领域具有几十年工作经验的人类专家。</p>
<h3 id="决策树的优缺点"><a href="#决策树的优缺点" class="headerlink" title="决策树的优缺点"></a>决策树的优缺点</h3><blockquote>
<p>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。</p>
<p>缺点：可能会产生过渡匹配的问题。</p>
<p>使用数据类型：数值型和标称型。</p>
</blockquote>
<h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2><h3 id="实施决策树算法的步骤："><a href="#实施决策树算法的步骤：" class="headerlink" title="实施决策树算法的步骤："></a>实施决策树算法的步骤：</h3><ul>
<li><p>1.收集数据</p>
</li>
<li><p>2.处理数据，保证每条数据的最末尾的数据是当前类型。</p>
</li>
<li><p>3.对多个可以划分的<strong>特征</strong>进行甄选，甄选的标准是<strong>保证通过甄选之后划分的结果的信息增益最大</strong>。划分的方式:按照当前甄选的特征进行划分。</p>
</li>
</ul>
<blockquote>
<p>比如影响是否是鱼类的类型的两个特征：不浮出水面是否可以生存，是否有脚蹼，若当前选择的特征“不浮出水面是否可以生存” 信息增益最大，那么将数据划分成：不浮出水面可以生存 和 不浮出水面不可以生存 两类数据。</p>
</blockquote>
<ul>
<li>4.如果划分后的数据全是同一类型（即香浓熵为0），则不再划分，否则，继续递归调用第三步的方法。</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在构造决策树时，我们需要解决的第一个问题就是，<strong>当数据集上哪个特征在划分数据分类时起决定性作用</strong>。为了找到<strong>决定性</strong>的特征，划分出<strong>最好</strong>的结果，我们必须<strong>评估每个特征</strong>。</p>
<p>完成测试之后，原始数据集就被划分为几个<strong>数据子集</strong>。这些数据子集会分布在第一个<strong>决策点</strong>的所有分支上。</p>
<p>如果某个分支下的数据属于同一类型，则当前分支下数据已经正确地划分，无需进行进一步对数据集进行分割。如果分支下的数据不属于同一类型，则需要重复划分数据子集，直到<strong>所有具有相同类型的数据均在一个数据子集内</strong>。</p>
<p>伪代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检测数据集中的每个子项是否属于同一分类</span><br><span class="line">If so return 类标签;</span><br><span class="line">Else</span><br><span class="line">     寻找划分数据集的最好特征</span><br><span class="line">     划分数据集</span><br><span class="line">     创建分支节点</span><br><span class="line">          for 每个划分的子集</span><br><span class="line">               ＃ 递归调用函数createBranch</span><br><span class="line">               调用函数createBranch并增加返回结果到分支节点中</span><br><span class="line">     return 分支节点</span><br></pre></td></tr></table></figure>
<h3 id="核心算法介绍"><a href="#核心算法介绍" class="headerlink" title="核心算法介绍"></a>核心算法介绍</h3><p><strong>划分算法</strong>：</p>
<p>主要参考<strong>ID3算法</strong>,每次划分数据集时只选取一个特征属性:</p>
<p><a href="http://en.wikipedia.org/wiki/ID3_algorithm">http://en.wikipedia.org/wiki/ID3_algorithm</a></p>
<p><strong>香浓熵</strong></p>
<blockquote>
<p><strong>克劳德·香农</strong><br>克劳德·香农被公认为是二十世纪最聪明的人之一，威廉·庞德斯通在其2005年出版的《财富公式》一书中是这样描写克劳德·香农的：</p>
<p>“贝尔实验室和MIT有很多人将香农和爱因斯坦相提并论，而其他人则认为这种对比是不公平的－－对香农是不公平的。”</p>
</blockquote>
<p>划分数据集的大原则是：<strong>将无需的数据变得更加有序</strong>。组织杂乱无章的数据的一种方法就是使用<strong>信息论</strong>度量信息，信息论是量化处理信息的分支学科。</p>
<p><code>在划分数据前后信息发生的变化称为信息增益。</code></p>
<p><strong>熵</strong>定义为<strong>信息的期望值</strong>，首先我们需要知道<strong>信息的定义</strong>。如果待分类的事务可能划分在多个分类之中，则<strong>符号$x_i$的信息</strong>定义为：</p>
<script type="math/tex; mode=display">l(n_i) = -log_2p(x_i)</script><p> 其中$p(x_i)$是选择该分类的概率。</p>
<p> 为了计算<strong>熵</strong>，我们需要计算<strong>所有类别所有可能值包含的信息期望值</strong>，通过下面公式得到：</p>
<script type="math/tex; mode=display">H = -\sum_{i=1}^np(x_i)log_2p(x_i)</script><p> 其中n是分类的数目。</p>
<h2 id="说这么多，不如举个栗子来的实在"><a href="#说这么多，不如举个栗子来的实在" class="headerlink" title="说这么多，不如举个栗子来的实在"></a>说这么多，不如举个栗子来的实在</h2><p>接下来我们对下列数据通过决策树来进行分析：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">不浮出水面是否可以生存</th>
<th style="text-align:center">是否有脚蹼</th>
<th style="text-align:center">属于鱼类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
</div>
<h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><blockquote>
<p>对数据进行分类时，我们首先要思考按照哪一个特征分类。这里我们需要分别计算分别按照两个特征进行分类之后的香浓熵，与分类之前的香浓熵进行对比，选取差值最大的（即为信息增益最大的）结果作为分类标准。</p>
</blockquote>
<p>模拟获取数据，注意数据的最末尾是当<strong>前数据的类型</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span>():</span></span><br><span class="line">    dataSet = [[<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">               [<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">               [<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;no&#x27;</span>]]</span><br><span class="line">    labels = [<span class="string">&#x27;no surfacing&#x27;</span>,<span class="string">&#x27;flippers&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> dataSet,labels</span><br></pre></td></tr></table></figure>
<p>传说中香农熵的计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算数据中最后一个元素（当前数据类型）的香农熵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    numEntries = <span class="built_in">len</span>(dataSet)</span><br><span class="line">    labelCounts = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        currentLabel = featVec[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">            labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">        labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    shannonEnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">        prob = <span class="built_in">float</span>(labelCounts[key])/numEntries</span><br><span class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>
<p>对数据进行分割：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dataSet:传入数据  </span></span><br><span class="line"><span class="comment"># axis:要进行切割的特征下标  </span></span><br><span class="line"><span class="comment"># value:用来切割的特征值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span>(<span class="params">dataSet, axis, value</span>):</span></span><br><span class="line">    retDataSet = []</span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">            reducedFeatVec = featVec[:axis]</span><br><span class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">            retDataSet.append(reducedFeatVec)</span><br><span class="line">    <span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure>
<p>甄选最适合划分的特征：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    <span class="comment"># 获取每组数据除去分类标签的数据长度</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算数据的基础的shannon熵</span></span><br><span class="line">    baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeature = -<span class="number">1</span></span><br><span class="line">    print(dataSet)</span><br><span class="line">    print(<span class="string">&quot;------&quot;</span> + <span class="built_in">str</span>(numFeatures))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每一列标签</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        <span class="comment"># 获取每一种标签下的对应的数据</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">        <span class="built_in">print</span> featList</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历并按照分类分割这一列下的数据 并计算分割后的shannone熵</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subDataSet = splitDataSet(dataSet,i,value)</span><br><span class="line">            prob = <span class="built_in">len</span>(subDataSet)/<span class="built_in">float</span>(<span class="built_in">len</span>(dataSet))</span><br><span class="line">            print(<span class="string">&quot;shannone:&quot;</span> + <span class="built_in">str</span>(calcShannonEnt(subDataSet)))</span><br><span class="line">            newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 之前基本的shannone熵 减去 分割后的数据的shannone熵 算出前后差值 差值越大，代表后面的分类中，分得的数据混杂项越少</span></span><br><span class="line">        infoGain = baseEntropy - newEntropy</span><br><span class="line">        <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">            bestInfoGain = infoGain</span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat,labels=createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chooseBestFeatureToSplit(myDat)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>得到最好的分类是第0个特征。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习(03)朴素贝叶斯构建敏感词过滤系统</title>
    <url>/2015/12/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(03)%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%9E%84%E5%BB%BA%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="贝叶斯理论入门"><a href="#贝叶斯理论入门" class="headerlink" title="贝叶斯理论入门"></a>贝叶斯理论入门</h2><h3 id="贝叶斯？"><a href="#贝叶斯？" class="headerlink" title="贝叶斯？"></a>贝叶斯？</h3><blockquote>
<p>贝叶斯概率以18世纪的一位神学家<strong>托马斯·贝叶斯<code>(Thomas Bayes)</code></strong>的名字命名。贝叶斯概率引入先验知识和逻辑推理来处理不确定命题。另一种概率解释称为频数概率<code>(frequency probability)</code>,它只从数据本身获得结论，并不考虑逻辑推理及先验知识。</p>
</blockquote>
<p><strong>朴素贝叶斯</strong>中的<strong>朴素</strong>一词的含义是指：整个形式化过程，我们只做最原始、最简单的假设。(如果你不理解这句话的含义，不要担心，后面我们会详细讲解的)。</p>
<h3 id="条件概率与贝叶斯准则"><a href="#条件概率与贝叶斯准则" class="headerlink" title="条件概率与贝叶斯准则"></a>条件概率与贝叶斯准则</h3><p>如果你对$p(x,y|c_1)$符号很熟悉，那么请跳过本段</p>
<h4 id="条件概率定义"><a href="#条件概率定义" class="headerlink" title="条件概率定义:"></a>条件概率定义:</h4><blockquote>
<p>事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为<strong>P(A|B)</strong>，读作“在B条件下A的概率”。</p>
</blockquote>
<h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>假设现在有一个装了7块石头的罐子，其中3块是灰色的，4块是黑色的，如果从罐子里随即取出一块石头，那么是灰色石头的可能性是多少？很显然，答案是3/7。</p>
<p>那么如果把这些石头分别放到两个桶中，A桶中为2块灰色2块黑色，B桶中为1块灰色2块黑色，那么取出灰色石头的概率又该如何计算呢？</p>
<p>要计算$P(gray)$或者$P(black)$,事先得知道石头所在桶的信息会不会改变结果。你有可能已经想到计算从B桶中取到灰色石头的概率的方法，这就是所谓的<strong>条件概率<code>(conditional probability)</code></strong>。</p>
<p>假定计算的是从B桶取到灰色石头的概率，这个概率可以记作$P(gray|bucketB)$,我们称之为“在已知石头出自B桶的条件下，取出灰色石头的概率”。不难得到，$P(gray|bucketA)$值为2/4,$P(gray|bucketB)$的值为1/3。</p>
<p>记从B桶中取出灰色石头的概率为：$P(gray and bucketB)$，石头出自B桶的概率为$P(pucketB)$，那么条件概率计算公式如下：</p>
<script type="math/tex; mode=display">P(gray|bucketB) = P(gray and bucketB)/P(bucketB)</script><h4 id="贝叶斯准则"><a href="#贝叶斯准则" class="headerlink" title="贝叶斯准则"></a>贝叶斯准则</h4><p>另一种有效计算条件概率的方法称为<strong>贝叶斯准则</strong>。贝叶斯准则告诉我们如何交换条件概率中的条件与结果，即如果已知$p(x|c)$,要求$p(c|x)$,那么可以使用下面的计算方法：</p>
<script type="math/tex; mode=display">
p(c|x) = \dfrac{p(x|c)p(c)}{p(x)}</script><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>假设有一个数据集，它由两类数据组成，数据分布如下图所示：</p>
<p><img src="/img/ml_03_01.png" alt="朴素贝叶斯图例"></p>
<p>其中不同形状代表不同的数据类型。</p>
<p>我们现在用<strong>$p1(x,y)$</strong>表示数据点$(x,y)$属于类别1<em>(图中圆点表示的类型)</em>的概率，用<strong>$p2(x,y)$</strong>表示数据点$(x,y)$属于类别2<em>(图中三角形表示的类型)</em>的概率。</p>
<p>那么对于一个新的数据点$(x,y)$，我们可以通过以下规则来判断它所属于的类型：</p>
<ul>
<li>如果$p1(x,y) &gt; p2(x,y)$，那么类型为1</li>
<li>如果$p1(x,y) &lt; p2(x,y)$，那么类型为2</li>
</ul>
<h2 id="使用朴素贝叶斯进行文档分类"><a href="#使用朴素贝叶斯进行文档分类" class="headerlink" title="使用朴素贝叶斯进行文档分类"></a>使用朴素贝叶斯进行文档分类</h2><p>机器学习的一个重要应用就是文档的自动分类。对例如用户留言，邮件内容等任意类型的文本进行分类，我们可以观察文档中出现的词，并把每个词的出现或者不出现作为一个特征，这样得到的特征数目就会跟词汇表中的词目一样多。</p>
<h3 id="两个假设前提"><a href="#两个假设前提" class="headerlink" title="两个假设前提"></a>两个假设前提</h3><blockquote>
<p>我们使用的朴素贝叶斯进行文档分类时，需要建立在两个假设前提之上的，虽然这两个假设前提有一些瑕疵，但实际情况证明，贝叶斯工作的效果很好。</p>
</blockquote>
<p>假设词汇表中有1000个单词。要得到好的概率分布，就需要足够的数据样本，假定样本数为$N$。由统计学可知，如果每个特征需要$N$个样本，那么对于10个特征将需要$N^{10}$个样本，对于包含1000个特征的词汇表，将需要$N^{1000}$个样本。可以看到，所需要的样本书会随着特征数目的增大而迅速增长。</p>
<p><strong>假设1:特征之间相互独立</strong>，那么样本数就可以从$N^{1000}$减少到$1000N$了。</p>
<p><strong>假设2:每个特征同等重要</strong>。</p>
<blockquote>
<p>注释：<strong>特征之间相互独立</strong>指的是统计意义上的独立，即一个特征的出现的可能性不受其他特征所影响。 举个例子来说明：比如单词A出现在B后面的概率和出现在C后面的概率相同。很明显这种情况很不靠谱，这也正是<strong>朴素贝叶斯</strong>中<strong>朴素</strong>一词的含义。</p>
</blockquote>
<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>接下来我们要用python代码来实现一个侮辱性词汇过滤系统，要用到我们刚才学习的朴素贝叶斯的知识。也许你会问，构建一个侮辱性词汇集合的数据库，遇到了侮辱性词汇，就认定这个文本为侮辱性文本，不就可以很好的解决这个问题了吗？何必要用贝叶斯呢？</p>
<p>首先不否认这也是一种实现思路，但我们要做的过滤系统的最终效果将是由人工去判断样本数据是否为侮辱性的文本，然后剩下的就可以交给机器，机器会自动识别出侮辱性词汇，以及判断待测试数据是侮辱性文本的可能性和非侮辱性文本的可能性，取概率较大的作为判定结果来标识出侮辱性的文本。</p>
<h3 id="数据的处理"><a href="#数据的处理" class="headerlink" title="数据的处理"></a>数据的处理</h3><p>想要从一个文本中获取特征，首先需要<strong>拆分文本</strong>。这里的特征来自于文本的<strong>词条<code>(token)</code></strong>，我们可以把词条理解为单个单词。我们将出现在所有的文本中的词条做一个<strong>不重复的集合</strong>，然后对每一条文本进行标识，如果对应文本中对应位置的词条没有出现记为0，出现记为1。这样我们可以得到一系列用来标识文本片段特征的由0和1组成的列表，这个列表我们称为<strong>词条向量</strong>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="准备数据：从文本中构建词条向量"><a href="#准备数据：从文本中构建词条向量" class="headerlink" title="准备数据：从文本中构建词条向量"></a>准备数据：从文本中构建词条向量</h4><p><strong>构建数据源：</strong>首先创建数据源，获取所有文本词条集合以及对应类型集合，这里省略分词部分逻辑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span>():</span></span><br><span class="line">    <span class="comment"># 文本集合，每条文本中都有若干条词条</span></span><br><span class="line">    postingList = [[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;please&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                   [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 1代表侮辱性文字，0代表正常言论</span></span><br><span class="line">    <span class="comment"># 这些数据将由人工标注，用于训练程序以便自动检测侮辱性留言</span></span><br><span class="line">    classVec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postingList,classVec</span><br></pre></td></tr></table></figure>
<p><strong>词条字典构建：</strong>将所有词条集合传入，得到一个所有不重复词条的集合字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span>(<span class="params">dataSet</span>):</span></span><br><span class="line">    vocabSet = <span class="built_in">set</span>([])</span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="comment"># &#x27;|&#x27;操作符可以取两个列表的并集，set()方法可以去除重复项</span></span><br><span class="line">        vocabSet = vocabSet | <span class="built_in">set</span>(document)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocabSet)</span><br></pre></td></tr></table></figure>
<p><strong>构建词条向量：</strong>传入词条字典，和待测试的对应文本词条集合，得到词条向量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span>(<span class="params">vocabList, inputSet</span>):</span></span><br><span class="line">    <span class="comment"># 初始化词条向量</span></span><br><span class="line">    <span class="comment"># [0]*len(vocabList) 可以获得一个和vocabList等长的，全部由0组成的集合</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*<span class="built_in">len</span>(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            <span class="comment"># 如果词条集合中的词条出现在了词条字典中，则将词条向量中的词条对应位置的元素记为1</span></span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;the word: %s is not in my Vocabulary!&quot;</span> % word</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>
<p>执行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">postingList,classVec = loadDataSet()</span><br><span class="line">print(<span class="string">&quot;------postings------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> posting <span class="keyword">in</span> postingList:</span><br><span class="line">    print(posting)</span><br><span class="line">print(<span class="string">&quot;------classVec------&quot;</span>)</span><br><span class="line">print(classVec)</span><br><span class="line"></span><br><span class="line">vocabList = createVocabList(postingList)</span><br><span class="line">print(<span class="string">&quot;------vocabList------&quot;</span>)</span><br><span class="line">print(vocabList)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;------words2Vec------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> posting <span class="keyword">in</span> postingList:</span><br><span class="line">    print(setOfWords2Vec(vocabList,posting))</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------postings------</span><br><span class="line">[&#39;my&#39;, &#39;dog&#39;, &#39;has&#39;, &#39;flea&#39;, &#39;problems&#39;, &#39;help&#39;, &#39;please&#39;]</span><br><span class="line">[&#39;maybe&#39;, &#39;not&#39;, &#39;take&#39;, &#39;him&#39;, &#39;to&#39;, &#39;dog&#39;, &#39;park&#39;, &#39;stupid&#39;]</span><br><span class="line">[&#39;my&#39;, &#39;dalmation&#39;, &#39;is&#39;, &#39;so&#39;, &#39;cute&#39;, &#39;I&#39;, &#39;love&#39;, &#39;him&#39;]</span><br><span class="line">[&#39;stop&#39;, &#39;posting&#39;, &#39;stupid&#39;, &#39;worthless&#39;, &#39;garbage&#39;]</span><br><span class="line">[&#39;mr&#39;, &#39;licks&#39;, &#39;ate&#39;, &#39;my&#39;, &#39;steak&#39;, &#39;how&#39;, &#39;to&#39;, &#39;stop&#39;, &#39;him&#39;]</span><br><span class="line">[&#39;quit&#39;, &#39;buying&#39;, &#39;worthless&#39;, &#39;dog&#39;, &#39;food&#39;, &#39;stupid&#39;]</span><br><span class="line">------classVec------</span><br><span class="line">[0, 1, 0, 1, 0, 1]</span><br><span class="line">------vocabList------</span><br><span class="line">[&#39;cute&#39;, &#39;love&#39;, &#39;help&#39;, &#39;garbage&#39;, &#39;quit&#39;, &#39;I&#39;, &#39;problems&#39;, &#39;is&#39;, &#39;park&#39;, &#39;stop&#39;, &#39;flea&#39;, &#39;dalmation&#39;, &#39;licks&#39;, &#39;food&#39;, &#39;not&#39;, &#39;him&#39;, &#39;buying&#39;, &#39;posting&#39;, &#39;has&#39;, &#39;worthless&#39;, &#39;ate&#39;, &#39;to&#39;, &#39;maybe&#39;, &#39;please&#39;, &#39;dog&#39;, &#39;how&#39;, &#39;stupid&#39;, &#39;so&#39;, &#39;take&#39;, &#39;mr&#39;, &#39;steak&#39;, &#39;my&#39;]</span><br><span class="line">------words2Vec------</span><br><span class="line">[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1]</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0]</span><br><span class="line">[1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1]</span><br><span class="line">[0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1]</span><br><span class="line">[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了这六组待测试数据的词条向量。</p>
<h4 id="训练算法：通过词条向量计算是侮辱性评论的概率"><a href="#训练算法：通过词条向量计算是侮辱性评论的概率" class="headerlink" title="训练算法：通过词条向量计算是侮辱性评论的概率"></a>训练算法：通过词条向量计算是侮辱性评论的概率</h4><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><p>前面介绍了如何将一组单词转换为一组数字，接下来看看如何使用这些数字计算概率。</p>
<p>现在我们已经知道了一个词是否出现在一篇文档中，也知道该文档所属的类别。根据前面提到的贝叶斯准则，我们将其中的$x$替换为$\textbf{w}$。<strong>注意：这里的粗体的$\textbf{w}$代表一个向量，即它是由多个值组成。</strong></p>
<script type="math/tex; mode=display">
p(c_i|\textbf{w}) = \dfrac{p(\textbf{w}|c_i)p(c_i)}{p(\textbf{w})}</script><p>我们将使用上述公式，对每个类计算该值，然后比较着两个概率值的大小<code>（这个例子中就是分别计算是侮辱性言论和不是侮辱性言论的概率，比较两种情况的概率大小）</code>。</p>
<p>如何计算呢？</p>
<p><strong>step1:计算$p(c_{i})$</strong></p>
<p>首先可以通过类别i<code>(侮辱性言论或者非侮辱性言论)</code>中文档数除以总的文档数来计算$p(ci)$<code>(对应类别的文档占总文档数的比例)</code></p>
<p><strong>step2:计算$p(\textbf{w}|c_i)$</strong></p>
<p>这里就要用到朴素贝叶斯的假设了。假设$\textbf{w}$展开为一个个独立特征，那么可以将上述概率写作$p(w_0,w_1,w_2..w_n|c_i)$。这里假设所有词都互相独立，该假设也称作<strong>条件独立假设</strong>，它意味着可以使用$p(w_0|c_i)p(w_1|c_i)p(w_2|c_i)..p(w_n|c_i)$来计算上述概率，这就极大的简化了计算的过程。</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><p>朴素贝叶斯分类器训练函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># trainMatrix:多个词条向量组成的集合矩阵</span></span><br><span class="line"><span class="comment"># trainCategory:分类标签集合</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNBO</span>(<span class="params">trainMatrix, trainCategory</span>):</span></span><br><span class="line">    <span class="comment"># 记录词条向量个数</span></span><br><span class="line">    numTrainDocs = <span class="built_in">len</span>(trainMatrix)</span><br><span class="line">    <span class="comment"># 单个词条向量的长度，即词条字典的长度</span></span><br><span class="line">    numWords = <span class="built_in">len</span>(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 引入numpy后，sum函数可以计算一个集合的所有元素的总和</span></span><br><span class="line">    <span class="comment"># pAbusive 是所有词条向量中 是侮辱性言论的概率： 3/6 = 0.5</span></span><br><span class="line">    pAbusive = <span class="built_in">sum</span>(trainCategory) / <span class="built_in">float</span>(numTrainDocs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化 侮辱性/非侮辱性 言论中 词条分布总和向量</span></span><br><span class="line">    <span class="comment"># 引入numpy后,zeros(numWords)方法用来得到一个和numWords等长的0矩阵</span></span><br><span class="line">    p0Num = zeros(numWords)</span><br><span class="line">    p1Num = zeros(numWords)</span><br><span class="line">    <span class="comment"># 初始化 侮辱性/非侮辱性 言论中 词条总个数</span></span><br><span class="line">    p0Denom = <span class="number">0.0</span></span><br><span class="line">    p1Denom = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果为侮辱性言论，记录所有侮辱性词条向量累加之后的总向量</span></span><br><span class="line">            p1Num += trainMatrix[i]</span><br><span class="line">            <span class="comment"># 记录所有侮辱性言论中，总的词条个数</span></span><br><span class="line">            p1Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果为非侮辱性言论，记录所有非侮辱性词条向量累加之后的总向量</span></span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            <span class="comment"># 记录所有非侮辱性言论中，总的词条个数</span></span><br><span class="line">            p0Denom += <span class="built_in">sum</span>(trainMatrix[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算出一个标示每个词可能是侮辱性词汇概率的向量</span></span><br><span class="line">    p1Vect = p1Num / p1Denom</span><br><span class="line">    <span class="comment"># 计算出一个标示每个词可能是非侮辱性词汇概率的向量</span></span><br><span class="line">    p0Vect = p0Num / p0Denom</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p0Vect, p1Vect, pAbusive</span><br></pre></td></tr></table></figure>
<p>运行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">postingList, classVec = loadDataSet()</span><br><span class="line"></span><br><span class="line">vocabList = createVocabList(postingList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> posting <span class="keyword">in</span> postingList:</span><br><span class="line">    word2Vec = setOfWords2Vec(vocabList, posting)</span><br><span class="line">    trainMat.append(word2Vec)</span><br><span class="line"></span><br><span class="line">p0V,p1V,pAb = trainNBO(trainMat,classVec)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;------p0V------&quot;</span>)</span><br><span class="line">print(p0V)</span><br><span class="line">print(<span class="string">&quot;------p1V------&quot;</span>)</span><br><span class="line">print(p1V)</span><br><span class="line">print(<span class="string">&quot;------pAb------&quot;</span>)</span><br><span class="line">print(pAb)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">------p0V------</span><br><span class="line">[ <span class="number">0.04166667</span>  <span class="number">0.04166667</span>  <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.04166667</span></span><br><span class="line">  <span class="number">0.04166667</span>  <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.04166667</span>  <span class="number">0.04166667</span>  <span class="number">0.04166667</span></span><br><span class="line">  <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.08333333</span>  <span class="number">0.</span>          <span class="number">0.</span></span><br><span class="line">  <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.04166667</span>  <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.04166667</span></span><br><span class="line">  <span class="number">0.04166667</span>  <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.04166667</span>  <span class="number">0.</span>          <span class="number">0.04166667</span></span><br><span class="line">  <span class="number">0.04166667</span>  <span class="number">0.125</span>     ]</span><br><span class="line">------p1V------</span><br><span class="line">[ <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.</span>          <span class="number">0.</span></span><br><span class="line">  <span class="number">0.</span>          <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.</span></span><br><span class="line">  <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.</span></span><br><span class="line">  <span class="number">0.10526316</span>  <span class="number">0.</span>          <span class="number">0.05263158</span>  <span class="number">0.05263158</span>  <span class="number">0.</span>          <span class="number">0.10526316</span></span><br><span class="line">  <span class="number">0.</span>          <span class="number">0.15789474</span>  <span class="number">0.</span>          <span class="number">0.05263158</span>  <span class="number">0.</span>          <span class="number">0.</span>          <span class="number">0.</span>        ]</span><br><span class="line">------pAb------</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<p>p0V是所有词汇出现在非侮辱性言论中的概率向量。</p>
<p>p1V是所有词汇出现在侮辱性言论中的概率向量。</p>
<p>从中可以看出，p1V中，概率最大的是倒数第六个0.15789474,然后查询词条字典，发现这个词是‘stupid’,这意味着‘stupid’这个单词是最能表征类型1的词条，事实也确实如此。同时我们也能发现最能表征类别0的词条是‘him’。</p>
<p><code>从结果中我们同样也能看到，在p0V中为0的词条，在p1V中不为0，相反的，在p1V中为0的词条，在p0V中也不为0。其实这并不是绝对的，这是巧合所致，如果我们的测试样本数量足够大，就可以看出这个现象了。</code></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>代码实现了贝叶斯分类器，并不是完事大吉了，有些地方我们需要根据实际情况来优化我们的代码。</p>
<h4 id="注意点1："><a href="#注意点1：" class="headerlink" title="注意点1："></a>注意点1：</h4><p>利用贝叶斯分类器对文档进行分类时，要计算多个概率的乘积，以获得文档属于某个类别的概率，即计算$p(w_0|1)p(w_1|1)p(w_2|1)$。如果其中一个概率为0，那么最后的成积也为0。为降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2<code>(分子分母各加1)</code>。</p>
<p>将trainNBO()的14到18这几行代码进行修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 侮辱性/非侮辱性 言论中 词条分布总和向量</span></span><br><span class="line">   <span class="comment"># 引入numpy后,zeros(numWords)方法用来得到一个和numWords等长的单位矩阵</span></span><br><span class="line">   p0Num = ones(numWords)</span><br><span class="line">   p1Num = ones(numWords)</span><br><span class="line">   <span class="comment"># 初始化 侮辱性/非侮辱性 言论中 词条总个数</span></span><br><span class="line">   p0Denom = <span class="number">2.0</span></span><br><span class="line">   p1Denom = <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<h4 id="注意点2："><a href="#注意点2：" class="headerlink" title="注意点2："></a>注意点2：</h4><p>另一个问题是下溢出，这是由于太多很小的数相乘造成的。当计算$p(w_0|c_i)p(w_1|c_i)p(w_2|c_i)…p(w_N|c_i)$时，由于大部分因子都非常小，所以非常容易出现下溢出<code>(可以尝试用python计算多个很小的数字相乘，最后的结果会变为0)</code>。</p>
<p>一种解决办法是对乘积取自然对数。在代数中有$ln(a*b)=ln(a)+ln(b)$,于是通过求对数可以将乘法转化为加法，从而避免下溢出或者浮点数舍入导致的错误。同时，采用自然对数进行处理不会有任何损失。</p>
<p>修改trainNBO()中的代码，在return之前添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分别对每个元素取对数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p1Vect)):</span><br><span class="line">    p1Vect[i]=log(p1Vect[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p0Vect)):</span><br><span class="line">    p0Vect[i]=log(p0Vect[i])</span><br></pre></td></tr></table></figure>
<h3 id="只差一步，构建朴素贝叶斯分类函数"><a href="#只差一步，构建朴素贝叶斯分类函数" class="headerlink" title="只差一步，构建朴素贝叶斯分类函数"></a>只差一步，构建朴素贝叶斯分类函数</h3><p>现在已经准备好了构建完整的分类器了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vec2Classify:待测试数据的词条向量</span></span><br><span class="line"><span class="comment"># pClass1:所有词条向量中是侮辱性词条向量的概率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span>(<span class="params">vec2Classify, p0Vec, p1Vec, pClass1</span>):</span></span><br><span class="line">	<span class="comment"># sum(vec2Classify * p1Vec)当前词条向量中，每个词条可能是侮辱性词条的概率之积p(w:c1)</span></span><br><span class="line">	<span class="comment"># pClass1 : p(c1)</span></span><br><span class="line">    p1 = <span class="built_in">sum</span>(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">    p0 = <span class="built_in">sum</span>(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>执行代码，检验结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">postingList, classVec = loadDataSet()</span><br><span class="line">vocabList = createVocabList(postingList)</span><br><span class="line"></span><br><span class="line">trainMat = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> posting <span class="keyword">in</span> postingList:</span><br><span class="line">    word2Vec = setOfWords2Vec(vocabList, posting)</span><br><span class="line">    trainMat.append(word2Vec)</span><br><span class="line"></span><br><span class="line">p0V,p1V,pAb = trainNBO(trainMat,classVec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据1</span></span><br><span class="line">testEntry = [<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;my&#x27;</span>,<span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">thisDoc = array(setOfWords2Vec(vocabList,testEntry))</span><br><span class="line"><span class="built_in">print</span> testEntry,<span class="string">&#x27;classified as: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据2</span></span><br><span class="line">testEntry = [<span class="string">&#x27;stupid&#x27;</span>,<span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">thisDoc = array(setOfWords2Vec(vocabList,testEntry))</span><br><span class="line"><span class="built_in">print</span> testEntry,<span class="string">&#x27;classified as: &#x27;</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>] classified <span class="keyword">as</span>:  <span class="number">0</span></span><br><span class="line">[<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>] classified <span class="keyword">as</span>:  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，完成了朴素贝叶斯识别侮辱性言论的系统。对于分类而言，有的时候使用概率要比使用硬规则更为有效。可以看出，朴素贝叶斯提供了一种<strong>利用已知值来估计未知概率的有效方法</strong>。</p>
<p>虽然建立在<strong>特征独立性假设</strong>和<strong>特征同等重要假设</strong>之上，但是，贝叶斯分类器依然是一种很有效的分类器。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习(04)Logistic回归</title>
    <url>/2016/01/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(04)Logistic%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h2 id="什么是Logistic回归"><a href="#什么是Logistic回归" class="headerlink" title="什么是Logistic回归"></a>什么是Logistic回归</h2><h3 id="什么是回归？"><a href="#什么是回归？" class="headerlink" title="什么是回归？"></a>什么是<strong>回归</strong>？</h3><p>假设现在有一些数据点，我们用一条直线对这些点进行拟合（该线称为最佳拟合直线），这个拟合过程就称作<strong>回归</strong>。</p>
<p>Logistic回归分类的主要思想是：根据现有数据边界线建立回归公式，以此进行分类。这里的<code>&quot;回归&quot;</code>一词，源于最佳拟合，在训练分类器时的主要做法就是寻找最佳拟合参数集，这其中运用到的就是<strong>最优化算法</strong>(可以找到最优解的算法)。</p>
<p>其中回归过程中运用到的数学原理的核心，就是<strong>Logistic函数</strong>。</p>
<h3 id="什么是Logistic"><a href="#什么是Logistic" class="headerlink" title="什么是Logistic"></a>什么是Logistic</h3><blockquote>
<p><strong>Logistic函数</strong>或<strong>Logistic曲线</strong>是一种常见的S形函数，它是皮埃尔·弗朗索瓦·韦吕勒在1844或1845年在研究它与人口增长的关系时命名的。广义Logistic曲线可以模仿一些情况人口增长（P）的S形曲线。起初阶段大致是指数增长；然后随着开始变得饱和，增加变慢；最后，达到成熟时增加停止。</p>
</blockquote>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>简单来说如果想了解到底哪些因素是胃癌的危险因素，我们就可以使用Logistic回归来处理。</p>
<p>想探讨胃癌发生的危险因素，可以选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群肯定有不同的体征和生活方式等。这里的因变量就是是否胃癌，即“是”或“否”，为两分类变量，自变量就可以包括很多了，例如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。通过Logistic回归分析，我们可以大致了解到底哪些因素是胃癌的危险因素。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数01-矩阵乘法</title>
    <url>/2015/11/29/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B001-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<h2 id="矩阵的乘法："><a href="#矩阵的乘法：" class="headerlink" title="矩阵的乘法："></a>矩阵的乘法：</h2><p>矩阵A与矩阵B相乘，运算方式是矩阵A的行的每一项 去乘B矩阵的每一列 并且加起来 构成相乘之后的矩阵</p>
<script type="math/tex; mode=display">
 \begin{bmatrix}
   a & b \\\
   c & d 
  \end{bmatrix}
  \{*}
  \begin{bmatrix}
   e & f \\\
   g & h
  \end{bmatrix}
  \{=}
  \begin{bmatrix}
   (ae + bg) & (af + bh) \\\
   (ce + dg) & (cf + dh) 
  \end{bmatrix}</script><h2 id="关于交换律："><a href="#关于交换律：" class="headerlink" title="关于交换律："></a>关于交换律：</h2><p>矩阵乘法是不满足交换律的：</p>
<script type="math/tex; mode=display">
AB != BA</script><h2 id="行列不相同的矩阵相乘："><a href="#行列不相同的矩阵相乘：" class="headerlink" title="行列不相同的矩阵相乘："></a>行列不相同的矩阵相乘：</h2><p>一个3x2的矩阵与一个2x3的矩阵相乘，得到的是一个2x2的矩阵：</p>
<script type="math/tex; mode=display">
 \begin{bmatrix}
   3 & 1 & 2 \\\
   -2 & 0 & 5
  \end{bmatrix}
  \{+}
  \begin{bmatrix}
   1 & 3 \\\
   0 & 5 \\\
   2 & 5
  \end{bmatrix}
  \{=}
  \begin{bmatrix}
   (3\cdot(-1) + 1\cdot0 + 2\cdot2) & (3\cdot3 + 1\cdot5 + 2\cdot5) \\\
   ((-2)\cdot1 + 0\cdot0 + 5\cdot2) & ((-2)\cdot3 + 0\cdot5 + 5\cdot5) 
  \end{bmatrix}
  \{=}
  \begin{bmatrix}
   1 & 24 \\\
   8 & 19 
  \end{bmatrix}</script><p>只有<strong>第一个矩阵到列数和第二个矩阵的行数相同</strong>，才能做矩阵乘法运算：</p>
<p>A[m:n] 和 B[n:p] 向量是可以相乘的，结果是C[m:p] </p>
<p>A[m:n] 和 B[p:q] 向量是不可以做乘法运算的</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数02-矩阵的逆</title>
    <url>/2015/11/29/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B002-%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86/</url>
    <content><![CDATA[<h2 id="单位向量"><a href="#单位向量" class="headerlink" title="单位向量"></a>单位向量</h2><p>如果有一个矩阵I,对于以下两种情况都成立：</p>
<script type="math/tex; mode=display">
I \cdot A = A</script><script type="math/tex; mode=display">
A \cdot I = A</script><p>那么I被称为单位矩阵。</p>
<p>单位矩阵是行列数相同，第i行i列为1，其他为0的矩阵。</p>
<p>例如：</p>
<script type="math/tex; mode=display">
 \begin{bmatrix}
   1 & 0 & 0 \\\
   0 & 1 & 0 \\\
   0 & 0 & 1
  \end{bmatrix}</script><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><p>如果矩阵I是单位矩阵</p>
<script type="math/tex; mode=display">
A \cdot A^{-1} = I</script><script type="math/tex; mode=display">
A^{-1} \cdot A = I</script><p>那么<script type="math/tex">A^{-1}</script>就是矩阵A的逆矩阵。</p>
<h2 id="对2x2的矩阵求逆"><a href="#对2x2的矩阵求逆" class="headerlink" title="对2x2的矩阵求逆"></a>对2x2的矩阵求逆</h2><script type="math/tex; mode=display">
A
\{=}
\begin{bmatrix}
   a & b \\\
   c & d 
  \end{bmatrix}</script><script type="math/tex; mode=display">
A^{-1}
\{=}
\dfrac{1}{ad-bc}\begin{bmatrix}
   d & -b \\\
   -c & a
  \end{bmatrix}</script><h2 id="通过高思消元法（增广矩阵）求任意矩阵的逆矩阵"><a href="#通过高思消元法（增广矩阵）求任意矩阵的逆矩阵" class="headerlink" title="通过高思消元法（增广矩阵）求任意矩阵的逆矩阵"></a>通过高思消元法（增广矩阵）求任意矩阵的逆矩阵</h2><p>对增广矩阵进行一系列<strong>初等行变换</strong> 使得左边的矩阵变成右边的单位矩阵</p>
<p>所谓初等行变换 就是某一行与其他任意行进行加减或者成倍的加减 或者替换 操作</p>
<p>举例：</p>
<script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0\\\
      0 & 2 & 1 & 0 & 1 & 0\\\
      1 & 1 & 1 & 0 & 0 & 1
    \end{array}
\right]\tag{0}</script><script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0\\\
      0 & 2 & 1 & 0 & 1 & 0\\\
      0 & 1 & 0 & -1 & 0 & 1
    \end{array}
\right]\tag{1}</script><script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0\\\
      0 & 1 & 0 & -1 & 0 & 1\\\
      0 & 2 & 1 & 0 & 1 & 0
    \end{array}
\right]\tag{2}</script><script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|ccc}
      1 & 0 & 1 & 1 & 0 & 0\\\
      0 & 1 & 0 & -1 & 0 & 1\\\
      0 & 0 & 1 & 2 & 1 & -2
    \end{array}
\right]\tag{3}</script><script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|ccc}
      1 & 0 & 0 & -1 & -1 & 2\\\
      0 & 1 & 0 & -1 & 0 & 1\\\
      0 & 0 & 1 & 2 & 1 & -2
    \end{array}
\right]\tag{3}</script><p>经过一系列初等变化，左侧矩阵变为了单位矩阵，右侧矩阵变为了原左侧矩阵的逆矩阵。</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数03-矩阵法求解方程组</title>
    <url>/2015/11/29/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B003-%E7%9F%A9%E9%98%B5%E6%B3%95%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<p>矩阵是一种思考问题的方式，我们可以用它来解决我们遇到的一些问题：</p>
<h2 id="求解二元一次方程组"><a href="#求解二元一次方程组" class="headerlink" title="求解二元一次方程组"></a>求解二元一次方程组</h2><script type="math/tex; mode=display">
3x + 2y = 7</script><script type="math/tex; mode=display">
-6x + 6y = 6</script><p>通过矩阵来求解，可以转换成如下格式：</p>
<script type="math/tex; mode=display">
 \begin{bmatrix}
   3 & 2 \\\
   -6 & 6 
  \end{bmatrix}
  \
  \begin{bmatrix}
   x \\\
   y
  \end{bmatrix}
  \{=}
  \begin{bmatrix}
   7 \\\
   6
  \end{bmatrix}</script><p>相当于：</p>
<script type="math/tex; mode=display">
A \cdot x=B</script><p>为了求解出未知数x，我们需要在等式两边乘以矩阵A的逆矩阵：</p>
<script type="math/tex; mode=display">
A^{-1} \cdot A \cdot x=A^{-1} \cdot B</script><script type="math/tex; mode=display">
I \cdot x=A^{-1} \cdot B</script><script type="math/tex; mode=display">
x=A^{-1} \cdot B</script><p>解得：</p>
<script type="math/tex; mode=display">
 A^{-1}=
 \dfrac{1}{30}
 \begin{bmatrix}
   6 & -2 \\\
   -6 & 3 
  \end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
   x \\\
   y
  \end{bmatrix}
  =
  \dfrac{1}{30}
  \begin{bmatrix}
   6 & -2 \\\
   -6 & 3 
  \end{bmatrix}
  \begin{bmatrix}
   7 \\\
   6
  \end{bmatrix}
  =
  \begin{bmatrix}
   1 \\\
   2
  \end{bmatrix}</script>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数04-奇异矩阵</title>
    <url>/2015/11/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B004-%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="奇异矩阵"><a href="#奇异矩阵" class="headerlink" title="奇异矩阵"></a>奇异矩阵</h2><blockquote>
<p>当一个矩阵<strong>没有逆矩阵</strong>的时候，则称这个矩阵称为奇异矩阵。</p>
</blockquote>
<p>对于2x2矩阵的分析：</p>
<script type="math/tex; mode=display">
  A=
  \begin{bmatrix}
   a & b \\\
   c & d
  \end{bmatrix}
  \tag{0}</script><script type="math/tex; mode=display">
A^{-1}=\dfrac{1}{|A|}
\begin{bmatrix}
   d & -b \\\
   -c & a 
  \end{bmatrix}
  \tag{1}</script><script type="math/tex; mode=display">
{|A|}=ad - bc
\tag{2}</script><p>跟进2x2矩阵的逆矩阵的推导过程，我们发现当ad=bc时，无解。</p>
<p>所以，<strong>当行列式为0的时候，矩阵为奇异矩阵</strong>。</p>
<p>这条定律也可以推广到任意的[n:n]矩阵</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数05-求解三元线性方程组</title>
    <url>/2015/12/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B005-%E6%B1%82%E8%A7%A3%E4%B8%89%E5%85%83%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<h2 id="求解三元线性方程组"><a href="#求解三元线性方程组" class="headerlink" title="求解三元线性方程组"></a>求解三元线性方程组</h2><p>二元线性方程组，相当于求解在x，y坐标系中，两条不平行的直线的焦点坐标。</p>
<p>同理，求解三元线性方程组，相当于求解在x，y，z坐标系中，三个互不平行的平面的焦点坐标。</p>
<p>例如：</p>
<script type="math/tex; mode=display">
\begin{cases} 
-x + 2y - z = 9\\\\
x - 7y - 2z = -20\\\\
2x + 2y + z = 2
\end{cases}</script><p>通过增广矩阵求解：</p>
<script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|c}
      -1 & 2 & -1 & 9\\\
      3 & -7 & -2 & -20\\\
      2 & 2 & 1 & 2
    \end{array}
\right]\tag{1}</script><p>第二行加上第一行的3倍，第三行加第一行的2倍，消去第一列。</p>
<script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|c}
      -1 & 2 & -1 & 9\\\
      0 & -1 & -5 & 7\\\
      0 & 6 & -1 & 20
    \end{array}
\right]\tag{2}</script><p>同理，第三行与第二行进行运算，消除第二列：</p>
<script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|c}
      -1 & 2 & -1 & 9\\\
      0 & -1 & -5 & 7\\\
      0 & 0 & -31 & 62
    \end{array}
\right]\tag{3}</script><script type="math/tex; mode=display">
\left[
    \begin{array}{ccc|c}
      -1 & 2 & -1 & 9\\\
      0 & -1 & -5 & 7\\\
      0 & 0 & 1& -2
    \end{array}
\right]\tag{4}</script><p>从而得出：</p>
<script type="math/tex; mode=display">
\begin{cases} 
-x + 2y - z = 9\\\\
-y - 5z = 7\\\\
z = -2
\end{cases}</script><script type="math/tex; mode=display">
\begin{cases} 
x = -1\\\\
y = 3\\\\
z = -2
\end{cases}</script>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数06-向量简介</title>
    <url>/2015/12/05/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B006-%E5%90%91%E9%87%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h2><blockquote>
<p>有理数和无理数.其中无理数就是无限不循环小数,有理数就包括整数和分数.实数直观地定义为和数轴上的点一一对应的数.本来实数仅称作数,后来引入了虚数概念,原本的数称作“实数”——意义是“实在的数”</p>
</blockquote>
<p>π是一个实数，e是一个实数，√2是实数，3也是实数。但是1+2i不是实数。</p>
<h2 id="R-n"><a href="#R-n" class="headerlink" title="$R^n$"></a><strong>$R^n$</strong></h2><p><strong>$R^n$</strong>代表所有有序集的集合。（这里的n并不是n次方的意思。）</p>
<p>例如：</p>
<script type="math/tex; mode=display">
R^2 = \\{(x1,x2)  \|  x1,x2\in R  \\}</script><p>什么是$R^n$上的向量呢？</p>
<p>其实就是这些n元组中的一个特定值。[n个实数的有序集]</p>
<p>表示一个向量，有很多种方法，例如一个二维向量可以用（x1，x2）来表示，看起来有点像坐标系。或者可以这样表示<x1,x2></p>
<p>也可以用矩阵表示：</p>
<p>例如定义一个n维向量:</p>
<script type="math/tex; mode=display">
V=
\left[
\begin{matrix}
 v1  \\\
 v2  \\\
 \vdots \\\
 vn  \\\
\end{matrix}
\right]</script><h2 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h2><script type="math/tex; mode=display">
A=
\left[
\begin{matrix}
 a1  \\\
 a2  \\\
 \vdots \\\
 an  \\\
\end{matrix}
\right]</script><script type="math/tex; mode=display">
B=
\left[
\begin{matrix}
 b1  \\\
 b2  \\\
 \vdots \\\
 bn  \\\
\end{matrix}
\right]</script><script type="math/tex; mode=display">
A + B=
\left[
\begin{matrix}
 a1 + b1  \\\
 a2 + b2  \\\
 \vdots \\\
 an + bn  \\\
\end{matrix}
\right]</script><h2 id="数乘运算"><a href="#数乘运算" class="headerlink" title="数乘运算"></a>数乘运算</h2><script type="math/tex; mode=display">
A=
\left[
\begin{matrix}
 a1  \\\
 a2  \\\
 \vdots \\\
 an  \\\
\end{matrix}
\right]</script><script type="math/tex; mode=display">
cA=
\left[
\begin{matrix}
 ca1  \\\
 ca2  \\\
 \vdots \\\
 can  \\\
\end{matrix}
\right]</script><h2 id="零向量"><a href="#零向量" class="headerlink" title="零向量"></a>零向量</h2><p>零向量：每个元素都为0的n维向量。</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
 0  \\\
 0  \\\
 \vdots \\\
 0  \\\
\end{matrix}
\right]</script>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数07-直线的参数表示</title>
    <url>/2016/03/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B007-%E7%9B%B4%E7%BA%BF%E7%9A%84%E5%8F%82%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="直线的参数表示"><a href="#直线的参数表示" class="headerlink" title="直线的参数表示"></a>直线的参数表示</h2><p>学习线性代数之前，我们习惯了用$y=kx+b$这种格式来表示平面直角坐标系中的一条直线，这种表示虽然简洁，但并不具有<em>一般性</em>，比如如果想要表示n维平面内的一条直线，就不方便了。</p>
<p>学习了线性代数之后，我们就可以掌握一种通用的表达方式了，这一节来讲解线性代数中，如何通过向量参数来表示n纬平面内的一个直线。</p>
<p><img src="/img/la_07_01.png" alt=""></p>
<p>如图所示，向量$X$为，$<br>\left[<br>\begin{matrix}<br> 2  \\<br> 1  \\<br>\end{matrix}<br>\right]<br>$向量$X$为$<br>\left[<br>\begin{matrix}<br> 1  \\<br> 2  \\<br>\end{matrix}<br>\right]<br>$，那么如果我们想要求与向量$X$平行，且过$(1，2)$点所在的直线，改如何求得呢？</p>
<p>用如下公式计算即可：</p>
<script type="math/tex; mode=display">
l=\\{Y+tX | t \in R\\}</script><p>例如这个坐标系中的$X$向量和$Y$向量带入公式得：</p>
<script type="math/tex; mode=display">
\begin{cases} 
x = 1 + 2t\\\
y = 2 + t
\end{cases}</script><p>这就是这条直线的参数定义。</p>
<p>这个求直线的参数定义通常被写为如下格式：</p>
<script type="math/tex; mode=display">
l=\\{X+tV | t \in R\\}</script><p>其中向量$X$和向量$Y$可以是人意维度的向量，这也就具备了一般性。</p>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解优化Android图片内存回收</title>
    <url>/2015/11/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%BC%98%E5%8C%96Android%E5%9B%BE%E7%89%87%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>java提供了垃圾回收机制，我们不用像C++一样手动去处理垃圾内存。虽然省事，但是为了对垃圾回收器友好，我们应该引导gc，告诉它什么东西是垃圾内存。简单来说，就是不再使用的对象要置空，该回收的资源要回收。</p>
<p>android下老生常谈的异常OOM,主要产生的原因就是加载了过多的资源到内存，导致内存溢出。而在android界面中，图片一直是吃内存的大户。一个1024x800的png图片，打开ARGB通道，占用的内存总量如下：</p>
<blockquote>
<p>   1024 x 800 x 8 x 4 / 8 = 3276800byte = 3200kb = 3.125mb</p>
<p>   (内存=图片长度<em>图片宽度</em>单位像素占用的字节数)</p>
</blockquote>
<p>而系统分配给每个应用的内存总量是一定的，通常情况下不会超过128mb,因机型而异。除非将largeHeap选项开启，会获得大幅度的内存上限提升。但不是系统有多少内存就可以申请多少，而是由dalvik.vm.heapsize限制。Android官方给的建议是，作为程序员的我们应该努力减少内存的使用，想回收和复用的方法，而不是想方设法增大内存。当内存很大的时候，每次gc的时间也会长一些，性能会下降呦。</p>
<p>那么我们就来通过对view图片内存的释放来优化内存。</p>
<p>根据android的View类的源码，可以看出，当setBackgroundResource(0)时，之前的drawable对象会被移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the background to a given resource. The resource should refer to</span></span><br><span class="line"><span class="comment">    * a Drawable object or 0 to remove the background.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resid The identifier of the resource.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@attr</span> ref android.R.styleable#View_background</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@RemotableViewMethod</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundResource</span><span class="params">(<span class="keyword">int</span> resid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (resid != <span class="number">0</span> &amp;&amp; resid == mBackgroundResource) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Drawable d = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (resid != <span class="number">0</span>) &#123;</span><br><span class="line">           d = mContext.getDrawable(resid);</span><br><span class="line">       &#125;</span><br><span class="line">       setBackground(d);</span><br><span class="line"></span><br><span class="line">       mBackgroundResource = resid;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们在Activity的onDestory()方法中，调用view的setBackgroundResource(0)的方法，内存就可以在第一时间被gc回收了。</p>
<p>具体效果可以参考这片文章：</p>
<p><a href="http://dannylee1991.github.io/2015/11/19/android%E5%9B%BE%E7%89%87%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">Android图片内存优化</a></p>
<p>为了方便实用，我封装了一个工具:<a href="https://github.com/DannyLee1991/AnnoRecycleImage">AnnoRecycleImage</a>，具体用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RecycleViewBGRes</span>	<span class="comment">//对需要回收资源的控件添加注解</span></span><br><span class="line">    <span class="keyword">private</span> View root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RecycleViewBGRes(isCustom = true)</span>	<span class="comment">//自定义控件 isCustom = true</span></span><br><span class="line">    <span class="keyword">private</span> CustomView cv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RecycleViewBGRes</span></span><br><span class="line">    <span class="keyword">private</span> ImageView iv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line">        root = findViewById(R.id.root);</span><br><span class="line">        cv = (CustomView) findViewById(R.id.cv);</span><br><span class="line">        iv = (ImageView) findViewById(R.id.iv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//在onDestroy中 调用回收方法 处理标注有注解的对象</span></span><br><span class="line">        RecycleUtils.doRecycle(TestActivity.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则之 迪米特法则</title>
    <url>/2015/09/18/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迪米特原则（<strong>Law of Demeter, LoD</strong>）也称为最少知识原则(<strong>Least Knowledge Principle, LKP</strong>)，虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有做少的了解。</p>
<p>通俗的讲，一个类应该对自己需要耦合或调用的类知道的最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p>
<h2 id="进一步解释"><a href="#进一步解释" class="headerlink" title="进一步解释"></a>进一步解释</h2><h3 id="1-只和朋友交流"><a href="#1-只和朋友交流" class="headerlink" title="1.只和朋友交流"></a>1.只和朋友交流</h3><p>迪米特法则还有一个英文释义是：Only talk to your immediate friends(只与直接的朋友通信。)每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>老师命令班长清点一下班级里所有女生的数量</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老师类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">	<span class="comment">//老师对学生发布命令，清一下女生</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commond</span><span class="params">(GroupLeader groupLeader)</span></span>&#123;</span><br><span class="line">		List listGirls = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化女生</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">			listGirls.add(<span class="keyword">new</span> Girl());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//告诉体育委员开始执行清查任务</span></span><br><span class="line">		groupLeader.countGirls(listGirls);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//班长类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span></span>&#123;</span><br><span class="line">	<span class="comment">//清查女生数量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countGirls</span><span class="params">(List&lt;Girl&gt; listGirls)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;女生数量是：&quot;</span>+ listGirls.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//女生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">		<span class="comment">//老师发布命令</span></span><br><span class="line">		teacher.commond(<span class="keyword">new</span> GroupLeader());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">女生数量是：20</span><br></pre></td></tr></table></figure>
<p>仔细思考，这个程序是有问题的，老师的朋友类是班长，班长的朋友类是女生类，女生不属于老师类的朋友类，因为朋友类的定义是：<strong>出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内的类不属于朋友类。</strong>而迪米特法则告诉我们，一个类只和朋友类交流，但是刚才的commond方法和Girl类有了交流，这样破坏了Teacher类的健壮性。</p>
<p>修改后的程序，把Girl类从Teacher类中进行抽取,修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commond</span><span class="params">(GroupLeader groupLeader)</span></span>&#123;</span><br><span class="line">		groupLeader.countGirls();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Girl&gt; listGirls;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GroupLeader</span><span class="params">(List&lt;Girl&gt; _listGirls)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.listGirls = _listGirls;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countGirls</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;女生数量是：&quot;</span>+<span class="keyword">this</span>.listGirls.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		List&lt;Girl&gt; listGirls = <span class="keyword">new</span> ArrayList&lt;Girl&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">			listGirls.add(<span class="keyword">new</span> Girl());</span><br><span class="line">		&#125;</span><br><span class="line">		Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">		teacher.commond(<span class="keyword">new</span> GroupLeader(listGirls));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-朋友间也是有距离的"><a href="#2-朋友间也是有距离的" class="headerlink" title="2.朋友间也是有距离的"></a>2.朋友间也是有距离的</h3><p>迪米特法则定义即使是朋友，也不能无话不说，无所不知。</p>
<p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private／protected等访问权限，是否可以加上final关键字等。</p>
<p>迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、protected等访问权限。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>场景：模拟软件安装的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向导类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wizard</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">	<span class="comment">//第一步</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">first</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行第一个方法...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rand.nextInt(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第二步</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">second</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行第二个方法...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rand.nextInt(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第三步</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">third</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行第三个方法...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rand.nextInt(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//软件安装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallSoftware</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installWizard</span><span class="params">(Wizard wizard)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> first = wizard.first();</span><br><span class="line">		<span class="keyword">if</span>(first&gt;<span class="number">50</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> second = wizard.second();</span><br><span class="line">			<span class="keyword">if</span>(second&gt;<span class="number">50</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> third = wizard.third();</span><br><span class="line">				<span class="keyword">if</span>(third&gt;<span class="number">50</span>)&#123;</span><br><span class="line">					wizard.first();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		InstallSoftware invoker = <span class="keyword">new</span> InstallSoftware();</span><br><span class="line">		invoker.installWizard(<span class="keyword">new</span> Wizard());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序虽然简单，但仔细思考一下，<strong>Wizard类将太多的方法暴露给了InstallSoftware类，两者之间的朋友关系太过亲密了，耦合关系变得异常牢固，如果业务有变更，更改Wizard的同时，必须考虑InstallSoftware是否也需要做修改</strong>，从而扩大了变更的风险。因此我们需要进行重构。重构之后的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向导类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wizard</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">	<span class="comment">//第一步</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">first</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行第一个方法...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rand.nextInt(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第二步</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">second</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行第二个方法...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rand.nextInt(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第三步</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">third</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行第三个方法...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rand.nextInt(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//软件安装过程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installWizard</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> first = <span class="keyword">this</span>.first();</span><br><span class="line">		<span class="keyword">if</span>(first&gt;<span class="number">50</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> second = wizard.second();</span><br><span class="line">			<span class="keyword">if</span>(second&gt;<span class="number">50</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> third = wizard.third();</span><br><span class="line">				<span class="keyword">if</span>(third&gt;<span class="number">50</span>)&#123;</span><br><span class="line">					wizard.first();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将三个步骤的访问权限修改为private，同时把installWizard方法从InstallSoftware中移动到Wizard中。Wizard只对外暴露一个installWizard方法，这体现了类的高内聚特性。</p>
<p>修改后的InstallSoftware类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//软件安装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallSoftware</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installWizard</span><span class="params">(Wizard wizard)</span></span>&#123;</span><br><span class="line">		wizard.installWizard();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-如何衡量一个方法是否应该出现在当前类中？"><a href="#3-如何衡量一个方法是否应该出现在当前类中？" class="headerlink" title="3.如何衡量一个方法是否应该出现在当前类中？"></a>3.如何衡量一个方法是否应该出现在当前类中？</h3><p>在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？你可以坚持这样一个原则：</p>
<blockquote>
<p>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p>
</blockquote>
<h2 id="一个原则"><a href="#一个原则" class="headerlink" title="一个原则"></a>一个原则</h2><p>如果一个项目中，我和我需要调用的类之间超过了两次，就要考虑重构了。</p>
<p>迪米特法则要求类间解耦，但解耦是有限度的，在实际项目中需要适度的考虑这个原则，别为了套用原则而做项目。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>通过AspectJ代码注入来实现scheme跳转条件的检查判断</title>
    <url>/2017/03/21/%E9%80%9A%E8%BF%87AspectJ%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%9D%A5%E5%AE%9E%E7%8E%B0scheme%E8%B7%B3%E8%BD%AC%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%A3%80%E6%9F%A5%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>scheme跳转是Android通过外部链接打开APP指定页面的一种常见的实现方式，如果只是简单的跳转，那么不需要做什么额外的判断就可以打开指定页面了，但我们的产品中有一个需求就是：在通过scheme跳转打开某一个页面的时候，需要判断一些前置条件，如果前置条件满足的情况下，才能执行跳转，如果前置条件不满足，那么需要缓存本次跳转，直到需要满足的条件被触发时，才去执行跳转。</p>
<p>简单说来就是下面这张图：</p>
<p><img src="/img/17_03_21/001.png" alt=""></p>
<p>一开始我想到的处理方式是通过在Activity的基类里的<code>onCreate()</code>方法之前做判断逻辑，如果符合条件，则正常执行，如果条件不满足，则执行<code>finish()</code>。</p>
<p>虽然可以满足需求，但这样的代码侵入性太高，逻辑必须侵入到Activity的基类中，容易与基类中其他逻辑产生耦合。</p>
<p>因此为了解决这个方式，我想到的解决方式就是使用AOP的方式，在<code>onCreate()</code>之前注入我们的判断逻辑的代码，最后的使用方式可以简化到仅仅使用一行注解来添加判断条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SchemeCheck(conditions = &#123;Condition.LOGIN&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetActivityA</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我们就不用考虑在Activity的基类中写这些可能产生冗余的逻辑了。</p>
<p>最终实现效果如下：</p>
<ul>
<li>判断<strong>登录</strong>条件</li>
</ul>
<video width='300px' autoplay="autoplay" loop="loop" id="video" controls="" preload="none" >
  <source id="mp4" src="/img/17_03_21/002.mp4" type="video/mp4">
  <p>Your user agent does not support the HTML5 Video element.</p>
</video>

<ul>
<li>判断<strong>下载</strong>条件</li>
</ul>
<video width='300px' autoplay="autoplay" loop="loop" id="video" controls="" preload="none" >
  <source id="mp4" src="/img/17_03_21/003.mp4" type="video/mp4">
  <p>Your user agent does not support the HTML5 Video element.</p>
</video>

<ul>
<li>判断<strong>登录并且下载</strong></li>
</ul>
<video width='300px' align="center" autoplay="autoplay" loop="loop" id="video" controls="" preload="none" >
  <source id="mp4" src="/img/17_03_21/004.mp4" type="video/mp4">
  <p>Your user agent does not support the HTML5 Video element.</p>
</video>

<ul>
<li>判断登录或者下载</li>
</ul>
<video width='300px' autoplay="autoplay" loop="loop" id="video" controls="" preload="none" >
  <source id="mp4" src="/img/17_03_21/005.mp4" type="video/mp4">
  <p>Your user agent does not support the HTML5 Video element.</p>
</video>

<p>接下来介绍一下我是如何实现的。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>首先关于<strong>依赖注入</strong>以及<strong>AspectJ</strong>的相关使用，我参考了以下文章以及代码，具体使用方式我就不再赘述：</p>
<ul>
<li><a href="http://www.jianshu.com/p/0fa8073fd144">【翻译】Android中的AOP编程</a>  这一篇对AOP概念进行了介绍，并且通过AspectJ仿照<a href="https://github.com/JakeWharton/hugo">Hugo</a>实现了一个AOP的Demo。</li>
<li>JakeWharton大神的<a href="https://github.com/JakeWharton/hugo">hugo</a> 项目，通过AspectJ实现的日志工具。</li>
<li><a href="http://blog.csdn.net/crazy__chen/article/details/52014672">使用AspectJ在Android中实现Aop</a>这一篇文章是对上面的文章和hugo项目的总结。</li>
</ul>
<hr>
<p>下面是我的实现：</p>
<p>首先，定义注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface SchemeCheck &#123;</span><br><span class="line">    Condition[] conditions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得提醒的是，这里<code>@Retention</code>要定义为<code>RetentionPolicy.RUNTIME</code>，因为我们要在运行时检查注解的参数，来判断scheme的触发条件。如果你写成了<code>RetentionPolicy.CLASS</code>或者<code>RetentionPolicy.SOURCE</code>就检查不到了。</p>
<p><code>Condition</code>是我们定义的需要判断的条件枚举：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Condition &#123;</span><br><span class="line">    NULL(null),</span><br><span class="line">    LOGIN(new LoginCondition()),</span><br><span class="line">    DOWNLOAD_BOOK(new BookDownloadCondition()),</span><br><span class="line">    LOGIN_OR_DOWNLOAD_BOOK(new LoginOrBookDownloadCondition());</span><br><span class="line"></span><br><span class="line">    BaseCondition condition;</span><br><span class="line">    Condition(BaseCondition condition) &#123;</span><br><span class="line">        this.condition &#x3D; condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseCondition getCondition() &#123;</span><br><span class="line">        return condition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Condition</code>可以通过<code>getCondition()</code>来获取到具体的继承自<code>BaseCondition</code>的Condition对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class BaseCondition &#123;</span><br><span class="line">    public abstract boolean isSatisfied();</span><br><span class="line"></span><br><span class="line">    public abstract String unSatisfiedInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是Demo，我们的登录条件暂时写死，到时候换成你具体的业务逻辑即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LoginCondition extends BaseCondition &#123;</span><br><span class="line"></span><br><span class="line">    public static boolean isLogin &#x3D; false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSatisfied() &#123;</span><br><span class="line">        return isLogin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String unSatisfiedInfo() &#123;</span><br><span class="line">        return &quot;请先登录&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这些，我们就可以写注入代码了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class SchemeCheckAspect &#123;</span><br><span class="line">    @Pointcut(&quot;within(@demo.com.aj.anno.SchemeCheck *)&quot;)</span><br><span class="line">    public void withinAnnotatedClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(!synthetic * *(..)) &amp;&amp; withinAnnotatedClass()&quot;)</span><br><span class="line">    public void methodInsideAnnotatedType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(@demo.com.aj.anno.SchemeCheck * *(..)) || methodInsideAnnotatedType()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;method()&quot;)</span><br><span class="line">    public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        Signature signature &#x3D; joinPoint.getSignature();</span><br><span class="line">        String methodName &#x3D; signature.getName();</span><br><span class="line"></span><br><span class="line">        if (TextUtils.equals(methodName, &quot;onCreate&quot;)) &#123;</span><br><span class="line">            SchemeCheck anno &#x3D; (SchemeCheck) signature.getDeclaringType().getAnnotation(SchemeCheck.class);</span><br><span class="line">            if (anno !&#x3D; null) &#123;</span><br><span class="line">                Condition[] conditions &#x3D; anno.conditions();</span><br><span class="line">                Object point &#x3D; joinPoint.getThis();</span><br><span class="line">                if (point !&#x3D; null &amp;&amp; point instanceof Activity) &#123;</span><br><span class="line">                    Activity activity &#x3D; (Activity) point;</span><br><span class="line">                    handleScheme(activity, conditions);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 检查前置条件</span><br><span class="line">     *</span><br><span class="line">     * @return 是否通过检查</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean checkCondition(Condition[] conditions) &#123;</span><br><span class="line">        if (conditions !&#x3D; null) &#123;</span><br><span class="line">            for (Condition condition : conditions) &#123;</span><br><span class="line">                BaseCondition conditionObj &#x3D; condition.getCondition();</span><br><span class="line">                if (conditionObj !&#x3D; null</span><br><span class="line">                        &amp;&amp; !conditionObj.isSatisfied()) &#123;</span><br><span class="line">                    Toast.makeText(App.getContext(), conditionObj.unSatisfiedInfo(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                    SchemeManager.Cache.save(condition);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过验证</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void passSatisfy() &#123;</span><br><span class="line">        SchemeManager.Cache.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处理前置条件的检查结果</span><br><span class="line">     *</span><br><span class="line">     * @param isPass 检查是否通过</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void handleCheck(Activity activity, boolean isPass) &#123;</span><br><span class="line">        if (isPass) &#123;</span><br><span class="line">            passSatisfy();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *</span><br><span class="line">     * 处理scheme相关的事情</span><br><span class="line">     *</span><br><span class="line">     * @param activity</span><br><span class="line">     * @param conditions</span><br><span class="line">     * @return 是否通过验证</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean handleScheme(Activity activity, Condition[] conditions) &#123;</span><br><span class="line">        boolean passCheck &#x3D; true;</span><br><span class="line">        if (isStartByScheme(activity)) &#123;</span><br><span class="line">            passCheck &#x3D; checkCondition(conditions);</span><br><span class="line">            handleCheck(activity, passCheck);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            passCheck &#x3D; true;</span><br><span class="line">            passSatisfy();</span><br><span class="line">        &#125;</span><br><span class="line">        return passCheck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 检查是否是由scheme开启</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean isStartByScheme(Activity activity) &#123;</span><br><span class="line">        boolean isScheme &#x3D; false;</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            Intent intent &#x3D; activity.getIntent();</span><br><span class="line">            if (intent !&#x3D; null) &#123;</span><br><span class="line">                isScheme &#x3D; intent.getBooleanExtra(KEY_IS_SCHEME, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return isScheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在<code>onCreate()</code>方法开始之前，我们注入了scheme的判断逻辑，当条件满足时，直接执行了后面的逻辑；当条件不满足时，将不满足的条件进行缓存，并且<code>finish()</code>当前Activity。当正常执行了scheme跳转之后，清空缓存。</p>
<p>其中<code>SchemeManager</code>的逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SchemeManager &#123;</span><br><span class="line">    public static final String KEY_IS_SCHEME &#x3D; &quot;isScheme&quot;;</span><br><span class="line"></span><br><span class="line">    public static class Cache &#123;</span><br><span class="line">        public static String next &#x3D; &quot;&quot;;</span><br><span class="line">        public static Condition unSatisfiedCondition;</span><br><span class="line"></span><br><span class="line">        public static void save(Condition condition) &#123;</span><br><span class="line">            unSatisfiedCondition &#x3D; condition;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void clear()&#123;</span><br><span class="line">            next &#x3D; &quot;&quot;;</span><br><span class="line">            unSatisfiedCondition &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reExecuteScheme(Activity activity, Condition condition) &#123;</span><br><span class="line">        if (Cache.unSatisfiedCondition !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当缓存的条件与当前重复执行时触发的条件一致时，再次执行scheme</span><br><span class="line">            if (Cache.unSatisfiedCondition &#x3D;&#x3D; condition) &#123;</span><br><span class="line">                String scheme &#x3D; Cache.next;</span><br><span class="line">                executeScheme(activity, scheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void executeScheme(Activity activity, String schemeStr) &#123;</span><br><span class="line">        Cache.next &#x3D; schemeStr;</span><br><span class="line">        Class&lt;? extends Activity&gt; target &#x3D; null;</span><br><span class="line">        switch (schemeStr) &#123;</span><br><span class="line">            case &quot;startA&quot;:</span><br><span class="line">                target &#x3D; TargetActivityA.class;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;startB&quot;:</span><br><span class="line">                target &#x3D; TargetActivityB.class;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;startC&quot;:</span><br><span class="line">                target &#x3D; TargetActivityC.class;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;startD&quot;:</span><br><span class="line">                target &#x3D; TargetActivityD.class;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (target !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前页和目标页面是同一个页面  则清空缓存  防止递归调用产生死循环</span><br><span class="line">            if (target.equals(activity.getClass())) &#123;</span><br><span class="line">                Cache.clear();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Intent intent &#x3D; new Intent(activity, target);</span><br><span class="line">            intent.putExtra(KEY_IS_SCHEME, true);</span><br><span class="line">            activity.startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里包含有缓存管理的逻辑，以及<strong>执行scheme</strong>和<strong>重复执行scheme</strong>的逻辑。</p>
<p>其中，由于是Demo，执行scheme的逻辑用固定的字符串来代表scheme链接，这里需要你来替换为你自己的业务逻辑，因为你可能有解析scheme参数并且传递到目标Activity的逻辑。</p>
<p>scheme缓存保存了scheme链接和最后一次没有通过的条件枚举值，当下一次条件被触发时，通过<code>reExecuteScheme</code>来执行缓存中的scheme，达到继续跳转的效果。</p>
<p>例如，在登录成功的地方，可以执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reExecuteScheme(this, Condition.LOGIN);</span><br></pre></td></tr></table></figure>
<p>来达到登录成功时继续触发<strong>因未登录导致的scheme跳转失败的scheme跳转</strong>（好绕啊…）。</p>
<h2 id="愉快的调用"><a href="#愉快的调用" class="headerlink" title="愉快的调用"></a>愉快的调用</h2><p>接下来我们在需要加入scheme跳转判断的Activity的类上加入注解判断即可，例如我们在下面的Activity上加入<strong>登录</strong>以及<strong>词书下载</strong>的条件判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SchemeCheck(conditions &#x3D; &#123;Condition.LOGIN, Condition.DOWNLOAD_BOOK&#125;)</span><br><span class="line">public class TargetActivityC extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    public static void start(Activity activity) &#123;</span><br><span class="line">        activity.startActivity(new Intent(activity, TargetActivityC.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单呢？</p>
<h2 id="注意！这里有坑"><a href="#注意！这里有坑" class="headerlink" title="注意！这里有坑"></a>注意！这里有坑</h2><p>目前发现的一个坑就是我们的加入scheme跳转判断的子类Activity中必须有<code>onCreate</code>方法才可以正常执行，因为<code>AspectJ</code>只能判断当前子类中所触发的子类的方法。也就是说如果即使你对Activity的基类的<code>onCreate</code>进行了一层封装，完成了<code>onCreate</code>的所有工作，子类也需要复写一下<code>onCreate</code>。就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>否则会crash。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Django到Apach</title>
    <url>/2017/01/09/%E9%83%A8%E7%BD%B2Django%E5%88%B0Apach/</url>
    <content><![CDATA[<p>以ubuntu为例，部署Django到Apache上</p>
<h2 id="1-安装apache2"><a href="#1-安装apache2" class="headerlink" title="1.安装apache2"></a>1.安装apache2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>
<h2 id="2-安装mod-wsgi"><a href="#2-安装mod-wsgi" class="headerlink" title="2.安装mod_wsgi"></a>2.安装mod_wsgi</h2><p>Python2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-wsgi</span><br></pre></td></tr></table></figure>
<p>Python3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-wsgi-py3</span><br></pre></td></tr></table></figure>
<h2 id="3-准备一个新网站的配置文件"><a href="#3-准备一个新网站的配置文件" class="headerlink" title="3.准备一个新网站的配置文件"></a>3.准备一个新网站的配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;sitename.conf</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:8888&gt;</span><br><span class="line">    ServerName www.yourdomain.com</span><br><span class="line">    ServerAlias otherdomain.com</span><br><span class="line">    ServerAdmin tuweizhong@163.com</span><br><span class="line">  </span><br><span class="line">    Alias &#x2F;media&#x2F; &#x2F;home&#x2F;tu&#x2F;blog&#x2F;media&#x2F;</span><br><span class="line">    Alias &#x2F;static&#x2F; &#x2F;home&#x2F;tu&#x2F;blog&#x2F;static&#x2F;</span><br><span class="line">  </span><br><span class="line">    &lt;Directory &#x2F;home&#x2F;tu&#x2F;blog&#x2F;media&gt;</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;&#x2F;Directory&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;Directory &#x2F;home&#x2F;tu&#x2F;blog&#x2F;static&gt;</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;&#x2F;Directory&gt;</span><br><span class="line">  </span><br><span class="line">    WSGIScriptAlias &#x2F; &#x2F;home&#x2F;tu&#x2F;blog&#x2F;blog&#x2F;wsgi.py</span><br><span class="line">  </span><br><span class="line">    &lt;Directory &#x2F;home&#x2F;tu&#x2F;blog&#x2F;blog&gt;</span><br><span class="line">    &lt;Files wsgi.py&gt;</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;&#x2F;Files&gt;</span><br><span class="line">    &lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;&#x2F;VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-修改Django项目中wsgi-py文件"><a href="#4-修改Django项目中wsgi-py文件" class="headerlink" title="4.修改Django项目中wsgi.py文件"></a>4.修改Django项目中wsgi.py文件</h2><p>上面的配置中写的 WSGIScriptAlias / /home/tu/blog/blog/wsgi.py</p>
<p>就是把apache2和你的网站project联系起来了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">from os.path import join,dirname,abspath</span><br><span class="line"> </span><br><span class="line">PROJECT_DIR &#x3D; dirname(dirname(abspath(__file__)))#3</span><br><span class="line">import sys # 4</span><br><span class="line">sys.path.insert(0,PROJECT_DIR) # 5</span><br><span class="line"> </span><br><span class="line">os.environ[&quot;DJANGO_SETTINGS_MODULE&quot;] &#x3D; &quot;blog.settings&quot; # 7</span><br><span class="line"> </span><br><span class="line">from django.core.wsgi import get_wsgi_application</span><br><span class="line">application &#x3D; get_wsgi_application()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第 3，4，5 行为新加的内容，作用是让脚本找到django项目的位置，也可以在sitename.conf中做，用WSGIPythonPath,想了解的自行搜索, 第 7 行如果一台服务器有多个django project时一定要修改成上面那样，否则访问的时候会发生网站互相串的情况，即访问A网站到了B网站，一会儿正常，一会儿又不正常（当然也可以使用 mod_wsgi daemon 模式,点击这里查看）</p>
</blockquote>
<h2 id="5-监听端口"><a href="#5-监听端口" class="headerlink" title="5.监听端口"></a>5.监听端口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;apache2&#x2F;ports.conf</span><br></pre></td></tr></table></figure>
<p>将网站的端口加入监听列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Listen 80</span><br><span class="line">Listen 8888</span><br><span class="line"></span><br><span class="line">&lt;IfModule ssl_module&gt;</span><br><span class="line">	Listen 443</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_gnutls.c&gt;</span><br><span class="line">	Listen 443</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br><span class="line"></span><br><span class="line"># vim: syntax&#x3D;apache ts&#x3D;4 sw&#x3D;4 sts&#x3D;4 sr noet</span><br></pre></td></tr></table></figure>
<h2 id="6-设置目录和文件权限"><a href="#6-设置目录和文件权限" class="headerlink" title="6.设置目录和文件权限"></a>6.设置目录和文件权限</h2><p>一般目录权限设置为 755，文件权限设置为 644 </p>
<p>假如项目位置在 /home/tu/zqxt （在zqxt 下面有一个 manage.py，zqxt 是项目名称）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;tu&#x2F;</span><br><span class="line">sudo chmod -R 644 zqxt</span><br><span class="line">sudo find zqxt -type d -exec chmod 755 \&#123;\&#125; \;</span><br></pre></td></tr></table></figure>
<p><strong>apache 服务器运行用户可以在 /etc/apache2/envvars 文件里面改，这里使用的是默认值，当然也可以更改成自己的当前用户，这样的话权限问题就简单很多，但在服务器上推荐有 www-data 用户，更安全。以下是默认设置：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Since there is no sane way to get the parsed apache2 config in scripts, some</span><br><span class="line"># settings are defined via environment variables and then used in apache2ctl,</span><br><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;apache2, &#x2F;etc&#x2F;logrotate.d&#x2F;apache2, etc.</span><br><span class="line"> </span><br><span class="line">export APACHE_RUN_USER&#x3D;www-data</span><br><span class="line">export APACHE_RUN_GROUP&#x3D;www-data</span><br></pre></td></tr></table></figure>
<h3 id="上传文件夹权限"><a href="#上传文件夹权限" class="headerlink" title="上传文件夹权限"></a>上传文件夹权限</h3><p>media 文件夹一般用来存放用户上传文件，static 一般用来放自己网站的js，css，图片等，在settings.py中的相关设置</p>
<p>STATIC_URL 为静态文件的网址 STATIC_ROOT 为静态文件的根目录，</p>
<p>MEDIA_URL 为用户上传文件夹的根目录，MEDIA_URL为对应的访问网址</p>
<p>在settings.py中设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Static files (CSS, JavaScript, Images)</span><br><span class="line"># https:&#x2F;&#x2F;docs.djangoproject.com&#x2F;en&#x2F;dev&#x2F;howto&#x2F;static-files&#x2F;</span><br><span class="line">STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39;</span><br><span class="line">STATIC_ROOT &#x3D; os.path.join(BASE_DIR,&#39;static&#39;)</span><br><span class="line"> </span><br><span class="line"># upload folder</span><br><span class="line">MEDIA_URL &#x3D; &#39;&#x2F;media&#x2F;&#39;</span><br><span class="line">MEDIA_ROOT &#x3D; os.path.join(BASE_DIR,&#39;media&#39;)</span><br></pre></td></tr></table></figure>
<p>在 Linux 服务器上，用户上传目录还要设置给 www-data 用户的写权限，下面的方法比较好，不影响原来的用户的编辑。</p>
<p>假如上传目录为 zqxt/media/uploads 文件夹,进入media文件夹，将 uploads 用户组改为www-data，并且赋予该组写权限:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd media&#x2F; # 进入media文件夹</span><br><span class="line">sudo chgrp -R www-data uploads</span><br><span class="line">sudo chmod -R g+w uploads</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>备注</strong>：这两条命令，比直接用sudo chown -R www-data:www-data uploads 好，因为下面的命令不影响文件原来所属用户编辑文件，fedora系统应该不用设置上面的权限，但是个人强烈推荐用ubuntu,除非你对linux非常熟悉，你自己选择。</p>
</blockquote>
<p>如果你使用的是sqlite3数据库，还会提示 Attempt to write a readonly database,同样要给www-data写数据库的权限</p>
<p>进入项目目录的上一级，比如project目录为 /home/tu/blog 那就进入 /home/tu 执行下面的命令（和修改上传文件夹类似）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chgrp www-data blog</span><br><span class="line">sudo chmod g+w blog</span><br><span class="line">sudo chgrp www-data blog&#x2F;db.sqlite3  # 更改为你的数据库名称</span><br><span class="line">sudo chmod g+w blog&#x2F;db.sqlite3</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>备注</strong>：上面的不要加 -R ,-R是更改包括所有的子文件夹和文件，这样不安全。个人建议可以专门弄一个文件夹,用它来放sqlite3数据库，给该文件夹www-data写权限，而不是整个项目给写权限，有些文件只要读的权限就够了，给写权限会造成不安全。</p>
</blockquote>
<h2 id="7-激活新网站"><a href="#7-激活新网站" class="headerlink" title="7.激活新网站"></a>7.激活新网站</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo a2ensite sitename 或 sudo a2ensite sitename.conf</span><br></pre></td></tr></table></figure>
<h3 id="8-如果遇到了错误"><a href="#8-如果遇到了错误" class="headerlink" title="8.如果遇到了错误"></a>8.如果遇到了错误</h3><p>如果你重启apache时遇到了以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Job for apache2.service failed. See &quot;systemctl status apache2.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>
<p>尝试运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status apache2.service</span><br></pre></td></tr></table></figure>
<p>得到如下结果时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apache2.service - (null)</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;init.d&#x2F;apache2)</span><br><span class="line">   Active: failed (Result: exit-code) since Sat 2015-05-30 02:22:41 IST; 12s ago</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line">  Process: 4866 ExecStart&#x3D;&#x2F;etc&#x2F;init.d&#x2F;apache2 start (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)</span><br></pre></td></tr></table></figure>
<p>你可以考虑完全卸载apache，并清空配置，重新再来配置一次：</p>
<p>重装APACHE2：</p>
<p>替换已经删除的配置文件，而不重新安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get -o DPkg::Options::&#x3D;&quot;--force-confmiss&quot; --reinstall install apache2</span><br></pre></td></tr></table></figure>
<p>完全移除apache2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge apache2</span><br></pre></td></tr></table></figure>
<p>安装apache2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>
<p>参考文章：</p>
<ul>
<li><a href="http://www.ziqiangxuetang.com/django/django-deploy.html">Django 部署(Apache)</a></li>
<li><a href="http://askubuntu.com/questions/629995/apache-not-able-to-restart">Apache not able to restart</a></li>
</ul>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则之 里氏替换原则</title>
    <url>/2015/09/06/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则 英文名称<strong>Liskov Subtitution Principle, LSP</strong></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>传说中最正宗的定义：</p>
<blockquote>
<p>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</p>
<p>如果对每一个类型为S的对象o1,都有类型为T的对象o2,使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型.</p>
</blockquote>
<p>传说中第二种比较通俗的定义：</p>
<blockquote>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
<p>所有引用基类的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p>更通俗的一种定义：</p>
<blockquote>
<p>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是反过来就不行了，有子类出现的地方，父类未必就能适应。</p>
</blockquote>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="子类必须完全实现父类的方法"><a href="#子类必须完全实现父类的方法" class="headerlink" title="子类必须完全实现父类的方法"></a>子类必须完全实现父类的方法</h3><p>cs游戏中的枪支类图:<br><img src="/img/lishitihuan_1.png" alt="cs游戏枪支类图"></p>
<p>代码清单：</p>
<p>枪支的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line">	<span class="comment">//枪用来干什么的？杀敌！</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手枪、步枪、机枪的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handgun</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line">	<span class="comment">//手枪的特点是携带方便，射程短</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;手枪射击...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rifle</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line">	<span class="comment">//步枪的特点是射程远，威力大</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;步枪射击...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MachineGun</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机枪射击...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>士兵的实现类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义士兵的枪支</span></span><br><span class="line">	<span class="keyword">private</span> AbstractGun gun;</span><br><span class="line">	<span class="comment">//给士兵一支枪</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGun</span><span class="params">(AbstractGun _gun)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.gun = _gun;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killEnemy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;士兵开始杀敌人...&quot;</span>);</span><br><span class="line">		gun.shoot();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//产生三毛这个士兵</span></span><br><span class="line">		Soldier sanMao = <span class="keyword">new</span> Soldier();</span><br><span class="line">		<span class="comment">//给三毛一支枪</span></span><br><span class="line">		sanMao.setGun(<span class="keyword">new</span> Rifle());</span><br><span class="line">		sanMao.killEnemy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">士兵开始杀敌人...</span><br><span class="line">步枪射击...</span><br></pre></td></tr></table></figure>
<p>在这个程序中，我们给三毛这个士兵一把步枪，然后就开始杀敌了。如果要使用机枪，当然也可以，直接把sanMao.setGun(new Rifle())修改为sanMao.setGun(new MachineGun())即可,在编写程序时Solider士兵类根本不用知道是哪个型号的枪（子类）被传入。</p>
<blockquote>
<p><strong>注意</strong> 在类中调用其他类时，务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p>
</blockquote>
<p>如果我们要加入一把玩具枪，该如何处理呢？</p>
<p>第一种处理方式 ToyGun继承AbstractGun<br><img src="/img/lishitihuan_2.png" alt="继承方式拓展玩具枪"></p>
<p>但是玩具枪毕竟是玩具，不能当作真枪来杀敌人，所以这样拓展并不妥当，更好的处理方式应该是如下图：</p>
<p><img src="/img/lishitihuan_3.png" alt="委托的方式来拓展玩具枪"></p>
<p>ToyGun脱离继承，建立一个独立的父类，为了实现代码复用，可以与AbastractGun建立关联委托关系。例如，可以在AbstractToy中声明将声音、形状都委托给AbstractGun处理，仿真枪嘛，形状和声音都要和真实的枪一样了，然后两个基类下的子类自由延展，互不影响。</p>
<blockquote>
<p><strong>注意</strong> 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</p>
</blockquote>
<h3 id="子类可以有自己的个性"><a href="#子类可以有自己的个性" class="headerlink" title="子类可以有自己的个性"></a>子类可以有自己的个性</h3><p>子类当然可以有自己的方法和属性了，这里再次强调，是因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。</p>
<p>以刚才对枪支为例，步枪有几个比较“响亮”的型号，比如AK47、AUG狙击步枪等，把这两个型号的枪引入后的Rifle子类图如下：</p>
<p><img src="/img/lishitihuan_4.png" alt="步枪扩展"></p>
<p>代码清单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AUG</span> <span class="keyword">extends</span> <span class="title">Rifle</span></span>&#123;</span><br><span class="line">	<span class="comment">//狙击枪都携带一个精准的望远镜</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zoomOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;通过望远镜观察敌人...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;AUG射击...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>狙击手代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snipper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killEnemy</span><span class="params">(AUG aug)</span></span>&#123;</span><br><span class="line">		<span class="comment">//首先看看敌人的情况，别杀死敌人，自己也被人干掉</span></span><br><span class="line">		aug.zoomOut();</span><br><span class="line">		<span class="comment">//开始射击</span></span><br><span class="line">		aug.shoot();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//产生三毛这个狙击手</span></span><br><span class="line">		Snipper sanMao = <span class="keyword">new</span> Snipper();</span><br><span class="line">		sanMao.setRifle(<span class="keyword">new</span> AUG());</span><br><span class="line">		sanMao.killEnemy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过望远镜观察敌人...</span><br><span class="line">AUG射击...</span><br></pre></td></tr></table></figure>
<p>那么我们能不能传递Rifle父类给sanMao呢？如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//产生三毛这个狙击手</span></span><br><span class="line">		Snipper sanMao = <span class="keyword">new</span> Snipper();</span><br><span class="line">		sanMao.setRifle((AUG)(<span class="keyword">new</span> Rifle()));</span><br><span class="line">		sanMao.killEnemy();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示是不行的，会在运行期抛出java.lang.ClassCastException异常，这也是大家常说的向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现。</p>
<h3 id="覆盖或实现父类的方法时输入参数可以被放大"><a href="#覆盖或实现父类的方法时输入参数可以被放大" class="headerlink" title="覆盖或实现父类的方法时输入参数可以被放大"></a>覆盖或实现父类的方法时输入参数可以被放大</h3><blockquote>
<p>即子类方法的参数应该大于父类方法的参数，即子类方法的参数应该至少与父类相同或者或者是其父类</p>
</blockquote>
<h3 id="复写或实现父类的方法时输出结果可以被缩小"><a href="#复写或实现父类的方法时输出结果可以被缩小" class="headerlink" title="复写或实现父类的方法时输出结果可以被缩小"></a>复写或实现父类的方法时输出结果可以被缩小</h3><blockquote>
<p>即子类方法的返回值应该小于父类方法的返回值，即子类的返回值应该至多与父类的返回值相同或者是其子类</p>
</blockquote>
<p>以上两点 归根结底一句话：<strong>重载或实现 子类的方法输入范围&gt;=父类，返回范围&lt;=父类</strong>L</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则之 闭开原则</title>
    <url>/2015/10/04/%E9%97%AD%E5%BC%80%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>Software entities like classes,modules and functions should be open for extension but closed for modifications.(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。)</p>
</blockquote>
<p>开闭原则是java世界的最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。</p>
<h2 id="定义实质"><a href="#定义实质" class="headerlink" title="定义实质"></a>定义实质</h2><p>开闭原则定义已经非常明确的告诉我们，软件实体应该<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>软件实体通常包括以下几个部分：</p>
<p>1.项目或软件产品中按照一定的逻辑规则划分的模块。</p>
<p>2.抽象和类。</p>
<p>3.方法。</p>
<h2 id="如何使用开闭原则"><a href="#如何使用开闭原则" class="headerlink" title="如何使用开闭原则"></a>如何使用开闭原则</h2><p>开闭原则是一个非常虚的原则，前面五个原则是对开闭原则的具体解释，但是开闭原则并不局限于这么多，它“虚”得没有边界，就像“好好学习，天天向上”的口号一样，告诉我们要好好学习，但是学什么，怎么学并没有告诉我们，需要去体会和掌握。那么我们如何使用开闭原则呢？</p>
<h3 id="1-抽象约束"><a href="#1-抽象约束" class="headerlink" title="1.抽象约束"></a>1.抽象约束</h3><p>抽象是<strong>对一组事物的通用描述，没有具体的实现，</strong>也就表示它可以有非常多的可能性，可以跟随需求变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：</p>
<ul>
<li>1.通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法</li>
<li>2.参数类型、引用对象尽量使用接口或者抽象类，而不是实现类</li>
<li>3.抽象层尽量保持稳定，一旦确定即不允许修改。</li>
</ul>
<h3 id="2-元数据（metadata）控制模块行为"><a href="#2-元数据（metadata）控制模块行为" class="headerlink" title="2.元数据（metadata）控制模块行为"></a>2.元数据（metadata）控制模块行为</h3><p>什么是<strong>元数据</strong>？用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p>
<h3 id="3-封装变化"><a href="#3-封装变化" class="headerlink" title="3.封装变化"></a>3.封装变化</h3><p>对变化的封装包含两层含义：1.将相同的变化封装到一个接口或抽象类中；2.将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>隐马尔科夫模型</title>
    <url>/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h2><p>解决时序性的预测问题，我们通常会用到HMM模型（隐马尔科夫模型），但在开始介绍HMM模型之前，我们有必要先了解它的前置知识：</p>
<ul>
<li>马尔科夫链</li>
<li>马尔科夫模型</li>
</ul>
<h3 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h3><p>现有状态只和上一个状态有关，而未来状态只与现有状态有关:</p>
<p><img src="/img/18_11_11/001.png" width="400" hegiht="213" align=center /></p>
<p>满足这样的一种结构，我们就称之为<strong>马尔科夫链</strong>。</p>
<p>如果一个系统，在做不同状态之间转换的时候，当前状态只受到过的一个状态的影响，和其他状态都没有关系；换句话说，这个系统内的未来的一个状态只受到当前状态的影响，和其他状态都无关，满足这样性质的一个系统，我们就称之为是一个具有<strong>马尔科夫性</strong>的系统。</p>
<p>一个马尔科夫链，需要具备以下参数：</p>
<ul>
<li>初始分布</li>
<li>转移概率和转移概率矩阵</li>
</ul>
<h4 id="初始分布"><a href="#初始分布" class="headerlink" title="初始分布"></a>初始分布</h4><p>其中，初始分布如下：</p>
<script type="math/tex; mode=display">
\pi\_j(0) = P\\{ξ_0=j\\}</script><p>这个公式的含义是在一个系统内，各个状态初始时的概率分布情况。其中$\pi$是概率分布的意思。举例说明：</p>
<p>例如：假设一个系统内只有1、2、3这三种状态，其中状态1出现的概率为0.2，状态2出现的概率是0.3，状态3出现的概率是0.5。这三个概率即初始概率分布。</p>
<h4 id="转移概率和转移概率矩阵"><a href="#转移概率和转移概率矩阵" class="headerlink" title="转移概率和转移概率矩阵"></a>转移概率和转移概率矩阵</h4><p>继续上面的例子。当我们处于状态1时，下一个状态可能是状态2，可能是状态3，也可能是状态1。如果状态1变为状态2的概率是0.2，状态1变为状态3的概率是0.3，状态1变为状态1的概率是0.5：</p>
<p><img src="/img/18_11_11/002.png" width="400" hegiht="213" align=center /></p>
<p>这里的概率就是<strong>转移概率</strong>。</p>
<p>对于某一个状态来说，具有的转移概率一共有3个，那么对于3种状态来说一共有3x3=9个转移概率。我们可以用一个3x3的矩阵来表示。这个矩阵就被称为<strong>转移概率矩阵</strong>。</p>
<hr>
<p>一个具体的例子，<strong>愚蠢的顾客</strong>：</p>
<ul>
<li>某同类物品A、B、C的宣传力度不同，愚蠢的顾客在广告宣传的效应下，第一次尝试选择购买A、B、C的概率为0.2，0.4，0.4。经零售商统计，顾客的购买倾向为下表，尝试求某顾客第四次来购买各物品的概率：</li>
</ul>
<p><img src="/img/18_11_11/003.png" alt=""></p>
<p>在这个例子中，第一次购买A、B、C的概率0.2，0.4，0.4就是<strong>初始分布</strong>，上面的那个表就是<strong>状态转移矩阵</strong>。</p>
<h3 id="可观测的马尔科夫模型"><a href="#可观测的马尔科夫模型" class="headerlink" title="可观测的马尔科夫模型"></a>可观测的马尔科夫模型</h3><p>上面的描述都是关于<strong>马尔科夫链</strong>的，那么什么是<strong>马尔科夫模型</strong>呢？</p>
<ul>
<li><p>对于一个问题而言，我们有初始分布$\pi$，转移概率矩阵A，在给定的任意一个时刻t，我们都有一个状态$q_t$，随着时间的变化，一个状态转移到另一个状态，我们便能得到一个观测序列，<strong>即为状态序列</strong>$O=[q_1,q_2,q_3,q_4,…,q_m]$。而且整个问题中一共有n个观测状态。</p>
</li>
<li><p>出现这样的序列的概率为：</p>
</li>
</ul>
<script type="math/tex; mode=display">
P(O|A,\pi)=P(q_1)\prod\_{t=2}^mP(q_t|q_{t-1})</script><p>所以一个可观测的马尔科夫模型由一个三元组描述：$(A,\pi,n)$一般情况下简写为$(A,\pi)$。（因为观测状态的数量n可以从状态概率分布$\pi$得出）</p>
<p>这里的$A$就是转移概率矩阵，$\pi$就是状态初始分布，$n$就是观测状态的数量。</p>
<p>举个例子：</p>
<ul>
<li>有一个抽屉，抽屉里放有三种颜色的球，颜色分别为红蓝绿。某人随机的将球一个一个从抽屉中取出，球的颜色依次构成序列(C1,C2,C3,…)。如果红、蓝、绿三个状态的初始分布为$\pi=(0.5,0.2,0.3)$，转移概率矩阵:</li>
</ul>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
0.4 & 0.3 & 0.3 \\\\
0.2 & 0.6 & 0.2 \\\\
0.1 & 0.1 & 0.8
\end{pmatrix}</script><ul>
<li>那么出现颜色序列为：红，红，绿，绿 的概率是多少？</li>
</ul>
<p><strong>解答：</strong></p>
<p>初始概率分布$\pi=(0.5,0.2,0.3)$，可以看出，初始为红色的概率为0.5。</p>
<p>从状态转移矩阵可以看出，各个颜色变化的概率分布：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">红</th>
<th style="text-align:center">蓝</th>
<th style="text-align:center">绿</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>红</strong></td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.3</td>
<td style="text-align:center">0.3</td>
</tr>
<tr>
<td style="text-align:center"><strong>蓝</strong></td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">0.6</td>
<td style="text-align:center">0.2</td>
</tr>
<tr>
<td style="text-align:center"><strong>绿</strong></td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.8</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，红色转移到红色的概率为0.4，红色转移到绿色的概率是0.3，绿色转移到绿色的概率是0.8。所以最终出现序列红，红，绿，绿 的概率为：</p>
<script type="math/tex; mode=display">
P = 0.5 \times 0.4 \times 0.3 \times 0.8 = 0.048</script><p>所以上面的那个公式就是将所求的序列O之中的各个状态的转移概率连乘起来得到的最终概率：</p>
<script type="math/tex; mode=display">
P(O|A,\pi)=P(q_1)\prod\_{t=2}^mP(q_t|q_{t-1})</script><p><strong>问题来了</strong></p>
<p>那么我们能不能在只知道观测序列的情况下，得知初始分布和转移概率矩阵呢？</p>
<p><strong>解答：</strong></p>
<p>如果我们穷举了所有的观测序列，那么：</p>
<script type="math/tex; mode=display">
\pi_i=\frac{以状态i开始的序列的数目}{序列总数}</script><script type="math/tex; mode=display">
p_{ij}=\frac{从状态i转移到状态j的序列的数目}{从状态i开始的序列的总数}</script><p>具体实例，比如我们从抽屉中抽小球，四次的观测序列如下：</p>
<ul>
<li>[红，红，红]</li>
<li>[红，红，蓝]</li>
<li>[红，蓝，红]</li>
<li>[蓝，红，红]</li>
</ul>
<p>可以得出初始分布为：</p>
<script type="math/tex; mode=display">
\pi={0.75, 0.25}</script><p>转移概率为：</p>
<script type="math/tex; mode=display">
p\_{红蓝} = 1/3  \\\\
p\_{红红} = 2/3  \\\\
p\_{蓝蓝} = 0        \\\\
p\_{蓝红} = 1</script><h3 id="隐马尔科夫模型（Hidden-Markov-Model）"><a href="#隐马尔科夫模型（Hidden-Markov-Model）" class="headerlink" title="隐马尔科夫模型（Hidden Markov Model）"></a>隐马尔科夫模型（Hidden Markov Model）</h3><p>介绍完了上面的可观测的马尔科夫模型，接下来介绍<strong>隐马尔科夫模型</strong>。</p>
<p>隐马尔科夫模型的基本想法是：系统的状态S无法观测，但我们可以观测到某个其他和状态关联的事物，这个事物出现是伴随系统状态而出现的。</p>
<p>为什么会有无法观测的情况呢？举个例子：观测天空是否在下雨这个现象可以通过观测苔藓的生长情况来判断。比如下雨天，苔藓生长比较茂盛。所以我们可以通过观察苔藓来判断下雨的概率是否大。</p>
<p><img src="/img/18_11_11/004.png" alt=""></p>
<p>一个<strong>隐马尔科夫模型</strong>一般包含以下参数组成：</p>
<ul>
<li>观测集合：$R=\{R_1,R_2,R_3,R_4,…,R_m\}$<ul>
<li>代表我们能观测到的状态有哪些，比如抓小球的例子中就是红蓝绿三种颜色。</li>
</ul>
</li>
<li>观测序列：$O=[o_1,o_2,o_3,o_4,…,o_l]$<ul>
<li>代表我们能观测到的具体的观测序列</li>
</ul>
</li>
<li>状态集合：$S=\{S_1,S_2,S_3,S_4,…,S_n\}$<ul>
<li>代表状态的集合，比如上面的下雨天的例子中，状态就是晴天、雨天</li>
</ul>
</li>
<li>状态序列：$Q=[q_1,q_2,q_3,q_4,…,q_l]$<ul>
<li>就是出现某些状态的序列</li>
</ul>
</li>
<li>观测概率：$P\{o_i=R_k|q_t=S_j\}=b_j(i)$，记$B=[b_j(i)]$<ul>
<li>观测概率是隐马尔科夫模型特有的，在$t$时刻的时候，出现状态$q$，观测到状态$o_i$为指定状态$R_k$的概率。</li>
</ul>
</li>
</ul>
<p>所以，隐马尔可夫模型由一个五元组来描述$(A,B,\pi,R,S)$，一般情况下，可以简化为$(A,B,\pi)$。其中$A$是状态转移矩阵，$B$是观测概率，$\pi$是初始分布。</p>
<p><strong>注意</strong></p>
<ul>
<li>不同的状态序列可以产生相同的观测序列（以不同的概率产生）</li>
<li>状态转移是随机的，系统在一个状态中产生的观测也是随机的</li>
<li>可观测马尔科夫模型是隐马尔科夫模型的特例：当$m=n$，如果$i=j,b_j(i)=1$否则$b_j(i)=0$。<ul>
<li>即在马尔科夫模型下，状态序列和观测序列是一样的。</li>
</ul>
</li>
</ul>
<h4 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h4><p>隐马尔可夫模型一般可以用来解决三个基本问题：</p>
<ul>
<li>（1）<strong>估计</strong>：已知模型$(A,B,\pi)$，求观测序列出现的概率<ul>
<li>解决方法：前后向算法</li>
</ul>
</li>
<li>（2）<strong>预测</strong>：已知模型$(A,B,\pi)$和一个观测序列，求对应的不可观测的状态序列<ul>
<li>解决方法：Viterbi算法</li>
</ul>
</li>
<li>（3）<strong>学习</strong>：已知一组观测序列，求模型$(A,B,\pi)$<ul>
<li>解决方法：Baum-Welch算法</li>
</ul>
</li>
</ul>
<p>下面用一个具体的例子来了解一下这三个基本问题是如何处理的。</p>
<p><strong>股市预测</strong></p>
<ul>
<li>如果股市只有三种状态：牛市、熊市、普通</li>
<li>而且股票只有三种趋势：涨、跌、不变</li>
<li>如何利用隐马尔可夫模型进行股市预测？</li>
</ul>
<p><img src="/img/18_11_11/005.png" width="400" hegiht="213" align=center /></p>
<p>那么如果在股市预测问题中，应用隐马尔科夫模型，来解决上面的那三个对应的基本问题，分别如下：</p>
<ul>
<li>（1）已知模型，求观测到连续一周出现涨势的概率</li>
<li>（2）已知模型，观察到一周的变化情况为：涨、不变、涨、不变、跌，问股市的状态变化情况？</li>
<li>（3）观察到股市一周的变化情况为：涨、不变、涨、不变、跌，求下周一开盘时的涨跌情况？</li>
</ul>
<p>隐马尔科夫模型的代码如下<code>hmm.py</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import division</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class HMM:</span><br><span class="line">    &quot;&quot;&quot;Class to implement an HMM.</span><br><span class="line">    Defined by:</span><br><span class="line">        1. Hidden state transition probability matrix T</span><br><span class="line">        2. Observable emission probability matrix E</span><br><span class="line">        3. Prior probability matrix &#39;priors&#39;</span><br><span class="line">        4. Vocabulary of possible hidden states M (&#39;states&#39;)</span><br><span class="line">        5. Vocabulary of possible observable emissions V (&#39;emissions&#39;)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, states, emissions):</span><br><span class="line">        self._states &#x3D; states</span><br><span class="line">        self._emissions &#x3D; emissions</span><br><span class="line">        self._T &#x3D; dict()</span><br><span class="line">        self._E &#x3D; dict()</span><br><span class="line">        self._priors &#x3D; dict()</span><br><span class="line">        #print &quot;Don&#39;t forget to set: T, E, and priors...&quot;</span><br><span class="line"></span><br><span class="line">    def set_T(self, new_T):</span><br><span class="line">        tf &#x3D; True</span><br><span class="line">        for key in new_T:</span><br><span class="line">            if sorted(new_T[key].keys()) !&#x3D; sorted(self._states):</span><br><span class="line">                tf &#x3D; False</span><br><span class="line">        if sorted(new_T.keys()) !&#x3D; sorted(self._states):</span><br><span class="line">            tf &#x3D; False</span><br><span class="line"></span><br><span class="line">        if tf: self._T &#x3D; new_T</span><br><span class="line">        else:</span><br><span class="line">            print &quot;&quot;&quot;Unmatched key -- check dictionary!</span><br><span class="line">            T &#x3D;&gt; T[to state][given state]</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def set_E(self, new_E):</span><br><span class="line">        tf &#x3D; True</span><br><span class="line">        for key in new_E:</span><br><span class="line">            if sorted(new_E[key].keys()) !&#x3D; sorted(self._states):</span><br><span class="line">                tf &#x3D; False</span><br><span class="line">        if sorted(new_E.keys()) !&#x3D; sorted(self._emissions):</span><br><span class="line">            tf &#x3D; False</span><br><span class="line"></span><br><span class="line">        if tf: self._E &#x3D; new_E</span><br><span class="line">        else:</span><br><span class="line">            print &quot;&quot;&quot;Unmatched key -- check dictionary!</span><br><span class="line">            E &#x3D;&gt; E[emission][given state]</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def set_priors(self, new_priors):</span><br><span class="line">        if sorted(new_priors.keys()) &#x3D;&#x3D; sorted(self._states):</span><br><span class="line">            self._priors &#x3D; new_priors</span><br><span class="line">        else:</span><br><span class="line">            print &quot;&quot;&quot;Unmatched key -- check dictionary!</span><br><span class="line">            priors &#x3D;&gt; priors[state]</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># **************************************************</span><br><span class="line"># Functions that take an observation sequence and an HMM</span><br><span class="line"># **************************************************</span><br><span class="line"></span><br><span class="line">def forward(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return trellis representing p(theta_t | O_1^t).</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # initialize local variables</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    f &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            f[state].append(0)</span><br><span class="line"></span><br><span class="line">    # construct forward trellis</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        f[state][0] &#x3D; hmm._priors[state] * hmm._E[O[0]][state]</span><br><span class="line">    for t in range(1, n):</span><br><span class="line">        for j in hmm._states:</span><br><span class="line">            for i in hmm._states:</span><br><span class="line">                f[j][t] +&#x3D; f[i][t-1] * hmm._T[j][i] * hmm._E[O[t]][j]</span><br><span class="line">    return f</span><br><span class="line"></span><br><span class="line">def backward(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return trellis representing p(O_t+1^N | theta_t &#x3D;&#x3D; i).</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # initialize local variables</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    b &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            b[state].append(0)</span><br><span class="line"></span><br><span class="line">    # construct backward trellis</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        b[state][n-1] &#x3D; 1</span><br><span class="line">    for t in range(n-2, -1, -1):</span><br><span class="line">        for i in hmm._states:</span><br><span class="line">            for j in hmm._states:</span><br><span class="line">                b[i][t] +&#x3D; b[j][t+1] * hmm._T[j][i] * hmm._E[O[t+1]][j]</span><br><span class="line">    return b</span><br><span class="line"></span><br><span class="line">def posterior(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return trellis representing p(theta_t | O).</span><br><span class="line">    Posterior probabilities would be used to find the maximum likelihood</span><br><span class="line">        of a state at a given time step based on the observation sequence</span><br><span class="line">        O.  The value returned by the forward algorithm is the O_prob</span><br><span class="line">        value returned here.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # get n</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    # initialize forward, backward, and posterior trellises</span><br><span class="line">    f &#x3D; forward(O, hmm)</span><br><span class="line">    b &#x3D; backward(O, hmm)</span><br><span class="line">    p &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            p[state].append(0)</span><br><span class="line"></span><br><span class="line">    # total probability of sequence O</span><br><span class="line">    O_prob &#x3D; math.fsum([f[state][n-1] for state in hmm._states])</span><br><span class="line"></span><br><span class="line">    # build posterior trellis</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        for t in range(n):</span><br><span class="line">            p[state][t] &#x3D; (f[state][t] * b[state][t]) &#x2F; O_prob</span><br><span class="line"></span><br><span class="line">    return p</span><br><span class="line"></span><br><span class="line">def forward_algrithm(O, hmm):</span><br><span class="line">    f &#x3D; forward(O, hmm)</span><br><span class="line">    prop &#x3D; 0.0</span><br><span class="line">    for stat in hmm._T:</span><br><span class="line">        prop +&#x3D; f[stat][len(O)-1]</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">def viterbi_path(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return most likely hidden state path given observation sequence O.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    u &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    v &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    bt &#x3D; list()</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            for t in (u, v):</span><br><span class="line">                u[state].append(0)</span><br><span class="line">                v[state].append(str())</span><br><span class="line">        bt.append(str())</span><br><span class="line"></span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        u[state][0] &#x3D; hmm._priors[state] * hmm._E[O[0]][state]</span><br><span class="line">        # v[state][0] not of interest</span><br><span class="line">    for t in range(1, n):</span><br><span class="line">        for j in hmm._states:</span><br><span class="line">            for i in hmm._states:</span><br><span class="line">                p &#x3D; u[i][t-1] * hmm._T[j][i] * hmm._E[O[t]][j]</span><br><span class="line">                if p &gt; u[j][t]:</span><br><span class="line">                    u[j][t] &#x3D; p</span><br><span class="line">                    v[j][t] &#x3D; i</span><br><span class="line">    p &#x3D; 0</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        if u[state][n-1] &gt; p:</span><br><span class="line">            p &#x3D; u[state][n-1]</span><br><span class="line">            bt[n-1] &#x3D; state</span><br><span class="line">    for t in range(n-2, -1, -1):</span><br><span class="line">        bt[t] &#x3D; v[bt[t+1]][t+1]</span><br><span class="line"></span><br><span class="line">    return bt</span><br><span class="line"></span><br><span class="line">def baum_welch(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return new hmm from one iteration of re-estimation.&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    f &#x3D; forward(O, hmm)</span><br><span class="line">    b &#x3D; backward(O, hmm)</span><br><span class="line">    p &#x3D; posterior(O, hmm)</span><br><span class="line">    E_prime &#x3D; dict()</span><br><span class="line">    for emission in hmm._emissions: E_prime[emission] &#x3D; dict()</span><br><span class="line">    T_prime &#x3D; dict()</span><br><span class="line">    for state in hmm._states: T_prime[state] &#x3D; dict()</span><br><span class="line">    priors_prime &#x3D; dict()</span><br><span class="line"></span><br><span class="line">    # construct E_prime</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        den &#x3D; math.fsum([p[state][t] for t in range(n)])</span><br><span class="line">        for emission in hmm._emissions:</span><br><span class="line">            v &#x3D; 0</span><br><span class="line">            for t in range(n):</span><br><span class="line">                if O[t] &#x3D;&#x3D; emission: v +&#x3D; p[state][t]</span><br><span class="line">            E_prime[emission][state] &#x3D; v &#x2F; den</span><br><span class="line"></span><br><span class="line">    # construct T_prime</span><br><span class="line">    p_O &#x3D; math.fsum([f[s][n-1] for s in hmm._states])</span><br><span class="line">    for given in hmm._states:</span><br><span class="line">        den &#x3D; math.fsum([p[given][t] for t in range(n)])</span><br><span class="line">        for to in hmm._states:</span><br><span class="line">            v &#x3D; 0</span><br><span class="line">            for t in range(1, n):</span><br><span class="line">                v +&#x3D; ( f[given][t-1] *</span><br><span class="line">                       b[to][t] *</span><br><span class="line">                       hmm._T[to][given] *</span><br><span class="line">                       hmm._E[O[t]][to]</span><br><span class="line">                      ) &#x2F; p_O</span><br><span class="line">            T_prime[to][given] &#x3D; v &#x2F; den</span><br><span class="line"></span><br><span class="line">    # construct priors_prime</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        priors_prime[state] &#x3D; p[state][0]</span><br><span class="line"></span><br><span class="line">    new_hmm &#x3D; HMM(hmm._states, hmm._emissions)</span><br><span class="line">    new_hmm.set_E(E_prime)</span><br><span class="line">    new_hmm.set_T(T_prime)</span><br><span class="line">    new_hmm.set_priors(priors_prime)</span><br><span class="line"></span><br><span class="line">    return new_hmm</span><br></pre></td></tr></table></figure>
<p>下面我们来用这个模型解决这三个问题。</p>
<h5 id="估计问题：已知模型，求观测到连续一周出现涨势的概率"><a href="#估计问题：已知模型，求观测到连续一周出现涨势的概率" class="headerlink" title="估计问题：已知模型，求观测到连续一周出现涨势的概率"></a>估计问题：已知模型，求观测到连续一周出现涨势的概率</h5><p>已知模型如下图所示：</p>
<p><img src="/img/18_11_11/006.png" width="660" hegiht="413" align=center /></p>
<p>某股民根据经验判断当前为牛市、熊市、普通的概率分别是0.4、0.3、0.3。</p>
<p>这个问题中，我们的观测状态集合为：牛市、熊市、普通</p>
<p>我们的发射状态集合为：涨、跌、不变</p>
<p>初始分布$\pi$为：$(0.4, 0.3, 0.3)$</p>
<p>转移概率矩阵A：$<br>A=\begin{pmatrix}<br>0.6 &amp; 0.2 &amp; 0.2 \\<br>0.5 &amp; 0.3 &amp; 0.2 \\<br>0.4 &amp; 0.1 &amp; 0.5<br>\end{pmatrix}<br>$</p>
<p>观测概率矩阵B：$<br>A=\begin{pmatrix}<br>0.7 &amp; 0.1 &amp; 0.2 \\<br>0.1 &amp; 0.6 &amp; 0.3 \\<br>0.3 &amp; 0.3 &amp; 0.4<br>\end{pmatrix}<br>$</p>
<p>求连续一周出现涨势的概率，我们应该使用<strong>前后向算法</strong><code>forward_algrithm()</code>。改算法接收一个hmm模型。我们在初始化hmm模型的时候，需要设置观测状态<code>states</code>、发射状态<code>emissions</code>，转移概率矩阵<code>set_T()</code>，发射概率矩阵<code>set_E()</code>，以及初始分布<code>set_priors()</code>。</p>
<p>我们初始化好这些参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">def initTestModel():</span><br><span class="line">    model &#x3D; hmm.HMM([&#39;bull&#39;, &#39;bear&#39;, &#39;normal&#39;], [&#39;up&#39;, &#39;down&#39;, &#39;unchange&#39;])</span><br><span class="line">    transition_matrix &#x3D; &#123;</span><br><span class="line">        &#39;bull&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.6,</span><br><span class="line">            &#39;bear&#39;: 0.2,</span><br><span class="line">            &#39;normal&#39;: 0.2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;bear&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.5,</span><br><span class="line">            &#39;bear&#39;: 0.3,</span><br><span class="line">            &#39;normal&#39;: 0.2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;normal&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.4,</span><br><span class="line">            &#39;bear&#39;: 0.1,</span><br><span class="line">            &#39;normal&#39;: 0.5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emission_matrix &#x3D; &#123;</span><br><span class="line">        &#39;up&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.7,</span><br><span class="line">            &#39;bear&#39;: 0.1,</span><br><span class="line">            &#39;normal&#39;: 0.3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;down&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.1,</span><br><span class="line">            &#39;bear&#39;: 0.6,</span><br><span class="line">            &#39;normal&#39;: 0.3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;unchange&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.2,</span><br><span class="line">            &#39;bear&#39;: 0.3,</span><br><span class="line">            &#39;normal&#39;: 0.4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#x3D; &#123;&#39;bull&#39;:0.4, &#39;bear&#39;:0.3, &#39;normal&#39;:0.3&#125;</span><br><span class="line"> </span><br><span class="line">    model.set_T(transition_matrix)</span><br><span class="line">    model.set_E(emission_matrix)</span><br><span class="line">    model.set_priors(p)</span><br><span class="line"> </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<p>初始化模型完成之后，调用<code>forward_algrithm()</code>即可得出指定观测序列的预测结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def evaluate():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line">    prop &#x3D; model.forward_algrithm([&#39;up&#39;, &#39;up&#39;, &#39;up&#39;, &#39;up&#39;, &#39;up&#39;], model)</span><br><span class="line">    print prop</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.0232968298</span><br></pre></td></tr></table></figure>
<p>下面的代码可以查看所有组合可能出现的概率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def generate_weekly_list():</span><br><span class="line">    status &#x3D; [&#39;up&#39;,&#39;down&#39;,&#39;unchange&#39;]</span><br><span class="line"> </span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    weekly_list &#x3D; &#123;&#125;</span><br><span class="line">    for statu1 in status:</span><br><span class="line">        for statu2 in status:</span><br><span class="line">            for statu3 in status:</span><br><span class="line">                for statu4 in status:</span><br><span class="line">                    for statu5 in status:</span><br><span class="line">                        key &#x3D; statu1 + &#39;,&#39; + statu2 + &#39;,&#39; + statu3 + &#39;,&#39; + statu4 + &#39;,&#39; + statu5</span><br><span class="line">                        value &#x3D; [statu1, statu2, statu3, statu4, statu5]</span><br><span class="line">                        weekly_list[key] &#x3D; value</span><br><span class="line">    return weekly_list</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def evaluate():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line"> </span><br><span class="line">    all_list &#x3D; generate_weekly_list()</span><br><span class="line">    prop_list &#x3D; &#123;&#125;</span><br><span class="line">    for key in all_list:</span><br><span class="line">        prop &#x3D; hmm.forward_algrithm(all_list[key], model)</span><br><span class="line">        prop_list[key] &#x3D; prop</span><br><span class="line"> </span><br><span class="line">    sort_list &#x3D; sorted(prop_list.items(), lambda x, y: cmp(x[1], y[1]), reverse&#x3D;True)</span><br><span class="line"> </span><br><span class="line">    for (key, value) in sort_list:</span><br><span class="line">        print (&#39;%.6f:&#39; % value) + key</span><br></pre></td></tr></table></figure>
<h5 id="预测问题：已知模型-股市变化，求股市状态"><a href="#预测问题：已知模型-股市变化，求股市状态" class="headerlink" title="预测问题：已知模型+股市变化，求股市状态"></a>预测问题：已知模型+股市变化，求股市状态</h5><p>已知模型，观察到一周的变化情况为：涨、不变、涨、不变、跌，问股市的状态变化情况？</p>
<p>还是同样的模型：</p>
<p>观测状态集合为：牛市、熊市、普通</p>
<p>我们的发射状态集合为：涨、跌、不变</p>
<p>初始分布$\pi$为：$(0.4, 0.3, 0.3)$</p>
<p>转移概率矩阵A：$<br>A=\begin{pmatrix}<br>0.6 &amp; 0.2 &amp; 0.2 \\<br>0.5 &amp; 0.3 &amp; 0.2 \\<br>0.4 &amp; 0.1 &amp; 0.5<br>\end{pmatrix}<br>$</p>
<p>观测概率矩阵B：$<br>A=\begin{pmatrix}<br>0.7 &amp; 0.1 &amp; 0.2 \\<br>0.1 &amp; 0.6 &amp; 0.3 \\<br>0.3 &amp; 0.3 &amp; 0.4<br>\end{pmatrix}<br>$</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def predict():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line">    print hmm.viterbi_path([&#39;up&#39;, &#39;unchange&#39;, &#39;up&#39;, &#39;unchange&#39;, &#39;down&#39;], model)</span><br></pre></td></tr></table></figure>
<p>结果是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;bull&#39;, &#39;bull&#39;, &#39;bull&#39;, &#39;bull&#39;, &#39;bear&#39;]</span><br></pre></td></tr></table></figure>
<p>我们同样可以写出所有的组合的预测结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def predict():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line">    weekly_list &#x3D; generate_weekly_list()</span><br><span class="line">    for key in weekly_list:</span><br><span class="line">        print key + &#39;:&#39;</span><br><span class="line">        print hmm.viterbi_path(weekly_list[key], model)</span><br></pre></td></tr></table></figure>
<h5 id="学习问题：已知一堆观测序列，求模型"><a href="#学习问题：已知一堆观测序列，求模型" class="headerlink" title="学习问题：已知一堆观测序列，求模型"></a>学习问题：已知一堆观测序列，求模型</h5><p>某股民连续三周观测到股市的变动情况为：</p>
<ul>
<li>涨，不变，涨，跌，涨</li>
<li>跌，涨，跌，涨，不变</li>
<li>不变，不变，跌，涨，涨</li>
</ul>
<p>问，下周的变化情况？</p>
<p>这个问题的思路为：</p>
<p>根据观测序列 -&gt; 求出模型 -&gt; 得到$A,B,\pi$ -&gt; 预测当前状态 -&gt; 利用转移矩阵预测下一个状态。</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def learn():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line"> </span><br><span class="line">    o_list1 &#x3D; [&#39;up&#39;, &#39;unchange&#39;, &#39;up&#39;, &#39;down&#39;, &#39;up&#39;]</span><br><span class="line">    o_list2 &#x3D; [&#39;down&#39;, &#39;up&#39;, &#39;down&#39;, &#39;up&#39;, &#39;unchange&#39;]</span><br><span class="line">    o_list3 &#x3D; [&#39;unchange&#39;, &#39;unchange&#39;, &#39;down&#39;, &#39;up&#39;, &#39;up&#39;]</span><br><span class="line"> </span><br><span class="line">    model &#x3D; hmm.baum_welch(o_list1, model)</span><br><span class="line">    model &#x3D; hmm.baum_welch(o_list2, model)</span><br><span class="line">    model &#x3D; hmm.baum_welch(o_list3, model)</span><br><span class="line"> </span><br><span class="line">    print hmm.viterbi_path(o_list3, model)</span><br></pre></td></tr></table></figure>
<p>得出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;normal&#39;, &#39;bull&#39;, &#39;bear&#39;, &#39;bull&#39;, &#39;bull&#39;]</span><br></pre></td></tr></table></figure>
<p>你也可以将转移概率矩阵打印出来：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print model._T</span><br></pre></td></tr></table></figure></h2><p>以上就是HMM模型的全部内容。</p>
]]></content>
      <categories>
        <category>数学</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
