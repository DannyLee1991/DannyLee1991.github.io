<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>NumPy入门教程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="快速入门教程前提条件在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下这份教程。 如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅http:&#x2F;&#x2F;scipy.org&#x2F;install.html。 基础NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组">
<meta property="og:type" content="article">
<meta property="og:title" content="NumPy入门教程">
<meta property="og:url" content="http://example.com/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="快速入门教程前提条件在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下这份教程。 如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅http:&#x2F;&#x2F;scipy.org&#x2F;install.html。 基础NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/18_05_11/output_194_0.png">
<meta property="og:image" content="http://example.com/img/18_05_11/output_232_0.png">
<meta property="og:image" content="http://example.com/img/18_05_11/output_233_0.png">
<meta property="article:published_time" content="2018-05-11T11:43:55.000Z">
<meta property="article:modified_time" content="2021-02-08T08:48:41.853Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/18_05_11/output_194_0.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-NumPy入门教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-05-11T11:43:55.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      NumPy入门教程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下<a target="_blank" rel="noopener" href="http://docs.python.org/tut/">这份教程</a>。</p>
<p>如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅<a target="_blank" rel="noopener" href="http://scipy.org/install.html">http://scipy.org/install.html</a>。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组来索引。在NumPy中维度称之为**<em>axis（轴）**</em>。</p>
<p>例如，在3D空间中的一个坐标点<code>[1, 2, 1]</code>拥有一个axis。这个axis拥有3个元素，所以我们说它的长度是3。在下面的例子中，有2个axis。第一个axis的长度是2，第二个axis的长度是3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</span><br></pre></td></tr></table></figure>



<pre><code>[[1.0, 0.0, 0.0], [0.0, 1.0, 2.0]]
</code></pre>
<p>NumPy的数组class称之为<code>ndarray</code>。它还有另外一个别名：<code>array</code>。注意<code>numpy.array</code>与标准Python库中的<code>array.array</code>不一样，标准库中的<code>array</code>只可以操作以为数组，并且只能提供少量的方法。<code>ndarray</code>更重要的一些属性如下：</p>
<p><strong>ndarray.ndim</strong></p>
<pre><code>数组的axis(维度)数量
</code></pre>
<p><strong>ndarray.shape</strong></p>
<pre><code>数组的维度。这是一个整数类型的元组，指示了数组在每个维度下的尺寸信息。对于一个n行m列的矩阵来说，它的`shape`是`(n,m)`。因此`shape`元组的长度，也是axis的数量，即`ndim`。
</code></pre>
<p><strong>ndarray.size</strong></p>
<pre><code>数组的元素总数。值等于`shape`中的元素的乘积。
</code></pre>
<p><strong>ndarray.dtype</strong></p>
<pre><code>一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外，也可以使用NumPy自己提供的一些类型。例如`numpy.int32`,`numpy.int16`和`numpy.float64`。
</code></pre>
<p><strong>ndarray.itemsize</strong></p>
<pre><code>数组中每个元素占用的bytes大小。例如，一个数组的元素类型为`float64`，它的`itemsize`就是8(=64/8)，另一个数组的元素类型为`complex32`的`itemsize`值为4(=32/8)。这个值相当于`ndarray.dtype.itemsize`。
</code></pre>
<p><strong>ndarray.data</strong></p>
<pre><code>该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引来访问数组中的元素。
</code></pre>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>



<pre><code>(3, 5)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.ndim</span><br></pre></td></tr></table></figure>



<pre><code>2
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.dtype.name</span><br></pre></td></tr></table></figure>



<pre><code>&#39;int64&#39;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.itemsize</span><br></pre></td></tr></table></figure>



<pre><code>8
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.size</span><br></pre></td></tr></table></figure>



<pre><code>15
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(a)</span><br></pre></td></tr></table></figure>



<pre><code>numpy.ndarray
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([6, 7, 8])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(b)</span><br></pre></td></tr></table></figure>



<pre><code>numpy.ndarray
</code></pre>
<h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><p>有几种可以创建数组的方式。</p>
<p>例如，你可以通过使用<code>array</code>方法，从一个标准的Python列表或元组来创建一个numpy数组。数组的类型由序列中元素的类型自动推导得出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([2, 3, 4])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.dtype</span><br></pre></td></tr></table></figure>



<pre><code>dtype(&#39;int64&#39;)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</span><br><span class="line">b.dtype</span><br></pre></td></tr></table></figure>



<pre><code>dtype(&#39;float64&#39;)
</code></pre>
<p>在调用<code>array</code>方法来创建数组时，有一种常见的错误，就是在方法中传入了多个数字，而不是通过传入一个包含一组数字的list作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.array(1,2,3,4)   # WRONG</span><br><span class="line">a &#x3D; np.array([1,2,3,4]) # RIGHT</span><br></pre></td></tr></table></figure>
<p><code>array</code>函数将序列的序列转换为二维数组，将序列的序列的序列转换成3维数组，等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([(<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])
</code></pre>
<p>数组的类型也可以在创建的时候，显式的指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=<span class="built_in">complex</span>)</span><br><span class="line">c</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])
</code></pre>
<p>通常，数组的元素在初始状态下是未知的，但尺寸已知。因此，NumPy提供了一些方法来创建以初始化占位符填充的数组。这最大限度地减少了增加数组的开销，这是一项昂贵的操作。</p>
<p>方法<code>zeros</code>创建一个全部由0填充的数组，方法<code>ones</code>创建一个全部由1填充的数组，方法<code>empty</code>创建了一个全部由随机的数字填充的数组，随机数的值取决于内存当前的状态。默认情况下，创建出来的数组类型为<code>folat64</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dtype=np.int16) <span class="comment"># dtype可以被指定</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int16)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 未初始化，输出可能不同</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
</code></pre>
<p>为了创建数字序列，NumPy提供了一个类似于<code>range</code>的返回数组而不是列表的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<pre><code>array([10, 15, 20, 25])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span>) <span class="comment"># 可以接受float类型的参数</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
</code></pre>
<p>当<code>arange</code>与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数<code>linspace</code>来接收我们想要的元素数量作为参数，而不是步长：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)  <span class="comment"># 创建9个数字，均匀分布在0到2之间</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace( <span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</span><br><span class="line">f = np.sin(x)</span><br></pre></td></tr></table></figure>
<h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p>当你打印一个数组时，NumPy以一种类似嵌套列表的形式来展示，同时具有以下布局：</p>
<ul>
<li>最后一个axis从左向右打印</li>
<li>倒数第二个axis从上到下打印</li>
<li>其余的也是从上到下打印的，每个切片与下一个由空行分开。</li>
</ul>
<p>然后将一维数组打印为行，将二维数组作为矩阵，将三维数组作为矩阵列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># 一维数组</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)  <span class="comment"># 二维数组</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 三维数组</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
</code></pre>
<p>如果数组太大而无法打印，NumPy将自动跳过数组的中心部分并仅打印角点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[   0    1    2 ..., 9997 9998 9999]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[   0    1    2 ...,   97   98   99]
 [ 100  101  102 ...,  197  198  199]
 [ 200  201  202 ...,  297  298  299]
 ..., 
 [9700 9701 9702 ..., 9797 9798 9799]
 [9800 9801 9802 ..., 9897 9898 9899]
 [9900 9901 9902 ..., 9997 9998 9999]]
</code></pre>
<p>要禁用此行为并强制NumPy打印整个数组，可以使用<code>set_printoptions</code>更改打印选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=np.nan)</span><br></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>数组上的算术运算符应用于元素。一个新的数组被创建并填充结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([0, 1, 2, 3])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a-b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>



<pre><code>array([20, 29, 38, 47])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b**<span class="number">2</span></span><br></pre></td></tr></table></figure>



<pre><code>array([0, 1, 4, 9])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>*np.sin(a)</span><br></pre></td></tr></table></figure>



<pre><code>array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&lt;<span class="number">35</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ True,  True, False, False], dtype=bool)
</code></pre>
<p>不像其他的矩阵语言那样，<code>*</code>操作符在NumPy中是元素间的乘法。矩阵乘法可以使用<code>dot</code>方法来实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">A*B    <span class="comment"># 元素间的乘积</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[2, 0],
       [0, 4]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.dot(B)   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[5, 4],
       [3, 4]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dot(A, B) <span class="comment"># 矩阵乘法的另一种实现</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[5, 4],
       [3, 4]])
</code></pre>
<p>一些例如<code>+=</code>和<code>-=</code>的操作符，实现的方式是通过修改现有的矩阵而不是创建新的矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a *= <span class="number">3</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[3, 3, 3],
       [3, 3, 3]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b += a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 3.05432455,  3.59941571,  3.65058751],
       [ 3.85091779,  3.45890823,  3.55943444]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += b <span class="comment"># b 不会自动的转型成为 integer 类型</span></span><br></pre></td></tr></table></figure>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-87-3054fce39e6f&gt; in &lt;module&gt;()
----&gt; 1 a += b


TypeError: Cannot cast ufunc add output from dtype(&#39;float64&#39;) to dtype(&#39;int64&#39;) with casting rule &#39;same_kind&#39;
</code></pre>
<p>在使用不同类型的数组时，结果数组的类型对应于更一般或精确的数组（称为向上转型）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">3</span>, dtype=np.int32)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, pi, <span class="number">3</span>)</span><br><span class="line">b.dtype.name</span><br></pre></td></tr></table></figure>



<pre><code>&#39;float64&#39;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a+b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>



<pre><code>array([ 1.        ,  2.57079633,  4.14159265])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.dtype.name</span><br></pre></td></tr></table></figure>



<pre><code>&#39;float64&#39;
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = np.exp(c*<span class="number">1j</span>)</span><br><span class="line">d</span><br></pre></td></tr></table></figure>



<pre><code>array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.dtype.name</span><br></pre></td></tr></table></figure>



<pre><code>&#39;complex128&#39;
</code></pre>
<p>许多一元运算，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法来实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0.48681264,  0.52685408,  0.53980305],
       [ 0.27958753,  0.55125855,  0.70834892]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>



<pre><code>3.0926647737313067
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>



<pre><code>0.27958753466020847
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>



<pre><code>0.70834891569018965
</code></pre>
<p>默认情况下，这些操作适用于数组，就好像它是数字列表一样，无论其形状如何。但是，通过指定<code>axis</code>参数，可以沿着数组的指定轴(axis)应用操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="built_in">sum</span>(axis=<span class="number">0</span>)    <span class="comment"># 每一列的和</span></span><br></pre></td></tr></table></figure>



<pre><code>array([12, 15, 18, 21])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="built_in">min</span>(axis=<span class="number">1</span>)    <span class="comment"># 每一行的最小值</span></span><br></pre></td></tr></table></figure>



<pre><code>array([0, 4, 8])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.cumsum(axis=<span class="number">1</span>)   <span class="comment"># 每行的累加值</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]])
</code></pre>
<h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>NumPy提供了一些常见的数学运算方法，例如sin，cos和exp。在NumPy中，这些方法被称作”通用方法”(<code>ufunc</code>)。在NumPy中，这些方法操作在数组中的每个元素上，产生一个数组作为输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(<span class="number">3</span>)</span><br><span class="line">B</span><br></pre></td></tr></table></figure>



<pre><code>array([0, 1, 2])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.exp(B)</span><br></pre></td></tr></table></figure>



<pre><code>array([ 1.        ,  2.71828183,  7.3890561 ])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(B)</span><br></pre></td></tr></table></figure>



<pre><code>array([ 0.        ,  1.        ,  1.41421356])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = np.array([<span class="number">2.</span>, -<span class="number">1.</span>, <span class="number">4.</span>])</span><br><span class="line">np.add(B, C)</span><br></pre></td></tr></table></figure>



<pre><code>array([ 2.,  0.,  6.])
</code></pre>
<h4 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h4><p><strong>一维</strong>数组可以像Python中的list或其他序列一样进行索引、切片和迭代操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)**<span class="number">3</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<pre><code>8
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>



<pre><code>array([ 8, 27, 64])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:<span class="number">6</span>:<span class="number">2</span>] = -<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<pre><code>array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i**(<span class="number">1</span>/<span class="number">3.</span>))</span><br></pre></td></tr></table></figure>
<pre><code>nan
1.0
nan
3.0
nan
5.0
6.0
7.0
8.0
9.0


/usr/local/Homebrew/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power
  
</code></pre>
<p><strong>多维</strong>数组每个轴（axis）都有一个索引。这些索引以逗号分隔的元组给出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>*x + y</span><br><span class="line"></span><br><span class="line">b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<pre><code>23
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>] <span class="comment"># 输出第2列的每一行的元素</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 1, 11, 21, 31, 41])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[:, <span class="number">1</span>] <span class="comment"># 与上一步操作等价</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 1, 11, 21, 31, 41])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">1</span>:<span class="number">3</span>, :] <span class="comment"># 输出第2和第3行的每个列元素</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[10, 11, 12, 13],
       [20, 21, 22, 23]])
</code></pre>
<p>当提供的索引数量少于axis的数量时，缺失的索引被视为完整的切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[-<span class="number">1</span>] <span class="comment"># 输出最后一行。相当于 b[-1,:]</span></span><br></pre></td></tr></table></figure>



<pre><code>array([40, 41, 42, 43])
</code></pre>
<p>表达式<code>b[i]</code>的这种表示形式，意味着在<code>i</code>后面还有多个<code>:</code>，<code>:</code>的数量取决于剩余的axis数量。NumPy也允许你使用<code>...</code>来表示这一形式：<code>b[i,...]</code>。</p>
<p><strong>点</strong>(<code>...</code>)表示产生完整索引元组所需要的冒号。例如，如果<code>x</code>是一个5轴数组，那么：</p>
<ul>
<li><code>x[1,2,...]</code>等价于<code>x[1,2,:,:,:]</code>，</li>
<li><code>x[...,3]</code>等价于<code>x[:,:,:,:,3]</code>，</li>
<li><code>x[4,...,5,:]</code>等价于<code>x[4,:,:,5,:]</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个3D数组（由两个2D数组粘贴而成）</span></span><br><span class="line">c = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line">              [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line">              [<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]</span><br><span class="line">             ])</span><br><span class="line">c.shape</span><br></pre></td></tr></table></figure>



<pre><code>(2, 2, 3)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">1</span>,...]  <span class="comment"># 相当于 c[1,:,:] 或 c[1]</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[100, 101, 102],
       [110, 112, 113]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[...,<span class="number">2</span>]  <span class="comment"># 相当于 c[:,:,2]</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[  2,  13],
       [102, 113]])
</code></pre>
<p><strong>迭代</strong>多维数组是相对于第一个axis完成的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
</code></pre>
<p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组中所有元素的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line">    print(element)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
10
11
12
13
20
21
22
23
30
31
32
33
40
41
42
43
</code></pre>
<h3 id="Shape操作"><a href="#Shape操作" class="headerlink" title="Shape操作"></a>Shape操作</h3><h4 id="改变一个array的shape"><a href="#改变一个array的shape" class="headerlink" title="改变一个array的shape"></a>改变一个array的shape</h4><p>一个数组的形状由这个数组每个轴上的元素数量给出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>



<pre><code>(3, 4)
</code></pre>
<p>数组的形状可以通过各种命令进行更改。请注意，以下三个命令都返回一个修改后的数组，但都没有改变原数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.ravel()  <span class="comment"># 返回展开的数组</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 8.,  3.,  6.,  4.,  7.,  5.,  7.,  7.,  3.,  1.,  8.,  8.])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.reshape(<span class="number">6</span>,<span class="number">2</span>)  <span class="comment"># 返回一个改变了shape的数组</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 8.,  3.],
       [ 6.,  4.],
       [ 7.,  5.],
       [ 7.,  7.],
       [ 3.,  1.],
       [ 8.,  8.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.T  <span class="comment"># 返回数组的转置</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 8.,  7.,  3.],
       [ 3.,  5.,  1.],
       [ 6.,  7.,  8.],
       [ 4.,  7.,  8.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.T.shape</span><br></pre></td></tr></table></figure>



<pre><code>(4, 3)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>



<pre><code>(3, 4)
</code></pre>
<p>由ravel()产生的数组元素的顺序通常是”C-style”的，即最右边的索引“变化最快”，因此[0,0]之后的元素是[0,1]。如果一个数组变形为其他形状，数组再次被视为”C-style”。NumPy通常创建按次顺序存储的数组，因此<code>ravel()</code>通常不需要复制数组，但如果数组是通过对另一个数组进行切片操作，或者使用不寻常的方式创建的，则可能需要复制它。函数<code>ravel()</code>和<code>reshape()</code>也可以通过使用可选参数来使用FORTRAN-style的数组，其中最左侧的索引更改速度最快。</p>
<p><code>reshape</code>方法返回的结果是一个变形后的数组，而<code>ndarray.resize</code>方法会更改数组本身的形状：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.resize((<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 8.,  3.,  6.,  4.,  7.,  5.],
       [ 7.,  7.,  3.,  1.,  8.,  8.]])
</code></pre>
<p>如果在reshape操作中将尺寸参数传入-1，则会自动计算这一位置的尺寸：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre>
<h4 id="将不同的数组粘贴起来"><a href="#将不同的数组粘贴起来" class="headerlink" title="将不同的数组粘贴起来"></a>将不同的数组粘贴起来</h4><p>多个数组可以按照不同的axis来粘贴起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 9.,  9.],
       [ 8.,  6.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">b</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 5.,  3.],
       [ 0.,  4.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 9.,  9.],
       [ 8.,  6.],
       [ 5.,  3.],
       [ 0.,  4.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a,b))</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 9.,  9.,  5.,  3.],
       [ 8.,  6.,  0.,  4.]])
</code></pre>
<p>函数<code>column_stack</code>将1D数组作为列堆叠到2D数组中。它相当于仅用于2D数组的<code>hstack</code>操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> newaxis</span><br><span class="line">np.column_stack((a,b))   <span class="comment"># 仅作用于2D数组</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 9.,  9.,  5.,  3.],
       [ 8.,  6.,  0.,  4.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">4.</span>, <span class="number">2.</span>])</span><br><span class="line">b = np.array([<span class="number">3.</span>, <span class="number">8.</span>])</span><br><span class="line">np.column_stack((a,b))  <span class="comment"># 返回一个2D数组</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a,b))  <span class="comment"># 得到不同的结果</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 4.,  2.,  3.,  8.])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,newaxis]  <span class="comment"># 这将得到一个2D列向量</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4.],
       [ 2.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.column_stack((a[:,newaxis],b[:,newaxis]))</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a[:,newaxis],b[:,newaxis]))  <span class="comment"># 结果是一样的</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre>
<p>另一方面，函数<code>row_stack</code>相当于对任何数组进行<code>vstack</code>操作。一般情况下，对于具有两个以上维度的数组，<code>hstack</code>操作沿着它的第二个axis进行堆叠，<code>vstack</code>沿着它的第一个axis堆叠，<code>concatenate</code>沿着指定axis的方向进度堆叠。</p>
<p><strong>注意</strong></p>
<p>在复杂的情况下，<code>r_</code>和<code>c_</code>可用于通过沿着一个轴堆积数字来创建数组。他们允许使用表示范围的<code>:</code>操作符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<pre><code>array([1, 2, 3, 0, 4])
</code></pre>
<p>当使用数组作为参数时，<code>r_</code>和<code>c_</code>与默认行为的<code>vstack</code>和<code>hstack</code>类似，可以通过可选参数指定所要连接的轴的序号。</p>
<h4 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h4><p>使用<code>hsplit</code>，可以沿着水平轴来切割数组，或者通过指定返回的数组的形状来切割数组，或者通过指定需要分割的列来分割数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4.,  3.,  3.,  1.,  2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],
       [ 5.,  1.,  1.,  2.,  9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(a,<span class="number">3</span>)  <span class="comment"># 将a切分成3份</span></span><br></pre></td></tr></table></figure>



<pre><code>[array([[ 4.,  3.,  3.,  1.],
        [ 5.,  1.,  1.,  2.]]), array([[ 2.,  5.,  2.,  5.],
        [ 9.,  6.,  5.,  5.]]), array([[ 5.,  8.,  2.,  2.],
        [ 0.,  8.,  8.,  7.]])]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 沿着第3和第4列来切分数组</span></span><br></pre></td></tr></table></figure>



<pre><code>[array([[ 4.,  3.,  3.],
        [ 5.,  1.,  1.]]), array([[ 1.],
        [ 2.]]), array([[ 2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],
        [ 9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])]
</code></pre>
<p><code>vspilt</code>沿着垂直轴进行分割，<code>array_split</code>允许指定沿着那个轴来进行分割。</p>
<h3 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h3><p>当操作一个数组时，它们的数据有时会被复制到一个新的数组中，有时则不会。这通常会让新手感到困惑。下面是3个例子：</p>
<h4 id="完全没有复制"><a href="#完全没有复制" class="headerlink" title="完全没有复制"></a>完全没有复制</h4><p>简单的赋值不会复制数组对象或数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a    <span class="comment"># 没有新的对象被创建</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># a 和 b 是同一个ndarray对象的两个名字</span></span><br></pre></td></tr></table></figure>



<pre><code>True
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.shape = <span class="number">3</span>,<span class="number">4</span>  <span class="comment"># 改变a的shape</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>



<pre><code>(3, 4)
</code></pre>
<p>Python将可变对象作为引用传递，所以函数调用不会执行复制操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="built_in">id</span>(x))</span><br><span class="line">    </span><br><span class="line"><span class="built_in">id</span>(a)      <span class="comment"># id 是一个对象的唯一标识</span></span><br></pre></td></tr></table></figure>



<pre><code>4449897488
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<pre><code>4449897488
</code></pre>
<h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>不同的数组对象可以共享相同的数据。<code>view</code>函数创建一个新的数组对象，但它和原数组持有相同的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a.view()</span><br><span class="line">c <span class="keyword">is</span> a</span><br></pre></td></tr></table></figure>



<pre><code>False
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.base <span class="keyword">is</span> a  <span class="comment"># c 是 一个a数据所创建出来的视图</span></span><br></pre></td></tr></table></figure>



<pre><code>True
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.flags.owndata</span><br></pre></td></tr></table></figure>



<pre><code>False
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.shape = <span class="number">2</span>,<span class="number">6</span>  <span class="comment"># a的shape并不发生改变</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>



<pre><code>(3, 4)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>  <span class="comment"># a的数据发生改变</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])
</code></pre>
<p>对一个数组进行切片操作，返回它的一个视图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = a[ : , <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 也可以被写作 s = a[:,1:3]</span></span><br><span class="line">s[:] = <span class="number">10</span>  <span class="comment"># s[:] 是一个s的视图。注意这里 s = 10 和 s[:] = 10 的区别</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
</code></pre>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>copy</code>方法可以构造数组以及数据的完整副本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = a.copy()    <span class="comment"># 一个由新数据构成的新的数组对象被创建了</span></span><br><span class="line">d <span class="keyword">is</span> a</span><br></pre></td></tr></table></figure>



<pre><code>False
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.base <span class="keyword">is</span> a     <span class="comment"># d 与 a 不共享任何东西</span></span><br></pre></td></tr></table></figure>



<pre><code>False
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
</code></pre>
<h4 id="方法预览"><a href="#方法预览" class="headerlink" title="方法预览"></a>方法预览</h4><p>这里有一个NumPy中各种类型的比较有用的方法列表。</p>
<ul>
<li><p><strong>数组创建</strong></p>
<p><code>arange</code>,<code>array</code>,<code>copy</code>,<code>empty</code>,<code>empty_like</code>,<code>eye</code>,<code>fromfile</code>,<code>fromfunction</code>,<code>identity</code>,<code>linspace</code>,<code>logspace</code>,<code>mgrid</code>,<code>ogrid</code>,<code>ones</code>,<code>ones_like</code>,<code>zeros</code>,<code>zeros_like</code></p>
</li>
<li><p><strong>转换</strong></p>
<p>  <code>ndarray.astype</code>,<code>atleast_1d</code>,<code>atleast_2d</code>,<code>atleast_3d</code>,<code>mat</code></p>
</li>
<li><p><strong>手法</strong></p>
<p>  <code>array_split</code>, <code>column_stack</code>, <code>concatenate</code>, <code>diagonal</code>, <code>dsplit, dstack</code>, <code>hsplit</code>, <code>hstack</code>, <code>ndarray.item</code>, <code>newaxis</code>, <code>ravel</code>, <code>repeat</code>, <code>reshape</code>, <code>resize</code>, <code>squeeze</code>, <code>swapaxes</code>, <code>take</code>, <code>transpose</code>, <code>vsplit</code>, <code>vstack</code></p>
</li>
<li><p><strong>问题</strong></p>
<p>  <code>all</code>, <code>any</code>, <code>nonzero</code>, <code>where</code></p>
</li>
<li><p><strong>排序</strong></p>
<p>  <code>argmax</code>, <code>argmin</code>, <code>argsort</code>, <code>max</code>, <code>min</code>, <code>ptp</code>, <code>searchsorted</code>, <code>sort</code></p>
</li>
<li><p><strong>操作</strong></p>
<p>  <code>choose</code>, <code>compress</code>, <code>cumprod</code>, <code>cumsum</code>, <code>inner</code>, <code>ndarray.fill</code>, <code>imag</code>, <code>prod</code>, <code>put</code>, <code>putmask</code>, <code>real</code>, <code>sum</code></p>
</li>
<li><p><strong>基本统计</strong></p>
<p>  <code>cov</code>,<code>mean</code>,<code>std</code>,<code>var</code></p>
</li>
<li><p><strong>基本线性代数</strong></p>
<p>  <code>cross</code>,<code>dot</code>,<code>outer</code>,<code>linalg.svd</code>,<code>vdot</code></p>
</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>广播允许通用方法以有意义的方式处理形状不完全相同的输入。</p>
<p>广播第一法则是，如果所有的输入数组维度不都相同，一个“1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</p>
<p>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</p>
<p>应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">文档</a>找到。</p>
<h3 id="花哨的索引和索引技巧"><a href="#花哨的索引和索引技巧" class="headerlink" title="花哨的索引和索引技巧"></a>花哨的索引和索引技巧</h3><p>NumPy提供比常规Python序列更多的索引功能。正如我们前面看到的，除了通过整数和切片进行索引之外，还可以使用整数和布尔数组数组对索引进行索引。</p>
<h4 id="通过数组索引"><a href="#通过数组索引" class="headerlink" title="通过数组索引"></a>通过数组索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)**<span class="number">2</span>          <span class="comment"># 前12个方格</span></span><br><span class="line">i = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>])     <span class="comment"># 一个索引数组</span></span><br><span class="line">a[i]                          <span class="comment"># 一个在位置i的元素</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 1,  1,  9, 64, 25])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = np.array([[ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span>]])  <span class="comment"># 一个二维索引数组</span></span><br><span class="line">a[j]                              <span class="comment"># 与j的shape相同</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 9, 16],
       [81, 49]])
</code></pre>
<p>当被索引数组<code>a</code>是多维的时，每一个唯一的索引数列指向<code>a</code>的第一维。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">palette = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],           <span class="comment"># 黑</span></span><br><span class="line">                    [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],         <span class="comment"># 红</span></span><br><span class="line">                    [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],         <span class="comment"># 绿</span></span><br><span class="line">                    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],         <span class="comment"># 蓝</span></span><br><span class="line">                    [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]      <span class="comment"># 白</span></span><br><span class="line">                   ])</span><br><span class="line">image = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],           <span class="comment"># 每个值对应调色板中的颜色</span></span><br><span class="line">                  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>]</span><br><span class="line">                 ])</span><br><span class="line"></span><br><span class="line">palette[image]                         </span><br></pre></td></tr></table></figure>



<pre><code>array([[[  0,   0,   0],
        [255,   0,   0],
        [  0, 255,   0],
        [  0,   0,   0]],

       [[  0,   0,   0],
        [  0,   0, 255],
        [255, 255, 255],
        [  0,   0,   0]]])
</code></pre>
<p>我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = np.array([[<span class="number">0</span>,<span class="number">1</span>],    <span class="comment"># indices for the first dim of a</span></span><br><span class="line">             [<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">j = np.array([[<span class="number">2</span>,<span class="number">1</span>],    <span class="comment"># indices for the second dim</span></span><br><span class="line">             [<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">a[i,j]                  <span class="comment"># i 和 j必须拥有相同的shape</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 2,  6],
       [ 6, 10]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,j]</span><br></pre></td></tr></table></figure>



<pre><code>array([[[ 2,  1],
        [ 3,  3]],

       [[ 6,  5],
        [ 7,  7]],

       [[10,  9],
        [11, 11]]])
</code></pre>
<p>当然，我们可以将<code>i</code>和<code>j</code>放入一个序列中（比如说一个列表），然后用列表进行索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [i,j]</span><br><span class="line">a[l]        <span class="comment"># 相当于一个[i,j]</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre>
<p>但是，我们不能将<code>i</code>和<code>j</code>放进一个数组，因为这个数组将被解读为a的第一个维度的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = np.array([i,j])</span><br><span class="line">a[s]     <span class="comment"># 结果不是我们想要的</span></span><br></pre></td></tr></table></figure>

<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-204-79ccae1d198c&gt; in &lt;module&gt;()
      1 s = np.array([i,j])
----&gt; 2 a[s]     # 结果不是我们想要的


IndexError: index 3 is out of bounds for axis 0 with size 3
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="built_in">tuple</span>(s)]     <span class="comment"># 与 a[i,j]相同</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre>
<p>另一个常用的数组索引用法是搜索时间序列最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)    <span class="comment"># 时间尺度</span></span><br><span class="line">data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)  <span class="comment"># 4个时间依赖序列</span></span><br><span class="line">time</span><br></pre></td></tr></table></figure>



<pre><code>array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],
       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],
       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],
       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],
       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ind = data.argmax(axis=<span class="number">0</span>)    <span class="comment"># 每个序列的最大值的索引</span></span><br><span class="line">ind</span><br></pre></td></tr></table></figure>



<pre><code>array([2, 0, 3, 1])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_max = time[ind]         <span class="comment"># 时间序列对应的最大值</span></span><br><span class="line">data_max = data[ind, <span class="built_in">range</span>(data.shape[<span class="number">1</span>])]  <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></span><br><span class="line"></span><br><span class="line">time_max</span><br></pre></td></tr></table></figure>



<pre><code>array([  82.5 ,   20.  ,  113.75,   51.25])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_max</span><br></pre></td></tr></table></figure>



<pre><code>array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">all</span>(data_max == data.<span class="built_in">max</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>



<pre><code>True
</code></pre>
<p>你也可以使用数组索引作为目标来赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([0, 1, 2, 3, 4])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([0, 0, 2, 0, 0])
</code></pre>
<p>然而，当一个索引列表包含重复时，赋值被多次完成，保留最后一次的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([2, 1, 3, 3, 4])
</code></pre>
<p>这足够合理，但是小心如果你想用Python的<code>+=</code>结构，可能结果并非你所期望：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]] += <span class="number">1</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([1, 1, 3, 3, 4])
</code></pre>
<p>即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求<code>a+=1</code>和<code>a=a+1</code>等同。</p>
<h4 id="通过布尔数组索引"><a href="#通过布尔数组索引" class="headerlink" title="通过布尔数组索引"></a>通过布尔数组索引</h4><p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p>
<p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = a &gt; <span class="number">4</span></span><br><span class="line">b                   <span class="comment"># b 是一个和a形状相同的boolean数组</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[False, False, False, False],
       [False,  True,  True,  True],
       [ True,  True,  True,  True]], dtype=bool)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b]                <span class="comment"># 经过筛选后的1维数组</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 5,  6,  7,  8,  9, 10, 11])
</code></pre>
<p>这个属性在赋值时非常有用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[b] = <span class="number">0</span>            <span class="comment"># 将a中所有比4大的元素赋值为0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[0, 1, 2, 3],
       [4, 0, 0, 0],
       [0, 0, 0, 0]])
</code></pre>
<p>你可以参考曼德博集合示例看看如何使用布尔索引来生成<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Mandelbrot_set">曼德博集合</a>的图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span>(<span class="params">h,w,maxit=<span class="number">20</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个尺寸为（h,w）的曼德博分形图&quot;&quot;&quot;</span></span><br><span class="line">    y,x = np.ogrid[ -<span class="number">1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, -<span class="number">2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span>]</span><br><span class="line">    c = x+y * <span class="number">1j</span></span><br><span class="line">    z = c</span><br><span class="line">    divtime = maxit + np.zeros(z.shape,dtype=<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxit):</span><br><span class="line">        z = z**<span class="number">2</span> + c</span><br><span class="line">        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>    <span class="comment"># who is diverging</span></span><br><span class="line">        div_now = diverge &amp; (divtime == maxit)  <span class="comment"># who is diverging now</span></span><br><span class="line">        divtime[div_now] = i                    <span class="comment"># note when</span></span><br><span class="line">        z[diverge] = <span class="number">2</span>                          <span class="comment"># avoid diverging too much</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> divtime</span><br><span class="line"></span><br><span class="line">plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/img/18_05_11/output_194_0.png" alt="png"></p>
<p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b1 = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>])    <span class="comment"># 第一维的筛选</span></span><br><span class="line">b2 = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])  <span class="comment"># 第二维的筛选</span></span><br><span class="line"></span><br><span class="line">a[b1,:]       <span class="comment"># 选择行</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b1]         <span class="comment"># 和上面相同</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,b2]       <span class="comment"># 选择列</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b1,b2]      <span class="comment"># 一个奇怪的结果</span></span><br></pre></td></tr></table></figure>



<pre><code>array([ 4, 10])
</code></pre>
<p>注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，<code>b1</code>是一个秩为1长度为三的数组(<code>a</code>的行数)，<code>b2</code>(长度为4)与<code>a</code>的第二秩(列)相一致。</p>
<h4 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a>ix_()函数</h4><p><code>ix_</code>函数可以为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算a+b*c：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line">c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line">ax,bx,cx = np.ix_(a,b,c)</span><br><span class="line">ax</span><br></pre></td></tr></table></figure>



<pre><code>array([[[2]],

       [[3]],

       [[4]],

       [[5]]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bx</span><br></pre></td></tr></table></figure>



<pre><code>array([[[8],
        [5],
        [4]]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx</span><br></pre></td></tr></table></figure>



<pre><code>array([[[5, 4, 6, 8, 3]]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.shape, bx.shape, cx.shape</span><br></pre></td></tr></table></figure>



<pre><code>((4, 1, 1), (1, 3, 1), (1, 1, 5))
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = ax + bx * cx</span><br><span class="line">result</span><br></pre></td></tr></table></figure>



<pre><code>array([[[42, 34, 50, 66, 26],
        [27, 22, 32, 42, 17],
        [22, 18, 26, 34, 14]],

       [[43, 35, 51, 67, 27],
        [28, 23, 33, 43, 18],
        [23, 19, 27, 35, 15]],

       [[44, 36, 52, 68, 28],
        [29, 24, 34, 44, 19],
        [24, 20, 28, 36, 16]],

       [[45, 37, 53, 69, 29],
        [30, 25, 35, 45, 20],
        [25, 21, 29, 37, 17]]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<pre><code>17
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">3</span>] + b[<span class="number">2</span>] * c[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<pre><code>17
</code></pre>
<p>你也可以实行如下简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufunc_reduce</span>(<span class="params">ufct, *vectors</span>):</span></span><br><span class="line">    vs = np.ix_(*vectors)</span><br><span class="line">    r = ufct.identity</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> vs:</span><br><span class="line">        r = ufct(r,v)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>然后这样使用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufunc_reduce(np.add,a,b,c)</span><br></pre></td></tr></table></figure>



<pre><code>array([[[15, 14, 16, 18, 13],
        [12, 11, 13, 15, 10],
        [11, 10, 12, 14,  9]],

       [[16, 15, 17, 19, 14],
        [13, 12, 14, 16, 11],
        [12, 11, 13, 15, 10]],

       [[17, 16, 18, 20, 15],
        [14, 13, 15, 17, 12],
        [13, 12, 14, 16, 11]],

       [[18, 17, 19, 21, 16],
        [15, 14, 16, 18, 13],
        [14, 13, 15, 17, 12]]])
</code></pre>
<p>这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。</p>
<h4 id="用字符串索引"><a href="#用字符串索引" class="headerlink" title="用字符串索引"></a>用字符串索引</h4><p>参加<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/user/basics.rec.html#structured-arrays">结构化数组</a>。</p>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>继续前进，基本线性代数包含在这里。</p>
<h4 id="简单数组运算"><a href="#简单数组运算" class="headerlink" title="简单数组运算"></a>简单数组运算</h4><p>参考numpy文件夹中的linalg.py获得更多信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1.  2.]
 [ 3.  4.]]
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.transpose()</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 1.,  3.],
       [ 2.,  4.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.inv(a)</span><br></pre></td></tr></table></figure>



<pre><code>array([[-2. ,  1. ],
       [ 1.5, -0.5]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;  单位矩阵</span></span><br><span class="line">u</span><br></pre></td></tr></table></figure>



<pre><code>array([[ 1.,  0.],
       [ 0.,  1.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = np.array([[<span class="number">0.0</span>, -<span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">np.dot(j, j)   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>



<pre><code>array([[-1.,  0.],
       [ 0., -1.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.trace(u)    <span class="comment"># trace</span></span><br></pre></td></tr></table></figure>



<pre><code>2.0
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = np.array([[<span class="number">5.</span>],[<span class="number">7.</span>]])</span><br><span class="line">np.linalg.solve(a, y)</span><br></pre></td></tr></table></figure>



<pre><code>array([[-3.],
       [ 4.]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.eig(j)</span><br></pre></td></tr></table></figure>



<pre><code>(array([ 0.+1.j,  0.-1.j]),
 array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],
        [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Parameters:</span><br><span class="line">    square matrix</span><br><span class="line">Returns</span><br><span class="line">    The eigenvalues, each repeated according to its multiplicity.</span><br><span class="line">    The normalized (unit &quot;length&quot;) eigenvectors, such that the</span><br><span class="line">    column &#96;&#96;v[:,i]&#96;&#96; is the eigenvector corresponding to the</span><br><span class="line">    eigenvalue &#96;&#96;w[i]&#96;&#96; .</span><br></pre></td></tr></table></figure>
<h3 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="技巧和提示"></a>技巧和提示</h3><p>下面我们给出简短和有用的提示。</p>
<h4 id="“自动”改变形状"><a href="#“自动”改变形状" class="headerlink" title="“自动”改变形状"></a>“自动”改变形状</h4><p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">30</span>)</span><br><span class="line">a.shape = <span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>  <span class="comment"># -1 意味着 “无论需要什么”</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>



<pre><code>(2, 5, 3)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>



<pre><code>array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11],
        [12, 13, 14]],

       [[15, 16, 17],
        [18, 19, 20],
        [21, 22, 23],
        [24, 25, 26],
        [27, 28, 29]]])
</code></pre>
<h4 id="向量组合-stacking"><a href="#向量组合-stacking" class="headerlink" title="向量组合(stacking)"></a>向量组合(stacking)</h4><p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果<code>x</code>和<code>y</code>是两个相同长度的向量，你仅仅需要做<code>m=[x;y]</code>。在NumPy中这个过程通过函数<code>column_stack</code>、<code>dstack</code>、<code>hstack</code>和<code>vstack</code>来完成，取决于你想要在那个维度上组合。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)      <span class="comment"># x = ([0,2,4,6,8])</span></span><br><span class="line">y = np.arange(<span class="number">5</span>)           <span class="comment"># y = ([0,1,2,3,4])</span></span><br><span class="line">m = np.vstack([x,y])       <span class="comment"># m=([[0,2,4,6,8],</span></span><br><span class="line">                           <span class="comment">#     [0,1,2,3,4]])</span></span><br><span class="line">m</span><br></pre></td></tr></table></figure>



<pre><code>array([[0, 2, 4, 6, 8],
       [0, 1, 2, 3, 4]])
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xy = np.hstack([x,y])      <span class="comment"># xy = ([0,2,4,6,8,0,1,2,3,4])</span></span><br><span class="line">xy</span><br></pre></td></tr></table></figure>



<pre><code>array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])
</code></pre>
<h4 id="直方图-histogram"><a href="#直方图-histogram" class="headerlink" title="直方图(histogram)"></a>直方图(histogram)</h4><p>NumPy中<code>histogram</code>函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：<code>matplotlib</code>也有一个用来建立直方图的函数(叫作<code>hist</code>,正如matlab中一样)与NumPy中的不同。主要的差别是<code>pylab.hist</code>自动绘制直方图，而<code>numpy.histogram</code>仅仅产生数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 简历一个拥有10000个元素的正态分布的向量，方差为0.5^2，均值为2</span></span><br><span class="line">mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></span><br><span class="line">v = np.random.normal(mu,sigma,<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># 绘制分成50份的正态分布直方图</span></span><br><span class="line">plt.hist(v, bins=<span class="number">50</span>, normed=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/img/18_05_11/output_232_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用numpy计算直方图然后绘制它</span></span><br><span class="line">(n, bins) = np.histogram(v, bins=<span class="number">50</span>, normed=<span class="literal">True</span>)  <span class="comment"># NumPy version (no plot)</span></span><br><span class="line">plt.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:-<span class="number">1</span>]), n)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/img/18_05_11/output_233_0.png" alt="png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" data-id="ckkwc4355000wpas900f4a20g" data-title="NumPy入门教程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          【傅里叶变换及其应用】01-周期性，三角函数表示复杂函数
        
      </div>
    </a>
  
  
    <a href="/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Docker入门Part6-发布你的app</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/%E5%B7%A5%E5%85%B7/">工具</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/django/">django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/">工具学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/%E5%85%AC%E5%BC%80%E8%AF%BE/">公开课</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Tensorflow/">Tensorflow</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/cs231n/">cs231n</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI-QI/" rel="tag">AI-QI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/R/" rel="tag">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/" rel="tag">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/" rel="tag">gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kaggle/" rel="tag">kaggle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/" rel="tag">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" rel="tag">傅里叶变换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" rel="tag">工具学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%BC%80%E8%AF%BE/" rel="tag">斯坦福大学公开课</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%AF%E5%9D%A6%E7%A6%8F%E8%AF%BE%E7%A8%8B/" rel="tag">斯坦福课程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="tag">神经网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="tag">线性代数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/" rel="tag">论文翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI-QI/" style="font-size: 10px;">AI-QI</a> <a href="/tags/Android/" style="font-size: 18px;">Android</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/R/" style="font-size: 11px;">R</a> <a href="/tags/Tensorflow/" style="font-size: 17px;">Tensorflow</a> <a href="/tags/django/" style="font-size: 11px;">django</a> <a href="/tags/gradle/" style="font-size: 16px;">gradle</a> <a href="/tags/java/" style="font-size: 11px;">java</a> <a href="/tags/kaggle/" style="font-size: 10px;">kaggle</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/scala/" style="font-size: 10px;">scala</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 10px;">人工智能</a> <a href="/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/" style="font-size: 11px;">傅里叶变换</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">工具学习</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 12px;">数学</a> <a href="/tags/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E5%85%AC%E5%BC%80%E8%AF%BE/" style="font-size: 11px;">斯坦福大学公开课</a> <a href="/tags/%E6%96%AF%E5%9D%A6%E7%A6%8F%E8%AF%BE%E7%A8%8B/" style="font-size: 19px;">斯坦福课程</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">机器学习</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">神经网络</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 16px;">线性代数</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">论文翻译</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/">隐马尔科夫模型</a>
          </li>
        
          <li>
            <a href="/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/">【傅里叶变换及其应用讲义】第一章 傅里叶级数</a>
          </li>
        
          <li>
            <a href="/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/">【傅里叶变换及其应用】01-周期性，三角函数表示复杂函数</a>
          </li>
        
          <li>
            <a href="/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">NumPy入门教程</a>
          </li>
        
          <li>
            <a href="/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/">Docker入门Part6-发布你的app</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>