<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="愿你的努力终取得成果">
<meta property="og:type" content="website">
<meta property="og:title" content="圣巢">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="圣巢">
<meta property="og:description" content="愿你的努力终取得成果">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="DannyLee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>圣巢</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">圣巢</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/11/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">隐马尔科夫模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-11 19:20:58" itemprop="dateCreated datePublished" datetime="2018-11-11T19:20:58+00:00">2018-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:40" itemprop="dateModified" datetime="2021-02-10T16:11:40+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h2><p>解决时序性的预测问题，我们通常会用到HMM模型（隐马尔科夫模型），但在开始介绍HMM模型之前，我们有必要先了解它的前置知识：</p>
<ul>
<li>马尔科夫链</li>
<li>马尔科夫模型</li>
</ul>
<h3 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h3><p>现有状态只和上一个状态有关，而未来状态只与现有状态有关:</p>
<p><img src="/img/18_11_11/001.png" width="400" hegiht="213" align=center /></p>
<p>满足这样的一种结构，我们就称之为<strong>马尔科夫链</strong>。</p>
<p>如果一个系统，在做不同状态之间转换的时候，当前状态只受到过的一个状态的影响，和其他状态都没有关系；换句话说，这个系统内的未来的一个状态只受到当前状态的影响，和其他状态都无关，满足这样性质的一个系统，我们就称之为是一个具有<strong>马尔科夫性</strong>的系统。</p>
<p>一个马尔科夫链，需要具备以下参数：</p>
<ul>
<li>初始分布</li>
<li>转移概率和转移概率矩阵</li>
</ul>
<h4 id="初始分布"><a href="#初始分布" class="headerlink" title="初始分布"></a>初始分布</h4><p>其中，初始分布如下：</p>
<script type="math/tex; mode=display">
\pi\_j(0) = P\\{ξ_0=j\\}</script><p>这个公式的含义是在一个系统内，各个状态初始时的概率分布情况。其中$\pi$是概率分布的意思。举例说明：</p>
<p>例如：假设一个系统内只有1、2、3这三种状态，其中状态1出现的概率为0.2，状态2出现的概率是0.3，状态3出现的概率是0.5。这三个概率即初始概率分布。</p>
<h4 id="转移概率和转移概率矩阵"><a href="#转移概率和转移概率矩阵" class="headerlink" title="转移概率和转移概率矩阵"></a>转移概率和转移概率矩阵</h4><p>继续上面的例子。当我们处于状态1时，下一个状态可能是状态2，可能是状态3，也可能是状态1。如果状态1变为状态2的概率是0.2，状态1变为状态3的概率是0.3，状态1变为状态1的概率是0.5：</p>
<p><img src="/img/18_11_11/002.png" width="400" hegiht="213" align=center /></p>
<p>这里的概率就是<strong>转移概率</strong>。</p>
<p>对于某一个状态来说，具有的转移概率一共有3个，那么对于3种状态来说一共有3x3=9个转移概率。我们可以用一个3x3的矩阵来表示。这个矩阵就被称为<strong>转移概率矩阵</strong>。</p>
<hr>
<p>一个具体的例子，<strong>愚蠢的顾客</strong>：</p>
<ul>
<li>某同类物品A、B、C的宣传力度不同，愚蠢的顾客在广告宣传的效应下，第一次尝试选择购买A、B、C的概率为0.2，0.4，0.4。经零售商统计，顾客的购买倾向为下表，尝试求某顾客第四次来购买各物品的概率：</li>
</ul>
<p><img src="/img/18_11_11/003.png" alt=""></p>
<p>在这个例子中，第一次购买A、B、C的概率0.2，0.4，0.4就是<strong>初始分布</strong>，上面的那个表就是<strong>状态转移矩阵</strong>。</p>
<h3 id="可观测的马尔科夫模型"><a href="#可观测的马尔科夫模型" class="headerlink" title="可观测的马尔科夫模型"></a>可观测的马尔科夫模型</h3><p>上面的描述都是关于<strong>马尔科夫链</strong>的，那么什么是<strong>马尔科夫模型</strong>呢？</p>
<ul>
<li><p>对于一个问题而言，我们有初始分布$\pi$，转移概率矩阵A，在给定的任意一个时刻t，我们都有一个状态$q_t$，随着时间的变化，一个状态转移到另一个状态，我们便能得到一个观测序列，<strong>即为状态序列</strong>$O=[q_1,q_2,q_3,q_4,…,q_m]$。而且整个问题中一共有n个观测状态。</p>
</li>
<li><p>出现这样的序列的概率为：</p>
</li>
</ul>
<script type="math/tex; mode=display">
P(O|A,\pi)=P(q_1)\prod\_{t=2}^mP(q_t|q_{t-1})</script><p>所以一个可观测的马尔科夫模型由一个三元组描述：$(A,\pi,n)$一般情况下简写为$(A,\pi)$。（因为观测状态的数量n可以从状态概率分布$\pi$得出）</p>
<p>这里的$A$就是转移概率矩阵，$\pi$就是状态初始分布，$n$就是观测状态的数量。</p>
<p>举个例子：</p>
<ul>
<li>有一个抽屉，抽屉里放有三种颜色的球，颜色分别为红蓝绿。某人随机的将球一个一个从抽屉中取出，球的颜色依次构成序列(C1,C2,C3,…)。如果红、蓝、绿三个状态的初始分布为$\pi=(0.5,0.2,0.3)$，转移概率矩阵:</li>
</ul>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
0.4 & 0.3 & 0.3 \\\\
0.2 & 0.6 & 0.2 \\\\
0.1 & 0.1 & 0.8
\end{pmatrix}</script><ul>
<li>那么出现颜色序列为：红，红，绿，绿 的概率是多少？</li>
</ul>
<p><strong>解答：</strong></p>
<p>初始概率分布$\pi=(0.5,0.2,0.3)$，可以看出，初始为红色的概率为0.5。</p>
<p>从状态转移矩阵可以看出，各个颜色变化的概率分布：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">红</th>
<th style="text-align:center">蓝</th>
<th style="text-align:center">绿</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>红</strong></td>
<td style="text-align:center">0.4</td>
<td style="text-align:center">0.3</td>
<td style="text-align:center">0.3</td>
</tr>
<tr>
<td style="text-align:center"><strong>蓝</strong></td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">0.6</td>
<td style="text-align:center">0.2</td>
</tr>
<tr>
<td style="text-align:center"><strong>绿</strong></td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">0.8</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，红色转移到红色的概率为0.4，红色转移到绿色的概率是0.3，绿色转移到绿色的概率是0.8。所以最终出现序列红，红，绿，绿 的概率为：</p>
<script type="math/tex; mode=display">
P = 0.5 \times 0.4 \times 0.3 \times 0.8 = 0.048</script><p>所以上面的那个公式就是将所求的序列O之中的各个状态的转移概率连乘起来得到的最终概率：</p>
<script type="math/tex; mode=display">
P(O|A,\pi)=P(q_1)\prod\_{t=2}^mP(q_t|q_{t-1})</script><p><strong>问题来了</strong></p>
<p>那么我们能不能在只知道观测序列的情况下，得知初始分布和转移概率矩阵呢？</p>
<p><strong>解答：</strong></p>
<p>如果我们穷举了所有的观测序列，那么：</p>
<script type="math/tex; mode=display">
\pi_i=\frac{以状态i开始的序列的数目}{序列总数}</script><script type="math/tex; mode=display">
p_{ij}=\frac{从状态i转移到状态j的序列的数目}{从状态i开始的序列的总数}</script><p>具体实例，比如我们从抽屉中抽小球，四次的观测序列如下：</p>
<ul>
<li>[红，红，红]</li>
<li>[红，红，蓝]</li>
<li>[红，蓝，红]</li>
<li>[蓝，红，红]</li>
</ul>
<p>可以得出初始分布为：</p>
<script type="math/tex; mode=display">
\pi={0.75, 0.25}</script><p>转移概率为：</p>
<script type="math/tex; mode=display">
p\_{红蓝} = 1/3  \\\\
p\_{红红} = 2/3  \\\\
p\_{蓝蓝} = 0        \\\\
p\_{蓝红} = 1</script><h3 id="隐马尔科夫模型（Hidden-Markov-Model）"><a href="#隐马尔科夫模型（Hidden-Markov-Model）" class="headerlink" title="隐马尔科夫模型（Hidden Markov Model）"></a>隐马尔科夫模型（Hidden Markov Model）</h3><p>介绍完了上面的可观测的马尔科夫模型，接下来介绍<strong>隐马尔科夫模型</strong>。</p>
<p>隐马尔科夫模型的基本想法是：系统的状态S无法观测，但我们可以观测到某个其他和状态关联的事物，这个事物出现是伴随系统状态而出现的。</p>
<p>为什么会有无法观测的情况呢？举个例子：观测天空是否在下雨这个现象可以通过观测苔藓的生长情况来判断。比如下雨天，苔藓生长比较茂盛。所以我们可以通过观察苔藓来判断下雨的概率是否大。</p>
<p><img src="/img/18_11_11/004.png" alt=""></p>
<p>一个<strong>隐马尔科夫模型</strong>一般包含以下参数组成：</p>
<ul>
<li>观测集合：$R=\{R_1,R_2,R_3,R_4,…,R_m\}$<ul>
<li>代表我们能观测到的状态有哪些，比如抓小球的例子中就是红蓝绿三种颜色。</li>
</ul>
</li>
<li>观测序列：$O=[o_1,o_2,o_3,o_4,…,o_l]$<ul>
<li>代表我们能观测到的具体的观测序列</li>
</ul>
</li>
<li>状态集合：$S=\{S_1,S_2,S_3,S_4,…,S_n\}$<ul>
<li>代表状态的集合，比如上面的下雨天的例子中，状态就是晴天、雨天</li>
</ul>
</li>
<li>状态序列：$Q=[q_1,q_2,q_3,q_4,…,q_l]$<ul>
<li>就是出现某些状态的序列</li>
</ul>
</li>
<li>观测概率：$P\{o_i=R_k|q_t=S_j\}=b_j(i)$，记$B=[b_j(i)]$<ul>
<li>观测概率是隐马尔科夫模型特有的，在$t$时刻的时候，出现状态$q$，观测到状态$o_i$为指定状态$R_k$的概率。</li>
</ul>
</li>
</ul>
<p>所以，隐马尔可夫模型由一个五元组来描述$(A,B,\pi,R,S)$，一般情况下，可以简化为$(A,B,\pi)$。其中$A$是状态转移矩阵，$B$是观测概率，$\pi$是初始分布。</p>
<p><strong>注意</strong></p>
<ul>
<li>不同的状态序列可以产生相同的观测序列（以不同的概率产生）</li>
<li>状态转移是随机的，系统在一个状态中产生的观测也是随机的</li>
<li>可观测马尔科夫模型是隐马尔科夫模型的特例：当$m=n$，如果$i=j,b_j(i)=1$否则$b_j(i)=0$。<ul>
<li>即在马尔科夫模型下，状态序列和观测序列是一样的。</li>
</ul>
</li>
</ul>
<h4 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h4><p>隐马尔可夫模型一般可以用来解决三个基本问题：</p>
<ul>
<li>（1）<strong>估计</strong>：已知模型$(A,B,\pi)$，求观测序列出现的概率<ul>
<li>解决方法：前后向算法</li>
</ul>
</li>
<li>（2）<strong>预测</strong>：已知模型$(A,B,\pi)$和一个观测序列，求对应的不可观测的状态序列<ul>
<li>解决方法：Viterbi算法</li>
</ul>
</li>
<li>（3）<strong>学习</strong>：已知一组观测序列，求模型$(A,B,\pi)$<ul>
<li>解决方法：Baum-Welch算法</li>
</ul>
</li>
</ul>
<p>下面用一个具体的例子来了解一下这三个基本问题是如何处理的。</p>
<p><strong>股市预测</strong></p>
<ul>
<li>如果股市只有三种状态：牛市、熊市、普通</li>
<li>而且股票只有三种趋势：涨、跌、不变</li>
<li>如何利用隐马尔可夫模型进行股市预测？</li>
</ul>
<p><img src="/img/18_11_11/005.png" width="400" hegiht="213" align=center /></p>
<p>那么如果在股市预测问题中，应用隐马尔科夫模型，来解决上面的那三个对应的基本问题，分别如下：</p>
<ul>
<li>（1）已知模型，求观测到连续一周出现涨势的概率</li>
<li>（2）已知模型，观察到一周的变化情况为：涨、不变、涨、不变、跌，问股市的状态变化情况？</li>
<li>（3）观察到股市一周的变化情况为：涨、不变、涨、不变、跌，求下周一开盘时的涨跌情况？</li>
</ul>
<p>隐马尔科夫模型的代码如下<code>hmm.py</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import division</span><br><span class="line">import math</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class HMM:</span><br><span class="line">    &quot;&quot;&quot;Class to implement an HMM.</span><br><span class="line">    Defined by:</span><br><span class="line">        1. Hidden state transition probability matrix T</span><br><span class="line">        2. Observable emission probability matrix E</span><br><span class="line">        3. Prior probability matrix &#39;priors&#39;</span><br><span class="line">        4. Vocabulary of possible hidden states M (&#39;states&#39;)</span><br><span class="line">        5. Vocabulary of possible observable emissions V (&#39;emissions&#39;)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, states, emissions):</span><br><span class="line">        self._states &#x3D; states</span><br><span class="line">        self._emissions &#x3D; emissions</span><br><span class="line">        self._T &#x3D; dict()</span><br><span class="line">        self._E &#x3D; dict()</span><br><span class="line">        self._priors &#x3D; dict()</span><br><span class="line">        #print &quot;Don&#39;t forget to set: T, E, and priors...&quot;</span><br><span class="line"></span><br><span class="line">    def set_T(self, new_T):</span><br><span class="line">        tf &#x3D; True</span><br><span class="line">        for key in new_T:</span><br><span class="line">            if sorted(new_T[key].keys()) !&#x3D; sorted(self._states):</span><br><span class="line">                tf &#x3D; False</span><br><span class="line">        if sorted(new_T.keys()) !&#x3D; sorted(self._states):</span><br><span class="line">            tf &#x3D; False</span><br><span class="line"></span><br><span class="line">        if tf: self._T &#x3D; new_T</span><br><span class="line">        else:</span><br><span class="line">            print &quot;&quot;&quot;Unmatched key -- check dictionary!</span><br><span class="line">            T &#x3D;&gt; T[to state][given state]</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def set_E(self, new_E):</span><br><span class="line">        tf &#x3D; True</span><br><span class="line">        for key in new_E:</span><br><span class="line">            if sorted(new_E[key].keys()) !&#x3D; sorted(self._states):</span><br><span class="line">                tf &#x3D; False</span><br><span class="line">        if sorted(new_E.keys()) !&#x3D; sorted(self._emissions):</span><br><span class="line">            tf &#x3D; False</span><br><span class="line"></span><br><span class="line">        if tf: self._E &#x3D; new_E</span><br><span class="line">        else:</span><br><span class="line">            print &quot;&quot;&quot;Unmatched key -- check dictionary!</span><br><span class="line">            E &#x3D;&gt; E[emission][given state]</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def set_priors(self, new_priors):</span><br><span class="line">        if sorted(new_priors.keys()) &#x3D;&#x3D; sorted(self._states):</span><br><span class="line">            self._priors &#x3D; new_priors</span><br><span class="line">        else:</span><br><span class="line">            print &quot;&quot;&quot;Unmatched key -- check dictionary!</span><br><span class="line">            priors &#x3D;&gt; priors[state]</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># **************************************************</span><br><span class="line"># Functions that take an observation sequence and an HMM</span><br><span class="line"># **************************************************</span><br><span class="line"></span><br><span class="line">def forward(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return trellis representing p(theta_t | O_1^t).</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # initialize local variables</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    f &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            f[state].append(0)</span><br><span class="line"></span><br><span class="line">    # construct forward trellis</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        f[state][0] &#x3D; hmm._priors[state] * hmm._E[O[0]][state]</span><br><span class="line">    for t in range(1, n):</span><br><span class="line">        for j in hmm._states:</span><br><span class="line">            for i in hmm._states:</span><br><span class="line">                f[j][t] +&#x3D; f[i][t-1] * hmm._T[j][i] * hmm._E[O[t]][j]</span><br><span class="line">    return f</span><br><span class="line"></span><br><span class="line">def backward(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return trellis representing p(O_t+1^N | theta_t &#x3D;&#x3D; i).</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # initialize local variables</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    b &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            b[state].append(0)</span><br><span class="line"></span><br><span class="line">    # construct backward trellis</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        b[state][n-1] &#x3D; 1</span><br><span class="line">    for t in range(n-2, -1, -1):</span><br><span class="line">        for i in hmm._states:</span><br><span class="line">            for j in hmm._states:</span><br><span class="line">                b[i][t] +&#x3D; b[j][t+1] * hmm._T[j][i] * hmm._E[O[t+1]][j]</span><br><span class="line">    return b</span><br><span class="line"></span><br><span class="line">def posterior(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return trellis representing p(theta_t | O).</span><br><span class="line">    Posterior probabilities would be used to find the maximum likelihood</span><br><span class="line">        of a state at a given time step based on the observation sequence</span><br><span class="line">        O.  The value returned by the forward algorithm is the O_prob</span><br><span class="line">        value returned here.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # get n</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    # initialize forward, backward, and posterior trellises</span><br><span class="line">    f &#x3D; forward(O, hmm)</span><br><span class="line">    b &#x3D; backward(O, hmm)</span><br><span class="line">    p &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            p[state].append(0)</span><br><span class="line"></span><br><span class="line">    # total probability of sequence O</span><br><span class="line">    O_prob &#x3D; math.fsum([f[state][n-1] for state in hmm._states])</span><br><span class="line"></span><br><span class="line">    # build posterior trellis</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        for t in range(n):</span><br><span class="line">            p[state][t] &#x3D; (f[state][t] * b[state][t]) &#x2F; O_prob</span><br><span class="line"></span><br><span class="line">    return p</span><br><span class="line"></span><br><span class="line">def forward_algrithm(O, hmm):</span><br><span class="line">    f &#x3D; forward(O, hmm)</span><br><span class="line">    prop &#x3D; 0.0</span><br><span class="line">    for stat in hmm._T:</span><br><span class="line">        prop +&#x3D; f[stat][len(O)-1]</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">def viterbi_path(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return most likely hidden state path given observation sequence O.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    u &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    v &#x3D; &#123;state: list() for state in hmm._states&#125;</span><br><span class="line">    bt &#x3D; list()</span><br><span class="line">    for o in O:</span><br><span class="line">        for state in hmm._states:</span><br><span class="line">            for t in (u, v):</span><br><span class="line">                u[state].append(0)</span><br><span class="line">                v[state].append(str())</span><br><span class="line">        bt.append(str())</span><br><span class="line"></span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        u[state][0] &#x3D; hmm._priors[state] * hmm._E[O[0]][state]</span><br><span class="line">        # v[state][0] not of interest</span><br><span class="line">    for t in range(1, n):</span><br><span class="line">        for j in hmm._states:</span><br><span class="line">            for i in hmm._states:</span><br><span class="line">                p &#x3D; u[i][t-1] * hmm._T[j][i] * hmm._E[O[t]][j]</span><br><span class="line">                if p &gt; u[j][t]:</span><br><span class="line">                    u[j][t] &#x3D; p</span><br><span class="line">                    v[j][t] &#x3D; i</span><br><span class="line">    p &#x3D; 0</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        if u[state][n-1] &gt; p:</span><br><span class="line">            p &#x3D; u[state][n-1]</span><br><span class="line">            bt[n-1] &#x3D; state</span><br><span class="line">    for t in range(n-2, -1, -1):</span><br><span class="line">        bt[t] &#x3D; v[bt[t+1]][t+1]</span><br><span class="line"></span><br><span class="line">    return bt</span><br><span class="line"></span><br><span class="line">def baum_welch(O, hmm):</span><br><span class="line">    &quot;&quot;&quot;Return new hmm from one iteration of re-estimation.&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(O)</span><br><span class="line">    f &#x3D; forward(O, hmm)</span><br><span class="line">    b &#x3D; backward(O, hmm)</span><br><span class="line">    p &#x3D; posterior(O, hmm)</span><br><span class="line">    E_prime &#x3D; dict()</span><br><span class="line">    for emission in hmm._emissions: E_prime[emission] &#x3D; dict()</span><br><span class="line">    T_prime &#x3D; dict()</span><br><span class="line">    for state in hmm._states: T_prime[state] &#x3D; dict()</span><br><span class="line">    priors_prime &#x3D; dict()</span><br><span class="line"></span><br><span class="line">    # construct E_prime</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        den &#x3D; math.fsum([p[state][t] for t in range(n)])</span><br><span class="line">        for emission in hmm._emissions:</span><br><span class="line">            v &#x3D; 0</span><br><span class="line">            for t in range(n):</span><br><span class="line">                if O[t] &#x3D;&#x3D; emission: v +&#x3D; p[state][t]</span><br><span class="line">            E_prime[emission][state] &#x3D; v &#x2F; den</span><br><span class="line"></span><br><span class="line">    # construct T_prime</span><br><span class="line">    p_O &#x3D; math.fsum([f[s][n-1] for s in hmm._states])</span><br><span class="line">    for given in hmm._states:</span><br><span class="line">        den &#x3D; math.fsum([p[given][t] for t in range(n)])</span><br><span class="line">        for to in hmm._states:</span><br><span class="line">            v &#x3D; 0</span><br><span class="line">            for t in range(1, n):</span><br><span class="line">                v +&#x3D; ( f[given][t-1] *</span><br><span class="line">                       b[to][t] *</span><br><span class="line">                       hmm._T[to][given] *</span><br><span class="line">                       hmm._E[O[t]][to]</span><br><span class="line">                      ) &#x2F; p_O</span><br><span class="line">            T_prime[to][given] &#x3D; v &#x2F; den</span><br><span class="line"></span><br><span class="line">    # construct priors_prime</span><br><span class="line">    for state in hmm._states:</span><br><span class="line">        priors_prime[state] &#x3D; p[state][0]</span><br><span class="line"></span><br><span class="line">    new_hmm &#x3D; HMM(hmm._states, hmm._emissions)</span><br><span class="line">    new_hmm.set_E(E_prime)</span><br><span class="line">    new_hmm.set_T(T_prime)</span><br><span class="line">    new_hmm.set_priors(priors_prime)</span><br><span class="line"></span><br><span class="line">    return new_hmm</span><br></pre></td></tr></table></figure>
<p>下面我们来用这个模型解决这三个问题。</p>
<h5 id="估计问题：已知模型，求观测到连续一周出现涨势的概率"><a href="#估计问题：已知模型，求观测到连续一周出现涨势的概率" class="headerlink" title="估计问题：已知模型，求观测到连续一周出现涨势的概率"></a>估计问题：已知模型，求观测到连续一周出现涨势的概率</h5><p>已知模型如下图所示：</p>
<p><img src="/img/18_11_11/006.png" width="660" hegiht="413" align=center /></p>
<p>某股民根据经验判断当前为牛市、熊市、普通的概率分别是0.4、0.3、0.3。</p>
<p>这个问题中，我们的观测状态集合为：牛市、熊市、普通</p>
<p>我们的发射状态集合为：涨、跌、不变</p>
<p>初始分布$\pi$为：$(0.4, 0.3, 0.3)$</p>
<p>转移概率矩阵A：$<br>A=\begin{pmatrix}<br>0.6 &amp; 0.2 &amp; 0.2 \\<br>0.5 &amp; 0.3 &amp; 0.2 \\<br>0.4 &amp; 0.1 &amp; 0.5<br>\end{pmatrix}<br>$</p>
<p>观测概率矩阵B：$<br>A=\begin{pmatrix}<br>0.7 &amp; 0.1 &amp; 0.2 \\<br>0.1 &amp; 0.6 &amp; 0.3 \\<br>0.3 &amp; 0.3 &amp; 0.4<br>\end{pmatrix}<br>$</p>
<p>求连续一周出现涨势的概率，我们应该使用<strong>前后向算法</strong><code>forward_algrithm()</code>。改算法接收一个hmm模型。我们在初始化hmm模型的时候，需要设置观测状态<code>states</code>、发射状态<code>emissions</code>，转移概率矩阵<code>set_T()</code>，发射概率矩阵<code>set_E()</code>，以及初始分布<code>set_priors()</code>。</p>
<p>我们初始化好这些参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">def initTestModel():</span><br><span class="line">    model &#x3D; hmm.HMM([&#39;bull&#39;, &#39;bear&#39;, &#39;normal&#39;], [&#39;up&#39;, &#39;down&#39;, &#39;unchange&#39;])</span><br><span class="line">    transition_matrix &#x3D; &#123;</span><br><span class="line">        &#39;bull&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.6,</span><br><span class="line">            &#39;bear&#39;: 0.2,</span><br><span class="line">            &#39;normal&#39;: 0.2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;bear&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.5,</span><br><span class="line">            &#39;bear&#39;: 0.3,</span><br><span class="line">            &#39;normal&#39;: 0.2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;normal&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.4,</span><br><span class="line">            &#39;bear&#39;: 0.1,</span><br><span class="line">            &#39;normal&#39;: 0.5</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    emission_matrix &#x3D; &#123;</span><br><span class="line">        &#39;up&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.7,</span><br><span class="line">            &#39;bear&#39;: 0.1,</span><br><span class="line">            &#39;normal&#39;: 0.3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;down&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.1,</span><br><span class="line">            &#39;bear&#39;: 0.6,</span><br><span class="line">            &#39;normal&#39;: 0.3</span><br><span class="line">        &#125;,</span><br><span class="line">        &#39;unchange&#39;: &#123;</span><br><span class="line">            &#39;bull&#39;: 0.2,</span><br><span class="line">            &#39;bear&#39;: 0.3,</span><br><span class="line">            &#39;normal&#39;: 0.4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#x3D; &#123;&#39;bull&#39;:0.4, &#39;bear&#39;:0.3, &#39;normal&#39;:0.3&#125;</span><br><span class="line"> </span><br><span class="line">    model.set_T(transition_matrix)</span><br><span class="line">    model.set_E(emission_matrix)</span><br><span class="line">    model.set_priors(p)</span><br><span class="line"> </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<p>初始化模型完成之后，调用<code>forward_algrithm()</code>即可得出指定观测序列的预测结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def evaluate():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line">    prop &#x3D; model.forward_algrithm([&#39;up&#39;, &#39;up&#39;, &#39;up&#39;, &#39;up&#39;, &#39;up&#39;], model)</span><br><span class="line">    print prop</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0232968298</span><br></pre></td></tr></table></figure>
<p>下面的代码可以查看所有组合可能出现的概率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def generate_weekly_list():</span><br><span class="line">    status &#x3D; [&#39;up&#39;,&#39;down&#39;,&#39;unchange&#39;]</span><br><span class="line"> </span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    weekly_list &#x3D; &#123;&#125;</span><br><span class="line">    for statu1 in status:</span><br><span class="line">        for statu2 in status:</span><br><span class="line">            for statu3 in status:</span><br><span class="line">                for statu4 in status:</span><br><span class="line">                    for statu5 in status:</span><br><span class="line">                        key &#x3D; statu1 + &#39;,&#39; + statu2 + &#39;,&#39; + statu3 + &#39;,&#39; + statu4 + &#39;,&#39; + statu5</span><br><span class="line">                        value &#x3D; [statu1, statu2, statu3, statu4, statu5]</span><br><span class="line">                        weekly_list[key] &#x3D; value</span><br><span class="line">    return weekly_list</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def evaluate():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line"> </span><br><span class="line">    all_list &#x3D; generate_weekly_list()</span><br><span class="line">    prop_list &#x3D; &#123;&#125;</span><br><span class="line">    for key in all_list:</span><br><span class="line">        prop &#x3D; hmm.forward_algrithm(all_list[key], model)</span><br><span class="line">        prop_list[key] &#x3D; prop</span><br><span class="line"> </span><br><span class="line">    sort_list &#x3D; sorted(prop_list.items(), lambda x, y: cmp(x[1], y[1]), reverse&#x3D;True)</span><br><span class="line"> </span><br><span class="line">    for (key, value) in sort_list:</span><br><span class="line">        print (&#39;%.6f:&#39; % value) + key</span><br></pre></td></tr></table></figure>
<h5 id="预测问题：已知模型-股市变化，求股市状态"><a href="#预测问题：已知模型-股市变化，求股市状态" class="headerlink" title="预测问题：已知模型+股市变化，求股市状态"></a>预测问题：已知模型+股市变化，求股市状态</h5><p>已知模型，观察到一周的变化情况为：涨、不变、涨、不变、跌，问股市的状态变化情况？</p>
<p>还是同样的模型：</p>
<p>观测状态集合为：牛市、熊市、普通</p>
<p>我们的发射状态集合为：涨、跌、不变</p>
<p>初始分布$\pi$为：$(0.4, 0.3, 0.3)$</p>
<p>转移概率矩阵A：$<br>A=\begin{pmatrix}<br>0.6 &amp; 0.2 &amp; 0.2 \\<br>0.5 &amp; 0.3 &amp; 0.2 \\<br>0.4 &amp; 0.1 &amp; 0.5<br>\end{pmatrix}<br>$</p>
<p>观测概率矩阵B：$<br>A=\begin{pmatrix}<br>0.7 &amp; 0.1 &amp; 0.2 \\<br>0.1 &amp; 0.6 &amp; 0.3 \\<br>0.3 &amp; 0.3 &amp; 0.4<br>\end{pmatrix}<br>$</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def predict():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line">    print hmm.viterbi_path([&#39;up&#39;, &#39;unchange&#39;, &#39;up&#39;, &#39;unchange&#39;, &#39;down&#39;], model)</span><br></pre></td></tr></table></figure>
<p>结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#39;bull&#39;, &#39;bull&#39;, &#39;bull&#39;, &#39;bull&#39;, &#39;bear&#39;]</span><br></pre></td></tr></table></figure>
<p>我们同样可以写出所有的组合的预测结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def predict():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line">    weekly_list &#x3D; generate_weekly_list()</span><br><span class="line">    for key in weekly_list:</span><br><span class="line">        print key + &#39;:&#39;</span><br><span class="line">        print hmm.viterbi_path(weekly_list[key], model)</span><br></pre></td></tr></table></figure>
<h5 id="学习问题：已知一堆观测序列，求模型"><a href="#学习问题：已知一堆观测序列，求模型" class="headerlink" title="学习问题：已知一堆观测序列，求模型"></a>学习问题：已知一堆观测序列，求模型</h5><p>某股民连续三周观测到股市的变动情况为：</p>
<ul>
<li>涨，不变，涨，跌，涨</li>
<li>跌，涨，跌，涨，不变</li>
<li>不变，不变，跌，涨，涨</li>
</ul>
<p>问，下周的变化情况？</p>
<p>这个问题的思路为：</p>
<p>根据观测序列 -&gt; 求出模型 -&gt; 得到$A,B,\pi$ -&gt; 预测当前状态 -&gt; 利用转移矩阵预测下一个状态。</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def learn():</span><br><span class="line">    model &#x3D; initTestModel()</span><br><span class="line"> </span><br><span class="line">    o_list1 &#x3D; [&#39;up&#39;, &#39;unchange&#39;, &#39;up&#39;, &#39;down&#39;, &#39;up&#39;]</span><br><span class="line">    o_list2 &#x3D; [&#39;down&#39;, &#39;up&#39;, &#39;down&#39;, &#39;up&#39;, &#39;unchange&#39;]</span><br><span class="line">    o_list3 &#x3D; [&#39;unchange&#39;, &#39;unchange&#39;, &#39;down&#39;, &#39;up&#39;, &#39;up&#39;]</span><br><span class="line"> </span><br><span class="line">    model &#x3D; hmm.baum_welch(o_list1, model)</span><br><span class="line">    model &#x3D; hmm.baum_welch(o_list2, model)</span><br><span class="line">    model &#x3D; hmm.baum_welch(o_list3, model)</span><br><span class="line"> </span><br><span class="line">    print hmm.viterbi_path(o_list3, model)</span><br></pre></td></tr></table></figure>
<p>得出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#39;normal&#39;, &#39;bull&#39;, &#39;bear&#39;, &#39;bull&#39;, &#39;bull&#39;]</span><br></pre></td></tr></table></figure>
<p>你也可以将转移概率矩阵打印出来：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print model._T</span><br></pre></td></tr></table></figure></h2><p>以上就是HMM模型的全部内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/29/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9102-%E5%B0%86%E4%B8%80%E8%88%AC%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%AE%80%E5%8D%95%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">【傅里叶变换及其应用讲义】第一章 傅里叶级数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-29 01:52:58" itemprop="dateCreated datePublished" datetime="2018-10-29T01:52:58+00:00">2018-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/%E5%85%AC%E5%BC%80%E8%AF%BE/" itemprop="url" rel="index"><span itemprop="name">公开课</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><h2 id="介绍和选择"><a href="#介绍和选择" class="headerlink" title="介绍和选择"></a>介绍和选择</h2><p>基于傅里叶变换的方法几乎用于所有工程和科学领域，几乎所有工程师和科学家都使用。 比如对于以下领域的初学者：</p>
<ul>
<li>电路设计师</li>
<li>光谱学家</li>
<li>晶体学家</li>
<li>从事信号处理和通信工作的任何人</li>
<li>从事成像工作的人员</li>
</ul>
<p>我期待课堂上会有很不同领域的同学，这对我们所有人来说都很重要。 随着兴趣和背景的多样性，并非所有的例子和应用都是大家所熟悉的，并且与所有人相关。 我们都必须互相削减一些内容，这是我们所有人分出的机会。 同样，你也应该意识到这是许多可能课程中傅立叶变换的一门课程。 无论是在数学上还是在应用范围内，主题的丰富性意味着我们将几乎不断地做出选择。 关于这个主题的书看起来不一样，和这份讲义也不太一样 - 甚至用于基本对象和操作的符号也因书而异。 我会试着带大家在合适的时机选择一个合适的方向作为切入点来带领大家了解这门学科，并且我也会说出其他切入点会是什么。</p>
<hr>
<p>第一个选择是从哪里开始，我的选择是对傅立叶级数的简要处理。傅立叶分析最初涉及通过傅立叶级数表示和分析周期性现象，然后通过傅立叶将这些见解扩展到非周期性现象。 转变。 实际上，从傅立叶级数到傅立叶变换的一种方法是将非周期性现象（因此几乎任何一般函数）视为周期性现象的极限情况，因为周期趋于无穷大。 周期性情况下的一组离散频率在非周期情况下成为频率的连续体，频谱诞生了，随之而来的是该主题最重要的原则：</p>
<p><strong>每个信号都有一个频谱，由频谱决定。 您可以在时域（或空间）或频域中分析信号。</strong></p>
<p>我认为这条格言有资格成为宇宙组成的主要秘密之一。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/27/%E3%80%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%9101-%E5%91%A8%E6%9C%9F%E6%80%A7%EF%BC%8C%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">【傅里叶变换及其应用】01-周期性，三角函数表示复杂函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-27 17:03:58" itemprop="dateCreated datePublished" datetime="2018-10-27T17:03:58+00:00">2018-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E5%AD%A6/%E5%85%AC%E5%BC%80%E8%AF%BE/" itemprop="url" rel="index"><span itemprop="name">公开课</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://open.163.com/movie/2008/2/C/G/M7Q4BLENR_M7QBP61CG.html">课程视频地址</a></p>
<p>本质上，傅里叶级数可以看做是<strong>用数学的手段研究周期性现象</strong>的一门学科。</p>
<p>我们在初中高中学过cos和sin这些三角函数，我们是否可以使用这些三角函数来建模非常广泛的周期性现象呢？这正是这节课需要解决的问题。</p>
<h3 id="如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？"><a href="#如何使用简单的sin-t-，cos-t-来建模复杂的周期性现象？" class="headerlink" title="如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？"></a>如何使用简单的sin(t)，cos(t)来建模复杂的周期性现象？</h3><p>首先，我们这里说的<strong>复杂的周期性现象</strong>会普遍到什么程度呢？我们希望把这些方法应用在普遍的条件下，但是并不是所有的现象都是周期性的（其实甚至在一些周期性的现象中，这个假定也未必行得通）。所以，<strong>并不是所有的现象都试用这个方法</strong>。</p>
<p>其实现实生活中的现象，最终都会结束，我们只观察某一个特定时间段的现象。而数学函数，比如正余弦函数，都是无始无终的。那么如何用它们来描述那些会结束的现象呢？</p>
<p>在面对实际的现象时，比如下面这种现象：</p>
<p><img src=/img/18_10_27/001.png width="500" hegiht="313" align=center /></p>
<p>只存在于一个有限的时间段内，画出一个这样的信号。这并不是一个周期现象，但如果我们重复绘制这个图像，就可以强制使其成为周期性的函数了。</p>
<p><img src="/img/18_10_27/002.png" alt=""></p>
<p>或许我们只是对其中的一部分感兴趣，但对于数学分析，如果使其具有周期性，就对所有的都适用了。这个过程叫做<strong>信号的周期化（periodization of a signal）</strong>。它可以用于研究非周期性信号。</p>
<h4 id="信号周期化"><a href="#信号周期化" class="headerlink" title="信号周期化"></a>信号周期化</h4><p>我们通常把周期函数的周期设定为1，这样更加方便。因此函数$f(t)$需要满足：</p>
<ul>
<li>对任何$t$均有$f(t+1)=f(t)$，</li>
</ul>
<p>因此我们的信号模型可以表示为：</p>
<script type="math/tex; mode=display">sin(2πt) \tag{1-1}</script><p>以及</p>
<script type="math/tex; mode=display">cos(2πt) \tag{1-2}</script><p><strong><em>如果我们知道一个周期为1的周期性函数在任意一个单位为1的时间间隔内的形式，那么我们就可以知道整个函数了。</em></strong></p>
<h4 id="生成复杂的周期函数"><a href="#生成复杂的周期函数" class="headerlink" title="生成复杂的周期函数"></a>生成复杂的周期函数</h4><p>那么我们如何用简单的sin和cos函数来表示各种复杂的周期现象呢？</p>
<p>事实上，我们可以通过对$sin(2πt)$和$cos(2πt)$进行变换和相加的方式来得到相当普遍的周期为1的周期函数。</p>
<h5 id="对正余弦函数进行变换"><a href="#对正余弦函数进行变换" class="headerlink" title="对正余弦函数进行变换"></a>对正余弦函数进行变换</h5><p>下图是$sin(2πt)$的函数图像，其周期为1，频率为1：</p>
<p><img src=/img/18_10_27/003.png width="500" hegiht="313" align=center /></p>
<p>经过变换之后，$sin(4πt)$的函数图像如下，其周期为$1/2$，频率为2：</p>
<p><img src=/img/18_10_27/004.png width="500" hegiht="313" align=center /></p>
<blockquote>
<p>其实你也可以说他的周期是1。因为一秒之内它经历了两个完整的周期，你可以把这两个完整的周期看做一个周期，图形在整个坐标轴上一直在重复这个原始信号。</p>
</blockquote>
<p>再次变换之后，$sin(6πt)$的函数图像如下，其周期为$1/3$，频率为3：</p>
<p><img src=/img/18_10_27/005.png width="500" hegiht="313" align=center /></p>
<blockquote>
<p>同样，也可以把它看做周期是1。</p>
</blockquote>
<h5 id="对正余弦函数进行合并"><a href="#对正余弦函数进行合并" class="headerlink" title="对正余弦函数进行合并"></a>对正余弦函数进行合并</h5><p>现在把上面的三个函数合并：</p>
<script type="math/tex; mode=display">
y=sin(2πt) + sin(4πt) + sin(6πt)</script><p>其效果如下：</p>
<p><img src=/img/18_10_27/006.png width="300" hegiht="313" align=center /></p>
<p>组合之后的函数周期为1，它由3个不同频率的周期函数组成，频率分布为1，2，3。但把它们组合起来之后，却只有一个周期：周期为1。</p>
<p>我们不仅可以改变频率，也可以单独改变幅度，并且可以改变其中每一个的相位。</p>
<h4 id="表示一个复杂的周期函数的几种方式"><a href="#表示一个复杂的周期函数的几种方式" class="headerlink" title="表示一个复杂的周期函数的几种方式"></a>表示一个复杂的周期函数的几种方式</h4><h5 id="最基本的形式"><a href="#最基本的形式" class="headerlink" title="最基本的形式"></a>最基本的形式</h5><p>一个复杂的周期为1的信号，可以通过变换一系列的正余弦函数的<strong>频率</strong>、<strong>幅度</strong>和<strong>相位</strong>，然后将它们<strong>加起来</strong>，来得到。</p>
<script type="math/tex; mode=display">
y=\sum\_{k=1}^N A\_ksin(2πkt+φ\_k) \tag{1-3}</script><p>这是表示一个复杂周期的<strong>最一般</strong>的形式。</p>
<h5 id="利用和角公式来表示"><a href="#利用和角公式来表示" class="headerlink" title="利用和角公式来表示"></a>利用和角公式来表示</h5><p>正余弦和角公式：</p>
<script type="math/tex; mode=display">
sin(2πkt+φ_k)=sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k
\tag{1-4}</script><p>因此我们可以将上面的公式$(1-3)$展开成以下形式：</p>
<script type="math/tex; mode=display">
\begin{align\*}  
y&=\sum\_{k=1}^N A\_k(sin(2πkt) + cosφ_k + cos(2πkt) + sinφ_k)\\\\
&=\sum\_k^N  (a\_kcos(2πkt)+b\_ksin(2πkt))
\tag{1-5}
\end{align*}</script><p>这里的$a_k$和$b_k$是由A计算出的。</p>
<h5 id="加一个常数项的形式（直流分量形式）"><a href="#加一个常数项的形式（直流分量形式）" class="headerlink" title="加一个常数项的形式（直流分量形式）"></a>加一个常数项的形式（直流分量形式）</h5><script type="math/tex; mode=display">
y = \frac{a\_0}{2} + \sum\_{k=1}^N  (a\_kcos(2πkt)+b\_ksin(2πkt))
\tag{1-6}</script><p>这里的$\frac{a_0}{2}$是一个常数项，电器工程师常称之为<strong>直流分量(dc component)</strong>。因为电器工程师在研究交流电或直流电的过程中，发现有一部分是不随着周期发生改变的，这一部分称之为<strong>直流分量</strong>。</p>
<h5 id="复指数的表示形式"><a href="#复指数的表示形式" class="headerlink" title="复指数的表示形式"></a>复指数的表示形式</h5><p>上面几种都是比较常用的一些用于表示一个复杂信号的表示形式。但是迄今为止，最方便使用的还是用<strong>复指数</strong>的形式来表示：</p>
<script type="math/tex; mode=display">
e^{2πkt}=cos(2πkt) + i*sin(2πkt)
\tag{1-7}</script><p>在这里$i$的值为：</p>
<script type="math/tex; mode=display">
i=\sqrt{-1}
\tag{1-8}</script><p>根据著名的<strong>欧拉公式</strong>，我们可以用复指数的形式来表示正余弦函数，其中$cos$是实部，$sin$是虚部：</p>
<script type="math/tex; mode=display">
cos(2πkt)=\frac{e^{2πikt}+e^{-2πikt}}{2}
\\\\
sin(2πkt)=\frac{e^{2πikt}-e^{-2πikt}}{2i}
\tag{1-9}</script><p>你也可以将上面公式$(1-5)$的三角函数表示的和式的形式写成这种形式：</p>
<script type="math/tex; mode=display">
\sum\_{k=-n}^n C_ke^{2πikt}
\tag{1-10}</script><p>在这里$C_k$是复数。</p>
<blockquote>
<p><strong>共轭</strong></p>
<p>对于复数$a + bi$来说，其共轭为$a - bi$。<br>复数$C_k$的共轭表示为$\bar{C_k}$</p>
<p>另外，如果一个复数等于其自身的共轭意味着什么呢？$C_0=\bar{C_0}$</p>
<p>这意味着这个数本身是实数。</p>
</blockquote>
<p>如果你试着把余弦表示的方式全部转成了复指数的形式，你会发现$C_k$不仅仅是复数，它同时还满足<strong>对称性</strong>。并且由于它的对称性，所以$\sum_{k=-n}^n C_k $的总和为实数。</p>
<p>即：$ C_{-k} $等于$C_k$的共轭：</p>
<script type="math/tex; mode=display">
C_-k=\bar{C_k}
\tag{1-11}</script><p>这是一条重要的性质。</p>
<p>反过来，如果和式的系数满足对称性，那么总和就应该是实数。这是因为可以把所有项分成正项和负项两组，并且由于$(1-11)$的对称关系，复数和复数的共轭的和结果是实数，可以得出这个结论。</p>
<h4 id="我们生成的复杂的周期函数，其普遍性有多强？"><a href="#我们生成的复杂的周期函数，其普遍性有多强？" class="headerlink" title="我们生成的复杂的周期函数，其普遍性有多强？"></a>我们生成的复杂的周期函数，其普遍性有多强？</h4><p>$f(t)$是周期为1的周期函数，我们可以把$f(t)$写成$(1-10)$那种形式吗？</p>
<script type="math/tex; mode=display">
f(t)=\sum\_{k=-n}^n C_ke^{2πikt}
\tag{1-12}</script><p>换句话说，一个周期为1的复杂的周期函数，我们能用正余弦函数通过叠加变化以及组合来生成出来吗？</p>
<h5 id="假设我们能做到"><a href="#假设我们能做到" class="headerlink" title="假设我们能做到"></a>假设我们能做到</h5><p>假设我们可以做到用$(1-12)$来表示所有复杂的周期为1的周期函数，那么对于未知系数$C_k$我们如何求得呢？</p>
<p>以下是求$C_k$的过程：</p>
<script type="math/tex; mode=display">
\begin{align\*} 
f(t)&=\sum\_{k=-n}^n C_ke^{2πikt}\\\\
&=...+C_km^{2πikt}+...
\end{align\*}</script><p><img src="/img/18_10_27/007.png" alt=""></p>
<p>两边同时乘以$e^{-2\pi imt}$：</p>
<p><img src="/img/18_10_27/008.png" alt=""></p>
<p><img src="/img/18_10_27/009.png" alt=""></p>
<p>然后对两边同时求积分，积分区间是0到1，因为我们的频率是1：</p>
<p><img src="/img/18_10_27/010.png" alt=""></p>
<p>由于：</p>
<p><img src="/img/18_10_27/011.png" alt=""></p>
<p>所以：</p>
<p><img src="/img/18_10_27/012.png" alt=""></p>
<p><img src="/img/18_10_27/013.png" alt=""></p>
<p>其中：</p>
<p><img src="/img/18_10_27/014.png" alt=""></p>
<p><img src="/img/18_10_27/015.png" alt=""></p>
<p><img src="/img/18_10_27/016.png" alt=""></p>
<p><img src="/img/18_10_27/017.png" alt=""></p>
<p>这里的:</p>
<p><img src="/img/18_10_27/018.png" alt=""></p>
<p>是一个整数，就像$sin(2π)$乘以一个整数，这个整数是1，所以这里的结果是0。</p>
<p><img src="/img/18_10_27/019.png" alt=""></p>
<p>所以我们的$C_m$可以得到下面的结果：</p>
<p><img src="/img/18_10_27/020.png" alt=""></p>
<p>期初我们设定$f(t)$是已知的，所以我们就可以求得$C_m$了。</p>
<hr>
<p><strong>结论:</strong>给定周期为1的周期函数$f(t)$，如果能把$f(t)$写成和式的形式：$f(t)=\sum_{k=-n}^nC_ke^{2\pi ikt}$，那么溪水会按照这个公式给出，其中$C_k=\int_0^{1}e^{-2\pi ikt}f(t)dt$。</p>
<p>下节课我们将介绍，我们得到的这些参数，将带来什么意义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/11/NumPy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">NumPy入门教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-11 11:43:55" itemprop="dateCreated datePublished" datetime="2018-05-11T11:43:55+00:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>在开始本教程之前，你需要有一定的Python基础。如果你想要回顾一下Python相关的知识点，你可以看一下<a target="_blank" rel="noopener" href="http://docs.python.org/tut/">这份教程</a>。</p>
<p>如果你希望运行本教程中的示例，那么需要在您机器上安装一些软件。有关说明，请参阅<a target="_blank" rel="noopener" href="http://scipy.org/install.html">http://scipy.org/install.html</a>。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>NumPy的主要对象是齐次多维数组。它是一个元素的表（元素通常是数字），所有的元素拥有相同的类型，可以被一个正整数元组来索引。在NumPy中维度称之为<strong><em>axis（轴）</em></strong>。</p>
<p>例如，在3D空间中的一个坐标点<code>[1, 2, 1]</code>拥有一个axis。这个axis拥有3个元素，所以我们说它的长度是3。在下面的例子中，有2个axis。第一个axis的长度是2，第二个axis的长度是3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">[ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</span><br></pre></td></tr></table></figure>
<pre><code>[[1.0, 0.0, 0.0], [0.0, 1.0, 2.0]]
</code></pre><p>NumPy的数组class称之为<code>ndarray</code>。它还有另外一个别名：<code>array</code>。注意<code>numpy.array</code>与标准Python库中的<code>array.array</code>不一样，标准库中的<code>array</code>只可以操作以为数组，并且只能提供少量的方法。<code>ndarray</code>更重要的一些属性如下：</p>
<p><strong>ndarray.ndim</strong></p>
<pre><code>数组的axis(维度)数量
</code></pre><p><strong>ndarray.shape</strong></p>
<pre><code>数组的维度。这是一个整数类型的元组，指示了数组在每个维度下的尺寸信息。对于一个n行m列的矩阵来说，它的`shape`是`(n,m)`。因此`shape`元组的长度，也是axis的数量，即`ndim`。
</code></pre><p><strong>ndarray.size</strong></p>
<pre><code>数组的元素总数。值等于`shape`中的元素的乘积。
</code></pre><p><strong>ndarray.dtype</strong></p>
<pre><code>一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外，也可以使用NumPy自己提供的一些类型。例如`numpy.int32`,`numpy.int16`和`numpy.float64`。
</code></pre><p><strong>ndarray.itemsize</strong></p>
<pre><code>数组中每个元素占用的bytes大小。例如，一个数组的元素类型为`float64`，它的`itemsize`就是8(=64/8)，另一个数组的元素类型为`complex32`的`itemsize`值为4(=32/8)。这个值相当于`ndarray.dtype.itemsize`。
</code></pre><p><strong>ndarray.data</strong></p>
<pre><code>该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引来访问数组中的元素。
</code></pre><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 5)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.ndim</span><br></pre></td></tr></table></figure>
<pre><code>2
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;int64&#39;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.itemsize</span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.size</span><br></pre></td></tr></table></figure>
<pre><code>15
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>numpy.ndarray
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([6, 7, 8])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(b)</span><br></pre></td></tr></table></figure>
<pre><code>numpy.ndarray
</code></pre><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><p>有几种可以创建数组的方式。</p>
<p>例如，你可以通过使用<code>array</code>方法，从一个标准的Python列表或元组来创建一个numpy数组。数组的类型由序列中元素的类型自动推导得出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 3, 4])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.dtype</span><br></pre></td></tr></table></figure>
<pre><code>dtype(&#39;int64&#39;)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</span><br><span class="line">b.dtype</span><br></pre></td></tr></table></figure>
<pre><code>dtype(&#39;float64&#39;)
</code></pre><p>在调用<code>array</code>方法来创建数组时，有一种常见的错误，就是在方法中传入了多个数字，而不是通过传入一个包含一组数字的list作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; np.array(1,2,3,4)   # WRONG</span><br><span class="line">a &#x3D; np.array([1,2,3,4]) # RIGHT</span><br></pre></td></tr></table></figure>
<p><code>array</code>函数将序列的序列转换为二维数组，将序列的序列的序列转换成3维数组，等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([(<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])
</code></pre><p>数组的类型也可以在创建的时候，显式的指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=<span class="built_in">complex</span>)</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])
</code></pre><p>通常，数组的元素在初始状态下是未知的，但尺寸已知。因此，NumPy提供了一些方法来创建以初始化占位符填充的数组。这最大限度地减少了增加数组的开销，这是一项昂贵的操作。</p>
<p>方法<code>zeros</code>创建一个全部由0填充的数组，方法<code>ones</code>创建一个全部由1填充的数组，方法<code>empty</code>创建了一个全部由随机的数字填充的数组，随机数的值取决于内存当前的状态。默认情况下，创建出来的数组类型为<code>folat64</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dtype=np.int16) <span class="comment"># dtype可以被指定</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]], dtype=int16)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.empty((<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 未初始化，输出可能不同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
</code></pre><p>为了创建数字序列，NumPy提供了一个类似于<code>range</code>的返回数组而不是列表的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([10, 15, 20, 25])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span>) <span class="comment"># 可以接受float类型的参数</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
</code></pre><p>当<code>arange</code>与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数<code>linspace</code>来接收我们想要的元素数量作为参数，而不是步长：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)  <span class="comment"># 创建9个数字，均匀分布在0到2之间</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace( <span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</span><br><span class="line">f = np.sin(x)</span><br></pre></td></tr></table></figure>
<h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p>当你打印一个数组时，NumPy以一种类似嵌套列表的形式来展示，同时具有以下布局：</p>
<ul>
<li>最后一个axis从左向右打印</li>
<li>倒数第二个axis从上到下打印</li>
<li>其余的也是从上到下打印的，每个切片与下一个由空行分开。</li>
</ul>
<p>然后将一维数组打印为行，将二维数组作为矩阵，将三维数组作为矩阵列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)  <span class="comment"># 一维数组</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)  <span class="comment"># 二维数组</span></span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)  <span class="comment"># 三维数组</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<pre><code>[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
</code></pre><p>如果数组太大而无法打印，NumPy将自动跳过数组的中心部分并仅打印角点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[   0    1    2 ..., 9997 9998 9999]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[[   0    1    2 ...,   97   98   99]
 [ 100  101  102 ...,  197  198  199]
 [ 200  201  202 ...,  297  298  299]
 ..., 
 [9700 9701 9702 ..., 9797 9798 9799]
 [9800 9801 9802 ..., 9897 9898 9899]
 [9900 9901 9902 ..., 9997 9998 9999]]
</code></pre><p>要禁用此行为并强制NumPy打印整个数组，可以使用<code>set_printoptions</code>更改打印选项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=np.nan)</span><br></pre></td></tr></table></figure>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>数组上的算术运算符应用于元素。一个新的数组被创建并填充结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a-b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>array([20, 29, 38, 47])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b**<span class="number">2</span></span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 4, 9])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>*np.sin(a)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&lt;<span class="number">35</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ True,  True, False, False], dtype=bool)
</code></pre><p>不像其他的矩阵语言那样，<code>*</code>操作符在NumPy中是元素间的乘法。矩阵乘法可以使用<code>dot</code>方法来实现:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">A*B    <span class="comment"># 元素间的乘积</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[2, 0],
       [0, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.dot(B)   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[5, 4],
       [3, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dot(A, B) <span class="comment"># 矩阵乘法的另一种实现</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[5, 4],
       [3, 4]])
</code></pre><p>一些例如<code>+=</code>和<code>-=</code>的操作符，实现的方式是通过修改现有的矩阵而不是创建新的矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a *= <span class="number">3</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[3, 3, 3],
       [3, 3, 3]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b += a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 3.05432455,  3.59941571,  3.65058751],
       [ 3.85091779,  3.45890823,  3.55943444]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += b <span class="comment"># b 不会自动的转型成为 integer 类型</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-87-3054fce39e6f&gt; in &lt;module&gt;()
----&gt; 1 a += b


TypeError: Cannot cast ufunc add output from dtype(&#39;float64&#39;) to dtype(&#39;int64&#39;) with casting rule &#39;same_kind&#39;
</code></pre><p>在使用不同类型的数组时，结果数组的类型对应于更一般或精确的数组（称为向上转型）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones(<span class="number">3</span>, dtype=np.int32)</span><br><span class="line">b = np.linspace(<span class="number">0</span>, pi, <span class="number">3</span>)</span><br><span class="line">b.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;float64&#39;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a+b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>array([ 1.        ,  2.57079633,  4.14159265])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;float64&#39;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = np.exp(c*<span class="number">1j</span>)</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
       -0.54030231-0.84147098j])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.dtype.name</span><br></pre></td></tr></table></figure>
<pre><code>&#39;complex128&#39;
</code></pre><p>许多一元运算，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法来实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.48681264,  0.52685408,  0.53980305],
       [ 0.27958753,  0.55125855,  0.70834892]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>3.0926647737313067
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">min</span>()</span><br></pre></td></tr></table></figure>
<pre><code>0.27958753466020847
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">max</span>()</span><br></pre></td></tr></table></figure>
<pre><code>0.70834891569018965
</code></pre><p>默认情况下，这些操作适用于数组，就好像它是数字列表一样，无论其形状如何。但是，通过指定<code>axis</code>参数，可以沿着数组的指定轴(axis)应用操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="built_in">sum</span>(axis=<span class="number">0</span>)    <span class="comment"># 每一列的和</span></span><br></pre></td></tr></table></figure>
<pre><code>array([12, 15, 18, 21])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="built_in">min</span>(axis=<span class="number">1</span>)    <span class="comment"># 每一行的最小值</span></span><br></pre></td></tr></table></figure>
<pre><code>array([0, 4, 8])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.cumsum(axis=<span class="number">1</span>)   <span class="comment"># 每行的累加值</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  3,  6],
       [ 4,  9, 15, 22],
       [ 8, 17, 27, 38]])
</code></pre><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>NumPy提供了一些常见的数学运算方法，例如sin，cos和exp。在NumPy中，这些方法被称作”通用方法”(<code>ufunc</code>)。在NumPy中，这些方法操作在数组中的每个元素上，产生一个数组作为输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(<span class="number">3</span>)</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.exp(B)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 1.        ,  2.71828183,  7.3890561 ])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(B)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.        ,  1.        ,  1.41421356])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = np.array([<span class="number">2.</span>, -<span class="number">1.</span>, <span class="number">4.</span>])</span><br><span class="line">np.add(B, C)</span><br></pre></td></tr></table></figure>
<pre><code>array([ 2.,  0.,  6.])
</code></pre><h4 id="索引，切片和迭代"><a href="#索引，切片和迭代" class="headerlink" title="索引，切片和迭代"></a>索引，切片和迭代</h4><p><strong>一维</strong>数组可以像Python中的list或其他序列一样进行索引、切片和迭代操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)**<span class="number">3</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([ 8, 27, 64])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:<span class="number">6</span>:<span class="number">2</span>] = -<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i**(<span class="number">1</span>/<span class="number">3.</span>))</span><br></pre></td></tr></table></figure>
<pre><code>nan
1.0
nan
3.0
nan
5.0
6.0
7.0
8.0
9.0


/usr/local/Homebrew/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power
</code></pre><p><strong>多维</strong>数组每个轴（axis）都有一个索引。这些索引以逗号分隔的元组给出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>*x + y</span><br><span class="line"></span><br><span class="line">b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<pre><code>23
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>] <span class="comment"># 输出第2列的每一行的元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 1, 11, 21, 31, 41])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[:, <span class="number">1</span>] <span class="comment"># 与上一步操作等价</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 1, 11, 21, 31, 41])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">1</span>:<span class="number">3</span>, :] <span class="comment"># 输出第2和第3行的每个列元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[10, 11, 12, 13],
       [20, 21, 22, 23]])
</code></pre><p>当提供的索引数量少于axis的数量时，缺失的索引被视为完整的切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[-<span class="number">1</span>] <span class="comment"># 输出最后一行。相当于 b[-1,:]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([40, 41, 42, 43])
</code></pre><p>表达式<code>b[i]</code>的这种表示形式，意味着在<code>i</code>后面还有多个<code>:</code>，<code>:</code>的数量取决于剩余的axis数量。NumPy也允许你使用<code>...</code>来表示这一形式：<code>b[i,...]</code>。</p>
<p><strong>点</strong>(<code>...</code>)表示产生完整索引元组所需要的冒号。例如，如果<code>x</code>是一个5轴数组，那么：</p>
<ul>
<li><code>x[1,2,...]</code>等价于<code>x[1,2,:,:,:]</code>，</li>
<li><code>x[...,3]</code>等价于<code>x[:,:,:,:,3]</code>，</li>
<li><code>x[4,...,5,:]</code>等价于<code>x[4,:,:,5,:]</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个3D数组（由两个2D数组粘贴而成）</span></span><br><span class="line">c = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line">              [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line">              [<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]</span><br><span class="line">             ])</span><br><span class="line">c.shape</span><br></pre></td></tr></table></figure>
<pre><code>(2, 2, 3)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">1</span>,...]  <span class="comment"># 相当于 c[1,:,:] 或 c[1]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[100, 101, 102],
       [110, 112, 113]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[...,<span class="number">2</span>]  <span class="comment"># 相当于 c[:,:,2]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[  2,  13],
       [102, 113]])
</code></pre><p><strong>迭代</strong>多维数组是相对于第一个axis完成的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> b:</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
</code></pre><p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组中所有元素的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line">    print(element)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
10
11
12
13
20
21
22
23
30
31
32
33
40
41
42
43
</code></pre><h3 id="Shape操作"><a href="#Shape操作" class="headerlink" title="Shape操作"></a>Shape操作</h3><h4 id="改变一个array的shape"><a href="#改变一个array的shape" class="headerlink" title="改变一个array的shape"></a>改变一个array的shape</h4><p>一个数组的形状由这个数组每个轴上的元素数量给出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><p>数组的形状可以通过各种命令进行更改。请注意，以下三个命令都返回一个修改后的数组，但都没有改变原数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.ravel()  <span class="comment"># 返回展开的数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 8.,  3.,  6.,  4.,  7.,  5.,  7.,  7.,  3.,  1.,  8.,  8.])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.reshape(<span class="number">6</span>,<span class="number">2</span>)  <span class="comment"># 返回一个改变了shape的数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.],
       [ 6.,  4.],
       [ 7.,  5.],
       [ 7.,  7.],
       [ 3.,  1.],
       [ 8.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.T  <span class="comment"># 返回数组的转置</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  7.,  3.],
       [ 3.,  5.,  1.],
       [ 6.,  7.,  8.],
       [ 4.,  7.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.T.shape</span><br></pre></td></tr></table></figure>
<pre><code>(4, 3)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><p>由ravel()产生的数组元素的顺序通常是”C-style”的，即最右边的索引“变化最快”，因此[0,0]之后的元素是[0,1]。如果一个数组变形为其他形状，数组再次被视为”C-style”。NumPy通常创建按次顺序存储的数组，因此<code>ravel()</code>通常不需要复制数组，但如果数组是通过对另一个数组进行切片操作，或者使用不寻常的方式创建的，则可能需要复制它。函数<code>ravel()</code>和<code>reshape()</code>也可以通过使用可选参数来使用FORTRAN-style的数组，其中最左侧的索引更改速度最快。</p>
<p><code>reshape</code>方法返回的结果是一个变形后的数组，而<code>ndarray.resize</code>方法会更改数组本身的形状：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.resize((<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.,  7.,  5.],
       [ 7.,  7.,  3.,  1.,  8.,  8.]])
</code></pre><p>如果在reshape操作中将尺寸参数传入-1，则会自动计算这一位置的尺寸：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 8.,  3.,  6.,  4.],
       [ 7.,  5.,  7.,  7.],
       [ 3.,  1.,  8.,  8.]])
</code></pre><h4 id="将不同的数组粘贴起来"><a href="#将不同的数组粘贴起来" class="headerlink" title="将不同的数组粘贴起来"></a>将不同的数组粘贴起来</h4><p>多个数组可以按照不同的axis来粘贴起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.],
       [ 8.,  6.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 5.,  3.],
       [ 0.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.vstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.],
       [ 8.,  6.],
       [ 5.,  3.],
       [ 0.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a,b))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.,  5.,  3.],
       [ 8.,  6.,  0.,  4.]])
</code></pre><p>函数<code>column_stack</code>将1D数组作为列堆叠到2D数组中。它相当于仅用于2D数组的<code>hstack</code>操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> newaxis</span><br><span class="line">np.column_stack((a,b))   <span class="comment"># 仅作用于2D数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9.,  9.,  5.,  3.],
       [ 8.,  6.,  0.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">4.</span>, <span class="number">2.</span>])</span><br><span class="line">b = np.array([<span class="number">3.</span>, <span class="number">8.</span>])</span><br><span class="line">np.column_stack((a,b))  <span class="comment"># 返回一个2D数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a,b))  <span class="comment"># 得到不同的结果</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 4.,  2.,  3.,  8.])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,newaxis]  <span class="comment"># 这将得到一个2D列向量</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.],
       [ 2.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.column_stack((a[:,newaxis],b[:,newaxis]))</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hstack((a[:,newaxis],b[:,newaxis]))  <span class="comment"># 结果是一样的</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.],
       [ 2.,  8.]])
</code></pre><p>另一方面，函数<code>row_stack</code>相当于对任何数组进行<code>vstack</code>操作。一般情况下，对于具有两个以上维度的数组，<code>hstack</code>操作沿着它的第二个axis进行堆叠，<code>vstack</code>沿着它的第一个axis堆叠，<code>concatenate</code>沿着指定axis的方向进度堆叠。</p>
<p><strong>注意</strong></p>
<p>在复杂的情况下，<code>r_</code>和<code>c_</code>可用于通过沿着一个轴堆积数字来创建数组。他们允许使用表示范围的<code>:</code>操作符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 2, 3, 0, 4])
</code></pre><p>当使用数组作为参数时，<code>r_</code>和<code>c_</code>与默认行为的<code>vstack</code>和<code>hstack</code>类似，可以通过可选参数指定所要连接的轴的序号。</p>
<h4 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="将一个数组拆分成几个较小的数组"></a>将一个数组拆分成几个较小的数组</h4><p>使用<code>hsplit</code>，可以沿着水平轴来切割数组，或者通过指定返回的数组的形状来切割数组，或者通过指定需要分割的列来分割数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4.,  3.,  3.,  1.,  2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],
       [ 5.,  1.,  1.,  2.,  9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(a,<span class="number">3</span>)  <span class="comment"># 将a切分成3份</span></span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 4.,  3.,  3.,  1.],
        [ 5.,  1.,  1.,  2.]]), array([[ 2.,  5.,  2.,  5.],
        [ 9.,  6.,  5.,  5.]]), array([[ 5.,  8.,  2.,  2.],
        [ 0.,  8.,  8.,  7.]])]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 沿着第3和第4列来切分数组</span></span><br></pre></td></tr></table></figure>
<pre><code>[array([[ 4.,  3.,  3.],
        [ 5.,  1.,  1.]]), array([[ 1.],
        [ 2.]]), array([[ 2.,  5.,  2.,  5.,  5.,  8.,  2.,  2.],
        [ 9.,  6.,  5.,  5.,  0.,  8.,  8.,  7.]])]
</code></pre><p><code>vspilt</code>沿着垂直轴进行分割，<code>array_split</code>允许指定沿着那个轴来进行分割。</p>
<h3 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h3><p>当操作一个数组时，它们的数据有时会被复制到一个新的数组中，有时则不会。这通常会让新手感到困惑。下面是3个例子：</p>
<h4 id="完全没有复制"><a href="#完全没有复制" class="headerlink" title="完全没有复制"></a>完全没有复制</h4><p>简单的赋值不会复制数组对象或数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a    <span class="comment"># 没有新的对象被创建</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># a 和 b 是同一个ndarray对象的两个名字</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.shape = <span class="number">3</span>,<span class="number">4</span>  <span class="comment"># 改变a的shape</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><p>Python将可变对象作为引用传递，所以函数调用不会执行复制操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="built_in">id</span>(x))</span><br><span class="line">    </span><br><span class="line"><span class="built_in">id</span>(a)      <span class="comment"># id 是一个对象的唯一标识</span></span><br></pre></td></tr></table></figure>
<pre><code>4449897488
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<pre><code>4449897488
</code></pre><h4 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="视图或浅拷贝"></a>视图或浅拷贝</h4><p>不同的数组对象可以共享相同的数据。<code>view</code>函数创建一个新的数组对象，但它和原数组持有相同的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = a.view()</span><br><span class="line">c <span class="keyword">is</span> a</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.base <span class="keyword">is</span> a  <span class="comment"># c 是 一个a数据所创建出来的视图</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.flags.owndata</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.shape = <span class="number">2</span>,<span class="number">6</span>  <span class="comment"># a的shape并不发生改变</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(3, 4)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>  <span class="comment"># a的数据发生改变</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])
</code></pre><p>对一个数组进行切片操作，返回它的一个视图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = a[ : , <span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 也可以被写作 s = a[:,1:3]</span></span><br><span class="line">s[:] = <span class="number">10</span>  <span class="comment"># s[:] 是一个s的视图。注意这里 s = 10 和 s[:] = 10 的区别</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
</code></pre><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>copy</code>方法可以构造数组以及数据的完整副本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = a.copy()    <span class="comment"># 一个由新数据构成的新的数组对象被创建了</span></span><br><span class="line">d <span class="keyword">is</span> a</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.base <span class="keyword">is</span> a     <span class="comment"># d 与 a 不共享任何东西</span></span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[   0,   10,   10,    3],
       [1234,   10,   10,    7],
       [   8,   10,   10,   11]])
</code></pre><h4 id="方法预览"><a href="#方法预览" class="headerlink" title="方法预览"></a>方法预览</h4><p>这里有一个NumPy中各种类型的比较有用的方法列表。</p>
<ul>
<li><p><strong>数组创建</strong></p>
<p><code>arange</code>,<code>array</code>,<code>copy</code>,<code>empty</code>,<code>empty_like</code>,<code>eye</code>,<code>fromfile</code>,<code>fromfunction</code>,<code>identity</code>,<code>linspace</code>,<code>logspace</code>,<code>mgrid</code>,<code>ogrid</code>,<code>ones</code>,<code>ones_like</code>,<code>zeros</code>,<code>zeros_like</code></p>
</li>
<li><p><strong>转换</strong></p>
<p>  <code>ndarray.astype</code>,<code>atleast_1d</code>,<code>atleast_2d</code>,<code>atleast_3d</code>,<code>mat</code></p>
</li>
<li><p><strong>手法</strong></p>
<p>  <code>array_split</code>, <code>column_stack</code>, <code>concatenate</code>, <code>diagonal</code>, <code>dsplit, dstack</code>, <code>hsplit</code>, <code>hstack</code>, <code>ndarray.item</code>, <code>newaxis</code>, <code>ravel</code>, <code>repeat</code>, <code>reshape</code>, <code>resize</code>, <code>squeeze</code>, <code>swapaxes</code>, <code>take</code>, <code>transpose</code>, <code>vsplit</code>, <code>vstack</code></p>
</li>
<li><p><strong>问题</strong></p>
<p>  <code>all</code>, <code>any</code>, <code>nonzero</code>, <code>where</code></p>
</li>
<li><p><strong>排序</strong></p>
<p>  <code>argmax</code>, <code>argmin</code>, <code>argsort</code>, <code>max</code>, <code>min</code>, <code>ptp</code>, <code>searchsorted</code>, <code>sort</code></p>
</li>
<li><p><strong>操作</strong></p>
<p>  <code>choose</code>, <code>compress</code>, <code>cumprod</code>, <code>cumsum</code>, <code>inner</code>, <code>ndarray.fill</code>, <code>imag</code>, <code>prod</code>, <code>put</code>, <code>putmask</code>, <code>real</code>, <code>sum</code></p>
</li>
<li><p><strong>基本统计</strong></p>
<p>  <code>cov</code>,<code>mean</code>,<code>std</code>,<code>var</code></p>
</li>
<li><p><strong>基本线性代数</strong></p>
<p>  <code>cross</code>,<code>dot</code>,<code>outer</code>,<code>linalg.svd</code>,<code>vdot</code></p>
</li>
</ul>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>广播允许通用方法以有意义的方式处理形状不完全相同的输入。</p>
<p>广播第一法则是，如果所有的输入数组维度不都相同，一个“1”将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</p>
<p>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</p>
<p>应用广播法则之后，所有数组的大小必须匹配。更多细节可以从这个<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">文档</a>找到。</p>
<h3 id="花哨的索引和索引技巧"><a href="#花哨的索引和索引技巧" class="headerlink" title="花哨的索引和索引技巧"></a>花哨的索引和索引技巧</h3><p>NumPy提供比常规Python序列更多的索引功能。正如我们前面看到的，除了通过整数和切片进行索引之外，还可以使用整数和布尔数组数组对索引进行索引。</p>
<h4 id="通过数组索引"><a href="#通过数组索引" class="headerlink" title="通过数组索引"></a>通过数组索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)**<span class="number">2</span>          <span class="comment"># 前12个方格</span></span><br><span class="line">i = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>])     <span class="comment"># 一个索引数组</span></span><br><span class="line">a[i]                          <span class="comment"># 一个在位置i的元素</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 1,  1,  9, 64, 25])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = np.array([[ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span>]])  <span class="comment"># 一个二维索引数组</span></span><br><span class="line">a[j]                              <span class="comment"># 与j的shape相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 9, 16],
       [81, 49]])
</code></pre><p>当被索引数组<code>a</code>是多维的时，每一个唯一的索引数列指向<code>a</code>的第一维。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">palette = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],           <span class="comment"># 黑</span></span><br><span class="line">                    [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],         <span class="comment"># 红</span></span><br><span class="line">                    [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],         <span class="comment"># 绿</span></span><br><span class="line">                    [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],         <span class="comment"># 蓝</span></span><br><span class="line">                    [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]      <span class="comment"># 白</span></span><br><span class="line">                   ])</span><br><span class="line">image = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],           <span class="comment"># 每个值对应调色板中的颜色</span></span><br><span class="line">                  [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>]</span><br><span class="line">                 ])</span><br><span class="line"></span><br><span class="line">palette[image]                         </span><br></pre></td></tr></table></figure>
<pre><code>array([[[  0,   0,   0],
        [255,   0,   0],
        [  0, 255,   0],
        [  0,   0,   0]],

       [[  0,   0,   0],
        [  0,   0, 255],
        [255, 255, 255],
        [  0,   0,   0]]])
</code></pre><p>我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = np.array([[<span class="number">0</span>,<span class="number">1</span>],    <span class="comment"># indices for the first dim of a</span></span><br><span class="line">             [<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">j = np.array([[<span class="number">2</span>,<span class="number">1</span>],    <span class="comment"># indices for the second dim</span></span><br><span class="line">             [<span class="number">3</span>,<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">a[i,j]                  <span class="comment"># i 和 j必须拥有相同的shape</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  6],
       [ 6, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,j]</span><br></pre></td></tr></table></figure>
<pre><code>array([[[ 2,  1],
        [ 3,  3]],

       [[ 6,  5],
        [ 7,  7]],

       [[10,  9],
        [11, 11]]])
</code></pre><p>当然，我们可以将<code>i</code>和<code>j</code>放入一个序列中（比如说一个列表），然后用列表进行索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [i,j]</span><br><span class="line">a[l]        <span class="comment"># 相当于一个[i,j]</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre><p>但是，我们不能将<code>i</code>和<code>j</code>放进一个数组，因为这个数组将被解读为a的第一个维度的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = np.array([i,j])</span><br><span class="line">a[s]     <span class="comment"># 结果不是我们想要的</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

IndexError                                Traceback (most recent call last)

&lt;ipython-input-204-79ccae1d198c&gt; in &lt;module&gt;()
      1 s = np.array([i,j])
----&gt; 2 a[s]     # 结果不是我们想要的


IndexError: index 3 is out of bounds for axis 0 with size 3
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="built_in">tuple</span>(s)]     <span class="comment"># 与 a[i,j]相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 2,  5],
       [ 7, 11]])
</code></pre><p>另一个常用的数组索引用法是搜索时间序列最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)    <span class="comment"># 时间尺度</span></span><br><span class="line">data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)  <span class="comment"># 4个时间依赖序列</span></span><br><span class="line">time</span><br></pre></td></tr></table></figure>
<pre><code>array([  20.  ,   51.25,   82.5 ,  113.75,  145.  ])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.        ,  0.84147098,  0.90929743,  0.14112001],
       [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],
       [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],
       [-0.53657292,  0.42016704,  0.99060736,  0.65028784],
       [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ind = data.argmax(axis=<span class="number">0</span>)    <span class="comment"># 每个序列的最大值的索引</span></span><br><span class="line">ind</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 0, 3, 1])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_max = time[ind]         <span class="comment"># 时间序列对应的最大值</span></span><br><span class="line">data_max = data[ind, <span class="built_in">range</span>(data.shape[<span class="number">1</span>])]  <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></span><br><span class="line"></span><br><span class="line">time_max</span><br></pre></td></tr></table></figure>
<pre><code>array([  82.5 ,   20.  ,  113.75,   51.25])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_max</span><br></pre></td></tr></table></figure>
<pre><code>array([ 0.98935825,  0.84147098,  0.99060736,  0.6569866 ])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">all</span>(data_max == data.<span class="built_in">max</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>你也可以使用数组索引作为目标来赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 1, 2, 3, 4])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 0, 2, 0, 0])
</code></pre><p>然而，当一个索引列表包含重复时，赋值被多次完成，保留最后一次的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([2, 1, 3, 3, 4])
</code></pre><p>这足够合理，但是小心如果你想用Python的<code>+=</code>结构，可能结果并非你所期望：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]] += <span class="number">1</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([1, 1, 3, 3, 4])
</code></pre><p>即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求<code>a+=1</code>和<code>a=a+1</code>等同。</p>
<h4 id="通过布尔数组索引"><a href="#通过布尔数组索引" class="headerlink" title="通过布尔数组索引"></a>通过布尔数组索引</h4><p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p>
<p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b = a &gt; <span class="number">4</span></span><br><span class="line">b                   <span class="comment"># b 是一个和a形状相同的boolean数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[False, False, False, False],
       [False,  True,  True,  True],
       [ True,  True,  True,  True]], dtype=bool)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b]                <span class="comment"># 经过筛选后的1维数组</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 5,  6,  7,  8,  9, 10, 11])
</code></pre><p>这个属性在赋值时非常有用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[b] = <span class="number">0</span>            <span class="comment"># 将a中所有比4大的元素赋值为0</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 1, 2, 3],
       [4, 0, 0, 0],
       [0, 0, 0, 0]])
</code></pre><p>你可以参考曼德博集合示例看看如何使用布尔索引来生成<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Mandelbrot_set">曼德博集合</a>的图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span>(<span class="params">h,w,maxit=<span class="number">20</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个尺寸为（h,w）的曼德博分形图&quot;&quot;&quot;</span></span><br><span class="line">    y,x = np.ogrid[ -<span class="number">1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, -<span class="number">2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span>]</span><br><span class="line">    c = x+y * <span class="number">1j</span></span><br><span class="line">    z = c</span><br><span class="line">    divtime = maxit + np.zeros(z.shape,dtype=<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxit):</span><br><span class="line">        z = z**<span class="number">2</span> + c</span><br><span class="line">        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>    <span class="comment"># who is diverging</span></span><br><span class="line">        div_now = diverge &amp; (divtime == maxit)  <span class="comment"># who is diverging now</span></span><br><span class="line">        divtime[div_now] = i                    <span class="comment"># note when</span></span><br><span class="line">        z[diverge] = <span class="number">2</span>                          <span class="comment"># avoid diverging too much</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> divtime</span><br><span class="line"></span><br><span class="line">plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_05_11/output_194_0.png" alt="png"></p>
<p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">b1 = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>])    <span class="comment"># 第一维的筛选</span></span><br><span class="line">b2 = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])  <span class="comment"># 第二维的筛选</span></span><br><span class="line"></span><br><span class="line">a[b1,:]       <span class="comment"># 选择行</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b1]         <span class="comment"># 和上面相同</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[:,b2]       <span class="comment"># 选择列</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0,  2],
       [ 4,  6],
       [ 8, 10]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[b1,b2]      <span class="comment"># 一个奇怪的结果</span></span><br></pre></td></tr></table></figure>
<pre><code>array([ 4, 10])
</code></pre><p>注意一维数组的长度必须和你想要切片的维度或轴的长度一致，在之前的例子中，<code>b1</code>是一个秩为1长度为三的数组(<code>a</code>的行数)，<code>b2</code>(长度为4)与<code>a</code>的第二秩(列)相一致。</p>
<h4 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a>ix_()函数</h4><p><code>ix_</code>函数可以为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算a+b*c：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line">c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line">ax,bx,cx = np.ix_(a,b,c)</span><br><span class="line">ax</span><br></pre></td></tr></table></figure>
<pre><code>array([[[2]],

       [[3]],

       [[4]],

       [[5]]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bx</span><br></pre></td></tr></table></figure>
<pre><code>array([[[8],
        [5],
        [4]]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx</span><br></pre></td></tr></table></figure>
<pre><code>array([[[5, 4, 6, 8, 3]]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.shape, bx.shape, cx.shape</span><br></pre></td></tr></table></figure>
<pre><code>((4, 1, 1), (1, 3, 1), (1, 1, 5))
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = ax + bx * cx</span><br><span class="line">result</span><br></pre></td></tr></table></figure>
<pre><code>array([[[42, 34, 50, 66, 26],
        [27, 22, 32, 42, 17],
        [22, 18, 26, 34, 14]],

       [[43, 35, 51, 67, 27],
        [28, 23, 33, 43, 18],
        [23, 19, 27, 35, 15]],

       [[44, 36, 52, 68, 28],
        [29, 24, 34, 44, 19],
        [24, 20, 28, 36, 16]],

       [[45, 37, 53, 69, 29],
        [30, 25, 35, 45, 20],
        [25, 21, 29, 37, 17]]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>17
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">3</span>] + b[<span class="number">2</span>] * c[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<pre><code>17
</code></pre><p>你也可以实行如下简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufunc_reduce</span>(<span class="params">ufct, *vectors</span>):</span></span><br><span class="line">    vs = np.ix_(*vectors)</span><br><span class="line">    r = ufct.identity</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> vs:</span><br><span class="line">        r = ufct(r,v)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>然后这样使用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufunc_reduce(np.add,a,b,c)</span><br></pre></td></tr></table></figure>
<pre><code>array([[[15, 14, 16, 18, 13],
        [12, 11, 13, 15, 10],
        [11, 10, 12, 14,  9]],

       [[16, 15, 17, 19, 14],
        [13, 12, 14, 16, 11],
        [12, 11, 13, 15, 10]],

       [[17, 16, 18, 20, 15],
        [14, 13, 15, 17, 12],
        [13, 12, 14, 16, 11]],

       [[18, 17, 19, 21, 16],
        [15, 14, 16, 18, 13],
        [14, 13, 15, 17, 12]]])
</code></pre><p>这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。</p>
<h4 id="用字符串索引"><a href="#用字符串索引" class="headerlink" title="用字符串索引"></a>用字符串索引</h4><p>参加<a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy/user/basics.rec.html#structured-arrays">结构化数组</a>。</p>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>继续前进，基本线性代数包含在这里。</p>
<h4 id="简单数组运算"><a href="#简单数组运算" class="headerlink" title="简单数组运算"></a>简单数组运算</h4><p>参考numpy文件夹中的linalg.py获得更多信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1.0</span>,<span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1.  2.]
 [ 3.  4.]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.transpose()</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.,  3.],
       [ 2.,  4.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.inv(a)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-2. ,  1. ],
       [ 1.5, -0.5]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;  单位矩阵</span></span><br><span class="line">u</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 1.,  0.],
       [ 0.,  1.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = np.array([[<span class="number">0.0</span>, -<span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">np.dot(j, j)   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[-1.,  0.],
       [ 0., -1.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.trace(u)    <span class="comment"># trace</span></span><br></pre></td></tr></table></figure>
<pre><code>2.0
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = np.array([[<span class="number">5.</span>],[<span class="number">7.</span>]])</span><br><span class="line">np.linalg.solve(a, y)</span><br></pre></td></tr></table></figure>
<pre><code>array([[-3.],
       [ 4.]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.eig(j)</span><br></pre></td></tr></table></figure>
<pre><code>(array([ 0.+1.j,  0.-1.j]),
 array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],
        [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Parameters:</span><br><span class="line">    square matrix</span><br><span class="line">Returns</span><br><span class="line">    The eigenvalues, each repeated according to its multiplicity.</span><br><span class="line">    The normalized (unit &quot;length&quot;) eigenvectors, such that the</span><br><span class="line">    column &#96;&#96;v[:,i]&#96;&#96; is the eigenvector corresponding to the</span><br><span class="line">    eigenvalue &#96;&#96;w[i]&#96;&#96; .</span><br></pre></td></tr></table></figure>
<h3 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="技巧和提示"></a>技巧和提示</h3><p>下面我们给出简短和有用的提示。</p>
<h4 id="“自动”改变形状"><a href="#“自动”改变形状" class="headerlink" title="“自动”改变形状"></a>“自动”改变形状</h4><p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">30</span>)</span><br><span class="line">a.shape = <span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>  <span class="comment"># -1 意味着 “无论需要什么”</span></span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure>
<pre><code>(2, 5, 3)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11],
        [12, 13, 14]],

       [[15, 16, 17],
        [18, 19, 20],
        [21, 22, 23],
        [24, 25, 26],
        [27, 28, 29]]])
</code></pre><h4 id="向量组合-stacking"><a href="#向量组合-stacking" class="headerlink" title="向量组合(stacking)"></a>向量组合(stacking)</h4><p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果<code>x</code>和<code>y</code>是两个相同长度的向量，你仅仅需要做<code>m=[x;y]</code>。在NumPy中这个过程通过函数<code>column_stack</code>、<code>dstack</code>、<code>hstack</code>和<code>vstack</code>来完成，取决于你想要在那个维度上组合。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)      <span class="comment"># x = ([0,2,4,6,8])</span></span><br><span class="line">y = np.arange(<span class="number">5</span>)           <span class="comment"># y = ([0,1,2,3,4])</span></span><br><span class="line">m = np.vstack([x,y])       <span class="comment"># m=([[0,2,4,6,8],</span></span><br><span class="line">                           <span class="comment">#     [0,1,2,3,4]])</span></span><br><span class="line">m</span><br></pre></td></tr></table></figure>
<pre><code>array([[0, 2, 4, 6, 8],
       [0, 1, 2, 3, 4]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xy = np.hstack([x,y])      <span class="comment"># xy = ([0,2,4,6,8,0,1,2,3,4])</span></span><br><span class="line">xy</span><br></pre></td></tr></table></figure>
<pre><code>array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])
</code></pre><h4 id="直方图-histogram"><a href="#直方图-histogram" class="headerlink" title="直方图(histogram)"></a>直方图(histogram)</h4><p>NumPy中<code>histogram</code>函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：<code>matplotlib</code>也有一个用来建立直方图的函数(叫作<code>hist</code>,正如matlab中一样)与NumPy中的不同。主要的差别是<code>pylab.hist</code>自动绘制直方图，而<code>numpy.histogram</code>仅仅产生数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 简历一个拥有10000个元素的正态分布的向量，方差为0.5^2，均值为2</span></span><br><span class="line">mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></span><br><span class="line">v = np.random.normal(mu,sigma,<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># 绘制分成50份的正态分布直方图</span></span><br><span class="line">plt.hist(v, bins=<span class="number">50</span>, normed=<span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_05_11/output_232_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用numpy计算直方图然后绘制它</span></span><br><span class="line">(n, bins) = np.histogram(v, bins=<span class="number">50</span>, normed=<span class="literal">True</span>)  <span class="comment"># NumPy version (no plot)</span></span><br><span class="line">plt.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:-<span class="number">1</span>]), n)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/img/18_05_11/output_233_0.png" alt="png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/03/Docker%E5%85%A5%E9%97%A8Part6-%E5%8F%91%E5%B8%83%E4%BD%A0%E7%9A%84app/" class="post-title-link" itemprop="url">Docker入门Part6-发布你的app</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-03 14:46:00" itemprop="dateCreated datePublished" datetime="2018-05-03T14:46:00+00:00">2018-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>按照Part3部分，获取<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/overview/">Docker Compos</a>。</li>
<li>按照Part4部分，获取<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/overview/">Docker Machine</a>。</li>
<li>阅读Part1。</li>
<li>学习Part2中的如何创建容器。</li>
<li>确保您的镜像作为一个发布容器在运行。运行这条插入了<code>username</code>、<code>repo</code>和<code>tag</code>信息的命令:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li>
<li>获取到Part5中的最终版本的<code>compose.yml</code>文件。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>您一直在为整个教程编辑相同的Compose文件。那么，我们有一个好消息，这个Compose文件在生产环境中的效果与你的计算机上的效果是相同的。在这里，我们通过一些选项来运行Docker化的程序。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="Docker社区版（云服务提供者）"><a href="#Docker社区版（云服务提供者）" class="headerlink" title="Docker社区版（云服务提供者）"></a>Docker社区版（云服务提供者）</h3><p>如果您可以在生产环境中使用Docker社区版，那么你可以使用Docker Cloud来帮助您管理应用程序，例如Amazon Web Services，DigitalOcean，和Microsoft Azure等常用的服务提供商。</p>
<p>设置和部署：</p>
<ul>
<li>将Docker Cloud与您的首选提供商连接，授予Docker Cloud权限，以便为您自动配置以及为您”Docker化”VM。</li>
<li>使用Docker Cloud创建您的计算资源并创建您的swarm。</li>
<li>部署您的应用。</li>
</ul>
<blockquote>
<p>注意：我们没有链接到Docker Cloud文档。请务必在完成每个步骤后回到此页面。</p>
</blockquote>
<h4 id="连接Docker-Cloud"><a href="#连接Docker-Cloud" class="headerlink" title="连接Docker Cloud"></a>连接Docker Cloud</h4><p>你可以在<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/">标准模式</a>或<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/">swarm模式</a>下运行Docker Cloud。</p>
<p>如果你正在标准模式下运行Docker Cloud，请按照以下说明将您的服务提供商链接到Docker Cloud。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/link-aws-swarm/">Amazon Web Services 设置说明</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/link-do/">DigitalOcean 设置说明</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/link-azure/">Microsoft Azure 设置说明</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/link-packet/">Packet 设置说明</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/link-softlayer/">SoftLayer 设置说明</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/byoh/">使用Docker Cloud 代理来访问自己的主机</a>。</li>
</ul>
<p>如果您在Swarm模式下运行（推荐用于Amazon Web Services或Microsoft Azure），那么请跳至下一节关于如何<a href="#创建你的swarm">创建swarm</a>的部分。</p>
<h3 id="创建你的swarm"><a href="#创建你的swarm" class="headerlink" title="创建你的swarm"></a>创建你的swarm</h3><p>准备好创建一个swarm了吗？</p>
<ul>
<li>如果你在使用Amazon Web Services(AWS)，那么你可以<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-aws/">在AWS上自动地创建一个swarm</a>。</li>
<li>如果你在使用Microsoft Azure，那么你可以<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/create-cloud-swarm-azure/">在Azure上自动地创建一个swarm</a>。</li>
<li>否则，在Docker Cloud UI界面<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/getting-started/your_first_node/">创建你的节点</a>，然后运行<code>docker swarm init</code>并执行在Part4部分所学的<code>docker swarm join</code>命令。最后，通过点击屏幕顶部的开关<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/using-swarm-mode/">启用swarm模式</a>，并<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/">注册你刚刚创建的swarm</a>。</li>
</ul>
<blockquote>
<p>注意：如果您<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/infrastructure/byoh/">使用Docker云代理来自带主机</a>，则此提供程序不支持swarm模式。您可以使用Docker Cloud<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/register-swarms/">注册您自己的现有的swarm</a>。</p>
</blockquote>
<h3 id="在云服务平台上部署你的应用程序"><a href="#在云服务平台上部署你的应用程序" class="headerlink" title="在云服务平台上部署你的应用程序"></a>在云服务平台上部署你的应用程序</h3><ul>
<li><p>1.<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/">通过Docker Cloud连接到你自己的swarm</a>。有几种不同的连接方式：</p>
<ul>
<li><p>从Swarm模式的Docker Cloud Web界面中，选择页面顶部的Swarms，单击要连接的swarm，然后将给定的命令复制粘贴到命令行终端中。</p>
<p><img src="/img/18_05_02/004.png" alt=""></p>
<p>或者。。。</p>
</li>
<li><p>在Docker for Mac或Docker for Windows上，您可以<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/#use-docker-for-mac-or-windows-edge-to-connect-to-swarms">通过桌面应用菜单直接连接到swarm</a>。</p>
<p><img src="/img/18_05_02/005.png" alt=""></p>
<p>无论哪种方式，都将打开一个终端，其上下文是本地计算机，但其Docker命令会路由到云服务提供商上运行的swarm。您可以直接访问本地文件系统和远程swarm，从而启用纯粹的<code>docker</code>命令。</p>
</li>
</ul>
</li>
<li><p>2.运行<code>docker stack deploy -c docker-compose.yml getstartedlab</code>在云托管swarm上部署应用程序。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">	</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">Creating service getstartedlab_visualizer</span><br><span class="line">Creating service getstartedlab_redis</span><br></pre></td></tr></table></figure>
<p>  您的应用现在运行在了云服务平台上了。</p>
</li>
</ul>
<p><strong>运行一些swarm命令来验证部署：</strong></p>
<p>你可以使用swarm命令行，就像你之前做的那样，浏览并管理你的swarm。这里有一些你比较熟悉的例子：</p>
<ul>
<li>使用<code>docker node ls</code>列出节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[getstartedlab] ~ $ docker node ls</span><br><span class="line">ID                            HOSTNAME                                      STATUS              AVAILABILITY        MANAGER STATUS</span><br><span class="line">9442yi1zie2l34lj01frj3lsn     ip-172-31-5-208.us-west-1.compute.internal    Ready               Active              </span><br><span class="line">jr02vg153pfx6jr0j66624e8a     ip-172-31-6-237.us-west-1.compute.internal    Ready               Active              </span><br><span class="line">thpgwmoz3qefdvfzp7d9wzfvi     ip-172-31-18-121.us-west-1.compute.internal   Ready               Active              </span><br><span class="line">n2bsny0r2b8fey6013kwnom3m *   ip-172-31-20-217.us-west-1.compute.internal   Ready               Active              Leader</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>docker service ls</code>列出服务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[getstartedlab] ~&#x2F;sandbox&#x2F;getstart $ docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">x3jyx6uukog9        dockercloud-server-proxy   global              1&#x2F;1                 dockercloud&#x2F;server-proxy          *:2376-&gt;2376&#x2F;tcp</span><br><span class="line">ioipby1vcxzm        getstartedlab_redis        replicated          0&#x2F;1                 redis:latest                      *:6379-&gt;6379&#x2F;tcp</span><br><span class="line">u5cxv7ppv5o0        getstartedlab_visualizer   replicated          0&#x2F;1                 dockersamples&#x2F;visualizer:stable   *:8080-&gt;8080&#x2F;tcp</span><br><span class="line">vy7n2piyqrtr        getstartedlab_web          replicated          5&#x2F;5                 sam&#x2F;getstarted:part6    *:80-&gt;80&#x2F;tcp</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>docker service ps &lt;service&gt;</code>查看service的任务列表。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[getstartedlab] ~&#x2F;sandbox&#x2F;getstart $ docker service ps vy7n2piyqrtr</span><br><span class="line">ID                  NAME                  IMAGE                            NODE                                          DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">qrcd4a9lvjel        getstartedlab_web.1   sam&#x2F;getstarted:part6   ip-172-31-5-208.us-west-1.compute.internal    Running             Running 20 seconds ago                       </span><br><span class="line">sknya8t4m51u        getstartedlab_web.2   sam&#x2F;getstarted:part6   ip-172-31-6-237.us-west-1.compute.internal    Running             Running 17 seconds ago                       </span><br><span class="line">ia730lfnrslg        getstartedlab_web.3   sam&#x2F;getstarted:part6   ip-172-31-20-217.us-west-1.compute.internal   Running             Running 21 seconds ago                       </span><br><span class="line">1edaa97h9u4k        getstartedlab_web.4   sam&#x2F;getstarted:part6   ip-172-31-18-121.us-west-1.compute.internal   Running             Running 21 seconds ago                       </span><br><span class="line">uh64ez6ahuew        getstartedlab_web.5   sam&#x2F;getstarted:part6   ip-172-31-18-121.us-west-1.compute.internal   Running             Running 22 seconds ago        </span><br></pre></td></tr></table></figure>
<p><strong>在云供应商机器上开放服务端口</strong></p>
<p>此时，您的应用作为一个swarm部署在您的云提供商服务器上，正如刚刚运行的<code>docker</code>命令所证明的那样。但是，您仍然需要在云服务器上打开端口，以便：</p>
<ul>
<li>允许在工作节点上的<code>redis</code>服务和<code>web</code>服务之间进行通信</li>
<li>允许入站流量通过worker节点上的<code>web</code>服务，以便可以在浏览器访问Hello World和Visualizer。</li>
<li>允许运行<code>manager</code>的服务器上的入站SSH流量（这可能已在您的云提供商上设置）</li>
</ul>
<p>这些是您需要为每项服务公开的端口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Service</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">协议</th>
<th style="text-align:left">端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>web</code></td>
<td style="text-align:left">HTTP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">80</td>
</tr>
<tr>
<td style="text-align:left"><code>visualizer</code></td>
<td style="text-align:left">HTTP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">8080</td>
</tr>
<tr>
<td style="text-align:left"><code>redis</code></td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left">6379</td>
</tr>
</tbody>
</table>
</div>
<p>具体的做法取决于云服务平台。</p>
<p>我们以Amazon Web Services（AWS）为例。</p>
<blockquote>
<p><strong>redis如何持久化数据？</strong></p>
<p>为了使<code>redis</code>服务正常工作，在运行<code>docker stack deploy</code>之前，需要<code>ssh</code>进入manager运行的云服务器，并在<code>/home/docker/</code>中创建<code>data/</code>目录。另一种选择是将<code>docker-stack.yml</code>中的数据路径更改为manager服务器上已存在的一个路径。此示例不包含此步骤，因此示例输出中的<code>redis</code>服务未启动。</p>
</blockquote>
<p><strong>示例：AWS</strong></p>
<ul>
<li>1.登录<a target="_blank" rel="noopener" href="https://aws.amazon.com/">AWS控制台</a>，转到EC2仪表板，然后单击进入<strong>Running Instances</strong>查看节点。</li>
<li><p>2.在左侧的按钮，进入Network &amp; Security &gt; <strong>Security Groups</strong>。</p>
<p>  请参阅<code>getstartedlab-Manager-&lt;xxx&gt;</code>, <code>getstartedlab-Nodes-&lt;xxx&gt;</code>, 和 <code>getstartedlab-SwarmWide-&lt;xxx&gt;</code>的与swarm相关的安全组。</p>
</li>
<li><p>3.为swarm选择“节点”安全组。组名是这样的：<code>getstartedlab-NodeVpcSG-9HV9SMHDZT8C</code>。</p>
</li>
<li>4.为<code>web</code>，<code>visualizer</code>和<code>redis</code>服务添加入站规则，为每个服务设置类型，协议和端口（如上表所示），然后单击保存以应用规则。</li>
</ul>
<p><img src="/img/18_05_02/006.png" alt=""></p>
<blockquote>
<p>提示：当你保存新的规则时，会为IPv4和IPv6地址自动创建HTTP和TCP端口。</p>
</blockquote>
<p><img src="/img/18_05_02/007.png" alt=""></p>
<ul>
<li>5.进入<strong>Running Instances</strong>列表，获取其中一个worker的公共DNS名称，并将其粘贴到浏览器地址栏中。</li>
</ul>
<p><img src="/img/18_05_02/008.png" alt=""></p>
<p>就像本教程的前几部分一样，Hello World应用程序显示在端口<code>80</code>上，而Visualizer显示在端口<code>8080</code>上。</p>
<p><img src="/img/18_05_02/009.png" alt=""></p>
<p><img src="/img/18_05_02/010.png" alt=""></p>
<h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><p>从这里你可以完成你在教程前面部分学到的所有知识。</p>
<ul>
<li>通过修改<code>docker-compose.yml</code>文件并使用命令<code>docker stack deploy</code>重新发布来扩展你的应用程序。</li>
<li>通过编辑代码更改应用程序行为，然后重新构建并推送新镜像。（要做到这一点，请按照之前用于<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part2/#build-the-app">构建应用程序</a>和<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part2/#publish-the-image">发布镜像</a>的相同步骤）。</li>
<li>您可以使用<code>docker stack rm</code>命令来拆卸堆栈。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>
<p>与在本地Docker机器虚拟机上运行swarm的场景不同，不管您是否关闭本地主机，您的swarm和部署在其上的任何应用程序都将继续在云服务器上运行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/02/Docker%E5%85%A5%E9%97%A8Part5-%E5%A0%86%E6%A0%88/" class="post-title-link" itemprop="url">Docker入门Part5-堆栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-02 17:30:00" itemprop="dateCreated datePublished" datetime="2018-05-02T17:30:00+00:00">2018-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>按照Part3部分，获取<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/overview/">Docker Compos</a>。</li>
<li>按照Part4部分，获取<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/overview/">Docker Machine</a>。</li>
<li>阅读Part1。</li>
<li>学习Part2中的如何创建容器。</li>
<li>确保您已发布了那个<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part2/#share-your-image">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li>
<li>确保你在part4中设置的机器处于运行状态。运行<code>docker-machine ls</code>来验证这一点。如果机器处于停止状态，运行<code>docker-machine start myvm1</code>来启动manager，然后执行<code>docker-machine start myvm2</code>来启动worker。</li>
<li>让你在Part4创建的swarm处于运行状态并准备就绪。运行<code>docker-machine ssh myvm1 &quot;docker node ls&quot;</code>来验证这一点。如果swarm起来了，那么两个node的状态都是<code>ready</code>。如果不是这样，重新初始化swarm，并按照part4中的方式将worker加入到swarm中。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在part4中，你学到了如何设置一个swarm，这是一群运行Docker的机器，并为其部署了一个应用程序，其中容器在多台机器上运行。</p>
<p>在这里的Part5中，您将学习到分布式应用程序层次结构的顶部部分：<strong>堆栈(stack)</strong>。堆栈是一组相互关联的服务，它们可以共享依赖关系，并且可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能（尽管非常复杂的应用程序可能需要使用多个堆栈）。</p>
<p>一些好消息是，从Part3部分开始，在创建Compose文件并使用<code>docker stack deploy</code>时，从技术上讲，您其实一直都在使用堆栈。但这是在单个主机上运行的单个服务堆栈，通常不会发生在生产环境中。在这里，你可以把你学到的东西，使多个服务相互关联，并在多台机器上运行它们。</p>
<p>你做得很好，这就是你的主场！</p>
<h2 id="添加一项新服务并重新部署"><a href="#添加一项新服务并重新部署" class="headerlink" title="添加一项新服务并重新部署"></a>添加一项新服务并重新部署</h2><p>将服务添加到我们的<code>docker-compose.yml</code>文件很容易。首先，我们添加一个免费的可视化工具，让我们看看我们的swarm是如何安排容器的。</p>
<ul>
<li>1.打开<code>docker-compose.yml</code>文件，并用以下内容替换它。确保你的<code>username/repo:tag</code>是正确的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: username&#x2F;repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples&#x2F;visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role &#x3D;&#x3D; manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>这里唯一新增的东西就是<code>visualizer</code>。注意到这里有两个新的东西：一个<code>volumes</code>键，让visualizer可以访问Docker主机的socket文件，这项服务职能在swarm manager上运行。这是因为这个容器是由Docker创建的<a target="_blank" rel="noopener" href="https://github.com/ManoMarks/docker-swarm-visualizer">一个开源项目</a>构建的，它显示了一个图表中的swarm运行的Docker服务。</p>
<p>我们稍后会详细讨论放置约束和体积。</p>
<ul>
<li><p>2.确保你的shell被配置为与myvm1进行通信（完整的例子在<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager">这里</a>）。</p>
<ul>
<li>运行<code>docker-machine ls</code>来列出机器，并确保您已连接到<code>myvm1</code>，如旁边的星号所示。</li>
<li><p>如果需要，重新运行<code>docker-machine env myvm1</code>，然后运行给定的命令来配置shell。</p>
<p>在Mac或者Linux上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>在Windows命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3.在manager上重新运行<code>docker stack deploy</code>命令，并且需要更新的任何服务都会更新：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Updating service getstartedlab_web (id: angi1bf5e4to03qu9f93trnxm)</span><br><span class="line">Creating service getstartedlab_visualizer (id: l9mnwkeq2jiononb5ihz9u7a4)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>4.看一下visualizer。</p>
<p>  你可以看到compose文件中的<code>visualizer</code>运行在了8080端口。通过运行<code>docker-machine ls</code>可以获取每个节点的IP地址信息。分别访问任意一个IP地址的8080端口，你可以看到visualizer的运行效果：</p>
<p>  <img src="/img/18_05_02/001.png" alt=""></p>
<p>  <code>visualizer</code>的单个副本按照您的预期在manager上运行，并且<code>web</code>的5个实例遍布整个swarm。你可以通过运行<code>docker stack ps &lt;stack&gt;</code>来确认可视化的结果：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack ps getstartedlab</span><br></pre></td></tr></table></figure>
<p>  可视化器是一个独立的服务，可以在包含它的任何应用程序中运行。它不依赖于其他任何东西。现在让我们创建一个具有依赖关系的服务：提供访问者计数器的Redis服务。</p>
</li>
</ul>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p>
<ul>
<li>1.保存这个在最后位置添加Redis服务的新的<code>docker-compose.yml</code>文件。确保替换镜像详情部分的<code>username/repo:tag</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: username&#x2F;repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples&#x2F;visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role &#x3D;&#x3D; manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;home&#x2F;docker&#x2F;data:&#x2F;data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role &#x3D;&#x3D; manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>Redis在Docker库中有一个官方镜像，并已被授予<code>redis</code>作为镜像的简称，所以在这里没有<code>username/repo</code>符号。Redis端口6379已经由Redis预配置为从容器暴露给主机，在我们的Compose文件中，我们将它从主机展示给全世界，因此，如果您愿意，您可以将任何节点的IP输入到Redis桌面管理器中，并管理此Redis实例。</p>
<p>最重要的是，<code>redis</code>规范中有几件事情使数据在这个堆栈的部署之间持续存在：</p>
<ul>
<li><code>redis</code>总是在manager上运行，所以它总是使用相同的文件系统。</li>
<li><code>redis</code>在主机文件系统中访问任意目录作为容器内的<code>/data</code>，这是Redis存储数据的地方。</li>
</ul>
<p>这就是在您的主机物理文件系统中为Redis数据创建“真相源”。如果没有这个，Redis会将其数据存储在容器文件系统中的<code>/data</code>中，如果该容器曾经被重新部署，该数据将被清除。</p>
<p>这个真相的来源有两个组成部分：</p>
<ul>
<li>放置在Redis服务上的放置约束，确保它始终使用相同的主机。</li>
<li>您创建的容器，允许容器作为<code>./data</code>（位于Redis容器内）访问<code>./data</code>（在主机上）。在容器来来去去时，存储在指定主机上的<code>./data</code>文件仍然存在，从而保持连续性。</li>
</ul>
<p>您已准备好部署新的供Redis使用的堆栈了。</p>
<ul>
<li>2.在manager上创建一个<code>./data</code>目录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh myvm1 &quot;mkdir .&#x2F;data&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>3.确保你的shell被配置为与<code>myvm1</code>进行通信(完整的例子在<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager">这里</a>)。</p>
<ul>
<li>运行<code>docker-machine ls</code>列出机器，并确保你已经连接到了<code>myvm1</code>，由旁边的星号所指示。</li>
<li><p>如果需要的话，重新运行<code>docker-machine env myvm1</code>，然后运行下面给出的命令来配置shell。</p>
<p>在Mac或Linux上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>在Windows上命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>4.再次运行<code>docker stack deploy</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<ul>
<li>5.运行<code>docker service ls</code>来验证三个服务处于运行状态：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">x7uij6xb4foj        getstartedlab_redis        replicated          1&#x2F;1                 redis:latest                      *:6379-&gt;6379&#x2F;tcp</span><br><span class="line">n5rvhm52ykq7        getstartedlab_visualizer   replicated          1&#x2F;1                 dockersamples&#x2F;visualizer:stable   *:8080-&gt;8080&#x2F;tcp</span><br><span class="line">mifd433bti1d        getstartedlab_web          replicated          5&#x2F;5                 orangesnap&#x2F;getstarted:latest    *:80-&gt;80&#x2F;tcp</span><br></pre></td></tr></table></figure>
<ul>
<li>6.检查位于你的某个节点的网页，例如<code>http://192.168.99.101</code>，然后看访问者计数器的结果，该计数器现在已经存在并将信息存储在Redis上。</li>
</ul>
<p><img src="/img/18_05_02/002.png" alt=""></p>
<p>另外，请检查任一节点IP地址的端口8080处的可视化工具，并注意查看随<code>web</code>和<code>visualizer</code>工具一起运行的<code>redis</code>服务。</p>
<p><img src="/img/18_05_02/003.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/Docker%E5%85%A5%E9%97%A8Part4-Swarms/" class="post-title-link" itemprop="url">Docker入门Part4-Swarms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-26 13:46:00" itemprop="dateCreated datePublished" datetime="2018-04-26T13:46:00+00:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>按照Part3部分，获取<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/overview/">Docker Compos</a>。</li>
<li>获取预装<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a>和<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/">Docker for Windows</a>的<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/overview/">Docker Machine</a>，但在Linux系统上需要<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/install-machine/#installing-machine-directly">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统之前以及Windows 10 Home中，使用<a target="_blank" rel="noopener" href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>。</li>
<li>阅读Part1。</li>
<li>学习Part2中的如何创建容器。</li>
<li>确保您已发布了那个<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part2/#share-your-image">推送到仓库的</a><code>friendlyhello</code>镜像。我们在这里使用该共享镜像。</li>
<li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li>
<li>有一份Part3中的<code>docker-compose.yml</code>。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Part3中，你介绍了在Part2中编写的应用程序，并通过将其转化为service来定义应该如何在生产环境中运行，并在其进程内扩大5倍。</p>
<p>在Part4部分，您将此应用程序部署到集群上，并在多台机器上运行它。通过将多台机器连接到称为<strong>swarm</strong>的“Dockerized”群集，使多容器，多机器应用成为可能。</p>
<h2 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h2><p>Swarm是一组运行Docker并加入到集群中的机器。发生这种情况后，您将继续运行您习惯的Docker命令，但现在它们将由<strong>swarm manager</strong>在群集上执行。swarm中的机器可以是物理的或虚拟的。加入swarm后，他们被称为节点。</p>
<p>swarm管理器可以使用几种策略来运行容器，例如“emptiest node”—它用容器填充最少使用的机器。或者“global”，它可以确保每台机器只获取指定容器的一个实例。您指示swarm manager在Compose文件中使用这些策略，就像您已经使用的策略一样。</p>
<p>swarm manager是群体中唯一可以执行你的命令，或者授权其他机器作为<strong>worker</strong>加入群体的机器。worker只是提供能力，并没有权力告诉任何其他机器它能做什么和不能做什么。</p>
<p>到目前为止，您已经在本地机器上以单主机模式使用Docker。但是Docker也可以切换到<strong>swarm模式</strong>，这就是使用群集的原因。立即启用swarm模式使当前的机器成为swarm manager。从此，Docker将运行您在您管理的swarm上执行的命令，而不仅仅是在当前机器上执行。</p>
<h2 id="设置你的swarm"><a href="#设置你的swarm" class="headerlink" title="设置你的swarm"></a>设置你的swarm</h2><p>一个swarm是由多个节点组成，这些节点可以是物理机或虚拟机。基本概念很简单：运行<code>docker swarm init</code>来启用swarm模式，并使您当前的机器成为swarm管理器，然后在其他机器上运行<code>docker swarm join</code>，使其他机器以worker的身份加入到swarm中。我们将使用虚拟机快速创建一个双机群集，并将其变成swarm。</p>
<h3 id="创建一个集群"><a href="#创建一个集群" class="headerlink" title="创建一个集群"></a>创建一个集群</h3><h4 id="本地虚拟机（Mac，Linux，Windows-7和8）"><a href="#本地虚拟机（Mac，Linux，Windows-7和8）" class="headerlink" title="本地虚拟机（Mac，Linux，Windows 7和8）"></a>本地虚拟机（Mac，Linux，Windows 7和8）</h4><p>您需要一个可以创建虚拟机（VM）的虚拟机管理程序，因此请为您的计算机的操作系统<a target="_blank" rel="noopener" href="https://www.virtualbox.org/wiki/Downloads">安装Oracle VirtualBox</a>。</p>
<blockquote>
<p>注意：如果你在Windows系统下，并且已经安装了Hyper-V，例如Windows 10，那就没必要安装VirtualBox了，你可以使用Hyper-V替代。如果你正在使用<a target="_blank" rel="noopener" href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>，你应该已经安装好了VirtualBox。</p>
</blockquote>
<p>现在，使用<code>docker-machine</code>创建两个虚拟机VM，使用VirtualBox驱动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1</span><br><span class="line">docker-machine create --driver virtualbox myvm2</span><br></pre></td></tr></table></figure>
<h4 id="本地虚拟机（Windows-10-Hyper-V）"><a href="#本地虚拟机（Windows-10-Hyper-V）" class="headerlink" title="本地虚拟机（Windows 10/Hyper-V）"></a>本地虚拟机（Windows 10/Hyper-V）</h4><p>首先，快速为您的虚拟机（VM）创建一个虚拟交换机以便共享，以便它们可以相互连接。</p>
<ul>
<li>1.开启 Hyper-V Manager</li>
<li>2.点击右上角菜单中的<strong>Virtual Switch Manager</strong></li>
<li>3.单击创建类型为<strong>External</strong>的<strong>虚拟交换机</strong></li>
<li>4.将它命名为<code>myswitch</code>，然后选中复选框以共享主机的活动网络适配器</li>
</ul>
<p>现在，使用我们的节点管理工具<code>docker-machine</code>创建几个虚拟机：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm2</span><br></pre></td></tr></table></figure></h2><h3 id="列出虚拟机，并显示其IP地址"><a href="#列出虚拟机，并显示其IP地址" class="headerlink" title="列出虚拟机，并显示其IP地址"></a>列出虚拟机，并显示其IP地址</h3><p>你现在创建了两个虚拟机，名叫<code>myvm1</code>和<code>myvm2</code>。</p>
<p>使用下面的命令来列出这些虚拟机以及他们的IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure>
<p>这里是这个命令的输出示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce   </span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce   </span><br></pre></td></tr></table></figure>
<h3 id="初始化swarm和节点"><a href="#初始化swarm和节点" class="headerlink" title="初始化swarm和节点"></a>初始化swarm和节点</h3><p>第一台机器作为manager，它负责执行管理命令并认证worker机器加入集群，第二台机器是worker。</p>
<p>你可以对你的虚拟机通过<code>docker-machine ssh</code>来发送命令。通过执行<code>docker swarm init</code>来指导<code>myvm1</code>来成为swarm manager，然后你会看到像下面这样的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line">Swarm initialized: current node &lt;node ID&gt; is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">  docker swarm join \</span><br><span class="line">  --token &lt;token&gt; \</span><br><span class="line">  &lt;myvm ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>端口2377和2376</strong></p>
<p>始终使用端口2377（群管理端口）运行<code>docker swarm init</code>和<code>docker swarm join</code>，或根本不指定运行端口，并让其采用默认值。</p>
<p>由<code>docker-machine ls</code>返回的计算机IP地址包括端口2376，它是Docker守护进程端口。请勿使用此端口，否则<a target="_blank" rel="noopener" href="https://forums.docker.com/t/docker-swarm-join-with-virtualbox-connection-error-13-bad-certificate/31392/2">可能会遇到错误</a>。</p>
<p><strong>无法使用SSH？试试—native-ssh标志</strong></p>
<p>如果由于某些原因，您无法将命令发送给Swarm管理器，Docker Machine可以<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/reference/ssh/#different-types-of-ssh">选择让您使用自己的系统的SSH</a>。只需在调用<code>ssh</code>命令时指定<code>--native-ssh</code>标志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine --native-ssh ssh myvm1 ...</span><br></pre></td></tr></table></figure>
<p>如您所见，对<code>docker swarm init</code>的响应包含一个预配置的<code>docker swarm join</code>命令，您可以在要添加的任何节点上运行该命令。复制这条命令，并通过<code>docker-machine ssh</code>发送到<code>myvm2</code>，使<code>myvm2</code>作为woker的角色来加入到你新创建的集群中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 &quot;docker swarm join \</span><br><span class="line">--token &lt;token&gt; \</span><br><span class="line">&lt;ip&gt;:2377&quot;</span><br><span class="line"></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>
<p>恭喜，您已经创建了您的第一个swarm集群！</p>
<p>在manager机器上运行<code>docker node ls</code>来查看swarm中的node：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker node ls&quot;</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</span><br><span class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2               Ready               Active</span><br><span class="line">rihwohkh3ph38fhillhhb84sk *   myvm1               Ready               Active              Leader</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>离开一个swarm</strong></p>
<p>如果你的某个节点想要退出集群，你可以在节点上运行<code>docker swarm leave</code>。</p>
</blockquote>
<h2 id="发布你的应用到swarm集群"><a href="#发布你的应用到swarm集群" class="headerlink" title="发布你的应用到swarm集群"></a>发布你的应用到swarm集群</h2><p>最困难的部分已经结束了。现在你只需重复第3部分用于部署新swarm的流程即可。请记住，只有像<code>myvm1</code>这样的群集管理器才能执行Docker命令；worker机器只是提供使用而已。</p>
<h3 id="为swarm-manager配置docker-machine-shell"><a href="#为swarm-manager配置docker-machine-shell" class="headerlink" title="为swarm manager配置docker-machine shell"></a>为swarm manager配置<code>docker-machine</code> shell</h3><p>到目前为止，你已经可以在<code>docker-machine ssh</code>中包裹Docker命令来在虚拟机上执行指令了。另一种选择是运行<code>docker-machine env &lt;machine&gt;</code>来获取并执行一个命令，该命令将当前shell配置为与虚拟机上的Docker守护进程进行通信。此方法对下一步更有利，因为它允许您使用本地<code>docker-compose.yml</code>文件“远程”部署应用程序，而无需将其复制到任何位置。</p>
<p>键入<code>docker-machine env myvm1</code>，然后复制粘贴并运行作为输出最后一行提供的命令，这样可以将shell配置为swarm manager可以与<code>myvm1</code>进行对话。</p>
<p>配置shell的命令根据你是Mac，Linux还是Windows而有所不同。</p>
<h4 id="Mac，Linux"><a href="#Mac，Linux" class="headerlink" title="Mac，Linux"></a>Mac，Linux</h4><p>Mac或Linux上的Docker Machine shell</p>
<p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line">export DOCKER_TLS_VERIFY&#x3D;&quot;1&quot;</span><br><span class="line">export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH&#x3D;&quot;&#x2F;Users&#x2F;sam&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;myvm1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME&#x3D;&quot;myvm1&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure>
<p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce   </span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce   </span><br></pre></td></tr></table></figure>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>运行<code>docker-machine env myvm1</code>来获取与<code>myvm1</code>进行交互的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\sam\sandbox\get-started&gt; docker-machine env myvm1</span><br><span class="line">$Env:DOCKER_TLS_VERIFY &#x3D; &quot;1&quot;</span><br><span class="line">$Env:DOCKER_HOST &#x3D; &quot;tcp:&#x2F;&#x2F;192.168.203.207:2376&quot;</span><br><span class="line">$Env:DOCKER_CERT_PATH &#x3D; &quot;C:\Users\sam\.docker\machine\machines\myvm1&quot;</span><br><span class="line">$Env:DOCKER_MACHINE_NAME &#x3D; &quot;myvm1&quot;</span><br><span class="line">$Env:COMPOSE_CONVERT_WINDOWS_PATHS &#x3D; &quot;true&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># &amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>运行给出的命令，来配置你的shell来与<code>myvm1</code>进行交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>运行<code>docker-machine ls</code>以验证<code>myvm1</code>处于激活状态，星号表示激活状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:PATH&gt; docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER   STATE     URL                          SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        hyperv   Running   tcp:&#x2F;&#x2F;192.168.203.207:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        hyperv   Running   tcp:&#x2F;&#x2F;192.168.200.181:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure>
<h3 id="在swarm-manager上发布应用"><a href="#在swarm-manager上发布应用" class="headerlink" title="在swarm manager上发布应用"></a>在swarm manager上发布应用</h3><p>现在你已经拥有了<code>myvm1</code>，你可以使用它的权力作为swarm manager来部署你的应用，方法是使用第三部分中的<code>docker stack deploy</code>命令将你的本地副本<code>docker-compose.yml</code>发布到<code>myvm1</code>。这个命令也许会花费几秒钟时间来完成这一操作，部署需要花一段时间才能完成。在swarm manager上使用<code>docker service ps &lt;service_name&gt;</code>命令验证所有服务是否已被重新部署。</p>
<p>您通过<code>docker-machine shell</code>配置链接到<code>myvm1</code>，并且您仍然可以访问本地主机上的文件。确保你和之前在同一个目录下，并且其中包括你在第3部分中创建的<code>docker-compose.yml</code>文件。</p>
<p>就像之前一样，运行以下命令在<code>myvm1</code>上部署应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>就是这样，该应用程序就成功部署在了swarm集群上了！</p>
<blockquote>
<p>注意：如果你的镜像保存在了一个私有仓库而不是Docker Hub上，你需要登录到通过命令<code>docker login &lt;your-registry&gt;</code>来登录到这个仓库，并且然后你需要在上面的命令添加<code>--with-registry-auth</code>指令。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login registry.example.com</span><br><span class="line"></span><br><span class="line">docker stack deploy --with-registry-auth -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>这使用加密的WAL日志将登录令牌从本地客户端传递到部署服务的群集节点。有了这些信息，这些节点就能够登录到仓库并提取镜像。</p>
</blockquote>
<p>现在你可以使用Part3中的docker命令。只有这次注意到services（和相关容器）已经在<code>myvm1</code>和<code>myvm2</code>之间分配了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ps getstartedlab</span><br><span class="line"></span><br><span class="line">ID            NAME                  IMAGE                   NODE   DESIRED STATE</span><br><span class="line">jq2g3qp8nzwx  getstartedlab_web.1   john&#x2F;get-started:part2  myvm1  Running</span><br><span class="line">88wgshobzoxl  getstartedlab_web.2   john&#x2F;get-started:part2  myvm2  Running</span><br><span class="line">vbb1qbkb0o2z  getstartedlab_web.3   john&#x2F;get-started:part2  myvm2  Running</span><br><span class="line">ghii74p9budx  getstartedlab_web.4   john&#x2F;get-started:part2  myvm1  Running</span><br><span class="line">0prmarhavs87  getstartedlab_web.5   john&#x2F;get-started:part2  myvm2  Running</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用<code>docker-machine env</code>和<code>docker-machine ssh</code>连接到VM</strong></p>
<ul>
<li><p>要将shell设置为与<code>myvm2</code>等其他机器通信，只需在相同或不同的shell中重新运行<code>docker-machine env</code>，然后运行给定的命令以指向<code>myvm2</code>。这里指的是当前的shell。如果你更改为未配置的shell或打开一个新的shell，则需要重新运行这些命令。使用<code>docker-machine ls</code>列出机器列表，查看它们所处的状态，获取IP地址，如果有的话，并找出具体连接到的是哪一个地址。更多请参阅<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/get-started/#create-a-machine">Docker Machine getting started topics</a>。</p>
</li>
<li><p>或者，你可以以<code>docker-machine ssh &lt;machine&gt; &quot;&lt;command&gt;&quot;</code>的形式来打包Docker命令，该命令可以直接登陆到VM，但不会立即访问本地主机上的文件。</p>
</li>
<li><p>在Mac和Linux上，你可以使用<code>docker-machine scp &lt;file&gt; &lt;machine&gt;:~</code>来在机器间复制文件，但在Windows上，需要使用一个Linux类似<a target="_blank" rel="noopener" href="https://git-for-windows.github.io/">Git Bash</a>的终端模拟器来完成这类工作。</p>
</li>
</ul>
<p>本教程演示了<code>docker-machine ssh</code>和<code>docker-machine env</code>因为这些都可以通过<code>docker-machine</code>CLI在平台上使用。</p>
</blockquote>
<h3 id="访问你的集群"><a href="#访问你的集群" class="headerlink" title="访问你的集群"></a>访问你的集群</h3><p>你可以从<code>myvm1</code>或<code>myvm2</code>的IP地址访问您的应用程序。</p>
<p>你创建的网络在它们之间共享负载均衡。运行<code>docker-machine ls</code>来获取你的VM的IP地址，并通过浏览器访问其中的任何一个，点击刷新（或者仅仅使用<code>curl</code>来访问）</p>
<p><img src="/img/18_04_26/002.png" alt=""></p>
<p>有五个可能的容器ID全部随机循环，体现了负载均衡。</p>
<p>两个IP地址工作的原因是群中的节点参与<strong>入口路由网格</strong>。这可以确保部署在集群中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。以下是三节点swarm的端口8080上发布的名为<code>my-web</code>的服务的路由网络示意图：</p>
<p><img src="/img/18_04_26/003.png" alt=""></p>
<blockquote>
<p><strong>连接有问题？</strong></p>
<p>请记住，要使用swarm中的入口网络，在启用swarm模式之前，需要在swarm节点之间打开以下端口：</p>
<ul>
<li>端口7946 TCP/UDP （用于容器网络发现）</li>
<li>端口4789 UDP （用于容器入口网络）</li>
</ul>
</blockquote>
<h2 id="迭代和缩放你的应用程序"><a href="#迭代和缩放你的应用程序" class="headerlink" title="迭代和缩放你的应用程序"></a>迭代和缩放你的应用程序</h2><p>在这里，你可以完成你在Part2和Part3中学到的一切。</p>
<p>通过修改<code>docker-compose.yml</code>文件，可以缩放应用程序。</p>
<p>通过编辑代码，来改变应用的行为，然后重新构建，并将新的镜像push上去。（要做到这一点，请按照之前用于构建应用程序和发布镜像的相同步骤）。</p>
<p>无论是哪种情况，只需要通过再次运行<code>docker stack deploy</code>就可以发布这些变更。</p>
<p>你可以加入任何虚拟的或物理的机器到这个swarm中，对<code>myvm2</code>使用相同的<code>docker swarm join</code>命令，然后集群的容量就被扩大了。在运行<code>docker stack deploy</code>之后，你的应用程序就可以利用到这些资源了。</p>
<h2 id="清空并重启"><a href="#清空并重启" class="headerlink" title="清空并重启"></a>清空并重启</h2><h3 id="堆栈和swarm"><a href="#堆栈和swarm" class="headerlink" title="堆栈和swarm"></a>堆栈和swarm</h3><p>你可以通过运行<code>docker stack rm</code>来卸下堆栈。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>保留或删除swarm</strong>？</p>
<p>在稍后，如果您想要使某个worker离开swarm，可以在worker上使用<code>docker-machine ssh myvm2 &quot;docker swarm leave&quot;</code>来卸下woker，如果是manager的话，可以这样执行<code>docker-machine ssh myvm1 &quot;docker swarm leave --force&quot;</code>，但在后面的Part5的教学中，你还需要它，所以暂时保留。</p>
</blockquote>
<h3 id="重置docker-machine-shell变量设置"><a href="#重置docker-machine-shell变量设置" class="headerlink" title="重置docker-machine shell变量设置"></a>重置docker-machine shell变量设置</h3><p>你可以通过你当前的shell执行以下命令来重置<code>docker-machine</code>环境变量。</p>
<p>在Mac或Linux上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(docker-machine env -u)</span><br></pre></td></tr></table></figure>
<p>在Windows上，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env -u | Invoke-Expression</span><br></pre></td></tr></table></figure>
<p>这将shell与<code>docker-machine</code>创建的虚拟机断开连接，并允许你继续在同一个shell中工作，现在使用本机docker命令。更多信息，请见<a target="_blank" rel="noopener" href="https://docs.docker.com/machine/get-started/#unset-environment-variables-in-the-current-shell">Machine topic on unsetting environment variables</a>。</p>
<p>重启Docker machines</p>
<p>如果你关闭本地主机，Docker machines将停止运行。你可以通过运行<code>docker-machine ls</code>来检查机器运行的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL   SWARM   DOCKER    ERRORS</span><br><span class="line">myvm1   -        virtualbox   Stopped                 Unknown</span><br><span class="line">myvm2   -        virtualbox   Stopped                 Unknown</span><br></pre></td></tr></table></figure>
<p>重启已经停止的机器，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine start &lt;machine-name&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine start myvm1</span><br><span class="line">Starting &quot;myvm1&quot;...</span><br><span class="line">(myvm1) Check network to re-create if needed...</span><br><span class="line">(myvm1) Waiting for an IP...</span><br><span class="line">Machine &quot;myvm1&quot; was started.</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Started machines may have new IP addresses. You may need to re-run the &#96;docker-machine env&#96; command.</span><br><span class="line"></span><br><span class="line">$ docker-machine start myvm2</span><br><span class="line">Starting &quot;myvm2&quot;...</span><br><span class="line">(myvm2) Check network to re-create if needed...</span><br><span class="line">(myvm2) Waiting for an IP...</span><br><span class="line">Machine &quot;myvm2&quot; was started.</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Started machines may have new IP addresses. You may need to re-run the &#96;docker-machine env&#96; command.</span><br></pre></td></tr></table></figure>
<h2 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h2><p>在part4部分，你学习到了什么是swarm，节点在swarm中可以作为worker，也可以作为manager，创建一个swarm，并在上面发布一个应用。你看到Docker的核心命令和part3中并没有什么不同，他们只需要将目标锁定在swarm主机上运行。你还看到了Docker网络的力量，即使它们运行在不同的机器上，也可以跨容器保持请求负载均衡。最后，你学习了如何在集群上迭代和缩放应用程序。以下是您可能想要运行的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 # Create a VM (Mac, Win7, Linux)</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1 # Win10</span><br><span class="line">docker-machine env myvm1                # View basic information about your node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node ls&quot;         # List the nodes in your swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker node inspect &lt;node ID&gt;&quot;        # Inspect a node</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm join-token -q worker&quot;   # View join token</span><br><span class="line">docker-machine ssh myvm1   # Open an SSH session with the VM; type &quot;exit&quot; to end</span><br><span class="line">docker node ls                # View nodes in swarm (while logged on to manager)</span><br><span class="line">docker-machine ssh myvm2 &quot;docker swarm leave&quot;  # Make the worker leave the swarm</span><br><span class="line">docker-machine ssh myvm1 &quot;docker swarm leave -f&quot; # Make master leave, kill swarm</span><br><span class="line">docker-machine ls # list VMs, asterisk shows which VM this shell is talking to</span><br><span class="line">docker-machine start myvm1            # Start a VM that is currently not running</span><br><span class="line">docker-machine env myvm1      # show environment variables and command for myvm1</span><br><span class="line">eval $(docker-machine env myvm1)         # Mac command to connect shell to myvm1</span><br><span class="line">&amp; &quot;C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe&quot; env myvm1 | Invoke-Expression   # Windows command to connect shell to myvm1</span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  # Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ # Copy file to node&#39;s home dir (only required if you use ssh to connect to manager and deploy the app)</span><br><span class="line">docker-machine ssh myvm1 &quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;   # Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span><br><span class="line">eval $(docker-machine env -u)     # Disconnect shell from VMs, use native docker</span><br><span class="line">docker-machine stop $(docker-machine ls -q)               # Stop all running VMs</span><br><span class="line">docker-machine rm $(docker-machine ls -q) # Delete all VMs and their disk images</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/Docker%E5%85%A5%E9%97%A8Part3-%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">Docker入门Part3-服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-26 10:12:00" itemprop="dateCreated datePublished" datetime="2018-04-26T10:12:00+00:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>安装<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">Docker 1.13或更高的版本</a>。</li>
<li>获取<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/overview/">Docker Compose</a>。在<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a>和<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-for-windows/">Docker for Windows</a>中，它已预先安装，这一步很方便。在Linux系统上，您需要<a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases">直接安装它</a>。在没有<em>Hyper-V</em>的Windows 10系统上，使用<a target="_blank" rel="noopener" href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>。</li>
<li>阅读Part1部分。</li>
<li>学习Part2中如何创建容器。</li>
<li>确定你已经通过<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/part2/#share-your-image">上传到仓库</a>的方式发布了<code>friendlyhello</code>镜像。我们在这里使用共享镜像。</li>
<li>确定你的镜像作为一个已部署的容器。运行下面这条命令，插入你的<code>username</code>、<code>repo</code>、和<code>tag</code>:<code>docker run -p 80:80 username/repo:tag</code>，然后访问<code>http://localhost/</code>。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在第三部分，我们将扩展我们的应用并实现负载均衡。为了做到这一点，我们必须在分布式应用程序的层次结构中升一级：<strong>service(服务)</strong>。</p>
<ul>
<li>Stack</li>
<li><strong>Services(服务 你在这里)</strong></li>
<li>Container（参见 part2）</li>
</ul>
<h2 id="关于Services"><a href="#关于Services" class="headerlink" title="关于Services"></a>关于Services</h2><p>在一个分布式应用中，应用的不同部分被称为”services”。例如，想象你有一个影片分享站点，它也许包括一个关于将应用数据存储在数据库中的service，一个在用户上传一些东西之后在后台对其进行转码操作的service，一个前端的服务，等等。</p>
<p>Services实际上只是“生产中的容器”。service只运行一个镜像，但用于编纂镜像的运行方式—应该使用哪个端口，应该运行多少个容器副本以便服务具有所需的容量，等等。缩放service会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p>
<p>幸运的是，使用Docker平台定义，运行和扩展services非常简单 — 仅仅写一个<code>docker-compose.yml</code>文件即可。</p>
<h2 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h2><p>一个<code>docker-compose.yml</code>文件是一个用于定义Docker容器在生产环境中的行为的YAML文件。</p>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><p>将此文件另存为<code>docker-compose.yml</code>，无论你在哪里。确保您已将第2部分中创建的镜像推送到注册表中，并通根据你的镜像的具体的信息替换掉<code>username/repo:tag</code>部分来更新此<code>.yml</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username&#x2F;repo:tag with your name and image details</span><br><span class="line">    image: username&#x2F;repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>这个<code>docker-compose.yml</code>文件告诉Docker要做以下事情：</p>
<ul>
<li>按照Part2中的方式从仓库中下拉我们的镜像。</li>
<li>运行镜像的5个实例作为一个名为<code>web</code>的service，限制每个实例，最多占用10%CPU(所有的核)、50MB的RAM。</li>
<li>如果一个容器失败了立刻重启。</li>
<li>将主机上的端口80映射到<code>web</code>的端口80。</li>
<li>指示<code>web</code>容器通过名为<code>webnet</code>负载均衡网络共享80端口。（在内部，容器本身在临时端口上发布到<code>web</code>的80端口）。</li>
<li>使用默认设置（这是一个负载均衡覆盖网络）定义<code>webnet</code>网络。</li>
</ul>
<h2 id="运行你的全新的负载均衡应用"><a href="#运行你的全新的负载均衡应用" class="headerlink" title="运行你的全新的负载均衡应用"></a>运行你的全新的负载均衡应用</h2><p>在我们可以使用<code>docker stack deploy</code>命令之前，我们首先运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：我们在Part4部分深入了解该命令的含义。如果你不运行<code>docker swarm init</code>命令的话，你会得到这样一条错误信息：”this node is not a swarm manager.”。</p>
</blockquote>
<p>现在，让我们来运行它吧。你需要给你的应用起一个名字。这里我们起名为<code>getstartedlab</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>我们的单个service堆栈在一台主机上运行了5个部署映像的容器实例。让我们来进一步了解。</p>
<p>在我们的应用程序中获取一项service的service ID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure>
<p>查找<code>web</code>service的输出信息，找到那个以你的应用程序名称作为前缀信息。如果您将其命名为与此示例中显示的相同，那么这里的名称为<code>getstartedlab_web</code>。还列出了service ID以及副本数量，镜像名称和对外暴露的端口。</p>
<p>在service中运行的单个容器称为<strong>task(任务)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps getstartedlab_web</span><br></pre></td></tr></table></figure>
<p>如果您只列出系统中的所有容器，任务也会显示出来，它不会被service所过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -q</span><br></pre></td></tr></table></figure>
<p>你可以运行几次<code>curl -4 http://localhost</code>，或者通过浏览器打开这个链接尝试刷新几次。</p>
<p><img src="/img/18_04_26/001.png" alt=""></p>
<p>无论哪种方式，容器ID都会发生变化，从而显示负载均衡;在每个请求中，以循环方式选择5个任务中的一个来响应。容器ID与前一个命令(<code>docker container ls -q</code>)的输出相匹配。</p>
<blockquote>
<p><strong>在Windows10下运行？</strong></p>
<p>Windows10的PowerShell可以使用<code>curl</code>命令，但如果不行的话，你可以尝试获取一个Linux终端模拟器，例如<a target="_blank" rel="noopener" href="https://git-for-windows.github.io/">Git BASH</a>或者下载很相似的<a target="_blank" rel="noopener" href="http://gnuwin32.sourceforge.net/packages/wget.htm">wget for Windows</a>。</p>
<p><strong>响应时间慢？</strong></p>
<p>根据您的环境的网络配置，容器可能需要长达30秒才能响应HTTP请求。这并不代表Docker或群集性能，而是我们稍后在本教程中讨论的未满足的Redis依赖项。就目前而言，访客柜台并不是出于同样的原因;我们还没有添加service来保存数据。</p>
</blockquote>
<h2 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h2><p>你可以通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值来扩展应用，保存<code>docker-compose.yml</code>的改变之后，重新运行<code>docker stack deploy</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure>
<p>Docker执行一个就地更新，不需要先撤下堆栈或杀死任何容器。</p>
<p>现在，重新运行<code>docker container ls -q</code>以查看重新配置的已部署实例。如果您扩大副本，则会启动更多任务，因此还会启动更多容器。</p>
<h3 id="撤下应用和swarm"><a href="#撤下应用和swarm" class="headerlink" title="撤下应用和swarm"></a>撤下应用和swarm</h3><ul>
<li>通过指令<code>docker stack rm</code>来撤下应用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure>
<ul>
<li>撤下swarm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>
<p>用Docker新建并扩展您的应用程序非常简单。您已经朝着学习如何在生产中运行容器迈出了一大步。接下来，您将学习如何将这个应用程序作为Docker机器群集上的真正群体运行。</p>
<blockquote>
<p>注意：像这里的Compose文件是用于通过Docker来定义应用程序，并且可以通过<a target="_blank" rel="noopener" href="https://docs.docker.com/docker-cloud/">Docker Cloud</a>上传到云端，或者任何带有<a target="_blank" rel="noopener" href="https://www.docker.com/enterprise-edition">Docker 企业版</a>的云服务上。</p>
</blockquote>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>总而言之，在输入<code>docker run</code>运行时非常简单，生产中的容器真正实现将其作为服务运行。服务在Compose文件中编写容器的行为，此文件可用于缩放，限制和重新部署我们的应用程序。对服务的更改可以在运行时适用，使用启动服务的相同命令：<code>docker stack deploy</code>。</p>
<p>现阶段需要学习的一些命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls                                            # List stacks or apps</span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose file</span><br><span class="line">docker service ls                 # List running services associated with an app</span><br><span class="line">docker service ps &lt;service&gt;                  # List tasks associated with an app</span><br><span class="line">docker inspect &lt;task or container&gt;                   # Inspect task or container</span><br><span class="line">docker container ls -q                                      # List container IDs</span><br><span class="line">docker stack rm &lt;appname&gt;                             # Tear down an application</span><br><span class="line">docker swarm leave --force      # Take down a single node swarm from the manager</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/25/Docker%E5%85%A5%E9%97%A8Part2-%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">Docker入门Part2-容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-25 16:43:00" itemprop="dateCreated datePublished" datetime="2018-04-25T16:43:00+00:00">2018-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">安装Docker1.13或更高版本</a>。</li>
<li>阅读Part1部分。</li>
<li>让您的环境快速测试运行，以确保您全部设置完毕：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在是开始以Docker方式构建应用程序的时候了。我们从这种应用程序的层次结构的容器的底部开始，进行详细介绍。在这个层次上面是一个服务，它定义了容器在生产中的行为方式，如Part3部分所述。最后，在顶层的堆栈部分定义了Part5部分中涵盖的所有服务的交互。</p>
<ul>
<li>Stack （堆栈）</li>
<li>Services （服务）</li>
<li><strong>Container</strong>（容器，你在这里）</li>
</ul>
<h2 id="您的新开发环境"><a href="#您的新开发环境" class="headerlink" title="您的新开发环境"></a>您的新开发环境</h2><p>之前，如果您要开始编写Python应用程序，您第一个要做的事情就是在您的机器上安装Python运行环境。但是，这会造成您的计算机上的环境需要完美适合您的应用程序按预期运行，并且还需要与您的生产环境相匹配。</p>
<p>使用Docker，您可以将一个可移植的Python运行环境作为一个镜像获取，无需安装。然后，您的构建可以将基础Python镜像与应用程序代码一起包括在内，确保您的应用程序，依赖项和运行环境都在一起。</p>
<p>这些可移植的镜像是由称为<code>Dockerfile</code>的东西定义的。</p>
<h2 id="通过Dockerfile定义一个容器"><a href="#通过Dockerfile定义一个容器" class="headerlink" title="通过Dockerfile定义一个容器"></a>通过<code>Dockerfile</code>定义一个容器</h2><p><code>Dockerfile</code>定义了容器内的环境发生的事情。像访问网络接口以及磁盘驱动器等资源是在此环境内虚拟化的，这与系统的其余部分是隔离开的，因此您需要将端口映射到外部世界，并明确指定要将哪些文件“复制”到该环境中。但是，在完成这些之后，您可以预期，在此<code>Dockerfile</code>中定义的应用程序构建在运行时的行为完全相同。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><code>Dockerfile</code></h3><p>创建一个空目录。改变目录(<code>cd</code>)到这个新的目录下，创建一个叫做<code>Dockerfile</code>的文件，将下面的内容复制粘贴到这个文件中，并保存。注意记下<code>Dockerfile</code>中的注释部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line"># 使用一个官方的Python运行时环境作为父镜像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to &#x2F;app</span><br><span class="line"># 设置工作目录到&#x2F;app目录下</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at &#x2F;app</span><br><span class="line"># 复制当前目录内容到容器的&#x2F;app目录下</span><br><span class="line">ADD . &#x2F;app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line"># 安装所有requirements.txt中指定的需要的包</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line"># 使得该容器的80端口对外可用</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line"># 当容器加载时，运行app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<p>这个<code>Dockerfile</code>提到了我们尚未创建的两个文件，名叫<code>app.py</code>和<code>requirements.txt</code>。接下来让我们来创建出来。</p>
<h2 id="应用程序本身"><a href="#应用程序本身" class="headerlink" title="应用程序本身"></a>应用程序本身</h2><p>创建两个文件<code>requirements.txt</code>和<code>app.py</code>，并把他们放在和<code>Dockerfile</code>相同的目录下。这就完成了我们的应用程序，正如你看到的一样，非常简单。当上面的<code>Dockerfile</code>被内置到镜像中时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>存在，并且<code>app.py</code>的输出可以通过HTTP访问，这要归功于<code>EXPOSE</code>命令。</p>
<h3 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a><code>requirements.txt</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>
<h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a><code>app.py</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis &#x3D; Redis(host&#x3D;&quot;redis&quot;, db&#x3D;0, socket_connect_timeout&#x3D;2, socket_timeout&#x3D;2)</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits &#x3D; redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits &#x3D; &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;&#x2F;i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html &#x3D; &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;&#x2F;h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;&#x2F;b&gt; &#123;hostname&#125;&lt;br&#x2F;&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;&#x2F;b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name&#x3D;os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname&#x3D;socket.gethostname(), visits&#x3D;visits)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.run(host&#x3D;&#39;0.0.0.0&#39;, port&#x3D;80)</span><br></pre></td></tr></table></figure>
<p>现在我们看到<code>pip install -r requirements.txt</code>命令安装了Python的Flask和Redis库，并且应用打印出了环境变量<code>NAME</code>，同时输出了方法<code>socket.gethostname()</code>输出的内容。最后，因为Redis没有运行（因为我们只安装了Python库，而不是Redis本身），所以这里应该会失败，并产生错误消息。</p>
<blockquote>
<p>注意：在容器内部访问主机的名称将检索容器ID，这与正在运行的可执行文件的进程ID相似。</p>
</blockquote>
<p>就是这样！你的系统上不需要Python或者任何<code>requirements.txt</code>文件，也不需要在你的系统上安装或运行此镜像。这看起来你并没有真正用Python和Flask建立一个运行环境，但事实上已经建立好了。</p>
<h2 id="构建一个应用"><a href="#构建一个应用" class="headerlink" title="构建一个应用"></a>构建一个应用</h2><p>我们准备构建应用程序。确保您仍然处于新目录的顶层。以下是<code>ls</code>命令应该显示的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile		app.py			requirements.txt</span><br></pre></td></tr></table></figure>
<p>现在运行build命令。这会创建一个Docker镜像，我们将使用<code>-t</code>标记它，这样可以给它指定一个友好的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure>
<p>你构建的镜像在哪里？它在你的机器的本地Docker镜像注册表中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest   </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Linux用户的故障排除</p>
<p><em>DNS设置</em></p>
<p>代理服务器在启动并运行后可以阻止与您的网络应用程序的连接。如果您位于代理服务器的后面，请使用<code>ENV</code>命令为您的代理服务器指定主机和端口，将以下行添加到<code>Dockerfile</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set proxy server, replace host:port with values for your servers</span><br><span class="line">ENV http_proxy host:port</span><br><span class="line">ENV https_proxy host:port</span><br></pre></td></tr></table></figure>
<p><em>代理服务设置</em></p>
<p>DNS错误配置可能会导致<code>pip</code>出现问题。您需要设置您自己的DNS服务器地址以使<code>pip</code>正常工作。您可能需要更改Docker守护程序的DNS设置。您可以按照以下方式来编辑（或者创建）带有<code>dns</code>信息的配置文件<code>/etc/docker/daemon.json</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;dns&quot;: [&quot;your_dns_address&quot;, &quot;8.8.8.8&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，列表的第一个元素是你的DNS服务器的地址。第二项是Google的DNS，当第一项不可用时可以使用它。</p>
<p>在继续之前，保存`daemon.json并重新启动docker服务。</p>
<p><code>sudo service docker restart</code></p>
<p>修复后，重试运行<code>build</code>命令。</p>
</blockquote>
<h2 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h2><p>运行应用程序，使用<code>-p</code>将机器的端口4000映射到容器的已发布端口<code>80</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>你可以在<code>http://0.0.0.0:80</code>看到一条消息，Python正在为你的应用程序提供服务。但是，该消息来自容器内部，它不知道您将该容器的端口<code>80</code>映射到<code>4000</code>，从而制作正确的URL<code>http://localhost:4000</code>。</p>
<p>在网络浏览器中转到该URL以查看网页上显示的显示内容。</p>
<p><img src="/img/18_04_25/004.png" alt=""></p>
<blockquote>
<p>注意：如果你正在在Windows7上使用Docker Toolbox，使用Docker Machine IP来替代<code>localhost</code>。例如：<a target="_blank" rel="noopener" href="http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine">http://192.168.99.100:4000/。要查找IP地址，请使用该命令`docker-machine</a> ip`。</p>
</blockquote>
<p>您也可以在shell中使用<code>curl</code>命令来查看相同的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:4000</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;Hello World!&lt;&#x2F;h3&gt;&lt;b&gt;Hostname:&lt;&#x2F;b&gt; 8fc990912a14&lt;br&#x2F;&gt;&lt;b&gt;Visits:&lt;&#x2F;b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>
<p>这个<code>4000:80</code>的端口重映射是为了演示<code>Dockerfile</code>中的<code>EXPOSE</code>与使用<code>docker run -p</code>发布的内容之间的区别。在后面的步骤中，我们只需将主机上的端口80映射到容器中的端口80并使用<code>http://localhost</code>。</p>
<p>在终端中点击<code>CTRL + C</code>退出。</p>
<blockquote>
<p><strong>在Windows下，显式的停止容器</strong></p>
<p>在Windows系统下，<code>CTRL+C</code>不会停止容器。到目前为止，首先键入<code>CTRL+C</code>以获取提示（或打开另一个shell），然后输入<code>docker container ls</code>来列出运行中的容器，其次是<code>docker container stop &lt;Container NAME or ID&gt;</code>来停止容器。否则，你会在下一步重新运行容器时得到一个来自守护进程的错误消息。</p>
</blockquote>
<p>现在让我们以分离模式在后台运行应用程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>您可以获取应用的长容器ID，然后将其显示到终端。你的容器在后台运行。你也可以通过<code>docker container ls</code>来看到简短的容器ID（并且在运行命令时可以互换使用）。</p>
<p>注意到<code>CONTAINER ID</code>与<code>http://localhost:4000</code>上的内容匹配。</p>
<p>现在我们使用<code>docker container stop</code>来结束指定<code>CONTAINER ID</code><br>的进程，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop 1fa4ab2cf395</span><br></pre></td></tr></table></figure>
<h2 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h2><p>为了演示我们刚才创建的可移植性，我们上传我们构建的镜像并在其他地方运行它。毕竟，当您想要将容器部署到生产环境时，您需要知道如何推送注册表。</p>
<p>注册表是存储库的集合，而存储库是镜像的集合 - 有点像GitHub存储库，但不同的是这里代码已经创建。注册表上的帐户可以创建许多存储库。 <code>docker</code> CLI默认使用Docker的公共注册表。</p>
<blockquote>
<p>注意：我们在这里使用Docker的公共注册表仅仅是因为它是免费和预先配置的，但是有许多公共选项可供选择，您甚至可以使用<a target="_blank" rel="noopener" href="https://docs.docker.com/datacenter/dtr/2.2/guides/">Docker Trusted Registry</a>设置您自己的私有注册表。</p>
</blockquote>
<h3 id="登录你的Docker-ID"><a href="#登录你的Docker-ID" class="headerlink" title="登录你的Docker ID"></a>登录你的Docker ID</h3><p>如果你没有Docker账号，需要在<a href="cloud.docker.com">cloud.docker.com</a>上注册一个。记下你的用户名。</p>
<p>登录到本地计算机上的Docker公共注册表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
<h3 id="给镜像打标签"><a href="#给镜像打标签" class="headerlink" title="给镜像打标签"></a>给镜像打标签</h3><p>将本地镜像与注册表中的存储库相关联的符号是<code>username/repository:tag</code>。该tag是可选的，但建议使用，因为它是注册管理机构用于为Docker镜像提供版本的机制。为该上下文提供存储库并标记有意义的名称，例如<code>get-started:part2</code>。这将镜像置于启动存储库中，并将其标记为<code>part2</code>。</p>
<p>现在，给镜像整体的打上标签。带入你的用户名、仓库名、和标签名运行<code>docker tag image</code>以便将镜像上传到你想要的地址。命令的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username&#x2F;repository:tag</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag friendlyhello john&#x2F;get-started:part2</span><br></pre></td></tr></table></figure>
<p>运行<code>docker image ls</code>来查看你的新的带有标签信息的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello            latest              d9e555c53008        3 minutes ago       195MB</span><br><span class="line">john&#x2F;get-started         part2               d9e555c53008        3 minutes ago       195MB</span><br><span class="line">python                   2.7-slim            1c7128a655f6        5 days ago          183MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>上传带有标签信息的镜像到仓库中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push username&#x2F;repository:tag</span><br></pre></td></tr></table></figure>
<p>完成后，此上传的结果将公开发布。如果你登录到<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，你会在那里看到带有pull命令的新的镜像文件。</p>
<h3 id="从远程仓库中下拉并且运行镜像"><a href="#从远程仓库中下拉并且运行镜像" class="headerlink" title="从远程仓库中下拉并且运行镜像"></a>从远程仓库中下拉并且运行镜像</h3><p>截止到目前，你可以使用<code>docker run</code>命令来在任何机器上运行你的应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username&#x2F;repository:tag</span><br></pre></td></tr></table></figure>
<p>如果镜像在本地机器上不可用，Docker会从远程仓库中下拉到本地。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 john&#x2F;get-started:part2</span><br><span class="line">Unable to find image &#39;john&#x2F;get-started:part2&#39; locally</span><br><span class="line">part2: Pulling from john&#x2F;get-started</span><br><span class="line">10a267c67f42: Already exists</span><br><span class="line">f68a39a6a5e4: Already exists</span><br><span class="line">9beaffc0cf19: Already exists</span><br><span class="line">3c1fe835fb6b: Already exists</span><br><span class="line">4c9f1fa8fcb8: Already exists</span><br><span class="line">ee7d8f576a14: Already exists</span><br><span class="line">fbccdcced46e: Already exists</span><br><span class="line">Digest: sha256:0601c866aab2adcc6498200efd0f754037e909e5fd42069adeff72d1e2439068</span><br><span class="line">Status: Downloaded newer image for john&#x2F;get-started:part2</span><br><span class="line"> * Running on http:&#x2F;&#x2F;0.0.0.0:80&#x2F; (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>
<p>不管<code>docker run</code>在哪里运行，它都会将你的镜像以及Python和<code>requirements.txt</code>中所有的依赖关系一起提取出来，并运行您的代码。它们都在一个整洁的小包中一起旅行，并且Docker不需要您在主机上安装任何东西来运行它。</p>
<h2 id="Part2结论"><a href="#Part2结论" class="headerlink" title="Part2结论"></a>Part2结论</h2><p>这里列出了这个页面的基本Docker命令，以及一些相关的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .  # Create image using this directory&#39;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyhello  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username&#x2F;repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username&#x2F;repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username&#x2F;repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/04/25/Docker%E5%85%A5%E9%97%A8Part1-%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="DannyLee">
      <meta itemprop="description" content="愿你的努力终取得成果">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="圣巢">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/25/Docker%E5%85%A5%E9%97%A8Part1-%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">Docker入门Part1-定位和设置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-25 12:17:00" itemprop="dateCreated datePublished" datetime="2018-04-25T12:17:00+00:00">2018-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-10 16:11:39" itemprop="dateModified" datetime="2021-02-10T16:11:39+00:00">2021-02-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>翻译自<a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/">docker官方文档</a>。</p>
</blockquote>
<p>欢迎！我们很高兴您来学习Docker。 Docker入门教程将教你如何：</p>
<ul>
<li>1.设置您的Docker环境（本节内容）</li>
<li>2.构建一个镜像，并将其作为一个容器运行</li>
<li>3.通过运行多个容器来缩放你的应用</li>
<li>4.通过集群来分发你的应用</li>
<li>5.通过添加后端数据库来堆叠服务</li>
<li>6.发布你的应用到生产环境</li>
</ul>
<h2 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h2><p>Docker是开发人员和系统管理员使用容器<strong>开发</strong>、<strong>部署</strong>和<strong>运行</strong>应用程序的平台。使用Linux容器来部署应用程序称为<em>集装箱化</em>(Containerization)。容器的概念并不新，但它们用于部署应用程序会很轻松。</p>
<p>集装箱化越来越受欢迎，因为集装箱是：</p>
<ul>
<li>灵活：即使是最复杂的应用也可以被集装箱化。</li>
<li>轻量级：容器利用并共享主机内核。</li>
<li>通用：您可以即时部署更新和升级。</li>
<li>轻便：你可以在本地构建，发布到云端，并且在任何地方运行。</li>
<li>可扩展：您可以增加和自动分发容器副本。</li>
<li>可堆叠：您可以及时的纵向堆叠服务。</li>
</ul>
<p><img src="/img/18_04_25/001.png" alt=""></p>
<h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>一个容器通过运行一个镜像来启动。一个<strong>镜像</strong>是一个可执行的程序包，其中包含运行该程序所需的所有内容，包括代码，运行时，库，环境变量和配置文件。</p>
<p><strong>容器</strong>是镜像的运行时实例 - 即执行时将镜像加载到内存中，这个内存中的部分就是容器（即具有状态或用户进程的镜像）。Linux环境下，你可以通过命令<code>docker ps</code>来查看你当前正在运行的容器。</p>
<h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>一个<strong>容器</strong>在Linux的<em>本地</em>运行，并与其他容器共享主机的内核。它运行在一个独立的进程，不占用任何其他可执行文件的内存，从而达到轻量化。</p>
<p>对比之下，<strong>虚拟机（VM）</strong>运行一个完整的“guest”操作系统，通过虚拟机管理程序虚拟访问主机资源。一般来说，虚拟机提供的环境比大多数应用程序需要的资源更多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/img/18_04_25/002.png" alt=""></td>
<td style="text-align:center"><img src="/img/18_04_25/003.png" alt=""></td>
</tr>
</tbody>
</table>
</div>
<h2 id="准备你的Docker环境"><a href="#准备你的Docker环境" class="headerlink" title="准备你的Docker环境"></a>准备你的Docker环境</h2><p>在支持的平台上安装Docker社区版本(CE)或者企业版(EE)。</p>
<blockquote>
<p>对于完整的Kubernetes集成</p>
<ul>
<li><p>Docker for Mac上的Kubernetes在17.12 Edge（mac45）或17.12 Stable（mac46）及更高版本中可用。</p>
</li>
<li><p>Docker for Windows上的Kubernetes仅在18.02 Edge（win50）和更高边缘通道中可用。</p>
</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/">安装Docker</a></p>
<h3 id="测试Docker版本号"><a href="#测试Docker版本号" class="headerlink" title="测试Docker版本号"></a>测试Docker版本号</h3><ul>
<li>1.运行<code>docker --version</code>并确保您拥有支持的Docker版本：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"></span><br><span class="line">Docker version 17.12.0-ce, build c97c6d6</span><br></pre></td></tr></table></figure>
<ul>
<li>2.运行<code>docker info</code>或者(<code>docker version</code>没有<code>--</code>)来查看关于您的Docker安装的更多细节：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"></span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.12.0-ce</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了避免权限错误（以及<code>sudo</code>的使用），将您的用户添加到<code>docker</code>组。<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/installation/linux/linux-postinstall/">更多</a>。</p>
</blockquote>
<h3 id="测试Docker的安装"><a href="#测试Docker的安装" class="headerlink" title="测试Docker的安装"></a>测试Docker的安装</h3><ul>
<li>1.通过运行简单的Docker镜像<a target="_blank" rel="noopener" href="https://hub.docker.com/_/hello-world/">hello-world</a>来测试您的安装是否工作正常：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>2.列出下载到你机器上的<code>hello-world</code>镜像：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<ul>
<li>3.列出显示其消息后退出的<code>hello-world</code>容器（由镜像生成）。如果它仍在运行，则不需要<code>--all</code>选项：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls --all</span><br><span class="line"></span><br><span class="line">CONTAINER ID     IMAGE           COMMAND      CREATED            STATUS</span><br><span class="line">54f4984ed6a8     hello-world     &quot;&#x2F;hello&quot;     20 seconds ago     Exited (0) 19 seconds ago</span><br></pre></td></tr></table></figure>
<h2 id="本节回顾"><a href="#本节回顾" class="headerlink" title="本节回顾"></a>本节回顾</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## List Docker CLI commands</span><br><span class="line">docker</span><br><span class="line">docker container --help</span><br><span class="line"></span><br><span class="line">## Display Docker version and info</span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">## Execute Docker image</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">## List Docker images</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">## List Docker containers (running, all, all in quiet mode)</span><br><span class="line">docker container ls</span><br><span class="line">docker container ls --all</span><br><span class="line">docker container ls -aq</span><br></pre></td></tr></table></figure>
<h2 id="Part1结论"><a href="#Part1结论" class="headerlink" title="Part1结论"></a>Part1结论</h2><p>容器化使<a target="_blank" rel="noopener" href="https://www.docker.com/use-cases/cicd">CI/CD</a>无缝衔接。例如：</p>
<ul>
<li>应用程序没有系统依赖关系</li>
<li>更新可以推送到分布式应用程序的任何部分</li>
<li>资源密度可以被优化。</li>
</ul>
<p>使用Docker，扩展应用程序的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="DannyLee"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">DannyLee</p>
  <div class="site-description" itemprop="description">愿你的努力终取得成果</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DannyLee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
